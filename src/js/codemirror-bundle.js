// node_modules/@marijn/find-cluster-break/src/index.js
var rangeFrom = [];
var rangeTo = [];
(() => {
  let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 0, n = 0; i < numbers.length; i++)
    (i % 2 ? rangeTo : rangeFrom).push(n = n + numbers[i]);
})();
function isExtendingChar(code) {
  if (code < 768) return false;
  for (let from = 0, to = rangeFrom.length; ; ) {
    let mid = from + to >> 1;
    if (code < rangeFrom[mid]) to = mid;
    else if (code >= rangeTo[mid]) from = mid + 1;
    else return true;
    if (from == to) return false;
  }
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
var ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0) break;
      else pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos) return found;
    pos--;
  }
  return 0;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1)) return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}

// node_modules/@codemirror/state/dist/index.js
var Text = class _Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    );
    if (text.length)
      text.decompose(
        0,
        text.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to - from) + text.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to = this.length) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a = new RawTextCursor(this), b = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a.next(skip);
      b.next(skip);
      skip = 0;
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
        return false;
      pos += a.value.length;
      if (a.done || pos >= end)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to == null)
        to = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text) {
    if (text.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0])
      return _Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
};
var TextLeaf = class _TextLeaf extends Text {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let string2 = this.text[i], end = offset + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to, target, open) {
    let text = from <= 0 && to >= this.length ? this : new _TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new _TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to, text) {
    if (!(text instanceof _TextLeaf))
      return super.replace(from, to, text);
    [from, to] = clip(this, from, to);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text.length - (to - from);
    if (lines.length <= 32)
      return new _TextLeaf(lines, newLen);
    return TextNode.from(_TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i], end = pos + line.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line of text) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new _TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new _TextLeaf(part, len));
    return target;
  }
};
var TextNode = class _TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    if (text.lines < this.lines)
      for (let i = 0, pos = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i] = updated;
            return new _TextNode(copy, this.length - (to - from) + text.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to, text);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof _TextNode))
      return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children)
        ch.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add2(child) {
      let last;
      if (child.lines > maxChunk && child instanceof _TextNode) {
        for (let node of child.children)
          add2(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add2(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length);
  }
};
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (let line of text)
    length += line.length + 1;
  return length;
}
function appendText(text, target, from = 0, to = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
    let line = text[i], end = pos + line.length;
    if (end >= from) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to) {
  return appendText(text, [""], from, to);
}
var RawTextCursor = class {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
};
var PartialTextCursor = class {
  constructor(text, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    this.pos = start > end ? text.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var LineCursor = class {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
};
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
var Line = class {
  /**
  @internal
  */
  constructor(from, to, number2, text) {
    this.from = from;
    this.to = to;
    this.number = number2;
    this.text = text;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function clip(text, from, to) {
  from = Math.max(0, Math.min(text.length, from));
  return [from, Math.max(from, Math.min(text.length, to))];
}
function findClusterBreak2(str, pos, forward = true, includeExtending = true) {
  return findClusterBreak(str, pos, forward, includeExtending);
}
function surrogateLow2(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh2(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt2(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh2(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow2(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize2(code) {
  return code < 65536 ? 1 : 2;
}
var DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ (function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
})(MapMode || (MapMode = {}));
var ChangeDesc = class _ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2)
      result += this.sections[i];
    return result;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }
    return result;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new _ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to = from) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
      let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from)
        return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result = "";
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new _ChangeDesc(json);
  }
  /**
  @internal
  */
  static create(sections) {
    return new _ChangeDesc(sections);
  }
};
var ChangeSet = class _ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i], ins = sections[i + 1];
      if (ins >= 0) {
        sections[i] = ins;
        sections[i + 1] = len;
        let index = i >> 1;
        while (inserted.length < index)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done: for (let i = 0, pos = 0; ; ) {
      let next = i == ranges.length ? 1e9 : ranges[i++];
      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0)
          addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }
      let end = ranges[i++];
      while (pos < end) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }
    return {
      changes: new _ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i], ins = this.sections[i + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set = new _ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof _ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to = from, insert: insert2 } = spec;
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new _ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i = 0; i < json.length; i++) {
      let part = json[i];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i)
          inserted.push(Text.empty);
        inserted[i] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i].length);
      }
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new _ChangeSet(sections, inserted);
  }
};
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (last >= 0 && len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values2, sections, value) {
  if (value.length == 0)
    return;
  let index = sections.length - 2 >> 1;
  if (index < values2.length) {
    values2[values2.length - 1] = values2[values2.length - 1].append(value);
  } else {
    while (values2.length < index)
      values2.push(Text.empty);
    values2.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++], ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
          break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a.done && b.len || b.done && a.len) {
      throw new Error("Mismatched change set lengths");
    } else if (a.ins == -1 && b.ins == -1) {
      let len = Math.min(a.len, b.len);
      addSection(sections, len, -1);
      a.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
      let len = b.len;
      addSection(sections, b.ins, -1);
      while (len) {
        let piece = Math.min(a.len, len);
        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
          addSection(sections, 0, a.ins);
          if (insert2)
            addInsert(insert2, sections, a.text);
          inserted = a.i;
        }
        a.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a.ins >= 0) {
      let len = 0, left = a.len;
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len);
          len += piece;
          left -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a.i ? a.ins : 0);
      if (insert2 && inserted < a.i)
        addInsert(insert2, sections, a.text);
      inserted = a.i;
      a.forward(a.len - left);
    } else if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len), sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
var SectionIter = class {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length ? Text.empty : inserted[index];
  }
  textBit(len) {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
};
var SelectionRange = class _SelectionRange {
  constructor(from, to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 7;
    return level == 7 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to;
    if (this.empty) {
      from = to = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from == this.from && to == this.to ? this : new _SelectionRange(from, to, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return this.anchor == other.anchor && this.head == other.head && this.goalColumn == other.goalColumn && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
  /**
  @internal
  */
  static create(from, to, flags) {
    return new _SelectionRange(from, to, flags);
  }
};
var EditorSelection = class _EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return _EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main = true) {
    return _EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return _EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new _EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new _EditorSelection([_EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range = ranges[i];
      if (range.empty ? range.from <= pos : range.from < pos)
        return _EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new _EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a, b) => a.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i = 1; i < ranges.length; i++) {
      let range = ranges[i], prev = ranges[i - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from, to = Math.max(range.to, prev.to);
        if (i <= mainIndex)
          mainIndex--;
        ranges.splice(--i, 2, range.anchor > range.head ? _EditorSelection.range(to, from) : _EditorSelection.range(from, to));
      }
    }
    return new _EditorSelection(ranges, mainIndex);
  }
};
function checkSelection(selection2, docLength) {
  for (let range of selection2.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
var nextID = 0;
var Facet = class _Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(config2 = {}) {
    return new _Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray : (a, b) => a === b), !!config2.static, config2.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x) => x;
    return this.compute([field], (state) => get(state.field(field)));
  }
};
function sameArray(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
var FacetProvider = class {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a2;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id2];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
};
function compareArray(a, b, compare2) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!compare2(a[i], b[i]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values2 = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2)
        for (let val of value)
          values2.push(val);
      else
        values2.push(value);
    }
    return facet.combine(values2);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
var initField = /* @__PURE__ */ Facet.define({ static: true });
var StateField = class _StateField {
  constructor(id2, createF, updateF, compareF, spec) {
    this.id = id2;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config2) {
    let field = new _StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i) => i.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
        if ((reInit = init.find((i) => i.field == this)) && reInit != oldInit.find((i) => i.field == this)) {
          state.values[idx] = reInit.create(state);
          return 1;
        }
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create) {
    return [this, initField.of({ field: this, create })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
var Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ prec(Prec_.lowest)
};
var PrecExtension = class {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
};
var Compartment = class _Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return _Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
};
var CompartmentInstance = class {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
};
var Configuration = class _Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a) => field.slot(a));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id2 in facets) {
      let providers = facets[id2], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id2] || [];
      if (providers.every(
        (p) => p.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p) => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => p.dynamicSlot(a));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address));
    return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
};
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
var languageData = /* @__PURE__ */ Facet.define();
var allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((v) => v),
  static: true
});
var lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.length ? values2[0] : void 0,
  static: true
});
var changeFilter = /* @__PURE__ */ Facet.define();
var transactionFilter = /* @__PURE__ */ Facet.define();
var transactionExtender = /* @__PURE__ */ Facet.define();
var readOnly = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.length ? values2[0] : false
});
var Annotation = class {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
};
var AnnotationType = class {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
};
var StateEffectType = class {
  /**
  @internal
  */
  constructor(map) {
    this.map = map;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
};
var StateEffect = class _StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
};
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
var Transaction = class _Transaction {
  constructor(startState, changes, selection2, effects, annotations, scrollIntoView3) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection2;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView3;
    this._doc = null;
    this._state = null;
    if (selection2)
      checkSelection(selection2, changes.newLength);
    if (!annotations.some((a) => a.type == _Transaction.time))
      this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection2, effects, annotations, scrollIntoView3) {
    return new _Transaction(startState, changes, selection2, effects, annotations, scrollIntoView3);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e = this.annotation(_Transaction.userEvent);
    return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
  }
};
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a2;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false)
      filter = false;
    let seq = !!specs[i].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
  }
  let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
var none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ (function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
})(CharCategory || (CharCategory = {}));
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++)
      if (char.indexOf(wordChars[i]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
var EditorState = class _EditorState {
  constructor(config2, doc2, selection2, values2, computeSlot, tr) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection2;
    this.values = values2;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr)
      tr._state = this;
    for (let i = 0; i < this.config.dynamicSlots.length; i++)
      ensureAddr(this, i << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    let selection2 = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
    new _EditorState(conf, tr.newDoc, selection2, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text) {
    if (typeof text == "string")
      text = this.toText(text);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json, config2 = {}, fields) {
    if (!json || typeof json.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json, prop)) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return _EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
    let selection2 = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection2, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection2 = selection2.asSingle();
    return new _EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(_EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(_EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase2, ...insert2) {
    for (let map of this.facet(_EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
        phrase2 = map[phrase2];
        break;
      }
    if (insert2.length)
      phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i) => {
        if (i == "$")
          return "$";
        let n = +(i || 1);
        return !n || n > insert2.length ? m : insert2[n - 1];
      });
    return phrase2;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values2 = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values2.push(result[name2]);
      }
    }
    return values2;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at) {
    let chars = this.languageDataAt("wordChars", at);
    return makeCategorizer(chars.length ? chars[0] : "");
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak2(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak2(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
};
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.length ? values2[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = /* @__PURE__ */ Facet.define({
  compare(a, b) {
    let kA = Object.keys(a), kB = Object.keys(b);
    return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
function combineConfig(configs, defaults3, combine = {}) {
  let result = {};
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0) ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults3)
    if (result[key] === void 0)
      result[key] = defaults3[key];
  return result;
}
var RangeValue = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to = from) {
    return Range.create(from, to, this);
  }
};
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
function cmpVal(a, b) {
  return a == b || a.constructor == b.constructor && a.eq(b);
}
var Range = class _Range {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from, to, value) {
    return new _Range(from, to, value);
  }
};
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
var Chunk = class _Chunk {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from, to, f) {
    for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
      if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new _Chunk(from, to, value, maxPoint) : null, pos: newPos };
  }
};
var RangeSet = class _RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new _RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  /**
  @internal
  */
  chunkEnd(index) {
    return this.chunkPos[index] + this.chunk[index].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add2.length == 0 && !filter)
      return this;
    if (sort)
      add2 = add2.slice().sort(cmpRange);
    if (this.isEmpty)
      return add2.length ? _RangeSet.of(add2) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i < add2.length) {
      if (i < add2.length && (cur2.from - add2[i].from || cur2.startSide - add2[i].value.startSide) >= 0) {
        let range = add2[i++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(Range.create(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to, f) {
    if (this.isEmpty)
      return;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
        return;
    }
    this.nextLayer.between(from, to, f);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b, textDiff);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to) {
    if (to == null)
      to = 1e9 - 1;
    let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
    let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a.length != b.length)
      return false;
    if (!a.length)
      return true;
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !cmpVal(sideA.point, sideB.point)))
        return false;
      if (sideA.to > to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to, iterator, minPointSize = -1) {
    let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let openRanges = cursor2.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor2.to, to);
      if (cursor2.point) {
        let active = cursor2.activeForPoint(cursor2.to);
        let openCount = cursor2.pointFrom < from ? active.length + 1 : cursor2.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank);
        openRanges = Math.min(cursor2.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor2.active, openRanges);
        openRanges = cursor2.openEnd(curTo);
      }
      if (cursor2.to > to)
        return openRanges + (cursor2.point && cursor2.to > to ? 1 : 0);
      pos = cursor2.to;
      cursor2.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length)
      return _RangeSet.empty;
    let result = sets[sets.length - 1];
    for (let i = sets.length - 2; i >= 0; i--) {
      for (let layer2 = sets[i]; layer2 != _RangeSet.empty; layer2 = layer2.nextLayer)
        result = new _RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
    }
    return result;
  }
};
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
      let cur2 = ranges[i];
      if (cmpRange(prev, cur2) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur2;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
var RangeSetBuilder = class _RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from, to, value);
  }
  /**
  @internal
  */
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  /**
  @internal
  */
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
};
function findSharedChunks(a, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set of a)
    for (let i = 0; i < set.chunk.length; i++)
      if (set.chunk[i].maxPoint <= 0)
        inA.set(set.chunk[i], set.chunkPos[i]);
  let shared = /* @__PURE__ */ new Set();
  for (let set of b)
    for (let i = 0; i < set.chunk.length; i++) {
      let known = inA.get(set.chunk[i]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
        shared.add(set.chunk[i]);
    }
  return shared;
}
var LayerCursor = class {
  constructor(layer2, skip, minPoint, rank = 0) {
    this.layer = layer2;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index) {
    if (index == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
};
var HeapCursor = class _HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i = 0; i < sets.length; i++) {
      for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur2, skip, minPoint, i));
      }
    }
    return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
};
function heapBubble(heap, index) {
  for (let cur2 = heap[index]; ; ) {
    let childIndex = (index << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index] = child;
    index = childIndex;
  }
}
var SpanCursor = class {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index) {
    remove(this.active, index);
    remove(this.activeTo, index);
    remove(this.activeRank, index);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i = 0, { value, to, rank } = this.cursor;
    while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)
      i++;
    insert(this.active, i, value);
    insert(this.activeTo, i, to);
    insert(this.activeRank, i, rank);
    if (trackOpen)
      insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a = this.minActive;
      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }
        this.removeActive(a);
        if (trackOpen)
          remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
        this.openStart++;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank)
        break;
      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
        active.push(this.active[i]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
      open++;
    return open;
  }
};
function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  let bounds = !!comparator.boundChange;
  for (let boundChange = false; ; ) {
    let dEnd = a.to + dPos - b.to, diff = dEnd || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
    let point = a.point || b.point;
    if (point) {
      if (!(a.point && b.point && cmpVal(a.point, b.point) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
        comparator.comparePoint(pos, clipEnd, a.point, b.point);
      boundChange = false;
    } else {
      if (boundChange)
        comparator.boundChange(pos);
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active);
      if (bounds && clipEnd < endB && (dEnd || a.openEnd(end) != b.openEnd(end)))
        boundChange = true;
    }
    if (end > endB)
      break;
    pos = end;
    if (diff <= 0)
      a.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (a[i] != b[i] && !cmpVal(a[i], b[i]))
      return false;
  return true;
}
function remove(array, index) {
  for (let i = index, e = array.length - 1; i < e; i++)
    array[i] = array[i + 1];
  array.pop();
}
function insert(array, index, value) {
  for (let i = array.length - 1; i >= index; i--)
    array[i + 1] = array[i];
  array[index] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i = 0; i < array.length; i++)
    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i;
      foundPos = array[i];
    }
  return found;
}
function countColumn(string2, tabSize, to = string2.length) {
  let n = 0;
  for (let i = 0; i < to && i < string2.length; ) {
    if (string2.charCodeAt(i) == 9) {
      n += tabSize - n % tabSize;
      i++;
    } else {
      n++;
      i = findClusterBreak2(string2, i);
    }
  }
  return n;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i = 0, n = 0; ; ) {
    if (n >= col)
      return i;
    if (i == string2.length)
      break;
    n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = findClusterBreak2(string2, i);
  }
  return strict === true ? -1 : string2.length;
}

// node_modules/style-mod/src/style-mod.js
var C = "\u037C";
var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : /* @__PURE__ */ Symbol("styleSet");
var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
var StyleModule = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = [];
    let { finish } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null) return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
            value,
            target
          );
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let id2 = top[COUNT] || 1;
    top[COUNT] = id2 + 1;
    return C + id2.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root, modules, options) {
    let set = root[SET], nonce = options && options.nonce;
    if (!set) set = new StyleSet(root, nonce);
    else if (nonce) set.setNonce(nonce);
    set.mount(Array.isArray(modules) ? modules : [modules], root);
  }
};
var adoptedSet = /* @__PURE__ */ new Map();
var StyleSet = class {
  constructor(root, nonce) {
    let doc2 = root.ownerDocument || root, win = doc2.defaultView;
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2);
      if (adopted) return root[SET] = adopted;
      this.sheet = new win.CSSStyleSheet();
      adoptedSet.set(doc2, this);
    } else {
      this.styleTag = doc2.createElement("style");
      if (nonce) this.styleTag.setAttribute("nonce", nonce);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules, root) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i], index = this.modules.indexOf(mod);
      if (index < j && index > -1) {
        this.modules.splice(index, 1);
        j--;
        index = -1;
      }
      if (index == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet) for (let k = 0; k < mod.rules.length; k++)
          sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index) pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (sheet) {
      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
    } else {
      let text = "";
      for (let i = 0; i < this.modules.length; i++)
        text += this.modules[i].getRules() + "\n";
      this.styleTag.textContent = text;
      let target = root.head || root;
      if (this.styleTag.parentNode != target)
        target.insertBefore(this.styleTag, target.firstChild);
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
      this.styleTag.setAttribute("nonce", nonce);
  }
};

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++) base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc") name2 = "Escape";
  if (name2 == "Del") name2 = "Delete";
  if (name2 == "Left") name2 = "ArrowLeft";
  if (name2 == "Up") name2 = "ArrowUp";
  if (name2 == "Right") name2 = "ArrowRight";
  if (name2 == "Down") name2 = "ArrowDown";
  return name2;
}

// node_modules/crelt/index.js
function crelt() {
  var elt2 = arguments[0];
  if (typeof elt2 == "string") elt2 = document.createElement(elt2);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
      var value = next[name2];
      if (typeof value == "string") elt2.setAttribute(name2, value);
      else if (value != null) elt2[name2] = value;
    }
    i++;
  }
  for (; i < arguments.length; i++) add(elt2, arguments[i]);
  return elt2;
}
function add(elt2, child) {
  if (typeof child == "string") {
    elt2.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt2.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt2, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/view/dist/index.js
var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
var gecko = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
var chrome = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
var webkit = "webkitFontSmoothing" in doc.documentElement.style;
var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
  windows: /* @__PURE__ */ /Win/.test(nav.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
  ie: ie2,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit,
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  safari,
  safari_version: safari ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
var noAttrs = /* @__PURE__ */ Object.create(null);
function attrsEq(a, b, ignore) {
  if (a == b)
    return true;
  if (!a)
    a = noAttrs;
  if (!b)
    b = noAttrs;
  let keysA = Object.keys(a), keysB = Object.keys(b);
  if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
    return false;
  for (let key of keysA) {
    if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
      return false;
  }
  return true;
}
function setAttrs(dom, attrs) {
  for (let i = dom.attributes.length - 1; i >= 0; i--) {
    let name2 = dom.attributes[i].name;
    if (attrs[name2] == null)
      dom.removeAttribute(name2);
  }
  for (let name2 in attrs) {
    let value = attrs[name2];
    if (name2 == "style")
      dom.style.cssText = value;
    else if (dom.getAttribute(name2) != value)
      dom.setAttribute(name2, value);
  }
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs)) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = "";
        else
          dom.removeAttribute(name2);
      }
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2])) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = attrs[name2];
        else
          dom.setAttribute(name2, attrs[name2]);
      }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < dom.attributes.length; i++) {
    let attr = dom.attributes[i];
    attrs[attr.name] = attr.value;
  }
  return attrs;
}
var WidgetType = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  @internal
  */
  get editable() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
};
var BlockType = /* @__PURE__ */ (function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
})(BlockType || (BlockType = {}));
var Decoration = class extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
    side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start, end } = getInclusive(spec, block);
      startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
Decoration.none = RangeSet.empty;
var MarkDecoration = class _MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec);
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.attrs = spec.class && spec.attributes ? combineAttrs(spec.attributes, { class: spec.class }) : spec.class ? { class: spec.class } : spec.attributes || noAttrs;
  }
  eq(other) {
    return this == other || other instanceof _MarkDecoration && this.tagName == other.tagName && attrsEq(this.attrs, other.attrs);
  }
  range(from, to = from) {
    if (from >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }
};
MarkDecoration.prototype.point = false;
var LineDecoration = class _LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof _LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to = from) {
    if (to != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }
};
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
var PointDecoration = class _PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof _PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to = from) {
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }
};
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin >= from)
    ranges[last] = Math.max(ranges[last], to);
  else
    ranges.push(from, to);
}
var BlockWrapper = class _BlockWrapper extends RangeValue {
  constructor(tagName, attributes) {
    super();
    this.tagName = tagName;
    this.attributes = attributes;
  }
  eq(other) {
    return other == this || other instanceof _BlockWrapper && this.tagName == other.tagName && attrsEq(this.attributes, other.attributes);
  }
  /**
  Create a block wrapper object with the given tag name and
  attributes.
  */
  static create(spec) {
    return new _BlockWrapper(spec.tagName, spec.attributes || noAttrs);
  }
  /**
  Create a range set from the given block wrapper ranges.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
};
BlockWrapper.prototype.startSide = BlockWrapper.prototype.endSide = -1;
function getSelection(root) {
  let target;
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }
  return target.getSelection();
}
function contains(dom, node) {
  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection2) {
  if (!selection2.anchorNode)
    return false;
  try {
    return contains(dom, selection2.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
}
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV")
        return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  let vp = win.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale(elt2, rect) {
  let scaleX = rect.width / elt2.offsetWidth;
  let scaleY = rect.height / elt2.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt2.offsetWidth) < 1)
    scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt2.offsetHeight) < 1)
    scaleY = 1;
  return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur2 = dom, stop = false; cur2 && !stop; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position))
          stop = true;
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode;
          continue;
        }
        let rect2 = cur2.getBoundingClientRect();
        ({ scaleX, scaleY } = getScale(cur2, rect2));
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y == "nearest") {
        if (rect.top < bounding.top) {
          moveY = rect.top - (bounding.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = rect.top - (bounding.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x == "nearest") {
        if (rect.left < bounding.left) {
          moveX = rect.left - (bounding.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = rect.left - (bounding.left + xMargin);
        }
      } else {
        let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur2.scrollTop;
            cur2.scrollTop += moveY / scaleY;
            movedY = (cur2.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur2.scrollLeft;
            cur2.scrollLeft += moveX / scaleX;
            movedX = (cur2.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y = "nearest";
        }
      }
      if (top2)
        break;
      if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right)
        rect = {
          left: Math.max(rect.left, bounding.left),
          right: Math.min(rect.right, bounding.right),
          top: Math.max(rect.top, bounding.top),
          bottom: Math.min(rect.bottom, bounding.bottom)
        };
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
function scrollableParents(dom) {
  let doc2 = dom.ownerDocument, x, y;
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2 == doc2.body || x && y) {
      break;
    } else if (cur2.nodeType == 1) {
      if (!y && cur2.scrollHeight > cur2.clientHeight)
        y = cur2;
      if (!x && cur2.scrollWidth > cur2.clientWidth)
        x = cur2;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
  return { x, y };
}
var DOMSelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range) {
    let { anchorNode, focusNode } = range;
    this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
};
var preventScrollSupported = null;
if (browser.safari && browser.safari_version >= 26)
  preventScrollSupported = false;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i = 0; i < stack.length; ) {
      let elt2 = stack[i++], top2 = stack[i++], left = stack[i++];
      if (elt2.scrollTop != top2)
        elt2.scrollTop = top2;
      if (elt2.scrollLeft != left)
        elt2.scrollLeft = left;
    }
  }
}
var scratchRange;
function textRange(node, from, to = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to);
  range.setStart(node, from);
  return range;
}
function dispatchKey(elt2, name2, code, mods) {
  let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
  if (mods)
    ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt2.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt2.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
      return node;
    node = node.assignedSlot || node.parentNode;
  }
  return null;
}
function atElementStart(doc2, selection2) {
  let node = selection2.focusNode, offset = selection2.focusOffset;
  if (!node || selection2.anchorNode != node || selection2.anchorOffset != offset)
    return false;
  offset = Math.min(offset, maxOffset(node));
  for (; ; ) {
    if (offset) {
      if (node.nodeType != 1)
        return false;
      let prev = node.childNodes[offset - 1];
      if (prev.contentEditable == "false")
        offset--;
      else {
        node = prev;
        offset = maxOffset(node);
      }
    } else if (node == doc2) {
      return true;
    } else {
      offset = domIndex(node);
      node = node.parentNode;
    }
  }
}
function isScrolledToBottom(elt2) {
  return elt2.scrollTop > Math.max(1, elt2.scrollHeight - elt2.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset > 0) {
      return { node, offset };
    } else if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset < node.nodeValue.length) {
      return { node, offset };
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset];
      offset = 0;
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
var DOMPos = class _DOMPos {
  constructor(node, offset, precise = true) {
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
};
var Direction = /* @__PURE__ */ (function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
})(Direction || (Direction = {}));
var LTR = Direction.LTR;
var RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i = 0; i < str.length; i++)
    result.push(1 << +str[i]);
  return result;
}
var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var Brackets = /* @__PURE__ */ Object.create(null);
var BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
  Brackets[l] = r;
  Brackets[r] = -l;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
}
var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var BidiSpan = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  constructor(from, to, level) {
    this.from = from;
    this.to = to;
    this.level = level;
  }
  /**
  @internal
  */
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(forward, dir) {
    return forward == (this.dir == dir);
  }
  /**
  @internal
  */
  static find(order, index, level, assoc) {
    let maybe = -1;
    for (let i = 0; i < order.length; i++) {
      let span = order[i];
      if (span.from <= index && span.to >= index) {
        if (span.level == level)
          return i;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
          maybe = i;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
};
function isolatesEq(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    let iA = a[i], iB = b[i];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
      return false;
  }
  return true;
}
var types = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = charType(line.charCodeAt(i));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = types[i];
      if (type == 128) {
        if (i < to - 1 && prev == types[i + 1] && prev & 24)
          type = types[i] = prev;
        else
          types[i] = 256;
      } else if (type == 64) {
        let end = i + 1;
        while (end < to && types[end] == 64)
          end++;
        let replace2 = i && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i; j < end; j++)
          types[j] = replace2;
        i = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i = from, ch, br, type; i < to; i++) {
      if (br = Brackets[ch = line.charCodeAt(i)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i = from; i < to; ) {
      let type = types[i];
      if (type == 256) {
        let end = i + 1;
        for (; ; ) {
          if (end == to) {
            if (iI == isolates.length)
              break;
            end = isolates[iI++].to;
            to = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types[end] : outerType) == 1;
        let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i; ) {
          if (j == fromJ) {
            j = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j] = replace2;
        }
        i = end;
      } else {
        prev = type;
        i++;
      }
    }
  }
}
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from, iI = 0; iCh < to; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum)
            break run;
          let iso = isolates[iI];
          if (!sameDir)
            for (let upto = iso.to, jI = iI + 1; ; ) {
              if (upto == to)
                break run;
              if (jI < isolates.length && isolates[jI].from == upto)
                upto = isolates[jI++].to;
              else if (types[upto] == ourType)
                break run;
              else
                break;
            }
          iI++;
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.from > iCh)
              order.push(new BidiSpan(iCh, iso.from, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.to;
          }
          iScan = iso.to;
        } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break;
        } else {
          iScan++;
        }
      }
      if (recurse)
        emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
      else if (iCh < iScan)
        order.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to, iI = isolates.length; iCh > from; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum)
            break run;
          let iso = isolates[--iI];
          if (!sameDir)
            for (let upto = iso.from, jI = iI; ; ) {
              if (upto == from)
                break run;
              if (jI && isolates[jI - 1].to == upto)
                upto = isolates[--jI].from;
              else if (types[upto - 1] == ourType)
                break run;
              else
                break;
            }
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.to < iCh)
              order.push(new BidiSpan(iso.to, iCh, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.from;
          }
          iScan = iso.from;
        } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
          break;
        } else {
          iScan--;
        }
      }
      if (recurse)
        emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
      else if (iScan < iCh)
        order.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line, from, to, isolates, outerType);
  processBracketPairs(line, from, to, isolates, outerType);
  processNeutrals(from, to, isolates, outerType);
  emitSpans(line, from, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
  if (!line)
    return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line))
    return trivialOrder(line.length);
  if (isolates.length)
    while (line.length > types.length)
      types[types.length] = 256;
  let order = [], level = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level, level, isolates, 0, line.length, order);
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
var movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a2;
  let startIndex = start.head - line.from;
  let spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
  let span = order[spanI], spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order.length)
      return null;
    span = order[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = findClusterBreak2(line.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to)
    nextIndex = spanEnd;
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to) {
  for (let i = from; i < to; i++) {
    let type = charType(text.charCodeAt(i));
    if (type == 1)
      return LTR;
    if (type == 2 || type == 4)
      return RTL;
  }
  return LTR;
}
var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
var exceptionSink = /* @__PURE__ */ Facet.define();
var updateListener = /* @__PURE__ */ Facet.define();
var inputHandler = /* @__PURE__ */ Facet.define();
var focusChangeEffect = /* @__PURE__ */ Facet.define();
var clipboardInputFilter = /* @__PURE__ */ Facet.define();
var clipboardOutputFilter = /* @__PURE__ */ Facet.define();
var perLineTextDirection = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((x) => x)
});
var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((x) => x)
});
var scrollHandler = /* @__PURE__ */ Facet.define();
var ScrollTarget = class _ScrollTarget {
  constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
    this.range = range;
    this.y = y;
    this.x = x;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
    this.isSnapshot = isSnapshot;
  }
  map(changes) {
    return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(state) {
    return this.range.to <= state.doc.length ? this : new _ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
};
var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
var setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror && window.onerror(String(exception), context, void 0, void 0, exception)) ;
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
var editable = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : true });
var nextPluginID = 0;
var viewPlugin = /* @__PURE__ */ Facet.define({
  combine(plugins) {
    return plugins.filter((p, i) => {
      for (let j = 0; j < i; j++)
        if (plugins[j].plugin == p.plugin)
          return false;
      return true;
    });
  }
});
var ViewPlugin = class _ViewPlugin {
  constructor(id2, create, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id2;
    this.create = create;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.baseExtensions = buildExtensions(this);
    this.extension = this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(arg) {
    return this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create, spec) {
    const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
    return new _ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin) => {
      let ext = [];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide)
        ext.push(provide(plugin));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return _ViewPlugin.define((view, arg) => new cls(view, arg), spec);
  }
};
var PluginInstance = class {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.plugin.create(view, this.spec.arg);
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e) {
          logException(update.state, e, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a2;
    if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
};
var editorAttributes = /* @__PURE__ */ Facet.define();
var contentAttributes = /* @__PURE__ */ Facet.define();
var decorations = /* @__PURE__ */ Facet.define();
var blockWrappers = /* @__PURE__ */ Facet.define();
var outerDecorations = /* @__PURE__ */ Facet.define();
var atomicRanges = /* @__PURE__ */ Facet.define();
var bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length)
    return isolates;
  let sets = isolates.map((i) => i instanceof Function ? i(view) : i);
  let result = [];
  RangeSet.spans(sets, line.from, line.to, {
    point() {
    },
    span(fromDoc, toDoc, active, open) {
      let from = fromDoc - line.from, to = toDoc - line.from;
      let level = result;
      for (let i = active.length - 1; i >= 0; i--, open--) {
        let direction = active[i].spec.bidiIsolate, update;
        if (direction == null)
          direction = autoDirection(line.text, from, to);
        if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {
          update.to = to;
          level = update.inner;
        } else {
          let add2 = { from, to, direction, inner: [] };
          level.push(add2);
          level = add2.inner;
        }
      }
    }
  });
  return result;
}
var scrollMargins = /* @__PURE__ */ Facet.define();
function getScrollMargins(view) {
  let left = 0, right = 0, top2 = 0, bottom = 0;
  for (let source of view.state.facet(scrollMargins)) {
    let m = source(view);
    if (m) {
      if (m.left != null)
        left = Math.max(left, m.left);
      if (m.right != null)
        right = Math.max(right, m.right);
      if (m.top != null)
        top2 = Math.max(top2, m.top);
      if (m.bottom != null)
        bottom = Math.max(bottom, m.bottom);
    }
  }
  return { left, right, top: top2, bottom };
}
var styleModule = /* @__PURE__ */ Facet.define();
var ChangedRange = class _ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new _ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set) {
    let i = set.length, me = this;
    for (; i > 0; i--) {
      let range = set[i - 1];
      if (range.fromA > me.toA)
        continue;
      if (range.toA < me.fromA)
        break;
      me = me.join(range);
      set.splice(i - 1, 1);
    }
    set.splice(i, 0, me);
    return set;
  }
  // Extend a set to cover all the content in `ranges`, which is a
  // flat array with each pair of numbers representing fromB/toB
  // positions. These pairs are generated in unchanged ranges, so the
  // offset between doc A and doc B is the same for their start and
  // end points.
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, off = 0; ; ) {
      let nextD = dI < diff.length ? diff[dI].fromB : 1e9;
      let nextR = rI < ranges.length ? ranges[rI] : 1e9;
      let fromB = Math.min(nextD, nextR);
      if (fromB == 1e9)
        break;
      let fromA = fromB + off, toB = fromB, toA = fromA;
      for (; ; ) {
        if (rI < ranges.length && ranges[rI] <= toB) {
          let end = ranges[rI + 1];
          rI += 2;
          toB = Math.max(toB, end);
          for (let i = dI; i < diff.length && diff[i].fromB <= toB; i++)
            off = diff[i].toA - diff[i].toB;
          toA = Math.max(toA, end + off);
        } else if (dI < diff.length && diff[dI].fromB <= toB) {
          let next = diff[dI++];
          toB = Math.max(toB, next.toB);
          toA = Math.max(toA, next.toA);
          off = next.toA - next.toB;
        } else {
          break;
        }
      }
      result.push(new _ChangedRange(fromA, toA, fromB, toB));
    }
    return result;
  }
};
var ViewUpdate = class _ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new _ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (16 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var noChildren = [];
var Tile = class {
  constructor(dom, length, flags = 0) {
    this.dom = dom;
    this.length = length;
    this.flags = flags;
    this.parent = null;
    dom.cmTile = this;
  }
  get breakAfter() {
    return this.flags & 1;
  }
  get children() {
    return noChildren;
  }
  isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  isComposite() {
    return false;
  }
  isLine() {
    return false;
  }
  isText() {
    return false;
  }
  isBlock() {
    return false;
  }
  get domAttrs() {
    return null;
  }
  sync(track) {
    this.flags |= 2;
    if (this.flags & 4) {
      this.flags &= ~4;
      let attrs = this.domAttrs;
      if (attrs)
        setAttrs(this.dom, attrs);
    }
  }
  toString() {
    return this.constructor.name + (this.children.length ? `(${this.children})` : "") + (this.breakAfter ? "#" : "");
  }
  destroy() {
    this.parent = null;
  }
  setDOM(dom) {
    this.dom = dom;
    dom.cmTile = this;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(tile, start = this.posAtStart) {
    let pos = start;
    for (let child of this.children) {
      if (child == tile)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(tile) {
    return this.posBefore(tile) + tile.length;
  }
  covers(side) {
    return true;
  }
  coordsIn(pos, side) {
    return null;
  }
  domPosFor(off, side) {
    let index = domIndex(this.dom);
    let after = this.length ? off > 0 : side > 0;
    return new DOMPos(this.parent.dom, index + (after ? 1 : 0), off == 0 || off == this.length);
  }
  markDirty(attrs) {
    this.flags &= ~2;
    if (attrs)
      this.flags |= 4;
    if (this.parent && this.parent.flags & 2)
      this.parent.markDirty(false);
  }
  get overrideDOMText() {
    return null;
  }
  get root() {
    for (let t2 = this; t2; t2 = t2.parent)
      if (t2 instanceof DocTile)
        return t2;
    return null;
  }
  static get(dom) {
    return dom.cmTile;
  }
};
var CompositeTile = class extends Tile {
  constructor(dom) {
    super(dom, 0);
    this._children = [];
  }
  isComposite() {
    return true;
  }
  get children() {
    return this._children;
  }
  get lastChild() {
    return this.children.length ? this.children[this.children.length - 1] : null;
  }
  append(child) {
    this.children.push(child);
    child.parent = this;
  }
  sync(track) {
    if (this.flags & 2)
      return;
    super.sync(track);
    let parent = this.dom, prev = null, next;
    let tracking = (track === null || track === void 0 ? void 0 : track.node) == parent ? track : null;
    let length = 0;
    for (let child of this.children) {
      child.sync(track);
      length += child.length + child.breakAfter;
      next = prev ? prev.nextSibling : parent.firstChild;
      if (tracking && next != child.dom)
        tracking.written = true;
      if (child.dom.parentNode == parent) {
        while (next && next != child.dom)
          next = rm$1(next);
      } else {
        parent.insertBefore(child.dom, next);
      }
      prev = child.dom;
    }
    next = prev ? prev.nextSibling : parent.firstChild;
    if (tracking && next)
      tracking.written = true;
    while (next)
      next = rm$1(next);
    this.length = length;
  }
};
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var DocTile = class extends CompositeTile {
  constructor(view, dom) {
    super(dom);
    this.view = view;
  }
  owns(tile) {
    for (; tile; tile = tile.parent)
      if (tile == this)
        return true;
    return false;
  }
  isBlock() {
    return true;
  }
  nearest(dom) {
    for (; ; ) {
      if (!dom)
        return null;
      let tile = Tile.get(dom);
      if (tile && this.owns(tile))
        return tile;
      dom = dom.parentNode;
    }
  }
  blockTiles(f) {
    for (let stack = [], cur2 = this, i = 0, pos = 0; ; ) {
      if (i == cur2.children.length) {
        if (!stack.length)
          return;
        cur2 = cur2.parent;
        if (cur2.breakAfter)
          pos++;
        i = stack.pop();
      } else {
        let next = cur2.children[i++];
        if (next instanceof BlockWrapperTile) {
          stack.push(i);
          cur2 = next;
          i = 0;
        } else {
          let end = pos + next.length;
          let result = f(next, pos);
          if (result !== void 0)
            return result;
          pos = end + next.breakAfter;
        }
      }
    }
  }
  // Find the block at the given position. If side < -1, make sure to
  // stay before block widgets at that position, if side > 1, after
  // such widgets (used for selection drawing, which needs to be able
  // to get coordinates for positions that aren't valid cursor positions).
  resolveBlock(pos, side) {
    let before, beforeOff = -1, after, afterOff = -1;
    this.blockTiles((tile, off) => {
      let end = off + tile.length;
      if (pos >= off && pos <= end) {
        if (tile.isWidget() && side >= -1 && side <= 1) {
          if (tile.flags & 32)
            return true;
          if (tile.flags & 16)
            before = void 0;
        }
        if ((off < pos || pos == end && (side < -1 ? tile.length : tile.covers(1))) && (!before || !tile.isWidget() && before.isWidget())) {
          before = tile;
          beforeOff = pos - off;
        }
        if ((end > pos || pos == off && (side > 1 ? tile.length : tile.covers(-1))) && (!after || !tile.isWidget() && after.isWidget())) {
          after = tile;
          afterOff = pos - off;
        }
      }
    });
    if (!before && !after)
      throw new Error("No tile at position " + pos);
    return before && side < 0 || !after ? { tile: before, offset: beforeOff } : { tile: after, offset: afterOff };
  }
};
var BlockWrapperTile = class _BlockWrapperTile extends CompositeTile {
  constructor(dom, wrapper) {
    super(dom);
    this.wrapper = wrapper;
  }
  isBlock() {
    return true;
  }
  covers(side) {
    if (!this.children.length)
      return false;
    return side < 0 ? this.children[0].covers(-1) : this.lastChild.covers(1);
  }
  get domAttrs() {
    return this.wrapper.attributes;
  }
  static of(wrapper, dom) {
    let tile = new _BlockWrapperTile(dom || document.createElement(wrapper.tagName), wrapper);
    if (!dom)
      tile.flags |= 4;
    return tile;
  }
};
var LineTile = class _LineTile extends CompositeTile {
  constructor(dom, attrs) {
    super(dom);
    this.attrs = attrs;
  }
  isLine() {
    return true;
  }
  static start(attrs, dom, keepAttrs) {
    let line = new _LineTile(dom || document.createElement("div"), attrs);
    if (!dom || !keepAttrs)
      line.flags |= 4;
    return line;
  }
  get domAttrs() {
    return this.attrs;
  }
  // Find the tile associated with a given position in this line.
  resolveInline(pos, side, forCoords) {
    let before = null, beforeOff = -1, after = null, afterOff = -1;
    function scan(tile, pos2) {
      for (let i = 0, off = 0; i < tile.children.length && off <= pos2; i++) {
        let child = tile.children[i], end = off + child.length;
        if (end >= pos2) {
          if (child.isComposite()) {
            scan(child, pos2 - off);
          } else if ((!after || after.isHidden && (side > 0 || forCoords && onSameLine(after, child))) && (end > pos2 || child.flags & 32)) {
            after = child;
            afterOff = pos2 - off;
          } else if (off < pos2 || child.flags & 16 && !child.isHidden) {
            before = child;
            beforeOff = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(this, pos);
    let target = (side < 0 ? before : after) || before || after;
    return target ? { tile: target, offset: target == before ? beforeOff : afterOff } : null;
  }
  coordsIn(pos, side) {
    let found = this.resolveInline(pos, side, true);
    if (!found)
      return fallbackRect(this);
    return found.tile.coordsIn(Math.max(0, found.offset), side);
  }
  domIn(pos, side) {
    let found = this.resolveInline(pos, side);
    if (found) {
      let { tile, offset } = found;
      if (this.dom.contains(tile.dom)) {
        if (tile.isText())
          return new DOMPos(tile.dom, Math.min(tile.dom.nodeValue.length, offset));
        return tile.domPosFor(offset, tile.flags & 16 ? 1 : tile.flags & 32 ? -1 : side);
      }
      let parent = found.tile.parent, saw = false;
      for (let ch of parent.children) {
        if (saw)
          return new DOMPos(ch.dom, 0);
        if (ch == found.tile) {
          saw = true;
        }
      }
    }
    return new DOMPos(this.dom, 0);
  }
};
function fallbackRect(tile) {
  let last = tile.dom.lastChild;
  if (!last)
    return tile.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1] || null;
}
function onSameLine(a, b) {
  let posA = a.coordsIn(0, 1), posB = b.coordsIn(0, 1);
  return posA && posB && posB.top < posA.bottom;
}
var MarkTile = class _MarkTile extends CompositeTile {
  constructor(dom, mark) {
    super(dom);
    this.mark = mark;
  }
  get domAttrs() {
    return this.mark.attrs;
  }
  static of(mark, dom) {
    let tile = new _MarkTile(dom || document.createElement(mark.tagName), mark);
    if (!dom)
      tile.flags |= 4;
    return tile;
  }
};
var TextTile = class _TextTile extends Tile {
  constructor(dom, text) {
    super(dom, text.length);
    this.text = text;
  }
  sync(track) {
    if (this.flags & 2)
      return;
    super.sync(track);
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  isText() {
    return true;
  }
  toString() {
    return JSON.stringify(this.text);
  }
  coordsIn(pos, side) {
    let length = this.dom.nodeValue.length;
    if (pos > length)
      pos = length;
    let from = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else if (to < length) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to < length)
        to++;
    }
    let rects = textRange(this.dom, from, to).getClientRects();
    if (!rects.length)
      return null;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  static of(text, dom) {
    let tile = new _TextTile(dom || document.createTextNode(text), text);
    if (!dom)
      tile.flags |= 2;
    return tile;
  }
};
var WidgetTile = class _WidgetTile extends Tile {
  constructor(dom, length, widget, flags) {
    super(dom, length, flags);
    this.widget = widget;
  }
  isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  covers(side) {
    if (this.flags & 48)
      return false;
    return (this.flags & (side < 0 ? 64 : 128)) > 0;
  }
  coordsIn(pos, side) {
    return this.coordsInWidget(pos, side, false);
  }
  coordsInWidget(pos, side, block) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    if (block) {
      return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    } else {
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return null;
      let fromBack = this.flags & 16 ? true : this.flags & 32 ? false : pos > 0;
      for (let i = fromBack ? rects.length - 1 : 0; ; i += fromBack ? -1 : 1) {
        rect = rects[i];
        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return flattenRect(rect, !fromBack);
    }
  }
  get overrideDOMText() {
    if (!this.length)
      return Text.empty;
    let { root } = this;
    if (!root)
      return Text.empty;
    let start = this.posAtStart;
    return root.view.state.doc.slice(start, start + this.length);
  }
  destroy() {
    super.destroy();
    this.widget.destroy(this.dom);
  }
  static of(widget, view, length, flags, dom) {
    if (!dom) {
      dom = widget.toDOM(view);
      if (!widget.editable)
        dom.contentEditable = "false";
    }
    return new _WidgetTile(dom, length, widget, flags);
  }
};
var WidgetBufferTile = class extends Tile {
  constructor(flags) {
    let img = document.createElement("img");
    img.className = "cm-widgetBuffer";
    img.setAttribute("aria-hidden", "true");
    super(img, 0, flags);
  }
  get isHidden() {
    return true;
  }
  get overrideDOMText() {
    return Text.empty;
  }
  coordsIn(pos) {
    return this.dom.getBoundingClientRect();
  }
};
var TilePointer = class {
  constructor(top2) {
    this.index = 0;
    this.beforeBreak = false;
    this.parents = [];
    this.tile = top2;
  }
  // Advance by the given distance. If side is -1, stop leaving or
  // entering tiles, or skipping zero-length tiles, once the distance
  // has been traversed. When side is 1, leave, enter, or skip
  // everything at the end position.
  advance(dist2, side, walker) {
    let { tile, index, beforeBreak, parents } = this;
    while (dist2 || side > 0) {
      if (!tile.isComposite()) {
        if (index == tile.length) {
          beforeBreak = !!tile.breakAfter;
          ({ tile, index } = parents.pop());
          index++;
        } else if (!dist2) {
          break;
        } else {
          let take = Math.min(dist2, tile.length - index);
          if (walker)
            walker.skip(tile, index, index + take);
          dist2 -= take;
          index += take;
        }
      } else if (beforeBreak) {
        if (!dist2)
          break;
        if (walker)
          walker.break();
        dist2--;
        beforeBreak = false;
      } else if (index == tile.children.length) {
        if (!dist2 && !parents.length)
          break;
        if (walker)
          walker.leave(tile);
        beforeBreak = !!tile.breakAfter;
        ({ tile, index } = parents.pop());
        index++;
      } else {
        let next = tile.children[index], brk = next.breakAfter;
        if ((side > 0 ? next.length <= dist2 : next.length < dist2) && (!walker || walker.skip(next, 0, next.length) !== false || !next.isComposite)) {
          beforeBreak = !!brk;
          index++;
          dist2 -= next.length;
        } else {
          parents.push({ tile, index });
          tile = next;
          index = 0;
          if (walker && next.isComposite())
            walker.enter(next);
        }
      }
    }
    this.tile = tile;
    this.index = index;
    this.beforeBreak = beforeBreak;
    return this;
  }
  get root() {
    return this.parents.length ? this.parents[0].tile : this.tile;
  }
};
var OpenWrapper = class {
  constructor(from, to, wrapper, rank) {
    this.from = from;
    this.to = to;
    this.wrapper = wrapper;
    this.rank = rank;
  }
};
var TileBuilder = class {
  constructor(cache2, root, blockWrappers2) {
    this.cache = cache2;
    this.root = root;
    this.blockWrappers = blockWrappers2;
    this.curLine = null;
    this.lastBlock = null;
    this.afterWidget = null;
    this.pos = 0;
    this.wrappers = [];
    this.wrapperPos = 0;
  }
  addText(text, marks2, openStart, tile) {
    var _a2;
    this.flushBuffer();
    let parent = this.ensureMarks(marks2, openStart);
    let prev = parent.lastChild;
    if (prev && prev.isText() && !(prev.flags & 8) && prev.length + text.length < 512) {
      this.cache.reused.set(
        prev,
        2
        /* Reused.DOM */
      );
      let tile2 = parent.children[parent.children.length - 1] = new TextTile(prev.dom, prev.text + text);
      tile2.parent = parent;
    } else {
      parent.append(tile || TextTile.of(text, (_a2 = this.cache.find(TextTile)) === null || _a2 === void 0 ? void 0 : _a2.dom));
    }
    this.pos += text.length;
    this.afterWidget = null;
  }
  addComposition(composition, context) {
    let line = this.curLine;
    if (line.dom != context.line.dom) {
      line.setDOM(this.cache.reused.has(context.line) ? freeNode(context.line.dom) : context.line.dom);
      this.cache.reused.set(
        context.line,
        2
        /* Reused.DOM */
      );
    }
    let head = line;
    for (let i = context.marks.length - 1; i >= 0; i--) {
      let mark = context.marks[i];
      let last = head.lastChild;
      if (last instanceof MarkTile && last.mark.eq(mark.mark)) {
        if (last.dom != mark.dom)
          last.setDOM(freeNode(mark.dom));
        head = last;
      } else {
        if (this.cache.reused.get(mark)) {
          let tile = Tile.get(mark.dom);
          if (tile)
            tile.setDOM(freeNode(mark.dom));
        }
        let nw = MarkTile.of(mark.mark, mark.dom);
        head.append(nw);
        head = nw;
      }
      this.cache.reused.set(
        mark,
        2
        /* Reused.DOM */
      );
    }
    let oldTile = Tile.get(composition.text);
    if (oldTile)
      this.cache.reused.set(
        oldTile,
        2
        /* Reused.DOM */
      );
    let text = new TextTile(composition.text, composition.text.nodeValue);
    text.flags |= 8;
    head.append(text);
  }
  addInlineWidget(widget, marks2, openStart) {
    let noSpace = this.afterWidget && widget.flags & 48 && (this.afterWidget.flags & 48) == (widget.flags & 48);
    if (!noSpace)
      this.flushBuffer();
    let parent = this.ensureMarks(marks2, openStart);
    if (!noSpace && !(widget.flags & 16))
      parent.append(this.getBuffer(1));
    parent.append(widget);
    this.pos += widget.length;
    this.afterWidget = widget;
  }
  addMark(tile, marks2, openStart) {
    this.flushBuffer();
    let parent = this.ensureMarks(marks2, openStart);
    parent.append(tile);
    this.pos += tile.length;
    this.afterWidget = null;
  }
  addBlockWidget(widget) {
    this.getBlockPos().append(widget);
    this.pos += widget.length;
    this.lastBlock = widget;
    this.endLine();
  }
  continueWidget(length) {
    let widget = this.afterWidget || this.lastBlock;
    widget.length += length;
    this.pos += length;
  }
  addLineStart(attrs, dom) {
    var _a2;
    if (!attrs)
      attrs = lineBaseAttrs;
    let tile = LineTile.start(attrs, dom || ((_a2 = this.cache.find(LineTile)) === null || _a2 === void 0 ? void 0 : _a2.dom), !!dom);
    this.getBlockPos().append(this.lastBlock = this.curLine = tile);
  }
  addLine(tile) {
    this.getBlockPos().append(tile);
    this.pos += tile.length;
    this.lastBlock = tile;
    this.endLine();
  }
  addBreak() {
    this.lastBlock.flags |= 1;
    this.endLine();
    this.pos++;
  }
  addLineStartIfNotCovered(attrs) {
    if (!this.blockPosCovered())
      this.addLineStart(attrs);
  }
  ensureLine(attrs) {
    if (!this.curLine)
      this.addLineStart(attrs);
  }
  ensureMarks(marks2, openStart) {
    var _a2;
    let parent = this.curLine;
    for (let i = marks2.length - 1; i >= 0; i--) {
      let mark = marks2[i], last;
      if (openStart > 0 && (last = parent.lastChild) && last instanceof MarkTile && last.mark.eq(mark)) {
        parent = last;
        openStart--;
      } else {
        let tile = MarkTile.of(mark, (_a2 = this.cache.find(MarkTile, (m) => m.mark.eq(mark))) === null || _a2 === void 0 ? void 0 : _a2.dom);
        parent.append(tile);
        parent = tile;
        openStart = 0;
      }
    }
    return parent;
  }
  endLine() {
    if (this.curLine) {
      this.flushBuffer();
      let last = this.curLine.lastChild;
      if (!last || !hasContent(this.curLine, false) || last.dom.nodeName != "BR" && last.isWidget() && !(browser.ios && hasContent(this.curLine, true)))
        this.curLine.append(this.cache.findWidget(
          BreakWidget,
          0,
          32
          /* TileFlag.After */
        ) || new WidgetTile(
          BreakWidget.toDOM(),
          0,
          BreakWidget,
          32
          /* TileFlag.After */
        ));
      this.curLine = this.afterWidget = null;
    }
  }
  updateBlockWrappers() {
    if (this.wrapperPos > this.pos + 1e4) {
      this.blockWrappers.goto(this.pos);
      this.wrappers.length = 0;
    }
    for (let i = this.wrappers.length - 1; i >= 0; i--)
      if (this.wrappers[i].to < this.pos)
        this.wrappers.splice(i, 1);
    for (let cur2 = this.blockWrappers; cur2.value && cur2.from <= this.pos; cur2.next())
      if (cur2.to >= this.pos) {
        let wrap = new OpenWrapper(cur2.from, cur2.to, cur2.value, cur2.rank), i = this.wrappers.length;
        while (i > 0 && (this.wrappers[i - 1].rank - wrap.rank || this.wrappers[i - 1].to - wrap.to) < 0)
          i--;
        this.wrappers.splice(i, 0, wrap);
      }
    this.wrapperPos = this.pos;
  }
  getBlockPos() {
    var _a2;
    this.updateBlockWrappers();
    let parent = this.root;
    for (let wrap of this.wrappers) {
      let last = parent.lastChild;
      if (wrap.from < this.pos && last instanceof BlockWrapperTile && last.wrapper.eq(wrap.wrapper)) {
        parent = last;
      } else {
        let tile = BlockWrapperTile.of(wrap.wrapper, (_a2 = this.cache.find(BlockWrapperTile, (t2) => t2.wrapper.eq(wrap.wrapper))) === null || _a2 === void 0 ? void 0 : _a2.dom);
        parent.append(tile);
        parent = tile;
      }
    }
    return parent;
  }
  blockPosCovered() {
    let last = this.lastBlock;
    return last != null && !last.breakAfter && (!last.isWidget() || (last.flags & (32 | 128)) > 0);
  }
  getBuffer(side) {
    let flags = 2 | (side < 0 ? 16 : 32);
    let found = this.cache.find(
      WidgetBufferTile,
      void 0,
      1
      /* Reused.Full */
    );
    if (found)
      found.flags = flags;
    return found || new WidgetBufferTile(flags);
  }
  flushBuffer() {
    if (this.afterWidget && !(this.afterWidget.flags & 32)) {
      this.afterWidget.parent.append(this.getBuffer(-1));
      this.afterWidget = null;
    }
  }
};
var TextStream = class {
  constructor(doc2) {
    this.skipCount = 0;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
  }
  skip(len) {
    if (this.textOff + len <= this.text.length) {
      this.textOff += len;
    } else {
      this.skipCount += len - (this.text.length - this.textOff);
      this.text = "";
      this.textOff = 0;
    }
  }
  next(maxLen) {
    if (this.textOff == this.text.length) {
      let { value, lineBreak, done } = this.cursor.next(this.skipCount);
      this.skipCount = 0;
      if (done)
        throw new Error("Ran out of text content when drawing inline views");
      this.text = value;
      let len = this.textOff = Math.min(maxLen, value.length);
      return lineBreak ? null : value.slice(0, len);
    }
    let end = Math.min(this.text.length, this.textOff + maxLen);
    let chars = this.text.slice(this.textOff, end);
    this.textOff = end;
    return chars;
  }
};
var buckets = [WidgetTile, LineTile, TextTile, MarkTile, WidgetBufferTile, BlockWrapperTile, DocTile];
for (let i = 0; i < buckets.length; i++)
  buckets[i].bucket = i;
var TileCache = class {
  constructor(view) {
    this.view = view;
    this.buckets = buckets.map(() => []);
    this.index = buckets.map(() => 0);
    this.reused = /* @__PURE__ */ new Map();
  }
  // Put a tile in the cache.
  add(tile) {
    let i = tile.constructor.bucket, bucket = this.buckets[i];
    if (bucket.length < 6)
      bucket.push(tile);
    else
      bucket[
        this.index[i] = (this.index[i] + 1) % 6
        /* C.Bucket */
      ] = tile;
  }
  find(cls, test, type = 2) {
    let i = cls.bucket;
    let bucket = this.buckets[i], off = this.index[i];
    for (let j = bucket.length - 1; j >= 0; j--) {
      let index = (j + off) % bucket.length, tile = bucket[index];
      if ((!test || test(tile)) && !this.reused.has(tile)) {
        bucket.splice(index, 1);
        if (index < off)
          this.index[i]--;
        this.reused.set(tile, type);
        return tile;
      }
    }
    return null;
  }
  findWidget(widget, length, flags) {
    let widgets = this.buckets[0];
    if (widgets.length)
      for (let i = 0, pass = 0; ; i++) {
        if (i == widgets.length) {
          if (pass)
            return null;
          pass = 1;
          i = 0;
        }
        let tile = widgets[i];
        if (!this.reused.has(tile) && (pass == 0 ? tile.widget.compare(widget) : tile.widget.constructor == widget.constructor && widget.updateDOM(tile.dom, this.view))) {
          widgets.splice(i, 1);
          if (i < this.index[0])
            this.index[0]--;
          if (tile.widget == widget && tile.length == length && (tile.flags & (496 | 1)) == flags) {
            this.reused.set(
              tile,
              1
              /* Reused.Full */
            );
            return tile;
          } else {
            this.reused.set(
              tile,
              2
              /* Reused.DOM */
            );
            return new WidgetTile(tile.dom, length, widget, tile.flags & ~(496 | 1) | flags);
          }
        }
      }
  }
  reuse(tile) {
    this.reused.set(
      tile,
      1
      /* Reused.Full */
    );
    return tile;
  }
  maybeReuse(tile, type = 2) {
    if (this.reused.has(tile))
      return void 0;
    this.reused.set(tile, type);
    return tile.dom;
  }
  clear() {
    for (let i = 0; i < this.buckets.length; i++)
      this.buckets[i].length = this.index[i] = 0;
  }
};
var TileUpdate = class {
  constructor(view, old, blockWrappers2, decorations2, disallowBlockEffectsFor) {
    this.view = view;
    this.decorations = decorations2;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.openWidget = false;
    this.openMarks = 0;
    this.cache = new TileCache(view);
    this.text = new TextStream(view.state.doc);
    this.builder = new TileBuilder(this.cache, new DocTile(view, view.contentDOM), RangeSet.iter(blockWrappers2));
    this.cache.reused.set(
      old,
      2
      /* Reused.DOM */
    );
    this.old = new TilePointer(old);
    this.reuseWalker = {
      skip: (tile, from, to) => {
        this.cache.add(tile);
        if (tile.isComposite())
          return false;
      },
      enter: (tile) => this.cache.add(tile),
      leave: () => {
      },
      break: () => {
      }
    };
  }
  run(changes, composition) {
    let compositionContext = composition && this.getCompositionContext(composition.text);
    for (let posA = 0, posB = 0, i = 0; ; ) {
      let next = i < changes.length ? changes[i++] : null;
      let skipA = next ? next.fromA : this.old.root.length;
      if (skipA > posA) {
        let len = skipA - posA;
        this.preserve(len, !i, !next);
        posA = skipA;
        posB += len;
      }
      if (!next)
        break;
      if (composition && next.fromA <= composition.range.fromA && next.toA >= composition.range.toA) {
        this.forward(next.fromA, composition.range.fromA, composition.range.fromA < composition.range.toA ? 1 : -1);
        this.emit(posB, composition.range.fromB);
        this.cache.clear();
        this.builder.addComposition(composition, compositionContext);
        this.text.skip(composition.range.toB - composition.range.fromB);
        this.forward(composition.range.fromA, next.toA);
        this.emit(composition.range.toB, next.toB);
      } else {
        this.forward(next.fromA, next.toA);
        this.emit(posB, next.toB);
      }
      posB = next.toB;
      posA = next.toA;
    }
    if (this.builder.curLine)
      this.builder.endLine();
    return this.builder.root;
  }
  preserve(length, incStart, incEnd) {
    let activeMarks = getMarks(this.old), openMarks = this.openMarks;
    this.old.advance(length, incEnd ? 1 : -1, {
      skip: (tile, from, to) => {
        if (tile.isWidget()) {
          if (this.openWidget) {
            this.builder.continueWidget(to - from);
          } else {
            let widget = to > 0 || from < tile.length ? WidgetTile.of(tile.widget, this.view, to - from, tile.flags & 496, this.cache.maybeReuse(tile)) : this.cache.reuse(tile);
            if (widget.flags & 256) {
              widget.flags &= ~1;
              this.builder.addBlockWidget(widget);
            } else {
              this.builder.ensureLine(null);
              this.builder.addInlineWidget(widget, activeMarks, openMarks);
              openMarks = activeMarks.length;
            }
          }
        } else if (tile.isText()) {
          this.builder.ensureLine(null);
          if (!from && to == tile.length) {
            this.builder.addText(tile.text, activeMarks, openMarks, this.cache.reuse(tile));
          } else {
            this.cache.add(tile);
            this.builder.addText(tile.text.slice(from, to), activeMarks, openMarks);
          }
          openMarks = activeMarks.length;
        } else if (tile.isLine()) {
          tile.flags &= ~1;
          this.cache.reused.set(
            tile,
            1
            /* Reused.Full */
          );
          this.builder.addLine(tile);
        } else if (tile instanceof WidgetBufferTile) {
          this.cache.add(tile);
        } else if (tile instanceof MarkTile) {
          this.builder.ensureLine(null);
          this.builder.addMark(tile, activeMarks, openMarks);
          this.cache.reused.set(
            tile,
            1
            /* Reused.Full */
          );
          openMarks = activeMarks.length;
        } else {
          return false;
        }
        this.openWidget = false;
      },
      enter: (tile) => {
        if (tile.isLine()) {
          this.builder.addLineStart(tile.attrs, this.cache.maybeReuse(tile));
        } else {
          this.cache.add(tile);
          if (tile instanceof MarkTile)
            activeMarks.unshift(tile.mark);
        }
        this.openWidget = false;
      },
      leave: (tile) => {
        if (tile.isLine()) {
          if (activeMarks.length)
            activeMarks.length = openMarks = 0;
        } else if (tile instanceof MarkTile) {
          activeMarks.shift();
          openMarks = Math.min(openMarks, activeMarks.length);
        }
      },
      break: () => {
        this.builder.addBreak();
        this.openWidget = false;
      }
    });
    this.text.skip(length);
  }
  emit(from, to) {
    let pendingLineAttrs = null;
    let b = this.builder, markCount = 0;
    let openEnd = RangeSet.spans(this.decorations, from, to, {
      point: (from2, to2, deco, active, openStart, index) => {
        if (deco instanceof PointDecoration) {
          if (this.disallowBlockEffectsFor[index]) {
            if (deco.block)
              throw new RangeError("Block decorations may not be specified via plugins");
            if (to2 > this.view.state.doc.lineAt(from2).to)
              throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
          }
          markCount = active.length;
          if (openStart > active.length) {
            b.continueWidget(to2 - from2);
          } else {
            let widget = deco.widget || (deco.block ? NullWidget.block : NullWidget.inline);
            let flags = widgetFlags(deco);
            let tile = this.cache.findWidget(widget, to2 - from2, flags) || WidgetTile.of(widget, this.view, to2 - from2, flags);
            if (deco.block) {
              if (deco.startSide > 0)
                b.addLineStartIfNotCovered(pendingLineAttrs);
              b.addBlockWidget(tile);
            } else {
              b.ensureLine(pendingLineAttrs);
              b.addInlineWidget(tile, active, openStart);
            }
          }
          pendingLineAttrs = null;
        } else {
          pendingLineAttrs = addLineDeco(pendingLineAttrs, deco);
        }
        if (to2 > from2)
          this.text.skip(to2 - from2);
      },
      span: (from2, to2, active, openStart) => {
        for (let pos = from2; pos < to2; ) {
          let chars = this.text.next(Math.min(512, to2 - pos));
          if (chars == null) {
            b.addLineStartIfNotCovered(pendingLineAttrs);
            b.addBreak();
            pos++;
          } else {
            b.ensureLine(pendingLineAttrs);
            b.addText(chars, active, pos == from2 ? openStart : active.length);
            pos += chars.length;
          }
          pendingLineAttrs = null;
        }
      }
    });
    b.addLineStartIfNotCovered(pendingLineAttrs);
    this.openWidget = openEnd > markCount;
    this.openMarks = openEnd;
  }
  forward(from, to, side = 1) {
    if (to - from <= 10) {
      this.old.advance(to - from, side, this.reuseWalker);
    } else {
      this.old.advance(5, -1, this.reuseWalker);
      this.old.advance(to - from - 10, -1);
      this.old.advance(5, side, this.reuseWalker);
    }
  }
  getCompositionContext(text) {
    let marks2 = [], line = null;
    for (let parent = text.parentNode; ; parent = parent.parentNode) {
      let tile = Tile.get(parent);
      if (parent == this.view.contentDOM)
        break;
      if (tile instanceof MarkTile)
        marks2.push(tile);
      else if (tile === null || tile === void 0 ? void 0 : tile.isLine())
        line = tile;
      else if (parent.nodeName == "DIV" && !line && parent != this.view.contentDOM)
        line = new LineTile(parent, lineBaseAttrs);
      else
        marks2.push(MarkTile.of(new MarkDecoration({ tagName: parent.nodeName.toLowerCase(), attributes: getAttrs(parent) }), parent));
    }
    return { line, marks: marks2 };
  }
};
function hasContent(tile, requireText) {
  let scan = (tile2) => {
    for (let ch of tile2.children)
      if ((requireText ? ch.isText() : ch.length) || scan(ch))
        return true;
    return false;
  };
  return scan(tile);
}
function widgetFlags(deco) {
  let flags = deco.isReplace ? (deco.startSide < 0 ? 64 : 0) | (deco.endSide > 0 ? 128 : 0) : deco.startSide > 0 ? 32 : 16;
  if (deco.block)
    flags |= 256;
  return flags;
}
var lineBaseAttrs = { class: "cm-line" };
function addLineDeco(value, deco) {
  let attrs = deco.spec.attributes, cls = deco.spec.class;
  if (!attrs && !cls)
    return value;
  if (!value)
    value = { class: "cm-line" };
  if (attrs)
    combineAttrs(attrs, value);
  if (cls)
    value.class += " " + cls;
  return value;
}
function getMarks(ptr) {
  let found = [];
  for (let i = ptr.parents.length; i > 1; i--) {
    let tile = i == ptr.parents.length ? ptr.tile : ptr.parents[i].tile;
    if (tile instanceof MarkTile)
      found.push(tile.mark);
  }
  return found;
}
function freeNode(node) {
  let tile = Tile.get(node);
  if (tile)
    tile.setDOM(node.cloneNode());
  return node;
}
var NullWidget = class extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt2) {
    return elt2.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
NullWidget.block = /* @__PURE__ */ new NullWidget("div");
var BreakWidget = /* @__PURE__ */ new class extends WidgetType {
  toDOM() {
    return document.createElement("br");
  }
  get isHidden() {
    return true;
  }
  get editable() {
    return true;
  }
}();
var DocView = class {
  constructor(view) {
    this.view = view;
    this.decorations = [];
    this.blockWrappers = [];
    this.dynamicDecorationMap = [false];
    this.domChanged = null;
    this.hasComposition = null;
    this.editContextFormatting = Decoration.none;
    this.lastCompositionAfterCursor = false;
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.updateDeco();
    this.tile = new DocTile(view, view.contentDOM);
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], null);
  }
  // Update the document view to a given state.
  update(update) {
    var _a2;
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    this.updateEditContextFormatting(update);
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
      if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
        readCompositionAt = this.domChanged.newSel.head;
      else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
        readCompositionAt = update.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      let { from, to } = this.hasComposition;
      changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
    if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, prevWrappers = this.blockWrappers;
    this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, this.decorations, update.changes);
    if (decoDiff.length)
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    let blockDiff = findChangedWrappers(prevWrappers, this.blockWrappers, update.changes);
    if (blockDiff.length)
      changedRanges = ChangedRange.extendWithRanges(changedRanges, blockDiff);
    if (composition && !changedRanges.some((r) => r.fromA <= composition.range.fromA && r.toA >= composition.range.toA))
      changedRanges = composition.range.addToSet(changedRanges.slice());
    if (this.tile.flags & 2 && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, composition);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, composition) {
    this.view.viewState.mustMeasureContent = true;
    let { observer } = this.view;
    observer.ignore(() => {
      if (composition || changes.length) {
        let oldTile = this.tile;
        let builder = new TileUpdate(this.view, oldTile, this.blockWrappers, this.decorations, this.dynamicDecorationMap);
        this.tile = builder.run(changes, composition);
        destroyDropped(oldTile, builder.cache.reused);
      }
      this.tile.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.tile.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.tile.sync(track);
      if (track && (track.written || observer.selectionRange.focusNode != track.node || !this.tile.dom.contains(track.node)))
        this.forceSelection = true;
      this.tile.dom.style.height = "";
    });
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.tile.children)
        if (child.isWidget() && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateEditContextFormatting(update) {
    this.editContextFormatting = this.editContextFormatting.map(update.changes);
    for (let tr of update.transactions)
      for (let effect of tr.effects)
        if (effect.is(setEditContextFormatting)) {
          this.editContextFormatting = effect.value;
        }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    let { dom } = this.tile;
    let activeElt = this.view.root.activeElement, focused = activeElt == dom;
    let selectionNotFocus = !focused && !(this.view.state.facet(editable) || dom.tabIndex > -1) && hasSelection(dom, this.view.observer.selectionRange) && !(activeElt && dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main, anchor, head;
    if (main.empty) {
      head = anchor = this.inlineDOMNearPos(main.anchor, main.assoc || 1);
    } else {
      head = this.inlineDOMNearPos(main.head, main.head == main.from ? 1 : -1);
      anchor = this.inlineDOMNearPos(main.anchor, main.anchor == main.from ? 1 : -1);
    }
    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, dom)) {
          dom.blur();
          dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel) ;
        else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
              if (text)
                anchor = new DOMPos(text.node, text.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
            rawSel.caretBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head.node, head.offset);
          } catch (_) {
          }
        } else {
          let range = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
        if (selectionNotFocus && this.view.root.activeElement == dom) {
          dom.blur();
          if (activeElt)
            activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(sel, cursor2) {
    return this.hasComposition && cursor2.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view } = this, cursor2 = view.state.selection.main;
    let sel = getSelection(view.root);
    let { anchorNode, anchorOffset } = view.observer.selectionRange;
    if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify)
      return;
    let line = this.lineAt(cursor2.head, cursor2.assoc);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor2.head == lineStart || cursor2.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor2.head + cursor2.assoc, cursor2.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from)
      sel.collapse(anchorNode, anchorOffset);
  }
  posFromDOM(node, offset) {
    let tile = this.tile.nearest(node);
    if (!tile)
      return this.tile.dom.compareDocumentPosition(node) & 2 ? 0 : this.view.state.doc.length;
    let start = tile.posAtStart;
    if (tile.isComposite()) {
      let after;
      if (node == tile.dom) {
        after = tile.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == tile.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == tile.dom.firstChild)
        return start;
      while (after && !Tile.get(after))
        after = after.nextSibling;
      if (!after)
        return start + tile.length;
      for (let i = 0, pos = start; ; i++) {
        let child = tile.children[i];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    } else if (tile.isText()) {
      return node == tile.dom ? start + offset : start + (offset ? tile.length : 0);
    } else {
      return start;
    }
  }
  domAtPos(pos, side) {
    let { tile, offset } = this.tile.resolveBlock(pos, side);
    if (tile.isWidget())
      return tile.domPosFor(pos, side);
    return tile.domIn(offset, side);
  }
  inlineDOMNearPos(pos, side) {
    let before, beforeOff = -1, beforeBad = false;
    let after, afterOff = -1, afterBad = false;
    this.tile.blockTiles((tile, off) => {
      if (tile.isWidget()) {
        if (tile.flags & 32 && off >= pos)
          return true;
        if (tile.flags & 16)
          beforeBad = true;
      } else {
        let end = off + tile.length;
        if (off <= pos) {
          before = tile;
          beforeOff = pos - off;
          beforeBad = end < pos;
        }
        if (end >= pos && !after) {
          after = tile;
          afterOff = pos - off;
          afterBad = off > pos;
        }
        if (off > pos && after)
          return true;
      }
    });
    if (!before && !after)
      return this.domAtPos(pos, side);
    if (beforeBad && after)
      before = null;
    else if (afterBad && before)
      after = null;
    return before && side < 0 || !after ? before.domIn(beforeOff, side) : after.domIn(afterOff, side);
  }
  coordsAt(pos, side) {
    let { tile, offset } = this.tile.resolveBlock(pos, side);
    if (tile.isWidget()) {
      if (tile.widget instanceof BlockGapWidget)
        return null;
      return tile.coordsInWidget(offset, side, true);
    }
    return tile.coordsIn(offset, side);
  }
  lineAt(pos, side) {
    let { tile } = this.tile.resolveBlock(pos, side);
    return tile.isLine() ? tile : null;
  }
  coordsForChar(pos) {
    let { tile, offset } = this.tile.resolveBlock(pos, 1);
    if (!tile.isLine())
      return null;
    function scan(tile2, offset2) {
      if (tile2.isComposite()) {
        for (let ch of tile2.children) {
          if (ch.length >= offset2) {
            let found = scan(ch, offset2);
            if (found)
              return found;
          }
          offset2 -= ch.length;
          if (offset2 < 0)
            break;
        }
      } else if (tile2.isText() && offset2 < tile2.length) {
        let end = findClusterBreak2(tile2.text, offset2);
        if (end == offset2)
          return null;
        let rects = textRange(tile2.dom, offset2, end).getClientRects();
        for (let i = 0; i < rects.length; i++) {
          let rect = rects[i];
          if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
            return rect;
        }
      }
      return null;
    }
    return scan(tile, offset);
  }
  measureVisibleLineHeights(viewport) {
    let result = [], { from, to } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    let spaceAbove = 0;
    let scan = (tile, pos, measureBounds) => {
      for (let i = 0; i < tile.children.length; i++) {
        if (pos > to)
          break;
        let child = tile.children[i], end = pos + child.length;
        let childRect = child.dom.getBoundingClientRect(), { height } = childRect;
        if (measureBounds && !i)
          spaceAbove += childRect.top - measureBounds.top;
        if (child instanceof BlockWrapperTile) {
          if (end > from)
            scan(child, pos, childRect);
        } else if (pos >= from) {
          if (spaceAbove > 0)
            result.push(-spaceAbove);
          result.push(height + spaceAbove);
          spaceAbove = 0;
          if (isWider) {
            let last = child.dom.lastChild;
            let rects = last ? clientRectsFor(last) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        if (measureBounds && i == tile.children.length - 1)
          spaceAbove += measureBounds.bottom - childRect.bottom;
        pos = end + child.breakAfter;
      }
    };
    scan(this.tile, 0, null);
    return result;
  }
  textDirectionAt(pos) {
    let { tile } = this.tile.resolveBlock(pos, 1);
    return getComputedStyle(tile.dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    let lineMeasure = this.tile.blockTiles((tile) => {
      if (tile.isLine() && tile.children.length && tile.length <= 20) {
        let totalWidth = 0, textHeight2;
        for (let child of tile.children) {
          if (!child.isText() || /[^ -~]/.test(child.text))
            return void 0;
          let rects = clientRectsFor(child.dom);
          if (rects.length != 1)
            return void 0;
          totalWidth += rects[0].width;
          textHeight2 = rects[0].height;
        }
        if (totalWidth)
          return {
            lineHeight: tile.dom.getBoundingClientRect().height,
            charWidth: totalWidth / tile.length,
            textHeight: textHeight2
          };
      }
    });
    if (lineMeasure)
      return lineMeasure;
    let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.tile.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect && rect.width ? rect.width / 27 : 7;
      textHeight = rect && rect.height ? rect.height : lineHeight;
      dummy.remove();
    });
    return { lineHeight, charWidth, textHeight };
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i = 0; ; i++) {
      let next = i == vs.viewports.length ? null : vs.viewports[i];
      let end = next ? next.from - 1 : this.view.state.doc.length;
      if (end > pos) {
        let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let i = 1;
    let allDeco = this.view.state.facet(decorations).map((d) => {
      let dynamic = this.dynamicDecorationMap[i++] = typeof d == "function";
      return dynamic ? d(this.view) : d;
    });
    let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i2) => {
      let dynamic = typeof d == "function";
      if (dynamic)
        dynamicOuter = true;
      return dynamic ? d(this.view) : d;
    });
    if (outerDeco.length) {
      this.dynamicDecorationMap[i++] = dynamicOuter;
      allDeco.push(RangeSet.join(outerDeco));
    }
    this.decorations = [
      this.editContextFormatting,
      ...allDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
    while (i < this.decorations.length)
      this.dynamicDecorationMap[i++] = false;
    this.blockWrappers = this.view.state.facet(blockWrappers).map((v) => typeof v == "function" ? v(this.view) : v);
  }
  scrollIntoView(target) {
    if (target.isSnapshot) {
      let ref = this.view.viewState.lineBlockAt(target.range.head);
      this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
      this.view.scrollDOM.scrollLeft = target.xMargin;
      return;
    }
    for (let handler of this.view.state.facet(scrollHandler)) {
      try {
        if (handler(this.view, target.range, target))
          return true;
      } catch (e) {
        logException(this.view.state, e, "scroll handler");
      }
    }
    let { range } = target;
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
    if (!rect)
      return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    let { offsetWidth, offsetHeight } = this.view.scrollDOM;
    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
  }
  lineHasWidget(pos) {
    let scan = (child) => child.isWidget() || child.children.some(scan);
    return scan(this.tile.resolveBlock(pos, 1).tile);
  }
  destroy() {
    destroyDropped(this.tile);
  }
};
function destroyDropped(tile, reused) {
  let r = reused === null || reused === void 0 ? void 0 : reused.get(tile);
  if (r != 1) {
    if (r == null)
      tile.destroy();
    for (let ch of tile.children)
      destroyDropped(ch, reused);
  }
}
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
  let textNode = textBefore || textAfter;
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let tileAfter = Tile.get(textAfter.node);
    if (!tileAfter || tileAfter.isText() && tileAfter.text != textAfter.node.nodeValue) {
      textNode = textAfter;
    } else if (view.docView.lastCompositionAfterCursor) {
      let tileBefore = Tile.get(textBefore.node);
      if (!(!tileBefore || tileBefore.isText() && tileBefore.text != textBefore.node.nodeValue))
        textNode = textAfter;
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore;
  if (!textNode)
    return null;
  let from = headPos - textNode.offset;
  return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found)
    return null;
  let { node: textNode, from, to } = found, text = textNode.nodeValue;
  if (/[\n\r]/.test(text))
    return null;
  if (view.state.doc.sliceString(found.from, found.to) != text)
    return null;
  let inv = changes.invertedDesc;
  return { range: new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to), text: textNode };
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1)
    return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
var DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes);
  }
};
function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a, b, diff, comp);
  return comp.changes;
}
var WrapperComparator = class {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint() {
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes);
  }
};
function findChangedWrappers(a, b, diff) {
  let comp = new WrapperComparator();
  RangeSet.compare(a, b, diff, comp);
  return comp.changes;
}
function inUneditable(node, inside) {
  for (let cur2 = node; cur2 && cur2 != inside; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition)
    changes.iterChangedRanges((from, to) => {
      if (from < composition.to && to > composition.from)
        touched = true;
    });
  return touched;
}
var BlockGapWidget = class extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt2 = document.createElement("div");
    elt2.className = "cm-gap";
    this.updateDOM(elt2);
    return elt2;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt2) {
    elt2.style.height = this.height + "px";
    return true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to = linePos;
  if (bias < 0)
    from = findClusterBreak2(line.text, linePos, false);
  else
    to = findClusterBreak2(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));
  while (from > 0) {
    let prev = findClusterBreak2(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak2(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from + line.from, to + line.from);
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function blockAt(view, pos, side) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type)) {
    let best;
    for (let l of line.type) {
      if (l.from > pos)
        break;
      if (l.to < pos)
        continue;
      if (l.from < pos && l.to > pos)
        return l;
      if (!best || l.type == BlockType.Text && (best.type != l.type || (side < 0 ? l.from < pos : l.to > pos)))
        best = l;
    }
    return best || line;
  }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head, start.assoc || -1);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur2 = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = view.visualLineSide(line, !forward);
    }
    if (!check) {
      if (!by)
        return next;
      check = by(char);
    } else if (!check(char)) {
      return cur2;
    }
    cur2 = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, (start.empty ? start.assoc : 0) || (forward ? 1 : -1)), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  let pos = posAtCoords(view, { x: resolvedGoal, y: startY + dist2 * dir }, false, dir);
  return EditorSelection.cursor(pos.pos, pos.assoc, void 0, goal);
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set of atoms) {
      set.between(pos - 1, pos + 1, (from, to, value) => {
        if (pos > from && pos < to) {
          let side = moved || bias || (pos - from < to - pos ? -1 : 1);
          pos = side < 0 ? from : to;
          moved = side;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
function skipAtomsForSelection(atoms, sel) {
  let ranges = null;
  for (let i = 0; i < sel.ranges.length; i++) {
    let range = sel.ranges[i], updated = null;
    if (range.empty) {
      let pos = skipAtomicRanges(atoms, range.from, 0);
      if (pos != range.from)
        updated = EditorSelection.cursor(pos, -1);
    } else {
      let from = skipAtomicRanges(atoms, range.from, -1);
      let to = skipAtomicRanges(atoms, range.to, 1);
      if (from != range.from || to != range.to)
        updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
    }
    if (updated) {
      if (!ranges)
        ranges = sel.ranges.slice();
      ranges[i] = updated;
    }
  }
  return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
var PosAssoc = class {
  constructor(pos, assoc) {
    this.pos = pos;
    this.assoc = assoc;
  }
};
function posAtCoords(view, coords, precise, scanY) {
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let { x, y } = coords, yOffset = y - docTop, block;
  for (; ; ) {
    if (yOffset < 0)
      return new PosAssoc(0, 1);
    if (yOffset > view.viewState.docHeight)
      return new PosAssoc(view.state.doc.length, -1);
    block = view.elementAtHeight(yOffset);
    if (scanY == null)
      break;
    if (block.type == BlockType.Text) {
      if (scanY < 0 ? block.to < view.viewport.from : block.from > view.viewport.to)
        break;
      let rect = view.docView.coordsAt(scanY < 0 ? block.from : block.to, scanY > 0 ? -1 : 1);
      if (rect && (scanY < 0 ? rect.top <= yOffset + docTop : rect.bottom >= yOffset + docTop))
        break;
    }
    let halfLine = view.viewState.heightOracle.textHeight / 2;
    yOffset = scanY > 0 ? block.bottom + halfLine : block.top - halfLine;
  }
  if (view.viewport.from >= block.to || view.viewport.to <= block.from) {
    if (precise)
      return null;
    if (block.type == BlockType.Text) {
      let pos = posAtCoordsImprecise(view, content2, block, x, y);
      return new PosAssoc(pos, pos == block.from ? 1 : -1);
    }
  }
  if (block.type != BlockType.Text)
    return yOffset < (block.top + block.bottom) / 2 ? new PosAssoc(block.from, 1) : new PosAssoc(block.to, -1);
  let line = view.docView.lineAt(block.from, 2);
  if (!line || line.length != block.length)
    line = view.docView.lineAt(block.from, -2);
  return posAtCoordsInline(view, line, block.from, x, y);
}
function posAtCoordsInline(view, tile, offset, x, y) {
  let closest = -1, closestRect = null;
  let dxClosest = 1e9, dyClosest = 1e9;
  let rowTop = y, rowBot = y;
  let checkRects = (rects, index) => {
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top == rect.bottom)
        continue;
      let dx = rect.left > x ? rect.left - x : rect.right < x ? x - rect.right : 0;
      let dy = rect.top > y ? rect.top - y : rect.bottom < y ? y - rect.bottom : 0;
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowTop = Math.min(rect.top, rowTop);
        rowBot = Math.max(rect.bottom, rowBot);
        dy = 0;
      }
      if (closest < 0 || (dy - dyClosest || dx - dxClosest) < 0) {
        if (closest >= 0 && dyClosest && dxClosest < dx && closestRect.top <= rowBot - 2 && closestRect.bottom >= rowTop + 2) {
          dyClosest = 0;
        } else {
          closest = index;
          dxClosest = dx;
          dyClosest = dy;
          closestRect = rect;
        }
      }
    }
  };
  if (tile.isText()) {
    for (let i = 0; i < tile.length; ) {
      let next = findClusterBreak2(tile.text, i);
      checkRects(textRange(tile.dom, i, next).getClientRects(), i);
      if (!dxClosest && !dyClosest)
        break;
      i = next;
    }
    let after = x > (closestRect.left + closestRect.right) / 2 == (dirAt(view, closest + offset) == Direction.LTR);
    return after ? new PosAssoc(offset + findClusterBreak2(tile.text, closest), -1) : new PosAssoc(offset + closest, 1);
  } else {
    if (!tile.length)
      return new PosAssoc(offset, 1);
    for (let i = 0; i < tile.children.length; i++) {
      let child = tile.children[i];
      if (child.flags & 48)
        continue;
      let rects = (child.dom.nodeType == 1 ? child.dom : textRange(child.dom, 0, child.length)).getClientRects();
      checkRects(rects, i);
      if (!dxClosest && !dyClosest)
        break;
    }
    let inner = tile.children[closest], innerOff = tile.posBefore(inner, offset);
    if (inner.isComposite() || inner.isText())
      return posAtCoordsInline(view, inner, innerOff, Math.max(closestRect.left, Math.min(closestRect.right, x)), y);
    let after = x > (closestRect.left + closestRect.right) / 2 == (dirAt(view, closest + offset) == Direction.LTR);
    return after ? new PosAssoc(innerOff + inner.length, -1) : new PosAssoc(innerOff, 1);
  }
}
function dirAt(view, pos) {
  let line = view.state.doc.lineAt(pos), spans = view.bidiSpans(line);
  return spans[BidiSpan.find(view.bidiSpans(line), pos - line.from, -1, 1)].dir;
}
var LineBreakPlaceholder = "\uFFFF";
var DOMReader = class {
  constructor(points, view) {
    this.points = points;
    this.view = view;
    this.text = "";
    this.lineSeparator = view.state.facet(EditorState.lineSeparator);
  }
  append(text) {
    this.text += text;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start)
      return this;
    let parent = start.parentNode;
    for (let cur2 = start; ; ) {
      this.findPointBefore(parent, cur2);
      let oldLen = this.text.length;
      this.readNode(cur2);
      let tile = Tile.get(cur2), next = cur2.nextSibling;
      if (next == end) {
        if ((tile === null || tile === void 0 ? void 0 : tile.breakAfter) && !next && parent != this.view.contentDOM)
          this.lineBreak();
        break;
      }
      let nextTile = Tile.get(next);
      if ((tile && nextTile ? tile.breakAfter : (tile ? tile.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || (tile === null || tile === void 0 ? void 0 : tile.isWidget())) && this.text.length > oldLen) && !isEmptyToEnd(next, end))
        this.lineBreak();
      cur2 = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node) {
    let text = node.nodeValue;
    for (let point of this.points)
      if (point.node == node)
        point.pos = this.text.length + Math.min(point.offset, text.length);
    for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m;
      if (this.lineSeparator) {
        nextBreak = text.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m = re.exec(text)) {
        nextBreak = m.index;
        breakSize = m[0].length;
      }
      this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node && point.pos > this.text.length)
            point.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node) {
    let tile = Tile.get(node);
    let fromView = tile && tile.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node, fromView.length);
      for (let i = fromView.iter(); !i.next().done; ) {
        if (i.lineBreak)
          this.lineBreak();
        else
          this.append(i.value);
      }
    } else if (node.nodeType == 3) {
      this.readTextNode(node);
    } else if (node.nodeName == "BR") {
      if (node.nextSibling)
        this.lineBreak();
    } else if (node.nodeType == 1) {
      this.readRange(node.firstChild, null);
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points)
      if (point.node == node && node.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointInside(node, length) {
    for (let point of this.points)
      if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
        point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
  }
};
function isAtEnd(parent, node, offset) {
  for (; ; ) {
    if (!node || offset < maxOffset(node))
      return false;
    if (node == parent)
      return true;
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
}
function isEmptyToEnd(node, end) {
  let widgets;
  for (; ; node = node.nextSibling) {
    if (node == end || !node)
      break;
    let view = Tile.get(node);
    if (!(view === null || view === void 0 ? void 0 : view.isWidget()))
      return false;
    if (view)
      (widgets || (widgets = [])).push(view);
  }
  if (widgets)
    for (let w of widgets) {
      let override = w.overrideDOMText;
      if (override === null || override === void 0 ? void 0 : override.length)
        return false;
    }
  return true;
}
var DOMPoint = class {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }
};
var DOMChange = class {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    this.domChanged = start > -1;
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = domBoundsAround(view.docView.tile, start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      let vp = view.viewport;
      if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
        let from = Math.min(head, anchor), to = Math.max(head, anchor);
        let offFrom = vp.from - from, offTo = vp.to - to;
        if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
          head = 0;
          anchor = view.state.doc.length;
        }
      }
      if (view.inputState.composing > -1 && view.state.selection.ranges.length > 1)
        this.newSel = view.state.selection.replaceRange(EditorSelection.range(anchor, head));
      else
        this.newSel = EditorSelection.single(anchor, head);
    }
  }
};
function domBoundsAround(tile, from, to, offset) {
  if (tile.isComposite()) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i = 0, pos = offset, prevEnd = offset; i < tile.children.length; i++) {
      let child = tile.children[i], end = pos + child.length;
      if (pos < from && end > to)
        return domBoundsAround(child, from, to, pos);
      if (end >= from && fromI == -1) {
        fromI = i;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == tile.dom) {
        toI = i;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + tile.length : toEnd,
      startDOM: (fromI ? tile.children[fromI - 1].dom.nextSibling : null) || tile.dom.firstChild,
      endDOM: toI < tile.children.length && toI >= 0 ? tile.children[toI].dom : null
    };
  } else if (tile.isText()) {
    return { from: offset, to: offset + tile.length, startDOM: tile.dom, endDOM: tile.dom.nextSibling };
  } else {
    return null;
  }
}
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let { from, to } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
    if (diff) {
      if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || sameSelPos(newSel, sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: change.from, to: change.to, insert: Text.of([change.insert.toString().replace(".", " ")]) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if (view.state.doc.lineAt(sel.from).to < sel.to && view.docView.lineHasWidget(sel.to) && view.inputState.insertingTextAt > Date.now() - 50) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.toText(view.inputState.insertingText)
    };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey);
  } else if (newSel && !sameSelPos(newSel, sel)) {
    let scrollIntoView3 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView3 = true;
      userEvent = view.inputState.lastSelectionOrigin;
      if (userEvent == "select.pointer")
        newSel = skipAtomsForSelection(view.state.facet(atomicRanges).map((f) => f(view)), newSel);
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
    return true;
  } else {
    return false;
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
  if (browser.ios && view.inputState.flushIOSKey(change))
    return true;
  let sel = view.state.selection.main;
  if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
    return true;
  let text = change.insert.toString();
  if (view.inputState.composing >= 0)
    view.inputState.composing++;
  let defaultTr;
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
  if (!view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text, defaultInsert)))
    view.dispatch(defaultInsert());
  return true;
}
function applyDefaultInsert(view, change, newSel) {
  let tr, startState = view.state, sel = startState.selection.main, inAtomic = -1;
  if (change.from == change.to && change.from < sel.from || change.from > sel.to) {
    let side = change.from < sel.from ? -1 : 1, pos = side < 0 ? sel.from : sel.to;
    let moved = skipAtomicRanges(startState.facet(atomicRanges).map((f) => f(view)), pos, side);
    if (change.from == moved)
      inAtomic = moved;
  }
  if (inAtomic > -1) {
    tr = {
      changes: change,
      selection: EditorSelection.cursor(change.from + change.insert.length, -1)
    };
  } else if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && (view.inputState.composing >= 0 || view.inputState.compositionPendingChange) && change.to <= sel.to + 10 && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = { from: composition.from, to: composition.to - dLen };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset = sel.to - change.to;
      tr = startState.changeByRange((range) => {
        if (range.from == sel.from && range.to == sel.to)
          return { changes, range: mainSel || range.map(changes) };
        let to = range.to - offset, from = to - replaced.length;
        if (view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        to >= compositionRange.from && from <= compositionRange.to)
          return { range };
        let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from = 0;
  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
    from++;
  if (from == minLen && a.length == b.length)
    return null;
  let toA = a.length, toB = b.length;
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return { from, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
function sameSelPos(selection2, range) {
  return range.head == selection2.main.head && range.anchor == selection2.main.anchor;
}
var InputState = class {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = void 0;
    this.tabFocusMode = -1;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.insertingText = "";
    this.insertingTextAt = 0;
    this.mouseSelection = null;
    this.draggedContent = null;
    this.handleEvent = this.handleEvent.bind(this);
    this.notifiedFocused = view.hasFocus;
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
    if (browser.gecko)
      firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event) {
    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
      return;
    if (event.type == "keydown" && this.keydown(event))
      return;
    if (this.view.updateState != 0)
      Promise.resolve().then(() => this.runHandlers(event.type, event));
    else
      this.runHandlers(event.type, event);
  }
  runHandlers(type, event) {
    let handlers2 = this.handlers[type];
    if (handlers2) {
      for (let observer of handlers2.observers)
        observer(this.view, event);
      for (let handler of handlers2.handlers) {
        if (event.defaultPrevented)
          break;
        if (handler(this.view, event)) {
          event.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
    for (let type in handlers2)
      if (type != "scroll") {
        let passive = !handlers2[type].handlers.length;
        let exists = prev[type];
        if (exists && passive != !exists.handlers.length) {
          dom.removeEventListener(type, this.handleEvent);
          exists = null;
        }
        if (!exists)
          dom.addEventListener(type, this.handleEvent, { passive });
      }
    for (let type in prev)
      if (type != "scroll" && !handlers2[type])
        dom.removeEventListener(type, this.handleEvent);
    this.handlers = handlers2;
  }
  keydown(event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return true;
    if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
      this.tabFocusMode = -1;
    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
      this.pendingIOSKey = pending || event;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event.keyCode != 229)
      this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey(change) {
    let key = this.pendingIOSKey;
    if (!key)
      return false;
    if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type) || event.synthetic)
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    this.view.observer.update(update);
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (this.draggedContent && update.docChanged)
      this.draggedContent = this.draggedContent.map(update.changes);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
};
function bindHandler(plugin, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin, event, view);
    } catch (e) {
      logException(view.state, e);
    }
  };
}
function computeHandlers(plugins) {
  let result = /* @__PURE__ */ Object.create(null);
  function record(type) {
    return result[type] || (result[type] = { observers: [], handlers: [] });
  }
  for (let plugin of plugins) {
    let spec = plugin.spec, handlers2 = spec && spec.plugin.domEventHandlers, observers2 = spec && spec.plugin.domEventObservers;
    if (handlers2)
      for (let type in handlers2) {
        let f = handlers2[type];
        if (f)
          record(type).handlers.push(bindHandler(plugin.value, f));
      }
    if (observers2)
      for (let type in observers2) {
        let f = observers2[type];
        if (f)
          record(type).observers.push(bindHandler(plugin.value, f));
      }
  }
  for (let type in handlers)
    record(type).handlers.push(handlers[type]);
  for (let type in observers)
    record(type).observers.push(observers[type]);
  return result;
}
var PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
var EmacsyPendingKeys = "dthko";
var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
var dragScrollMargin = 6;
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a, b) {
  return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
var MouseSelection = class {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style;
    this.mustSelect = mustSelect;
    this.scrollSpeed = { x: 0, y: 0 };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParents = scrollableParents(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event) {
    if (this.dragging === false)
      this.select(event);
  }
  move(event) {
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
      return;
    this.select(this.lastEvent = event);
    let sx = 0, sy = 0;
    let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
    if (this.scrollParents.x)
      ({ left, right } = this.scrollParents.x.getBoundingClientRect());
    if (this.scrollParents.y)
      ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
    let margins = getScrollMargins(this.view);
    if (event.clientX - margins.left <= left + dragScrollMargin)
      sx = -dragScrollSpeed(left - event.clientX);
    else if (event.clientX + margins.right >= right - dragScrollMargin)
      sx = dragScrollSpeed(event.clientX - right);
    if (event.clientY - margins.top <= top2 + dragScrollMargin)
      sy = -dragScrollSpeed(top2 - event.clientY);
    else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
      sy = dragScrollSpeed(event.clientY - bottom);
    this.setScrollSpeed(sx, sy);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = { x: sx, y: sy };
    if (sx || sy) {
      if (this.scrolling < 0)
        this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    let { x, y } = this.scrollSpeed;
    if (x && this.scrollParents.x) {
      this.scrollParents.x.scrollLeft += x;
      x = 0;
    }
    if (y && this.scrollParents.y) {
      this.scrollParents.y.scrollTop += y;
      y = 0;
    }
    if (x || y)
      this.view.win.scrollBy(x, y);
    if (this.dragging === false)
      this.select(this.lastEvent);
  }
  select(event) {
    let { view } = this, selection2 = skipAtomsForSelection(this.atoms, this.style.get(event, this.extend, this.multiple));
    if (this.mustSelect || !selection2.eq(view.state.selection, this.dragging === false))
      this.view.dispatch({
        selection: selection2,
        userEvent: "select.pointer"
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.transactions.some((tr) => tr.isUserEvent("input.type")))
      this.destroy();
    else if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target, tile; node != view.contentDOM; node = node.parentNode)
    if (!node || node.nodeType == 11 || (tile = Tile.get(node)) && tile.isWidget() && !tile.isHidden && tile.widget.ignoreEvent(event))
      return false;
  return true;
}
var handlers = /* @__PURE__ */ Object.create(null);
var observers = /* @__PURE__ */ Object.create(null);
var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function textFilter(state, facet, text) {
  for (let filter of state.facet(facet))
    text = filter(text, state);
  return text;
}
function doPaste(view, input) {
  input = textFilter(view.state, clipboardInputFilter, input);
  let { state } = view, changes, i = 1, text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return { range };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text.line(i++);
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
  if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
    view.inputState.tabFocusMode = Date.now() + 2e3;
  return false;
};
observers.touchstart = (view, e) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style)
      break;
  }
  if (!style && event.button == 0)
    style = basicMouseSelection(view, event);
  if (style) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    if (mustFocus)
      view.observer.ignore(() => {
        focusPreventScroll(view.contentDOM);
        let active = view.root.activeElement;
        if (active && !active.contains(view.contentDOM))
          active.blur();
      });
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event);
      return mouseSel.dragging === false;
    }
  } else {
    view.inputState.setSelectionOrigin("select.pointer");
  }
  return false;
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = view.docView.lineAt(pos, bias), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from, to);
  }
}
var BadMouseDetail = browser.ie && browser.ie_version <= 11;
var lastMouseDown = null;
var lastMouseDownCount = 0;
var lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = view.posAndSideAtCoords({ x: event.clientX, y: event.clientY }, false), type = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, extend, multiple) {
      let cur2 = view.posAndSideAtCoords({ x: event2.clientX, y: event2.clientY }, false), removed;
      let range = rangeForClick(view, cur2.pos, cur2.assoc, type);
      if (start.pos != cur2.pos && !extend) {
        let startRange = rangeForClick(view, start.pos, start.assoc, type);
        let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
        range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
      }
      if (extend)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos)))
        return removed;
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i = 0; i < sel.ranges.length; i++) {
    let { from, to } = sel.ranges[i];
    if (from <= pos && to >= pos)
      return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event) => {
  let { selection: { main: range } } = view.state;
  if (event.target.draggable) {
    let tile = view.docView.tile.nearest(event.target);
    if (tile && tile.isWidget()) {
      let from = tile.posAtStart, to = from + tile.length;
      if (from >= range.to || to <= range.from)
        range = EditorSelection.range(from, to);
    }
  }
  let { inputState } = view;
  if (inputState.mouseSelection)
    inputState.mouseSelection.dragging = true;
  inputState.draggedContent = range;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
    event.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
handlers.dragend = (view) => {
  view.inputState.draggedContent = null;
  return false;
};
function dropText(view, event, text, direct) {
  text = textFilter(view.state, clipboardInputFilter, text);
  if (!text)
    return;
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let { draggedContent } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
  let ins = { from: dropPos, insert: text };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer)
    return false;
  if (view.state.readOnly)
    return true;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    let text = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
    };
    for (let i = 0; i < files.length; i++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text[i] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i]);
    }
    return true;
  } else {
    let text = event.dataTransfer.getData("Text");
    if (text) {
      dropText(view, event, text, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event) => {
  if (view.state.readOnly)
    return true;
  view.observer.flush();
  let data2 = brokenClipboardAPI ? null : event.clipboardData;
  if (data2) {
    doPaste(view, data2.getData("text/plain") || data2.getData("text/uri-list"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)), ranges, linewise };
}
var lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let domSel = getSelection(view.root);
  if (domSel && !hasSelection(view.contentDOM, domSel))
    return false;
  let { text, ranges, linewise } = copiedRange(view.state);
  if (!text && !linewise)
    return false;
  lastLinewiseCopy = linewise ? text : null;
  if (event.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
  let data2 = brokenClipboardAPI ? null : event.clipboardData;
  if (data2) {
    data2.clearData();
    data2.setData("text/plain", text);
    return true;
  } else {
    captureCopy(view, text);
    return false;
  }
};
var isFocusChange = /* @__PURE__ */ Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus);
    if (effect)
      effects.push(effect);
  }
  return effects.length ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr = focusChangeTransaction(view.state, focus);
      if (tr)
        view.dispatch(tr);
      else
        view.update([]);
    }
  }, 10);
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.observer.editContext)
    return;
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = (view) => {
  if (view.observer.editContext)
    return;
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition)
        view.update([]);
    }, 50);
  }
};
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a2, _b;
  if (event.inputType == "insertText" || event.inputType == "insertCompositionText") {
    view.inputState.insertingText = event.data;
    view.inputState.insertingTextAt = Date.now();
  }
  if (event.inputType == "insertReplacementText" && view.observer.editContext) {
    let text = (_a2 = event.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event.getTargetRanges();
    if (text && ranges.length) {
      let r = ranges[0];
      let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);
      applyDOMChangeInner(view, { from, to, insert: view.state.toText(text) }, null);
      return true;
    }
  }
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
      setTimeout(() => {
        var _a3;
        if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  if (browser.ios && event.inputType == "deleteContentForward") {
    view.observer.flushSoon();
  }
  if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
    setTimeout(() => observers.compositionend(view, event), 20);
  }
  return false;
};
var appliedFirefoxHack = /* @__PURE__ */ new Set();
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
var heightChangeFlag = false;
function clearHeightChangeFlag() {
  heightChangeFlag = false;
}
var HeightOracle = class {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / Math.max(1, this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i = 0; i < lineHeights.length; i++) {
      let h = lineHeights[i];
      if (h < 0) {
        i++;
      } else if (!this.heightSamples[Math.floor(h * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.abs(lineHeight - this.lineHeight) > 0.3 || this.lineWrapping != lineWrapping || Math.abs(charWidth - this.charWidth) > 0.1;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i = 0; i < knownHeights.length; i++) {
        let h = knownHeights[i];
        if (h < 0)
          i++;
        else
          this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return changed;
  }
};
var MeasuredHeights = class {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var BlockInfo = class _BlockInfo {
  /**
  @internal
  */
  constructor(from, length, top2, height, _content) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this._content = _content;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(other) {
    let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new _BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
  }
};
var QueryType = /* @__PURE__ */ (function(QueryType3) {
  QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
  QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
  QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType3;
})(QueryType || (QueryType = {}));
var Epsilon = 1e-3;
var HeightMap = class _HeightMap {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        heightChangeFlag = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return _HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this, doc2 = oracle.doc;
    for (let i = changes.length - 1; i >= 0; i--) {
      let { fromA, toA, fromB, toB } = changes[i];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i > 0 && start.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA;
        fromB = changes[i - 1].fromB;
        i--;
        if (fromA < start.from)
          start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me = replace(me, me.replace(fromA, toA, nodes));
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i == j) {
        if (before > after * 2) {
          let split = nodes[i - 1];
          if (split.break)
            nodes.splice(--i, 1, split.left, null, split.right);
          else
            nodes.splice(--i, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i - 1] == null) {
      brk = 1;
      i--;
    } else if (nodes[i] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i)), brk, _HeightMap.of(nodes.slice(j)));
  }
};
function replace(old, val) {
  if (old == val)
    return old;
  if (old.constructor != val.constructor)
    heightChangeFlag = true;
  return val;
}
HeightMap.prototype.size = 1;
var SpaceDeco = /* @__PURE__ */ Decoration.replace({});
var HeightMapBlock = class extends HeightMap {
  constructor(length, height, deco) {
    super(length, height);
    this.deco = deco;
    this.spaceAbove = 0;
  }
  mainBlock(top2, offset) {
    return new BlockInfo(offset, this.length, top2 + this.spaceAbove, this.height - this.spaceAbove, this.deco || 0);
  }
  blockAt(height, _oracle, top2, offset) {
    return this.spaceAbove && height < top2 + this.spaceAbove ? new BlockInfo(offset, 0, top2, this.spaceAbove, SpaceDeco) : this.mainBlock(top2, offset);
  }
  lineAt(_value, _type, oracle, top2, offset) {
    let main = this.mainBlock(top2, offset);
    return this.spaceAbove ? this.blockAt(0, oracle, top2, offset).join(main) : main;
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    if (from <= offset + this.length && to >= offset)
      f(this.lineAt(0, QueryType.ByPos, oracle, top2, offset));
  }
  setMeasuredHeight(measured) {
    let next = measured.heights[measured.index++];
    if (next < 0) {
      this.spaceAbove = -next;
      next = measured.heights[measured.index++];
    } else {
      this.spaceAbove = 0;
    }
    this.setHeight(next);
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setMeasuredHeight(measured);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var HeightMapText = class _HeightMapText extends HeightMapBlock {
  constructor(length, height, above) {
    super(length, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
    this.spaceAbove = above;
  }
  mainBlock(top2, offset) {
    return new BlockInfo(offset, this.length, top2 + this.spaceAbove, this.height - this.spaceAbove, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof _HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap)
        node = new _HeightMapText(node.length, this.height, this.spaceAbove);
      else
        node.height = this.height;
      if (!this.outdated)
        node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more) {
      this.setMeasuredHeight(measured);
    } else if (force || this.outdated) {
      this.spaceAbove = 0;
      this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    }
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var HeightMapGap = class _HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1)
        perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return { firstLine, lastLine, perLine, perChar };
  }
  blockAt(height, oracle, top2, offset) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    if (oracle.lineWrapping) {
      let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
      let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top2, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
      let { from, length } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
    }
  }
  lineAt(value, type, oracle, top2, offset) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, oracle, top2, offset);
    if (type == QueryType.ByPosNoHeight) {
      let { from, to } = oracle.doc.lineAt(value);
      return new BlockInfo(from, to - from, 0, 0, 0);
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    from = Math.max(from, offset);
    to = Math.min(to, offset + this.length);
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    for (let pos = from, lineTop = top2; pos <= to; ) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof _HeightMapGap)
        nodes[nodes.length - 1] = new _HeightMapGap(last.length + after);
      else
        nodes.push(null, new _HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof _HeightMapGap)
        nodes[0] = new _HeightMapGap(from + first.length);
      else
        nodes.unshift(new _HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new _HeightMapGap(to - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new _HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      if (measured.from > offset)
        nodes.push(new _HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++], above = 0;
        if (height < 0) {
          above = -height;
          height = measured.heights[measured.index++];
        }
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line = new HeightMapText(len, height, above);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new _HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
        heightChangeFlag = true;
      return replace(this, result);
    } else if (force || this.outdated) {
      this.setHeight(oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var HeightMapBranch = class extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to, oracle, top2, offset, f);
      if (to >= rightOffset)
        this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
      if (from < mid.from)
        this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f);
      if (mid.to >= from && mid.from <= to)
        f(mid);
      if (to > mid.to)
        this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node of nodes)
      result.push(node);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left)
      return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to >= left)
        result.push(null);
    }
    if (to > left)
      this.right.decomposeLeft(to - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = replace(this.left, left);
    this.right = replace(this.right, right);
    this.setHeight(left.height + right.height);
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
var relevantWidgetHeight = 5;
var NodeBuilder = class _NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1, 0));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from, to } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1, 0));
    this.writtenTo = this.pos;
  }
  blankContent(from, to) {
    let gap = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line = new HeightMapText(0, -1, 0);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    let deco = block.deco;
    if (deco && deco.startSide > 0 && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (deco && deco.endSide > 0)
      this.covering = block;
  }
  addLineDeco(height, breaks, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    line.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1, 0));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node of this.nodes) {
      if (node instanceof HeightMapText)
        node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from, to) {
    let builder = new _NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to, builder, 0);
    return builder.finish(from);
  }
};
function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator2();
  RangeSet.compare(a, b, diff, comp, 0);
  return comp.changes;
}
var DecorationComparator2 = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to, a, b) {
    if (from < to || a && a.heightRelevant || b && b.heightRelevant)
      addRange(from, to, this.changes, 5);
  }
};
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt2 = parent;
      let style = window.getComputedStyle(elt2);
      if ((elt2.scrollHeight > elt2.clientHeight || elt2.scrollWidth > elt2.clientWidth) && style.overflow != "visible") {
        let parentRect = elt2.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt2.offsetParent : elt2.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function inWindow(elt2) {
  let rect = elt2.getBoundingClientRect(), win = elt2.ownerDocument.defaultView || window;
  return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
var LineGap = class {
  constructor(from, to, size, displaySize) {
    this.from = from;
    this.to = to;
    this.size = size;
    this.displaySize = displaySize;
  }
  static same(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let gA = a[i], gB = b[i];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
};
var LineGapWidget = class extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt2 = document.createElement("div");
    if (this.vertical) {
      elt2.style.height = this.size + "px";
    } else {
      elt2.style.width = this.size + "px";
      elt2.style.height = "2px";
      elt2.style.display = "inline-block";
    }
    return elt2;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var ViewState = class {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = false;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = staticDeco(state);
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    for (let i = 0; i < 2; i++) {
      this.viewport = this.getViewport(0, null);
      if (!this.updateForViewport())
        break;
    }
    this.updateViewportLines();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let pos = i ? main.head : main.anchor;
      if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
        let { from, to } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to));
      }
    }
    this.viewports = viewports.sort((a, b) => a.from - b.from);
    return this.updateScaler();
  }
  updateScaler() {
    let scaler = this.scaler;
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    return scaler.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
      this.viewportLines.push(scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = staticDeco(this.state);
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    clearHeightChangeFlag();
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight || heightChangeFlag)
      update.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = prevHeight;
    }
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    update.flags |= this.updateForViewport();
    if (viewportChange || !update.changes.empty || update.flags & 2)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges(update.changes);
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && (update.selectionSet || update.focusChanged) && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace;
    this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace) || this.mustMeasureContent;
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result = 0, bias = 0;
    if (domRect.width && domRect.height) {
      let { scaleX, scaleY } = getScale(dom, domRect);
      if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result |= 16;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 16 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 16;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget && !inWindow(view.dom))
      return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 16;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, Math.max(5, contentWidth / charWidth), lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 16;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      clearHeightChangeFlag();
      for (let vp of this.viewports) {
        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
      }
      if (heightChangeFlag)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange) {
      if (result & 2)
        result |= this.updateScaler();
      this.viewport = this.getViewport(bias, this.scrollTarget);
      result |= this.updateForViewport();
    }
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map = this.heightMap, oracle = this.heightOracle;
    let { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let { head } = scrollTarget.range;
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
          topPos = block.top;
        else
          topPos = block.bottom - viewHeight;
        viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from, to }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
    let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from, to, line, structure) => {
      if (to - from < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from && pos < to) {
          addGap(from, pos - 10, line, structure);
          addGap(pos + 10, to, line, structure);
          return;
        }
      }
      let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
          if (lineStart > from)
            to = lineStart;
        }
        let size = this.gapSize(line, from, to, structure);
        let displaySize = wrapping || size < 2e6 ? size : 2e6;
        gap = new LineGap(from, to, size, displaySize);
      }
      gaps.push(gap);
    };
    let checkLine = (line) => {
      if (line.length < doubleMargin || line.type != BlockType.Text)
        return;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin)
        return;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let horizOffset = 0;
        if (totalWidth > 2e6)
          for (let old of current) {
            if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
              horizOffset = old.size - old.displaySize;
          }
        let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
        let left, right;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (pxLeft - marginWidth) / totalWidth;
          right = (pxRight + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from)
        addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to)
        addGap(viewTo, line.to, line, structure);
    };
    for (let line of this.viewportLines) {
      if (Array.isArray(line.type))
        line.type.forEach(checkLine);
      else
        checkLine(line);
    }
    return gaps;
  }
  gapSize(line, from, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges(changes) {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({ from, to });
      },
      point() {
      }
    }, 20);
    let changed = 0;
    if (ranges.length != this.visibleRanges.length) {
      changed = 8 | 4;
    } else {
      for (let i = 0; i < ranges.length && !(changed & 8); i++) {
        let old = this.visibleRanges[i], nw = ranges[i];
        if (old.from != nw.from || old.to != nw.to) {
          changed |= 4;
          if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to))
            changed |= 8;
        }
      }
    }
    this.visibleRanges = ranges;
    return changed;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l) => l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block = this.lineBlockAtHeight(scrollTop + 8);
    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
};
var Viewport = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
function lineStructure(from, to, stateDeco) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(stateDeco, from, to, {
    span() {
    },
    point(from2, to2) {
      if (from2 > pos) {
        ranges.push({ from: pos, to: from2 });
        total += from2 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i = 0; ; i++) {
    let { from, to } = ranges[i], size = to - from;
    if (dist2 <= size)
      return from + dist2;
    dist2 -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from;
      break;
    }
    counted += to - from;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
var IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(other) {
    return other == this;
  }
};
function staticDeco(state) {
  let deco = state.facet(decorations).filter((d) => typeof d != "function");
  let outer = state.facet(outerDecorations).filter((d) => typeof d != "function");
  if (outer.length)
    deco.push(RangeSet.join(outer));
  return deco;
}
var BigScaler = class _BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from, to }) => {
      let top2 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top2;
      return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.top)
        return domBase + (n - base2) * this.scale;
      if (n <= vp.bottom)
        return vp.domTop + (n - vp.top);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.domTop)
        return base2 + (n - domBase) / this.scale;
      if (n <= vp.domBottom)
        return vp.top + (n - vp.domTop);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  eq(other) {
    if (!(other instanceof _BigScaler))
      return false;
    return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);
  }
};
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
}
var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.indexOf(true) > -1 });
var baseThemeID = /* @__PURE__ */ StyleModule.newName();
var baseLightID = /* @__PURE__ */ StyleModule.newName();
var baseDarkID = /* @__PURE__ */ StyleModule.newName();
var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
        if (m == "&")
          return main;
        if (!scopes || !scopes[m])
          throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }
  });
}
var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
var observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
var useCharData = browser.ie && browser.ie_version <= 11;
var DOMObserver = class {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.editContext = null;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.printQuery = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (window.EditContext && browser.android && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(browser.chrome && browser.chrome_version < 126)) {
      this.editContext = new EditContextManager(view);
      if (view.state.facet(editable))
        view.contentDOM.editContext = this.editContext.editContext;
    }
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (window.matchMedia)
      this.printQuery = window.matchMedia("print");
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a2;
        if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
          this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, { threshold: [0, 1e-3] });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e) {
    if (this.intersecting)
      this.flush(false);
    if (this.editContext)
      this.view.requestMeasure(this.editContext.measureReq);
    this.onScrollChanged(e);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint(event) {
    if ((event.type == "change" || !event.type) && !event.matches)
      return;
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.tile.nearest(sel.anchorNode);
    if (context && context.isWidget() && context.widget.ignoreEvent(event)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let selection2 = getSelection(view.root);
    if (!selection2)
      return false;
    let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection2) || selection2;
    if (!range || this.selectionRange.eq(range))
      return false;
    let local = hasSelection(this.dom, range);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range);
    if (local)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
          i++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active)
      return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key, keyCode) {
    var _a2;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key2 = this.delayedAndroidKey;
        if (key2) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key2.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key2.force)
            dispatchKey(this.dom, key2.key, key2.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key == "Enter")
      this.delayedAndroidKey = {
        key,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords())
      this.queue.push(mut);
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length)
      this.queue = [];
    let from = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from == -1) {
        ({ from, to } = range);
      } else {
        from = Math.min(range.from, from);
        to = Math.max(range.to, to);
      }
    }
    return { from, to, typeOver };
  }
  readChange() {
    let { from, to, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel)
      return null;
    if (from > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from, to, typeOver);
    this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
    return change;
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange) {
      this.view.requestMeasure();
      return false;
    }
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !sameSelPos(this.view.state.selection, domChange.newSel.main)))
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let tile = this.view.docView.tile.nearest(rec.target);
    if (!tile || tile.isWidget())
      return null;
    tile.markDirty(rec.type == "attributes");
    if (rec.type == "childList") {
      let childBefore = findChild(tile, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(tile, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? tile.posAfter(childBefore) : tile.posAtStart,
        to: childAfter ? tile.posBefore(childAfter) : tile.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: tile.posAtStart, to: tile.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.addEventListener)
        this.printQuery.addEventListener("change", this.onPrint);
      else
        this.printQuery.addListener(this.onPrint);
    } else
      win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.removeEventListener)
        this.printQuery.removeEventListener("change", this.onPrint);
      else
        this.printQuery.removeListener(this.onPrint);
    } else
      win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(update) {
    if (this.editContext) {
      this.editContext.update(update);
      if (update.startState.facet(editable) != update.state.facet(editable))
        update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
    }
  }
  destroy() {
    var _a2, _b, _c;
    this.stop();
    (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    if (this.editContext) {
      this.view.contentDOM.editContext = null;
      this.editContext.destroy();
    }
  }
};
function findChild(tile, dom, dir) {
  while (dom) {
    let curTile = Tile.get(dom);
    if (curTile && curTile.parent == tile)
      return curTile;
    let parent = dom.parentNode;
    dom = parent != tile.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function buildSelectionRangeFromRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor, 1);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariSelectionRangeHack(view, selection2) {
  if (selection2.getComposedRanges) {
    let range = selection2.getComposedRanges(view.root)[0];
    if (range)
      return buildSelectionRangeFromRange(view, range);
  }
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  return found ? buildSelectionRangeFromRange(view, found) : null;
}
var EditContextManager = class {
  constructor(view) {
    this.from = 0;
    this.to = 0;
    this.pendingContextChange = null;
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = null;
    this.resetRange(view.state);
    let context = this.editContext = new window.EditContext({
      text: view.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(view.state.selection.main.head)
    });
    this.handlers.textupdate = (e) => {
      let main = view.state.selection.main, { anchor, head } = main;
      let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);
      if (view.inputState.composing >= 0 && !this.composing)
        this.composing = { contextBase: e.updateRangeStart, editorBase: from, drifted: false };
      let deletes = to - from > e.text.length;
      if (from == this.from && anchor < this.from)
        from = anchor;
      else if (to == this.to && anchor > this.to)
        to = anchor;
      let diff = findDiff(view.state.sliceDoc(from, to), e.text, (deletes ? main.from : main.to) - from, deletes ? "end" : null);
      if (!diff) {
        let newSel = EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));
        if (!sameSelPos(newSel, main))
          view.dispatch({ selection: newSel, userEvent: "select" });
        return;
      }
      let change = {
        from: diff.from + from,
        to: diff.toA + from,
        insert: Text.of(e.text.slice(diff.from, diff.toB).split("\n"))
      };
      if ((browser.mac || browser.android) && change.from == head - 1 && /^\. ?$/.test(e.text) && view.contentDOM.getAttribute("autocorrect") == "off")
        change = { from, to, insert: Text.of([e.text.replace(".", " ")]) };
      this.pendingContextChange = change;
      if (!view.state.readOnly) {
        let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
        applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));
      }
      if (this.pendingContextChange) {
        this.revertPending(view.state);
        this.setSelection(view.state);
      }
      if (change.from < change.to && !change.insert.length && view.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(context.text.slice(Math.max(0, e.updateRangeStart - 1), Math.min(context.text.length, e.updateRangeStart + 1))))
        this.handlers.compositionend(e);
    };
    this.handlers.characterboundsupdate = (e) => {
      let rects = [], prev = null;
      for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++) {
        let rect = view.coordsForChar(i);
        prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
        rects.push(prev);
      }
      context.updateCharacterBounds(e.rangeStart, rects);
    };
    this.handlers.textformatupdate = (e) => {
      let deco = [];
      for (let format of e.getTextFormats()) {
        let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
        if (!/none/i.test(lineStyle) && !/none/i.test(thickness)) {
          let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);
          if (from < to) {
            let style = `text-decoration: underline ${/^[a-z]/.test(lineStyle) ? lineStyle + " " : lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${/thin/i.test(thickness) ? 1 : 2}px`;
            deco.push(Decoration.mark({ attributes: { style } }).range(from, to));
          }
        }
      }
      view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
    };
    this.handlers.compositionstart = () => {
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
        view.inputState.compositionFirstChange = true;
      }
    };
    this.handlers.compositionend = () => {
      view.inputState.composing = -1;
      view.inputState.compositionFirstChange = null;
      if (this.composing) {
        let { drifted } = this.composing;
        this.composing = null;
        if (drifted)
          this.reset(view.state);
      }
    };
    for (let event in this.handlers)
      context.addEventListener(event, this.handlers[event]);
    this.measureReq = { read: (view2) => {
      this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
      let sel = getSelection(view2.root);
      if (sel && sel.rangeCount)
        this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(update) {
    let off = 0, abort = false, pending = this.pendingContextChange;
    update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
      if (abort)
        return;
      let dLen = insert2.length - (toA - fromA);
      if (pending && toA >= pending.to) {
        if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
          pending = this.pendingContextChange = null;
          off += dLen;
          this.to += dLen;
          return;
        } else {
          pending = null;
          this.revertPending(update.state);
        }
      }
      fromA += off;
      toA += off;
      if (toA <= this.from) {
        this.from += dLen;
        this.to += dLen;
      } else if (fromA < this.to) {
        if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
          abort = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
        this.to += dLen;
      }
      off += dLen;
    });
    if (pending && !abort)
      this.revertPending(update.state);
    return !abort;
  }
  update(update) {
    let reverted = this.pendingContextChange, startSel = update.startState.selection.main;
    if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr) => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
      this.composing.drifted = true;
      this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
    } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
      this.pendingContextChange = null;
      this.reset(update.state);
    } else if (update.docChanged || update.selectionSet || reverted) {
      this.setSelection(update.state);
    }
    if (update.geometryChanged || update.docChanged || update.selectionSet)
      update.view.requestMeasure(this.measureReq);
  }
  resetRange(state) {
    let { head } = state.selection.main;
    this.from = Math.max(
      0,
      head - 1e4
      /* CxVp.Margin */
    );
    this.to = Math.min(
      state.doc.length,
      head + 1e4
      /* CxVp.Margin */
    );
  }
  reset(state) {
    this.resetRange(state);
    this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
    this.setSelection(state);
  }
  revertPending(state) {
    let pending = this.pendingContextChange;
    this.pendingContextChange = null;
    this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
  }
  setSelection(state) {
    let { main } = state.selection;
    let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
    let end = this.toContextPos(main.head);
    if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
      this.editContext.updateSelection(start, end);
  }
  rangeIsValid(state) {
    let { head } = state.selection.main;
    return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(contextPos, clipLen = this.to - this.from) {
    contextPos = Math.min(contextPos, clipLen);
    let c = this.composing;
    return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
  }
  toContextPos(editorPos) {
    let c = this.composing;
    return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
  }
  destroy() {
    for (let event in this.handlers)
      this.editContext.removeEventListener(event, this.handlers[event]);
  }
};
var EditorView = class _EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config2 = {}) {
    var _a2;
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.className = "cm-announced";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    if (config2.parent)
      config2.parent.appendChild(this.dom);
    let { dispatch } = config2;
    this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config2.root || getRoot(config2.parent) || document;
    this.viewState = new ViewState(config2.state || EditorState.create(config2));
    if (config2.scrollTo && config2.scrollTo.is(scrollIntoView))
      this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin of this.plugins)
      plugin.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
      document.fonts.ready.then(() => {
        this.viewState.mustMeasureContent = true;
        this.requestMeasure();
      });
  }
  dispatch(...input) {
    let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
    this.dispatchTransactions(trs, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr) => tr.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus)
        focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr.changes);
        if (tr.scrollIntoView) {
          let { main } = tr.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e of tr.effects)
          if (e.is(scrollIntoView))
            scrollTarget = e.value.clip(this.state);
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (redrawn)
      this.docViewUpdate();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener)) {
        try {
          listener(update);
        } catch (e) {
          logException(this.state, e, "update listener");
        }
      }
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState)
          this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin of this.plugins)
        plugin.update(this);
      this.docView.destroy();
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }
      for (let plugin of this.plugins)
        if (plugin.mustUpdate != update)
          plugin.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    if (prevSpecs != specs)
      this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let plugin of this.plugins) {
      let val = plugin.value;
      if (val && val.docViewUpdate) {
        try {
          val.docViewUpdate(this);
        } catch (e) {
          logException(this.state, e, "doc view update listener");
        }
      }
    }
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
    let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
      scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i = 0; ; i++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block.from;
            scrollAnchorHeight = block.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m) => {
          try {
            return m.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
          if (redrawn)
            this.docViewUpdate();
        }
        for (let i2 = 0; i2 < measuring.length; i2++)
          if (measured[i2] != BadMeasure) {
            try {
              let m = measuring[i2];
              if (m.write)
                m.write(measured[i2], this);
            } catch (e) {
              logException(this.state, e);
            }
          }
        if (redrawn)
          this.docView.updateSelection(true);
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrollAnchorHeight = -1;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff = newAnchorHeight - scrollAnchorHeight;
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(_EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(_EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1)
        return;
      if (request.key != null)
        for (let i = 0; i < this.measureRequests.length; i++) {
          if (this.measureRequests[i].key === request.key) {
            this.measureRequests[i] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin) {
    let known = this.pluginMap.get(plugin);
    if (known === void 0 || known && known.plugin != plugin)
      this.pluginMap.set(plugin, known = this.plugins.find((p) => p.plugin == plugin) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(line, end) {
    let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
    let span = order[end ? order.length - 1 : 0];
    return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos, side = 1) {
    return this.docView.domAtPos(pos, side);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    let found = posAtCoords(this, coords, precise);
    return found && found.pos;
  }
  posAndSideAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from), isolates;
    for (let entry of this.bidiCache) {
      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
        return entry.order;
    }
    if (!isolates)
      isolates = getIsolatedRanges(this, line);
    let order = computeOrder(line.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
    return order;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a2;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root) {
    if (this._root != root) {
      this._root = root;
      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    if (this.root.activeElement == this.contentDOM)
      this.contentDOM.blur();
    for (let plugin of this.plugins)
      plugin.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.docView.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop, scrollLeft } = this.scrollDOM;
    let ref = this.viewState.scrollAnchorAt(scrollTop);
    return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(to) {
    if (to == null)
      this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
    else if (typeof to == "boolean")
      this.inputState.tabFocusMode = to ? 0 : -1;
    else if (this.inputState.tabFocusMode != 0)
      this.inputState.tabFocusMode = Date.now() + to;
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a2;
    let content2 = dom.querySelector(".cm-content");
    let tile = content2 && Tile.get(content2) || Tile.get(dom);
    return ((_a2 = tile === null || tile === void 0 ? void 0 : tile.root) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
  }
};
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.clipboardInputFilter = clipboardInputFilter;
EditorView.clipboardOutputFilter = clipboardOutputFilter;
EditorView.scrollHandler = scrollHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.blockWrappers = blockWrappers;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : "" });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = /* @__PURE__ */ StateEffect.define();
var MaxBidiLine = 4096;
var BadMeasure = {};
var CachedOrder = class _CachedOrder {
  constructor(from, to, dir, isolates, fresh, order) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order;
  }
  static update(cache2, changes) {
    if (changes.empty && !cache2.some((c) => c.fresh))
      return cache2;
    let result = [], lastDir = cache2.length ? cache2[cache2.length - 1].dir : Direction.LTR;
    for (let i = Math.max(0, cache2.length - 10); i < cache2.length; i++) {
      let entry = cache2[i];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result;
  }
};
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
    let source = sources[i], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event, shift2) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift2 !== false && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
}));
var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
var Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map = Keymaps.get(bindings);
  if (!map)
    Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
  return map;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
var storedPrefix = null;
var PrefixTimeout = 4e3;
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is;
    else if (current != is)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add2 = (scope, key, command2, preventDefault, stopPropagation) => {
    var _a2, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
    for (let i = 1; i < parts.length; i++) {
      let prefix = parts.slice(0, i).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix])
        scopeObj[prefix] = {
          preventDefault: true,
          stopPropagation: false,
          run: [(view) => {
            let ourObj = storedPrefix = { view, prefix, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
    });
    if (command2)
      binding.run.push(command2);
    if (preventDefault)
      binding.preventDefault = true;
    if (stopPropagation)
      binding.stopPropagation = true;
  };
  for (let b of bindings) {
    let scopes = b.scope ? b.scope.split(" ") : ["editor"];
    if (b.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
        let { any } = b;
        for (let key in scopeObj)
          scopeObj[key].run.push((view) => any(view, currentKeyEvent));
      }
    let name2 = b[platform] || b.key;
    if (!name2)
      continue;
    for (let scope of scopes) {
      add2(scope, name2, b.run, b.preventDefault, b.stopPropagation);
      if (b.shift)
        add2(scope, "Shift-" + name2, b.shift, b.preventDefault, b.stopPropagation);
    }
  }
  return bound;
}
var currentKeyEvent = null;
function runHandlers(map, event, view, scope) {
  currentKeyEvent = event;
  let name2 = keyName(event);
  let charCode = codePointAt2(name2, 0), isChar = codePointSize2(charCode) == name2.length && name2 != " ";
  let prefix = "", handled = false, prevented = false, stopPropagation = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (modifierCodes.indexOf(event.keyCode) < 0) {
      prevented = true;
      storedPrefix = null;
    }
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.run)
        if (!ran.has(cmd2)) {
          ran.add(cmd2);
          if (cmd2(view)) {
            if (binding.stopPropagation)
              stopPropagation = true;
            return true;
          }
        }
      if (binding.preventDefault) {
        if (binding.stopPropagation)
          stopPropagation = true;
        prevented = true;
      }
    }
    return false;
  };
  let scopeObj = map[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) {
      handled = true;
    } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(browser.windows && event.ctrlKey && event.altKey) && // Alt-combinations on macOS tend to be typed characters
    !(browser.mac && event.altKey && !(event.ctrlKey || event.metaKey)) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
        handled = true;
      } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
        handled = true;
      }
    } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event, true)])) {
      handled = true;
    }
    if (!handled && runFor(scopeObj._any))
      handled = true;
  }
  if (prevented)
    handled = true;
  if (handled && stopPropagation)
    event.stopPropagation();
  currentKeyEvent = null;
  return handled;
}
var RectangleMarker = class _RectangleMarker {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(className, left, top2, width, height) {
    this.className = className;
    this.left = left;
    this.top = top2;
    this.width = width;
    this.height = height;
  }
  draw() {
    let elt2 = document.createElement("div");
    elt2.className = this.className;
    this.adjust(elt2);
    return elt2;
  }
  update(elt2, prev) {
    if (prev.className != this.className)
      return false;
    this.adjust(elt2);
    return true;
  }
  adjust(elt2) {
    elt2.style.left = this.left + "px";
    elt2.style.top = this.top + "px";
    if (this.width != null)
      elt2.style.width = this.width + "px";
    elt2.style.height = this.height + "px";
  }
  eq(p) {
    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(view, className, range) {
    if (range.empty) {
      let pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (!pos)
        return [];
      let base2 = getBase(view);
      return [new _RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
    } else {
      return rectanglesForRange(view, className, range);
    }
  }
};
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
  return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside) {
  let coords = view.coordsAtPos(pos, side * 2);
  if (!coords)
    return inside;
  let editorRect = view.dom.getBoundingClientRect();
  let y = (coords.top + coords.bottom) / 2;
  let left = view.posAtCoords({ x: editorRect.left + 1, y });
  let right = view.posAtCoords({ x: editorRect.right - 1, y });
  if (left == null || right == null)
    return inside;
  return { from: Math.max(inside.from, Math.min(left, right)), to: Math.min(inside.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to)
    return [];
  let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
  let startBlock = blockAt(view, from, 1), endBlock = blockAt(view, to, -1);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
    visualStart = wrappedLine(view, from, 1, visualStart);
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
    visualEnd = wrappedLine(view, to, -1, visualEnd);
  if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top)
      between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
    else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
      top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
    return pieces(top2).concat(between).concat(pieces(bottom));
  }
  function piece(left, top2, right, bottom) {
    return new RectangleMarker(className, left - base2.left, top2 - base2.top, Math.max(0, right - left), bottom - top2);
  }
  function pieces({ top: top2, bottom, horizontal }) {
    let pieces2 = [];
    for (let i = 0; i < horizontal.length; i += 2)
      pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
    return pieces2;
  }
  function drawForLine(from2, to2, line) {
    let top2 = 1e9, bottom = -1e9, horizontal = [];
    function addSpan(from3, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
      if (!fromCoords || !toCoords)
        return;
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
    for (let r of view.visibleRanges)
      if (r.to > start && r.from < end) {
        for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start, from2 == null, end, to2 == null, view.textDirection);
    return { top: top2, bottom, horizontal };
  }
  function drawForWidget(block, top2) {
    let y = contentRect.top + (top2 ? block.top : block.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function sameMarker(a, b) {
  return a.constructor == b.constructor && a.eq(b);
}
var LayerView = class {
  constructor(view, layer2) {
    this.view = view;
    this.layer = layer2;
    this.drawn = [];
    this.scaleX = 1;
    this.scaleY = 1;
    this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
    this.dom = view.scrollDOM.appendChild(document.createElement("div"));
    this.dom.classList.add("cm-layer");
    if (layer2.above)
      this.dom.classList.add("cm-layer-above");
    if (layer2.class)
      this.dom.classList.add(layer2.class);
    this.scale();
    this.dom.setAttribute("aria-hidden", "true");
    this.setOrder(view.state);
    view.requestMeasure(this.measureReq);
    if (layer2.mount)
      layer2.mount(this.dom, view);
  }
  update(update) {
    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
      this.setOrder(update.state);
    if (this.layer.update(update, this.dom) || update.geometryChanged) {
      this.scale();
      update.view.requestMeasure(this.measureReq);
    }
  }
  docViewUpdate(view) {
    if (this.layer.updateOnDocViewUpdate !== false)
      view.requestMeasure(this.measureReq);
  }
  setOrder(state) {
    let pos = 0, order = state.facet(layerOrder);
    while (pos < order.length && order[pos] != this.layer)
      pos++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX, scaleY } = this.view;
    if (scaleX != this.scaleX || scaleY != this.scaleY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
    }
  }
  draw(markers) {
    if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
      let old = this.dom.firstChild, oldI = 0;
      for (let marker of markers) {
        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
          old = old.nextSibling;
          oldI++;
        } else {
          this.dom.insertBefore(marker.draw(), old);
        }
      }
      while (old) {
        let next = old.nextSibling;
        old.remove();
        old = next;
      }
      this.drawn = markers;
      if (browser.safari && browser.safari_version >= 26)
        this.dom.style.display = this.dom.firstChild ? "" : "none";
    }
  }
  destroy() {
    if (this.layer.destroy)
      this.layer.destroy(this.dom, this.view);
    this.dom.remove();
  }
};
var layerOrder = /* @__PURE__ */ Facet.define();
function layer(config2) {
  return [
    ViewPlugin.define((v) => new LayerView(v, config2)),
    layerOrder.of(config2)
  ];
}
var selectionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a, b) => Math.min(a, b),
      drawRangeCursor: (a, b) => a || b
    });
  }
});
function drawSelection(config2 = {}) {
  return [
    selectionConfig.of(config2),
    cursorLayer,
    selectionLayer,
    hideNativeSelection,
    nativeSelectionHidden.of(true)
  ];
}
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
var cursorLayer = /* @__PURE__ */ layer({
  above: true,
  markers(view) {
    let { state } = view, conf = state.facet(selectionConfig);
    let cursors = [];
    for (let r of state.selection.ranges) {
      let prim = r == state.selection.main;
      if (r.empty || conf.drawRangeCursor) {
        let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
        let cursor2 = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (let piece of RectangleMarker.forRange(view, className, cursor2))
          cursors.push(piece);
      }
    }
    return cursors;
  },
  update(update, dom) {
    if (update.transactions.some((tr) => tr.selection))
      dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    let confChange = configChanged(update);
    if (confChange)
      setBlinkRate(update.state, dom);
    return update.docChanged || update.selectionSet || confChange;
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom);
  },
  class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
var selectionLayer = /* @__PURE__ */ layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges.map((r) => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
  },
  update(update, dom) {
    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
  },
  class: "cm-selectionLayer"
});
var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
}));
var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
  map(pos, mapping) {
    return pos == null ? null : mapping.mapPos(pos);
  }
});
var dropCursorPos = /* @__PURE__ */ StateField.define({
  create() {
    return null;
  },
  update(pos, tr) {
    if (pos != null)
      pos = tr.changes.mapPos(pos);
    return tr.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
  }
});
var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.cursor = null;
    this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(update) {
    var _a2;
    let cursorPos = update.state.field(dropCursorPos);
    if (cursorPos == null) {
      if (this.cursor != null) {
        (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
        this.cursor = null;
      }
    } else {
      if (!this.cursor) {
        this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
        this.cursor.className = "cm-dropCursor";
      }
      if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
        this.view.requestMeasure(this.measureReq);
    }
  }
  readPos() {
    let { view } = this;
    let pos = view.state.field(dropCursorPos);
    let rect = pos != null && view.coordsAtPos(pos);
    if (!rect)
      return null;
    let outer = view.scrollDOM.getBoundingClientRect();
    return {
      left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
      top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
      height: rect.bottom - rect.top
    };
  }
  drawCursor(pos) {
    if (this.cursor) {
      let { scaleX, scaleY } = this.view;
      if (pos) {
        this.cursor.style.left = pos.left / scaleX + "px";
        this.cursor.style.top = pos.top / scaleY + "px";
        this.cursor.style.height = pos.height / scaleY + "px";
      } else {
        this.cursor.style.left = "-100000px";
      }
    }
  }
  destroy() {
    if (this.cursor)
      this.cursor.remove();
  }
  setDropPos(pos) {
    if (this.view.state.field(dropCursorPos) != pos)
      this.view.dispatch({ effects: setDropCursorPos.of(pos) });
  }
}, {
  eventObservers: {
    dragover(event) {
      this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
    },
    dragleave(event) {
      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
        this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function dropCursor() {
  return [dropCursorPos, drawDropCursor];
}
function iterMatches(doc2, re, from, to, f) {
  re.lastIndex = 0;
  for (let cursor2 = doc2.iterRange(from, to), pos = from, m; !cursor2.next().done; pos += cursor2.value.length) {
    if (!cursor2.lineBreak)
      while (m = re.exec(cursor2.value))
        f(pos + m.index, m);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
    return visible;
  let result = [];
  for (let { from, to } of visible) {
    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
    if (result.length && result[result.length - 1].to >= from)
      result[result.length - 1].to = to;
    else
      result.push({ from, to });
  }
  return result;
}
var MatchDecorator = class {
  /**
  Create a decorator.
  */
  constructor(config2) {
    const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config2;
    if (!regexp.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    if (decorate) {
      this.addMatch = (match, view, from, add2) => decorate(add2, from, from + match[0].length, match, view);
    } else if (typeof decoration == "function") {
      this.addMatch = (match, view, from, add2) => {
        let deco = decoration(match, view, from);
        if (deco)
          add2(from, from + match[0].length, deco);
      };
    } else if (decoration) {
      this.addMatch = (match, _view, from, add2) => add2(from, from + match[0].length, decoration);
    } else {
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    }
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(view) {
    let build = new RangeSetBuilder(), add2 = build.add.bind(build);
    for (let { from, to } of matchRanges(view, this.maxLength))
      iterMatches(view.state.doc, this.regexp, from, to, (from2, m) => this.addMatch(m, view, from2, add2));
    return build.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(update, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update.docChanged)
      update.changes.iterChanges((_f, _t, from, to) => {
        if (to >= update.view.viewport.from && from <= update.view.viewport.to) {
          changeFrom = Math.min(from, changeFrom);
          changeTo = Math.max(to, changeTo);
        }
      });
    if (update.viewportMoved || changeTo - changeFrom > 1e3)
      return this.createDeco(update.view);
    if (changeTo > -1)
      return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r of view.visibleRanges) {
      let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
      if (to >= from) {
        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
        let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--)
            if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
              start = from;
              break;
            }
          for (; to < toLine.to; to++)
            if (this.boundary.test(toLine.text[to - toLine.from])) {
              end = to;
              break;
            }
        }
        let ranges = [], m;
        let add2 = (from2, to2, deco2) => ranges.push(deco2.range(from2, to2));
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
            this.addMatch(m, view, m.index + fromLine.from, add2);
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from2, m2) => this.addMatch(m2, view, from2, add2));
        }
        deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges });
      }
    }
    return deco;
  }
};
var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
var Names = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
var _supportsTabSize = null;
function supportsTabSize() {
  var _a2;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
var specialCharConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let config2 = combineConfig(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config2.replaceTabs = !supportsTabSize())
      config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
    if (config2.addSpecialChars)
      config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
    return config2;
  }
});
function highlightSpecialChars(config2 = {}) {
  return [specialCharConfig.of(config2), specialCharPlugin()];
}
var _plugin = null;
function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = /* @__PURE__ */ Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }
    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m, view, pos) => {
          let { doc: doc2 } = view.state;
          let code = codePointAt2(m[0], 0);
          if (code == 9) {
            let line = doc2.lineAt(pos);
            let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
            return Decoration.replace({
              widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
        },
        boundary: conf.replaceTabs ? void 0 : /[^]/
      });
    }
    update(update) {
      let conf = update.state.facet(specialCharConfig);
      if (update.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update.view);
      } else {
        this.decorations = this.decorator.updateDeco(update, this.decorations);
      }
    }
  }, {
    decorations: (v) => v.decorations
  }));
}
var DefaultPlaceholder = "\u2022";
function placeholder$1(code) {
  if (code >= 32)
    return DefaultPlaceholder;
  if (code == 10)
    return "\u2424";
  return String.fromCharCode(9216 + code);
}
var SpecialCharWidget = class extends WidgetType {
  constructor(options, code) {
    super();
    this.options = options;
    this.code = code;
  }
  eq(other) {
    return other.code == this.code;
  }
  toDOM(view) {
    let ph = placeholder$1(this.code);
    let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
    let custom = this.options.render && this.options.render(this.code, desc, ph);
    if (custom)
      return custom;
    let span = document.createElement("span");
    span.textContent = ph;
    span.title = desc;
    span.setAttribute("aria-label", desc);
    span.className = "cm-specialChar";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var TabWidget = class extends WidgetType {
  constructor(width) {
    super();
    this.width = width;
  }
  eq(other) {
    return other.width == this.width;
  }
  toDOM() {
    let span = document.createElement("span");
    span.textContent = "	";
    span.className = "cm-tab";
    span.style.width = this.width + "px";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var MaxOff = 2e3;
function rectangleFor(state, a, b) {
  let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
  let ranges = [];
  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
    let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      if (line.length <= endOff)
        ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      let start = findColumn(line.text, startCol, state.tabSize, true);
      if (start < 0) {
        ranges.push(EditorSelection.cursor(line.to));
      } else {
        let end = findColumn(line.text, endCol, state.tabSize);
        ranges.push(EditorSelection.range(line.from + start, line.from + end));
      }
    }
  }
  return ranges;
}
function absoluteColumn(view, x) {
  let ref = view.coordsAtPos(view.viewport.from);
  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let line = view.state.doc.lineAt(offset), off = offset - line.from;
  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
  return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event), startSel = view.state.selection;
  if (!start)
    return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, _extend, multiple) {
      let cur2 = getPos(view, event2);
      if (!cur2)
        return startSel;
      let ranges = rectangleFor(view.state, start, cur2);
      if (!ranges.length)
        return startSel;
      if (multiple)
        return EditorSelection.create(ranges.concat(startSel.ranges));
      else
        return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options) {
  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e) => e.altKey && e.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
var keys = {
  Alt: [18, (e) => !!e.altKey],
  Control: [17, (e) => !!e.ctrlKey],
  Shift: [16, (e) => !!e.shiftKey],
  Meta: [91, (e) => !!e.metaKey]
};
var showCrosshair = { style: "cursor: crosshair" };
function crosshairCursor(options = {}) {
  let [code, getter] = keys[options.key || "Alt"];
  let plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.isDown = false;
    }
    set(isDown) {
      if (this.isDown != isDown) {
        this.isDown = isDown;
        this.view.update([]);
      }
    }
  }, {
    eventObservers: {
      keydown(e) {
        this.set(e.keyCode == code || getter(e));
      },
      keyup(e) {
        if (e.keyCode == code || !getter(e))
          this.set(false);
      },
      mousemove(e) {
        this.set(getter(e));
      }
    }
  });
  return [
    plugin,
    EditorView.contentAttributes.of((view) => {
      var _a2;
      return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
    })
  ];
}
var Outside = "-10000px";
var TooltipViewManager = class {
  constructor(view, facet, createTooltipView, removeTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.removeTooltipView = removeTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t2) => t2);
    let prev = null;
    this.tooltipViews = this.tooltips.map((t2) => prev = createTooltipView(t2, prev));
  }
  update(update, above) {
    var _a2;
    let input = update.state.facet(this.facet);
    let tooltips = input.filter((x) => x);
    if (input === this.input) {
      for (let t2 of this.tooltipViews)
        if (t2.update)
          t2.update(update);
      return false;
    }
    let tooltipViews = [], newAbove = above ? [] : null;
    for (let i = 0; i < tooltips.length; i++) {
      let tip = tooltips[i], known = -1;
      if (!tip)
        continue;
      for (let i2 = 0; i2 < this.tooltips.length; i2++) {
        let other = this.tooltips[i2];
        if (other && other.create == tip.create)
          known = i2;
      }
      if (known < 0) {
        tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);
        if (newAbove)
          newAbove[i] = !!tip.above;
      } else {
        let tooltipView = tooltipViews[i] = this.tooltipViews[known];
        if (newAbove)
          newAbove[i] = above[known];
        if (tooltipView.update)
          tooltipView.update(update);
      }
    }
    for (let t2 of this.tooltipViews)
      if (tooltipViews.indexOf(t2) < 0) {
        this.removeTooltipView(t2);
        (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
      }
    if (above) {
      newAbove.forEach((val, i) => above[i] = val);
      above.length = newAbove.length;
    }
    this.input = input;
    this.tooltips = tooltips;
    this.tooltipViews = tooltipViews;
    return true;
  }
};
function windowSpace(view) {
  let docElt = view.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: docElt.clientHeight, right: docElt.clientWidth };
}
var tooltipConfig = /* @__PURE__ */ Facet.define({
  combine: (values2) => {
    var _a2, _b, _c;
    return {
      position: browser.ios ? "absolute" : ((_a2 = values2.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
      parent: ((_b = values2.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c = values2.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
    };
  }
});
var knownHeight = /* @__PURE__ */ new WeakMap();
var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.above = [];
    this.inView = true;
    this.madeAbsolute = false;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config2 = view.state.facet(tooltipConfig);
    this.position = config2.position;
    this.parent = config2.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
    this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
    this.manager = new TooltipViewManager(view, showTooltip, (t2, p) => this.createTooltip(t2, p), (t2) => {
      if (this.resizeObserver)
        this.resizeObserver.unobserve(t2.dom);
      t2.dom.remove();
    });
    this.above = this.manager.tooltips.map((t2) => !!t2.above);
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
        this.measureSoon();
    }, { threshold: [1] }) : null;
    this.observeIntersection();
    view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews)
        this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0)
      this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
  }
  update(update) {
    if (update.transactions.length)
      this.lastTransaction = Date.now();
    let updated = this.manager.update(update, this.above);
    if (updated)
      this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position && !this.madeAbsolute) {
      this.position = newConfig.position;
      for (let t2 of this.manager.tooltipViews)
        t2.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent)
        this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t2 of this.manager.tooltipViews)
        this.container.appendChild(t2.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure)
      this.maybeMeasure();
  }
  createTooltip(tooltip, prev) {
    let tooltipView = tooltip.create(this.view);
    let before = prev ? prev.dom : null;
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow = document.createElement("div");
      arrow.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    tooltipView.dom.style.left = "0px";
    this.container.insertBefore(tooltipView.dom, before);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    if (this.resizeObserver)
      this.resizeObserver.observe(tooltipView.dom);
    return tooltipView;
  }
  destroy() {
    var _a2, _b, _c;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let tooltipView of this.manager.tooltipViews) {
      tooltipView.dom.remove();
      (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
    }
    if (this.parent)
      this.container.remove();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let scaleX = 1, scaleY = 1, makeAbsolute = false;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom } = this.manager.tooltipViews[0];
      if (browser.safari) {
        let rect = dom.getBoundingClientRect();
        makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
      } else {
        makeAbsolute = !!dom.offsetParent && dom.offsetParent != this.container.ownerDocument.body;
      }
    }
    if (makeAbsolute || this.position == "absolute") {
      if (this.parent) {
        let rect = this.parent.getBoundingClientRect();
        if (rect.width && rect.height) {
          scaleX = rect.width / this.parent.offsetWidth;
          scaleY = rect.height / this.parent.offsetHeight;
        }
      } else {
        ({ scaleX, scaleY } = this.view.viewState);
      }
    }
    let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
    return {
      visible: {
        left: visible.left + margins.left,
        top: visible.top + margins.top,
        right: visible.right - margins.right,
        bottom: visible.bottom - margins.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((t2, i) => {
        let tv = this.manager.tooltipViews[i];
        return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
      scaleX,
      scaleY,
      makeAbsolute
    };
  }
  writeMeasure(measured) {
    var _a2;
    if (measured.makeAbsolute) {
      this.madeAbsolute = true;
      this.position = "absolute";
      for (let t2 of this.manager.tooltipViews)
        t2.dom.style.position = "absolute";
    }
    let { visible, space: space4, scaleX, scaleY } = measured;
    let others = [];
    for (let i = 0; i < this.manager.tooltips.length; i++) {
      let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
      let pos = measured.pos[i], size = measured.size[i];
      if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space4.top) || pos.top >= Math.min(visible.bottom, space4.bottom) || pos.right < Math.max(visible.left, space4.left) - 0.1 || pos.left > Math.min(visible.right, space4.right) + 0.1)) {
        dom.style.top = Outside;
        continue;
      }
      let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow ? 7 : 0;
      let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
      let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
      let left = size.width > space4.right - space4.left ? ltr ? space4.left : space4.right - size.width : ltr ? Math.max(space4.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space4.right - width)) : Math.min(Math.max(space4.left, pos.left - width + (arrow ? 14 : 0) - offset.x), space4.right - width);
      let above = this.above[i];
      if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space4.top : pos.bottom + height + arrowHeight + offset.y > space4.bottom) && above == space4.bottom - pos.bottom > pos.top - space4.top)
        above = this.above[i] = !above;
      let spaceVert = (above ? pos.top - space4.top : space4.bottom - pos.bottom) - arrowHeight;
      if (spaceVert < height && tView.resize !== false) {
        if (spaceVert < this.view.defaultLineHeight) {
          dom.style.top = Outside;
          continue;
        }
        knownHeight.set(tView, height);
        dom.style.height = (height = spaceVert) / scaleY + "px";
      } else if (dom.style.height) {
        dom.style.height = "";
      }
      let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
      let right = left + width;
      if (tView.overlap !== true) {
        for (let r of others)
          if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
            top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
        setLeftStyle(dom, (left - measured.parent.left) / scaleX);
      } else {
        dom.style.top = top2 / scaleY + "px";
        setLeftStyle(dom, left / scaleX);
      }
      if (arrow) {
        let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
        arrow.style.left = arrowLeft / scaleX + "px";
      }
      if (tView.overlap !== true)
        others.push({ left, top: top2, right, bottom: top2 + height });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned(measured.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView)
        this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView)
          for (let tv of this.manager.tooltipViews)
            tv.dom.style.top = Outside;
      }
    }
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function setLeftStyle(elt2, value) {
  let current = parseInt(elt2.style.left, 10);
  if (isNaN(current) || Math.abs(value - current) > 1)
    elt2.style.left = value + "px";
}
var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var noOffset = { x: 0, y: 0 };
var showTooltip = /* @__PURE__ */ Facet.define({
  enables: [tooltipPlugin, baseTheme]
});
function getTooltip(view, tooltip) {
  let plugin = view.plugin(tooltipPlugin);
  if (!plugin)
    return null;
  let found = plugin.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin.manager.tooltipViews[found];
}
var panelConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c of configs) {
      topContainer = topContainer || c.topContainer;
      bottomContainer = bottomContainer || c.bottomContainer;
    }
    return { topContainer, bottomContainer };
  }
});
function getPanel(view, panel) {
  let plugin = view.plugin(panelPlugin);
  let index = plugin ? plugin.specs.indexOf(panel) : -1;
  return index > -1 ? plugin.panels[index] : null;
}
var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s) => s);
    this.panels = this.specs.map((spec) => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter((p) => p.top));
    this.bottom.sync(this.panels.filter((p) => !p.top));
    for (let p of this.panels) {
      p.dom.classList.add("cm-panel");
      if (p.mount)
        p.mount();
    }
  }
  update(update) {
    let conf = update.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x) => x);
      let panels = [], top2 = [], bottom = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update)
            panel.update(update);
        }
        panels.push(panel);
        (panel.top ? top2 : bottom).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top2);
      this.bottom.sync(bottom);
      for (let p of mount) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    } else {
      for (let p of this.panels)
        if (p.update)
          p.update(update);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: (plugin) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin);
    return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
  })
});
var PanelGroup = class {
  constructor(view, top2, container) {
    this.view = view;
    this.top = top2;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    for (let p of this.panels)
      if (p.destroy && panels.indexOf(p) < 0)
        p.destroy();
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom)
          curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM)
      curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses)
      return;
    for (let cls of this.classes.split(" "))
      if (cls)
        this.container.classList.remove(cls);
    for (let cls of (this.classes = this.view.themeClasses).split(" "))
      if (cls)
        this.container.classList.add(cls);
  }
};
function rm(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}
var showPanel = /* @__PURE__ */ Facet.define({
  enables: panelPlugin
});
function showDialog(view, config2) {
  let resolve;
  let promise = new Promise((r) => resolve = r);
  let panelCtor = (view2) => createDialog(view2, config2, resolve);
  if (view.state.field(dialogField, false)) {
    view.dispatch({ effects: openDialogEffect.of(panelCtor) });
  } else {
    view.dispatch({ effects: StateEffect.appendConfig.of(dialogField.init(() => [panelCtor])) });
  }
  let close = closeDialogEffect.of(panelCtor);
  return { close, result: promise.then((form) => {
    let queue = view.win.queueMicrotask || ((f) => view.win.setTimeout(f, 10));
    queue(() => {
      if (view.state.field(dialogField).indexOf(panelCtor) > -1)
        view.dispatch({ effects: close });
    });
    return form;
  }) };
}
var dialogField = /* @__PURE__ */ StateField.define({
  create() {
    return [];
  },
  update(dialogs, tr) {
    for (let e of tr.effects) {
      if (e.is(openDialogEffect))
        dialogs = [e.value].concat(dialogs);
      else if (e.is(closeDialogEffect))
        dialogs = dialogs.filter((d) => d != e.value);
    }
    return dialogs;
  },
  provide: (f) => showPanel.computeN([f], (state) => state.field(f))
});
var openDialogEffect = /* @__PURE__ */ StateEffect.define();
var closeDialogEffect = /* @__PURE__ */ StateEffect.define();
function createDialog(view, config2, result) {
  let content2 = config2.content ? config2.content(view, () => done(null)) : null;
  if (!content2) {
    content2 = crelt("form");
    if (config2.input) {
      let input = crelt("input", config2.input);
      if (/^(text|password|number|email|tel|url)$/.test(input.type))
        input.classList.add("cm-textfield");
      if (!input.name)
        input.name = "input";
      content2.appendChild(crelt("label", (config2.label || "") + ": ", input));
    } else {
      content2.appendChild(document.createTextNode(config2.label || ""));
    }
    content2.appendChild(document.createTextNode(" "));
    content2.appendChild(crelt("button", { class: "cm-button", type: "submit" }, config2.submitLabel || "OK"));
  }
  let forms = content2.nodeName == "FORM" ? [content2] : content2.querySelectorAll("form");
  for (let i = 0; i < forms.length; i++) {
    let form = forms[i];
    form.addEventListener("keydown", (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        done(null);
      } else if (event.keyCode == 13) {
        event.preventDefault();
        done(form);
      }
    });
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      done(form);
    });
  }
  let panel = crelt("div", content2, crelt("button", {
    onclick: () => done(null),
    "aria-label": view.state.phrase("close"),
    class: "cm-dialog-close",
    type: "button"
  }, ["\xD7"]));
  if (config2.class)
    panel.className = config2.class;
  panel.classList.add("cm-dialog");
  function done(form) {
    if (panel.contains(panel.ownerDocument.activeElement))
      view.focus();
    result(form);
  }
  return {
    dom: panel,
    top: config2.top,
    mount: () => {
      if (config2.focus) {
        let focus;
        if (typeof config2.focus == "string")
          focus = content2.querySelector(config2.focus);
        else
          focus = content2.querySelector("input") || content2.querySelector("button");
        if (focus && "select" in focus)
          focus.select();
        else if (focus && "focus" in focus)
          focus.focus();
      }
    }
  };
}
var GutterMarker = class extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
};
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
var gutterLineClass = /* @__PURE__ */ Facet.define();
var gutterWidgetClass = /* @__PURE__ */ Facet.define();
var defaults = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {},
  side: "before"
};
var activeGutters = /* @__PURE__ */ Facet.define();
function gutter(config2) {
  return [gutters(), activeGutters.of({ ...defaults, ...config2 })];
}
var unfixGutters = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((x) => x)
});
function gutters(config2) {
  let result = [
    gutterView
  ];
  if (config2 && config2.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.domAfter = null;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters cm-gutters-before";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    this.fixed = !view.state.facet(unfixGutters);
    for (let gutter2 of this.gutters) {
      if (gutter2.config.side == "after")
        this.getDOMAfter().appendChild(gutter2.dom);
      else
        this.dom.appendChild(gutter2.dom);
    }
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  getDOMAfter() {
    if (!this.domAfter) {
      this.domAfter = document.createElement("div");
      this.domAfter.className = "cm-gutters cm-gutters-after";
      this.domAfter.setAttribute("aria-hidden", "true");
      this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      this.domAfter.style.position = this.fixed ? "sticky" : "";
      this.view.scrollDOM.appendChild(this.domAfter);
    }
    return this.domAfter;
  }
  update(update) {
    if (this.updateGutters(update)) {
      let vpA = this.prevViewport, vpB = update.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update.geometryChanged) {
      let min = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = min;
      if (this.domAfter)
        this.domAfter.style.minHeight = min;
    }
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
      if (this.domAfter)
        this.domAfter.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update.view.viewport;
  }
  syncGutters(detach) {
    let after = this.dom.nextSibling;
    if (detach) {
      this.dom.remove();
      if (this.domAfter)
        this.domAfter.remove();
    }
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
    for (let line of this.view.viewportLineBlocks) {
      if (classSet.length)
        classSet = [];
      if (Array.isArray(line.type)) {
        let first = true;
        for (let b of line.type) {
          if (b.type == BlockType.Text && first) {
            advanceCursor(lineClasses, classSet, b.from);
            for (let cx of contexts)
              cx.line(this.view, b, classSet);
            first = false;
          } else if (b.widget) {
            for (let cx of contexts)
              cx.widget(this.view, b);
          }
        }
      } else if (line.type == BlockType.Text) {
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, line, classSet);
      } else if (line.widget) {
        for (let cx of contexts)
          cx.widget(this.view, line);
      }
    }
    for (let cx of contexts)
      cx.finish();
    if (detach) {
      this.view.scrollDOM.insertBefore(this.dom, after);
      if (this.domAfter)
        this.view.scrollDOM.appendChild(this.domAfter);
    }
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev == cur2) {
      for (let gutter2 of this.gutters)
        if (gutter2.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur2) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g of this.gutters) {
        g.dom.remove();
        if (gutters2.indexOf(g) < 0)
          g.destroy();
      }
      for (let g of gutters2) {
        if (g.config.side == "after")
          this.getDOMAfter().appendChild(g.dom);
        else
          this.dom.appendChild(g.dom);
      }
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    for (let view of this.gutters)
      view.destroy();
    this.dom.remove();
    if (this.domAfter)
      this.domAfter.remove();
  }
}, {
  provide: (plugin) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin);
    if (!value || value.gutters.length == 0 || !value.fixed)
      return null;
    let before = value.dom.offsetWidth * view.scaleX, after = value.domAfter ? value.domAfter.offsetWidth * view.scaleX : 0;
    return view.textDirection == Direction.LTR ? { left: before, right: after } : { right: before, left: after };
  })
});
function asArray2(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor2, collect, pos) {
  while (cursor2.value && cursor2.from <= pos) {
    if (cursor2.from == pos)
      collect.push(cursor2.value);
    cursor2.next();
  }
}
var UpdateContext = class {
  constructor(gutter2, viewport, height) {
    this.gutter = gutter2;
    this.height = height;
    this.i = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
  }
  addElement(view, block, markers) {
    let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, height, above, markers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      gutter2.elements[this.i].update(view, height, above, markers);
    }
    this.height = block.bottom;
    this.i++;
  }
  line(view, line, extraMarkers) {
    let localMarkers = [];
    advanceCursor(this.cursor, localMarkers, line.from);
    if (extraMarkers.length)
      localMarkers = localMarkers.concat(extraMarkers);
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
      return;
    this.addElement(view, line, localMarkers);
  }
  widget(view, block) {
    let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
    for (let cls of view.state.facet(gutterWidgetClass)) {
      let marker2 = cls(view, block.widget, block);
      if (marker2)
        (markers || (markers = [])).push(marker2);
    }
    if (markers)
      this.addElement(view, block, markers);
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i) {
      let last = gutter2.elements.pop();
      gutter2.dom.removeChild(last.dom);
      last.destroy();
    }
  }
};
var SingleGutterView = class {
  constructor(view, config2) {
    this.view = view;
    this.config = config2;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config2.domEventHandlers) {
      this.dom.addEventListener(prop, (event) => {
        let target = event.target, y;
        if (target != this.dom && this.dom.contains(target)) {
          while (target.parentNode != this.dom)
            target = target.parentNode;
          let rect = target.getBoundingClientRect();
          y = (rect.top + rect.bottom) / 2;
        } else {
          y = event.clientY;
        }
        let line = view.lineBlockAtHeight(y - view.documentTop);
        if (config2.domEventHandlers[prop](view, line, event))
          event.preventDefault();
      });
    }
    this.markers = asArray2(config2.markers(view));
    if (config2.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray2(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp = update.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
  }
  destroy() {
    for (let elt2 of this.elements)
      elt2.destroy();
  }
};
var GutterElement = class {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutterElement";
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height) {
      this.height = height;
      this.dom.style.height = height + "px";
    }
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers))
      this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls = "cm-gutterElement", domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0; ; ) {
      let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
      if (marker) {
        let c = marker.elementClass;
        if (c)
          cls += " " + c;
        for (let i = iOld; i < this.markers.length; i++)
          if (this.markers[i].compare(marker)) {
            skipTo = i;
            matched = true;
            break;
          }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next = this.markers[iOld++];
        if (next.toDOM) {
          next.destroy(domPos);
          let after = domPos.nextSibling;
          domPos.remove();
          domPos = after;
        }
      }
      if (!marker)
        break;
      if (marker.toDOM) {
        if (matched)
          domPos = domPos.nextSibling;
        else
          this.dom.insertBefore(marker.toDOM(view), domPos);
      }
      if (matched)
        iOld++;
    }
    this.dom.className = cls;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function sameMarkers(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].compare(b[i]))
      return false;
  return true;
}
var lineNumberMarkers = /* @__PURE__ */ Facet.define();
var lineNumberWidgetMarker = /* @__PURE__ */ Facet.define();
var lineNumberConfig = /* @__PURE__ */ Facet.define({
  combine(values2) {
    return combineConfig(values2, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(a, b) {
        let result = Object.assign({}, a);
        for (let event in b) {
          let exists = result[event], add2 = b[event];
          result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
        }
        return result;
      }
    });
  }
});
var NumberMarker = class extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
};
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m) => m.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  widgetMarker: (view, widget, block) => {
    for (let m of view.state.facet(lineNumberWidgetMarker)) {
      let result = m(view, widget, block);
      if (result)
        return result;
    }
    return null;
  },
  lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers,
  side: "before"
}));
function lineNumbers(config2 = {}) {
  return [
    lineNumberConfig.of(config2),
    gutters(),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last = 9;
  while (last < lines)
    last = last * 10 + 9;
  return last;
}
var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
  let marks2 = [], last = -1;
  for (let range of state.selection.ranges) {
    let linePos = state.doc.lineAt(range.head).from;
    if (linePos > last) {
      last = linePos;
      marks2.push(activeLineGutterMarker.range(linePos));
    }
  }
  return RangeSet.of(marks2);
});
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range2 = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
var NodeProp = class {
  /**
  Create a new node prop type.
  */
  constructor(config2 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config2.perNode;
    this.deserialize = config2.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
    this.combine = config2.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
  constructor(tree, overlay, parser5, bracketed = false) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser5;
    this.bracketed = bracketed;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new _NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var NodeSet = class _NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types2) {
    this.types = types2;
    for (let i = 0; i < types2.length; i++)
      if (types2[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add2 = source(type);
        if (add2) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          let value = add2[1], prop = add2[0];
          if (prop.combine && prop.id in newProps)
            value = prop.combine(newProps[prop.id], value);
          newProps[prop.id] = value;
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new _NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  IterMode2[IterMode2["EnterBracketed"] = 16] = "EnterBracketed";
})(IterMode || (IterMode = {}));
var Tree = class _Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor2 = new TreeCursor(scope);
    cursor2.moveTo(pos, side);
    CachedNode.set(this, cursor2._tree);
    return cursor2;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c.type.isAnonymous))
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config2 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data2) {
    return buildTree(data2);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class _FlatBufferCursor {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class _TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index) {
    let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      let to = copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
      len = Math.max(len, to);
    }
    return new _TreeBuffer(copy, len, this.set);
  }
};
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a2;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
var BaseNode = class {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class _TreeNode extends BaseNode {
  constructor(_tree, from, index, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from, mounted;
        if (!(mode & IterMode.EnterBracketed && next instanceof Tree && (mounted = MountedTree.get(next)) && !mounted.overlay && mounted.bracketed && pos >= start && pos <= start + next.length) && !checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted2;
          if (!(mode & IterMode.IgnoreMounts) && (mounted2 = MountedTree.get(next)) && !mounted2.overlay)
            return new _TreeNode(mounted2.tree, start, i, parent);
          let inner = new _TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side, mode);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  prop(prop) {
    return this._tree.prop(prop);
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from, enterBracketed = mode & IterMode.EnterBracketed && mounted.bracketed;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 || enterBracketed ? from <= rPos : from < rPos) && (side < 0 || enterBracketed ? to >= rPos : to > rPos))
          return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function getChildren(node, type, before, after) {
  let cur2 = node.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur2.type.is(before);
      if (!cur2.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
};
var BufferNode = class _BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new _BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  prop(prop) {
    return this.type.prop(prop);
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new _BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new _BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new _BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i = 1; i < heads.length; i++) {
    let node = heads[i];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick = i;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node, mode = 0) {
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    this.mode = mode & ~IterMode.EnterBracketed;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      if (index > -1)
        for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache2 = this.bufferNode, result = null, depth = 0;
    if (cache2 && cache2.context == this.buffer) {
      scan: for (let index = this.index, d = this.stack.length; d >= 0; ) {
        for (let c = cache2; c; c = c._parent)
          if (c.index == index) {
            if (index == this.index)
              return c;
            result = c;
            depth = d + 1;
            break scan;
          }
        index = this.stack[--d];
      }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types: types2 } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this._tree, context, i);
      let type = types2[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name)
          return false;
        i--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data2) {
  var _a2;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data2;
  let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
    let { id: id2, start, end, size } = cursor2;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    if (size < 0) {
      cursor2.next();
      if (size == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types2[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
      let data3 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor2.pos - buffer2.size, index = data3.length;
      while (cursor2.pos > endPos)
        index = copyToBuffer(buffer2.start, data3, index);
      node = new TreeBuffer(data3, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor2.pos - size;
      cursor2.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor2.pos > endPos) {
        if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
          if (cursor2.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor2.end;
          }
          cursor2.next();
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor2.pos > minPos) {
      let { id: id2, start, end, size } = cursor2;
      if (size > 4) {
        cursor2.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id2, start, end);
        nodeCount++;
        cursor2.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
        buffer2[j++] = nodes[i];
        buffer2[j++] = nodes[i + 1] - start;
        buffer2[j++] = nodes[i + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i, from, to, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
    positions2.push(from - base2);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor2.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size;
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result.size = size;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize2;
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
        break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart2 = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3 || fork.size == -4)
            localSkipped += 4;
          else
            break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart2;
      size += nodeSize2;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id: id2, start, end, size } = cursor2;
    cursor2.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor2.pos - (size - 4);
        while (cursor2.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor2.pos > 0)
    takeNode(data2.start || 0, data2.bufferStart || 0, children, positions, -1, 0);
  let length = (_a2 = data2.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[data2.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var NodeWeakMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(buffer, index, value) {
    let inner = this.map.get(buffer);
    if (!inner)
      this.map.set(buffer, inner = /* @__PURE__ */ new Map());
    inner.set(index, value);
  }
  getBuffer(buffer, index) {
    let inner = this.map.get(buffer);
    return inner && inner.get(index);
  }
  /**
  Set the value for this syntax node.
  */
  set(node, value) {
    if (node instanceof BufferNode)
      this.setBuffer(node.context.buffer, node.index, value);
    else if (node instanceof TreeNode)
      this.map.set(node.tree, value);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(node) {
    return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(cursor2, value) {
    if (cursor2.buffer)
      this.setBuffer(cursor2.buffer.buffer, cursor2.index, value);
    else
      this.map.set(cursor2.tree, value);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(cursor2) {
    return cursor2.buffer ? this.getBuffer(cursor2.buffer.buffer, cursor2.index) : this.map.get(cursor2.tree);
  }
};
var TreeFragment = class _TreeFragment {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(from, to, tree, offset, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(tree, fragments = [], partial = false) {
    let result = [new _TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (let f of fragments)
      if (f.to > tree.length)
        result.push(f);
    return result;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
};
var Parser = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
};
function parseMixed(nest) {
  return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
var InnerParse = class {
  constructor(parser5, parse, overlay, bracketed, target, from) {
    this.parser = parser5;
    this.parse = parse;
    this.overlay = overlay;
    this.bracketed = bracketed;
    this.target = target;
    this.from = from;
  }
};
function checkRanges(ranges) {
  if (!ranges.length || ranges.some((r) => r.from >= r.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
}
var ActiveOverlay = class {
  constructor(parser5, predicate, mounts, index, start, bracketed, target, prev) {
    this.parser = parser5;
    this.predicate = predicate;
    this.mounts = mounts;
    this.index = index;
    this.start = start;
    this.bracketed = bracketed;
    this.target = target;
    this.prev = prev;
    this.depth = 0;
    this.ranges = [];
  }
};
var stoppedInner = new NodeProp({ perNode: true });
var MixedParse = class {
  constructor(base2, nest, input, fragments, ranges) {
    this.nest = nest;
    this.input = input;
    this.fragments = fragments;
    this.ranges = ranges;
    this.inner = [];
    this.innerDone = 0;
    this.baseTree = null;
    this.stoppedAt = null;
    this.baseParse = base2;
  }
  advance() {
    if (this.baseParse) {
      let done2 = this.baseParse.advance();
      if (!done2)
        return null;
      this.baseParse = null;
      this.baseTree = done2;
      this.startInner();
      if (this.stoppedAt != null)
        for (let inner2 of this.inner)
          inner2.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let result = this.baseTree;
      if (this.stoppedAt != null)
        result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
      return result;
    }
    let inner = this.inner[this.innerDone], done = inner.parse.advance();
    if (done) {
      this.innerDone++;
      let props = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props);
      props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser, inner.bracketed);
      inner.target.props = props;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let pos = this.input.length;
    for (let i = this.innerDone; i < this.inner.length; i++) {
      if (this.inner[i].from < pos)
        pos = Math.min(pos, this.inner[i].parse.parsedPos);
    }
    return pos;
  }
  stopAt(pos) {
    this.stoppedAt = pos;
    if (this.baseParse)
      this.baseParse.stopAt(pos);
    else
      for (let i = this.innerDone; i < this.inner.length; i++)
        this.inner[i].parse.stopAt(pos);
  }
  startInner() {
    let fragmentCursor = new FragmentCursor(this.fragments);
    let overlay = null;
    let covered = null;
    let cursor2 = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    scan: for (let nest, isCovered; ; ) {
      let enter = true, range;
      if (this.stoppedAt != null && cursor2.from >= this.stoppedAt) {
        enter = false;
      } else if (fragmentCursor.hasNode(cursor2)) {
        if (overlay) {
          let match = overlay.mounts.find((m) => m.frag.from <= cursor2.from && m.frag.to >= cursor2.to && m.mount.overlay);
          if (match)
            for (let r of match.mount.overlay) {
              let from = r.from + match.pos, to = r.to + match.pos;
              if (from >= cursor2.from && to <= cursor2.to && !overlay.ranges.some((r2) => r2.from < to && r2.to > from))
                overlay.ranges.push({ from, to });
            }
        }
        enter = false;
      } else if (covered && (isCovered = checkCover(covered.ranges, cursor2.from, cursor2.to))) {
        enter = isCovered != 2;
      } else if (!cursor2.type.isAnonymous && (nest = this.nest(cursor2, this.input)) && (cursor2.from < cursor2.to || !nest.overlay)) {
        if (!cursor2.tree) {
          materialize(cursor2);
          if (overlay)
            overlay.depth++;
          if (covered)
            covered.depth++;
        }
        let oldMounts = fragmentCursor.findMounts(cursor2.from, nest.parser);
        if (typeof nest.overlay == "function") {
          overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor2.from, !!nest.bracketed, cursor2.tree, overlay);
        } else {
          let ranges = punchRanges(this.ranges, nest.overlay || (cursor2.from < cursor2.to ? [new Range2(cursor2.from, cursor2.to)] : []));
          if (ranges.length)
            checkRanges(ranges);
          if (ranges.length || !nest.overlay)
            this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(""), nest.overlay ? nest.overlay.map((r) => new Range2(r.from - cursor2.from, r.to - cursor2.from)) : null, !!nest.bracketed, cursor2.tree, ranges.length ? ranges[0].from : cursor2.from));
          if (!nest.overlay)
            enter = false;
          else if (ranges.length)
            covered = { ranges, depth: 0, prev: covered };
        }
      } else if (overlay && (range = overlay.predicate(cursor2))) {
        if (range === true)
          range = new Range2(cursor2.from, cursor2.to);
        if (range.from < range.to) {
          let last = overlay.ranges.length - 1;
          if (last >= 0 && overlay.ranges[last].to == range.from)
            overlay.ranges[last] = { from: overlay.ranges[last].from, to: range.to };
          else
            overlay.ranges.push(range);
        }
      }
      if (enter && cursor2.firstChild()) {
        if (overlay)
          overlay.depth++;
        if (covered)
          covered.depth++;
      } else {
        for (; ; ) {
          if (cursor2.nextSibling())
            break;
          if (!cursor2.parent())
            break scan;
          if (overlay && !--overlay.depth) {
            let ranges = punchRanges(this.ranges, overlay.ranges);
            if (ranges.length) {
              checkRanges(ranges);
              this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r) => new Range2(r.from - overlay.start, r.to - overlay.start)), overlay.bracketed, overlay.target, ranges[0].from));
            }
            overlay = overlay.prev;
          }
          if (covered && !--covered.depth)
            covered = covered.prev;
        }
      }
    }
  }
};
function checkCover(covered, from, to) {
  for (let range of covered) {
    if (range.from >= to)
      break;
    if (range.to > from)
      return range.from <= from && range.to >= to ? 2 : 1;
  }
  return 0;
}
function sliceBuf(buf, startI, endI, nodes, positions, off) {
  if (startI < endI) {
    let from = buf.buffer[startI + 1];
    nodes.push(buf.slice(startI, endI, from));
    positions.push(from - off);
  }
}
function materialize(cursor2) {
  let { node } = cursor2, stack = [];
  let buffer = node.context.buffer;
  do {
    stack.push(cursor2.index);
    cursor2.parent();
  } while (!cursor2.tree);
  let base2 = cursor2.tree, i = base2.children.indexOf(buffer);
  let buf = base2.children[i], b = buf.buffer, newStack = [i];
  function split(startI, endI, type, innerOffset, length, stackPos) {
    let targetI = stack[stackPos];
    let children = [], positions = [];
    sliceBuf(buf, startI, targetI, children, positions, innerOffset);
    let from = b[targetI + 1], to = b[targetI + 2];
    newStack.push(children.length);
    let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();
    children.push(child);
    positions.push(from - innerOffset);
    sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);
    return new Tree(type, children, positions, length);
  }
  base2.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);
  for (let index of newStack) {
    let tree = cursor2.tree.children[index], pos = cursor2.tree.positions[index];
    cursor2.yield(new TreeNode(tree, pos + cursor2.from, index, cursor2._tree));
  }
}
var StructureCursor = class {
  constructor(root, offset) {
    this.offset = offset;
    this.done = false;
    this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(pos) {
    let { cursor: cursor2 } = this, p = pos - this.offset;
    while (!this.done && cursor2.from < p) {
      if (cursor2.to >= pos && cursor2.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;
      else if (!cursor2.next(false))
        this.done = true;
    }
  }
  hasNode(cursor2) {
    this.moveTo(cursor2.from);
    if (!this.done && this.cursor.from + this.offset == cursor2.from && this.cursor.tree) {
      for (let tree = this.cursor.tree; ; ) {
        if (tree == cursor2.tree)
          return true;
        if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
          tree = tree.children[0];
        else
          break;
      }
    }
    return false;
  }
};
var FragmentCursor = class {
  constructor(fragments) {
    var _a2;
    this.fragments = fragments;
    this.curTo = 0;
    this.fragI = 0;
    if (fragments.length) {
      let first = this.curFrag = fragments[0];
      this.curTo = (_a2 = first.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : first.to;
      this.inner = new StructureCursor(first.tree, -first.offset);
    } else {
      this.curFrag = this.inner = null;
    }
  }
  hasNode(node) {
    while (this.curFrag && node.from >= this.curTo)
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
  }
  nextFrag() {
    var _a2;
    this.fragI++;
    if (this.fragI == this.fragments.length) {
      this.curFrag = this.inner = null;
    } else {
      let frag = this.curFrag = this.fragments[this.fragI];
      this.curTo = (_a2 = frag.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : frag.to;
      this.inner = new StructureCursor(frag.tree, -frag.offset);
    }
  }
  findMounts(pos, parser5) {
    var _a2;
    let result = [];
    if (this.inner) {
      this.inner.cursor.moveTo(pos, 1);
      for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
        let mount = (_a2 = pos2.tree) === null || _a2 === void 0 ? void 0 : _a2.prop(NodeProp.mounted);
        if (mount && mount.parser == parser5) {
          for (let i = this.fragI; i < this.fragments.length; i++) {
            let frag = this.fragments[i];
            if (frag.from >= pos2.to)
              break;
            if (frag.tree == this.curFrag.tree)
              result.push({
                frag,
                pos: pos2.from - frag.offset,
                mount
              });
          }
        }
      }
    }
    return result;
  }
};
function punchRanges(outer, ranges) {
  let copy = null, current = ranges;
  for (let i = 1, j = 0; i < outer.length; i++) {
    let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
    for (; j < current.length; j++) {
      let r = current[j];
      if (r.from >= gapTo)
        break;
      if (r.to <= gapFrom)
        continue;
      if (!copy)
        current = copy = ranges.slice();
      if (r.from < gapFrom) {
        copy[j] = new Range2(r.from, gapFrom);
        if (r.to > gapTo)
          copy.splice(j + 1, 0, new Range2(gapTo, r.to));
      } else if (r.to > gapTo) {
        copy[j--] = new Range2(gapTo, r.to);
      } else {
        copy.splice(j--, 1);
      }
    }
  }
  return current;
}
function findCoverChanges(a, b, from, to) {
  let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
  let result = [];
  for (; ; ) {
    let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
    if (inA != inB) {
      let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
      if (start < end)
        result.push(new Range2(start, end));
    }
    pos = Math.min(nextA, nextB);
    if (pos == 1e9)
      break;
    if (nextA == pos) {
      if (!inA)
        inA = true;
      else {
        inA = false;
        iA++;
      }
    }
    if (nextB == pos) {
      if (!inB)
        inB = true;
      else {
        inB = false;
        iB++;
      }
    }
  }
  return result;
}
function enterFragments(mounts, ranges) {
  let result = [];
  for (let { pos, mount, frag } of mounts) {
    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
    let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
    if (mount.overlay) {
      let overlay = mount.overlay.map((r) => new Range2(r.from + pos, r.to + pos));
      let changes = findCoverChanges(ranges, overlay, from, to);
      for (let i = 0, pos2 = from; ; i++) {
        let last = i == changes.length, end = last ? to : changes[i].from;
        if (end > pos2)
          result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2 || frag.openStart, frag.to <= end || frag.openEnd));
        if (last)
          break;
        pos2 = changes[i].to;
      }
    } else {
      result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
    }
  }
  return result;
}

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class _Tag {
  /**
  @internal
  */
  constructor(name2, set, base2, modified) {
    this.name = name2;
    this.set = set;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let { name: name2 } = this;
    for (let mod of this.modified)
      if (mod.name)
        name2 = `${mod.name}(${name2})`;
    return name2;
  }
  static define(nameOrParent, parent) {
    let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof _Tag)
      parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new _Tag(name2, [], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(name2) {
    let mod = new Modifier(name2);
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class _Modifier {
  constructor(name2) {
    this.name = name2;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(base2.name, set, base2, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config2 of configs)
          set.push(_Modifier.get(parent, config2));
    return tag;
  }
};
function sameArray2(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e = sets.length; j < e; j++) {
      sets.push(sets[j].concat(array[i]));
    }
  }
  return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags3 = spec[prop];
    if (!Array.isArray(tags3))
      tags3 = [tags3];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags3, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp({
  combine(a, b) {
    let cur2, root, take;
    while (a || b) {
      if (!a || b && a.depth >= b.depth) {
        take = b;
        b = b.next;
      } else {
        take = a;
        a = a.next;
      }
      if (cur2 && cur2.mode == take.mode && !take.context && !cur2.context)
        continue;
      let copy = new Rule(take.tags, take.mode, take.context);
      if (cur2)
        cur2.next = copy;
      else
        root = copy;
      cur2 = copy;
    }
    return root;
  }
});
var Rule = class {
  constructor(tags3, mode, context, next) {
    this.tags = tags3;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags3, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags3) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags4) => {
      let cls = all;
      for (let tag of tags4) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags3) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags3);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
  builder.flush(to);
}
var HighlightBuilder = class {
  constructor(at, highlighters, span) {
    this.at = at;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at)
        this.at = at;
      this.class = cls;
    }
  }
  flush(to) {
    if (to > this.at && this.class)
      this.span(this.at, to, this.class);
  }
  highlightRange(cursor2, from, to, inheritedClass, highlighters) {
    let { type, from: start, to: end } = cursor2;
    if (start >= to || end <= from)
      return;
    if (type.isTop)
      highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor2) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls)
        cls += " ";
      cls += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from, start), cls);
    if (rule.opaque)
      return;
    let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
      let hasChild2 = cursor2.firstChild();
      for (let i = 0, pos = start; ; i++) {
        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom2 = Math.max(from, pos), rangeTo2 = Math.min(to, nextPos);
        if (rangeFrom2 < rangeTo2 && hasChild2) {
          while (cursor2.from < rangeTo2) {
            this.highlightRange(cursor2, rangeFrom2, rangeTo2, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo2, cursor2.to), cls);
            if (cursor2.to >= nextPos || !cursor2.nextSibling())
              break;
          }
        }
        if (!next || nextPos > to)
          break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
          this.startSpan(Math.min(to, pos), cls);
        }
      }
      if (hasChild2)
        cursor2.parent();
    } else if (cursor2.firstChild()) {
      if (mounted)
        inheritedClass = "";
      do {
        if (cursor2.to <= from)
          continue;
        if (cursor2.from >= to)
          break;
        this.highlightRange(cursor2, from, to, inheritedClass, highlighters);
        this.startSpan(Math.min(to, cursor2.to), cls);
      } while (cursor2.nextSibling());
      cursor2.parent();
    }
  }
};
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp);
  while (rule && rule.context && !node.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation = t();
var bracket = t(punctuation);
var meta = t();
var tags = {
  /**
  A comment.
  */
  comment,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t(comment),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t(comment),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t(comment),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t(heading),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: t(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t(),
  /**
  Deleted text.
  */
  deleted: t(),
  /**
  Changed text.
  */
  changed: t(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier("special")
};
for (let name2 in tags) {
  let val = tags[name2];
  if (val instanceof Tag)
    val.name = name2;
}
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/@codemirror/language/dist/index.js
var _a;
var languageDataProp = /* @__PURE__ */ new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values2) => values2.concat(baseData) : void 0
  });
}
var sublanguageProp = /* @__PURE__ */ new NodeProp();
var Language = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data2, parser5, extraExtensions = [], name2 = "") {
    this.data = data2;
    this.name = name2;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser5;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => {
        let top2 = topNodeAt(state, pos, side), data3 = top2.type.prop(languageDataProp);
        if (!data3)
          return [];
        let base2 = state.facet(data3), sub = top2.type.prop(sublanguageProp);
        if (sub) {
          let innerNode = top2.resolve(pos - top2.from, side);
          for (let sublang of sub)
            if (sublang.test(innerNode, state)) {
              let data4 = state.facet(sublang.facet);
              return sublang.type == "replace" ? data4 : data4.concat(base2);
            }
        }
        return base2;
      })
    ].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from, to: from + tree.length });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r of mount.overlay)
              result.push({ from: r.from + from, to: r.to + from });
          else
            result.push({ from, to: from + tree.length });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size)
            return;
        }
      }
      for (let i = 0; i < tree.children.length; i++) {
        let ch = tree.children[i];
        if (ch instanceof Tree)
          explore(ch, tree.positions[i] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
Language.setState = /* @__PURE__ */ StateEffect.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers | IterMode.EnterBracketed))
      if (node.type.isTop)
        tree = node;
  }
  return tree;
}
var LRLanguage = class _LRLanguage extends Language {
  constructor(data2, parser5, name2) {
    super(data2, parser5, [], name2);
    this.parser = parser5;
  }
  /**
  Define a language from a parser.
  */
  static define(spec) {
    let data2 = defineLanguageFacet(spec.languageData);
    return new _LRLanguage(data2, spec.parser.configure({
      props: [languageDataProp.add((type) => type.isTop ? data2 : void 0)]
    }), spec.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(options, name2) {
    return new _LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
};
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
var DocInput = class {
  /**
  Create an input object for the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos)
      return this.doc.sliceString(from, to);
    else
      return this.string.slice(from - stringStart, to - stringStart);
  }
};
var currentContext = null;
var ParseContext = class _ParseContext {
  constructor(parser5, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser5;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(parser5, state, viewport) {
    return new _ParseContext(parser5, state, [], Tree.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a2;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (until())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r; r = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r.from, r.to);
    return fragments;
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r of this.skipped) {
          let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
          if (from < to)
            skipped.push({ from, to });
        }
      }
    }
    return new _ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
      return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from, to } = this.skipped[i];
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from, to) {
    this.skipped.push({ from, to });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new class extends Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from, to = ranges[ranges.length - 1].to;
        let parser5 = {
          parsedPos: from,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (let r of ranges)
                cx.tempSkipped.push(r);
              if (until)
                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to;
            return new Tree(NodeType.none, [], [], to - from);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser5;
      }
    }();
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext;
  }
};
function cutFragments(fragments, from, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
var LanguageState = class _LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged && this.tree == this.context.tree)
      return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new _LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new _LanguageState(parseState);
  }
};
Language.state = /* @__PURE__ */ StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(Language.setState))
        return e.value;
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
var requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(
      () => {
        idle = requestIdleCallback(callback, {
          timeout: 500 - 100
          /* Work.MinPause */
        });
      },
      100
      /* Work.MinPause */
    );
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
      this.scheduleWork();
    if (update.docChanged || update.selectionSet) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(
      vpTo + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var language = /* @__PURE__ */ Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: (language2) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language2], (state) => {
      let lang = state.facet(language2);
      return lang && lang.name ? { "data-language": lang.name } : {};
    })
  ]
});
var LanguageSupport = class {
  /**
  Create a language support object.
  */
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
};
var LanguageDescription = class _LanguageDescription {
  constructor(name2, alias, extensions, filename, loadFunc, support = void 0) {
    this.name = name2;
    this.alias = alias;
    this.extensions = extensions;
    this.filename = filename;
    this.loadFunc = loadFunc;
    this.support = support;
    this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((support) => this.support = support, (err) => {
      this.loading = null;
      throw err;
    }));
  }
  /**
  Create a language description.
  */
  static of(spec) {
    let { load, support } = spec;
    if (!load) {
      if (!support)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      load = () => Promise.resolve(support);
    }
    return new _LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s) => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(descs, filename) {
    for (let d of descs)
      if (d.filename && d.filename.test(filename))
        return d;
    let ext = /\.([^.]+)$/.exec(filename);
    if (ext) {
      for (let d of descs)
        if (d.extensions.indexOf(ext[1]) > -1)
          return d;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(descs, name2, fuzzy = true) {
    name2 = name2.toLowerCase();
    for (let d of descs)
      if (d.alias.some((a) => a == name2))
        return d;
    if (fuzzy)
      for (let d of descs)
        for (let a of d.alias) {
          let found = name2.indexOf(a);
          if (found > -1 && (a.length > 2 || !/\w/.test(name2[found - 1]) && !/\w/.test(name2[found + a.length])))
            return d;
        }
    return null;
  }
};
var indentService = /* @__PURE__ */ Facet.define();
var indentUnit = /* @__PURE__ */ Facet.define({
  combine: (values2) => {
    if (!values2.length)
      return "  ";
    let unit = values2[0];
    if (!unit || /\S/.test(unit) || Array.from(unit).some((e) => e != unit[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values2[0]));
    return unit;
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
  if (ch == "	") {
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
    ch = " ";
  }
  for (let i = 0; i < cols; i++)
    result += ch;
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result !== void 0)
      return result;
  }
  let tree = syntaxTree(context.state);
  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
var IndentContext = class {
  /**
  Create an indent context.
  */
  constructor(state, options = {}) {
    this.state = state;
    this.options = options;
    this.unit = getIndentUnit(state);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos);
    let { simulateBreak, simulateDoubleBreak } = this.options;
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (simulateDoubleBreak && simulateBreak == pos)
        return { text: "", from: pos };
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
      else
        return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
    }
    return line;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
      return "";
    let { text, from } = this.lineAt(pos, bias);
    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
  }
  /**
  Find the column for the given position.
  */
  column(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let result = this.countColumn(text, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1)
      result += override - this.countColumn(text, text.search(/\S|$/));
    return result;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(line, pos = line.length) {
    return countColumn(line, this.state.tabSize, pos);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(text, text.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var indentNodeProp = /* @__PURE__ */ new NodeProp();
function syntaxIndentation(cx, ast, pos) {
  let stack = ast.resolveStack(pos);
  let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
  if (inner != stack.node) {
    let add2 = [];
    for (let cur2 = inner; cur2 && !(cur2.from < stack.node.from || cur2.to > stack.node.to || cur2.from == stack.node.from && cur2.type == stack.node.type); cur2 = cur2.parent)
      add2.push(cur2);
    for (let i = add2.length - 1; i >= 0; i--)
      stack = { node: add2[i], next: stack };
  }
  return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
  for (let cur2 = stack; cur2; cur2 = cur2.next) {
    let strategy = indentStrategy(cur2.node);
    if (strategy)
      return strategy(TreeIndentContext.create(cx, pos, cur2));
  }
  return 0;
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
var TreeIndentContext = class _TreeIndentContext extends IndentContext {
  constructor(base2, pos, context) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.context = context;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(base2, pos, context) {
    return new _TreeIndentContext(base2, pos, context);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(node) {
    let line = this.state.doc.lineAt(node.from);
    for (; ; ) {
      let atBreak = node.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, node))
        break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return indentFor(this.context.next, this.base, this.pos);
  }
};
function isParent(parent, of) {
  for (let cur2 = of; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last = tree.lastChild;
  if (!openToken)
    return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd2 = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last)
      return null;
    if (!next.type.isSkipped) {
      if (next.from >= lineEnd2)
        return null;
      let space4 = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
      return { from: openToken.from, to: openToken.to + space4 };
    }
    pos = next.to;
  }
}
function delimitedIndent({ closing: closing2, align = true, units = 1 }) {
  return (context) => delimitedStrategy(context, align, units, closing2);
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after = context.textAfter, space4 = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space4, space4 + closing2.length) == closing2 || closedAt == context.pos + space4;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
var flatIndent = (context) => context.baseIndent;
function continuedIndent({ except, units = 1 } = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
var DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((tr) => {
    if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
      return tr;
    let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
    if (!rules.length)
      return tr;
    let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
    if (head > line.from + DontIndentBeyond)
      return tr;
    let lineStart = doc2.sliceString(line.from, head);
    if (!rules.some((r) => r.test(lineStart)))
      return tr;
    let { state } = tr, last = -1, changes = [];
    for (let { head: head2 } of state.selection.ranges) {
      let line2 = state.doc.lineAt(head2);
      if (line2.from == last)
        continue;
      last = line2.from;
      let indent = getIndentation(state, line2.from);
      if (indent == null)
        continue;
      let cur2 = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent);
      if (cur2 != norm)
        changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
    }
    return changes.length ? [tr, { changes, sequential: true }] : tr;
  });
}
var foldService = /* @__PURE__ */ Facet.define();
var foldNodeProp = /* @__PURE__ */ new NodeProp();
function foldInside(node) {
  let first = node.firstChild, last = node.lastChild;
  return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}
function syntaxFolding(state, start, end) {
  let tree = syntaxTree(state);
  if (tree.length < end)
    return null;
  let stack = tree.resolveStack(end, 1);
  let found = null;
  for (let iter = stack; iter; iter = iter.next) {
    let cur2 = iter.node;
    if (cur2.to <= end || cur2.from > end)
      continue;
    if (found && cur2.from < start)
      break;
    let prop = cur2.type.prop(foldNodeProp);
    if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
      let value = prop(cur2, state);
      if (value && value.from <= end && value.from >= start && value.to > end)
        found = value;
    }
  }
  return found;
}
function isUnfinished(node) {
  let ch = node.lastChild;
  return ch && ch.to == node.to && ch.type.isError;
}
function foldable(state, lineStart, lineEnd2) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd2);
    if (result)
      return result;
  }
  return syntaxFolding(state, lineStart, lineEnd2);
}
function mapRange(range, mapping) {
  let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
  return from >= to ? void 0 : { from, to };
}
var foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
var unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
function selectedLines(view) {
  let lines = [];
  for (let { head } of view.state.selection.ranges) {
    if (lines.some((l) => l.from <= head && l.to >= head))
      continue;
    lines.push(view.lineBlockAt(head));
  }
  return lines;
}
var foldState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr) {
    if (tr.isUserEvent("delete"))
      tr.changes.iterChangedRanges((fromA, toA) => folded = clearTouchedFolds(folded, fromA, toA));
    folded = folded.map(tr.changes);
    for (let e of tr.effects) {
      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
        let { preparePlaceholder } = tr.state.facet(foldConfig);
        let widget = !preparePlaceholder ? foldWidget : Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });
        folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });
      } else if (e.is(unfoldEffect)) {
        folded = folded.update({
          filter: (from, to) => e.value.from != from || e.value.to != to,
          filterFrom: e.value.from,
          filterTo: e.value.to
        });
      }
    }
    if (tr.selection)
      folded = clearTouchedFolds(folded, tr.selection.main.head);
    return folded;
  },
  provide: (f) => EditorView.decorations.from(f),
  toJSON(folded, state) {
    let ranges = [];
    folded.between(0, state.doc.length, (from, to) => {
      ranges.push(from, to);
    });
    return ranges;
  },
  fromJSON(value) {
    if (!Array.isArray(value) || value.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let ranges = [];
    for (let i = 0; i < value.length; ) {
      let from = value[i++], to = value[i++];
      if (typeof from != "number" || typeof to != "number")
        throw new RangeError("Invalid JSON for fold state");
      ranges.push(foldWidget.range(from, to));
    }
    return Decoration.set(ranges, true);
  }
});
function clearTouchedFolds(folded, from, to = from) {
  let touched = false;
  folded.between(from, to, (a, b) => {
    if (a < to && b > from)
      touched = true;
  });
  return !touched ? folded : folded.update({
    filterFrom: from,
    filterTo: to,
    filter: (a, b) => a >= to || b <= from
  });
}
function findFold(state, from, to) {
  var _a2;
  let found = null;
  (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to, (from2, to2) => {
    if (!found || found.from > from2)
      found = { from: from2, to: to2 };
  });
  return found;
}
function foldExists(folded, from, to) {
  let found = false;
  folded.between(from, from, (a, b) => {
    if (a == from && b == to)
      found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
var foldCode = (view) => {
  for (let line of selectedLines(view)) {
    let range = foldable(view.state, line.from, line.to);
    if (range) {
      view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
      return true;
    }
  }
  return false;
};
var unfoldCode = (view) => {
  if (!view.state.field(foldState, false))
    return false;
  let effects = [];
  for (let line of selectedLines(view)) {
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }
  if (effects.length)
    view.dispatch({ effects });
  return effects.length > 0;
};
function announceFold(view, range, fold = true) {
  let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
var foldAll = (view) => {
  let { state } = view, effects = [];
  for (let pos = 0; pos < state.doc.length; ) {
    let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
    if (range)
      effects.push(foldEffect.of(range));
    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
  }
  if (effects.length)
    view.dispatch({ effects: maybeEnable(view.state, effects) });
  return !!effects.length;
};
var unfoldAll = (view) => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size)
    return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from, to) => {
    effects.push(unfoldEffect.of({ from, to }));
  });
  view.dispatch({ effects });
  return true;
};
var defaultConfig = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "\u2026"
};
var foldConfig = /* @__PURE__ */ Facet.define({
  combine(values2) {
    return combineConfig(values2, defaultConfig);
  }
});
function codeFolding(config2) {
  let result = [foldState, baseTheme$12];
  if (config2)
    result.push(foldConfig.of(config2));
  return result;
}
function widgetToDOM(view, prepared) {
  let { state } = view, conf = state.facet(foldConfig);
  let onclick = (event) => {
    let line = view.lineBlockAt(view.posAtDOM(event.target));
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      view.dispatch({ effects: unfoldEffect.of(folded) });
    event.preventDefault();
  };
  if (conf.placeholderDOM)
    return conf.placeholderDOM(view, onclick, prepared);
  let element = document.createElement("span");
  element.textContent = conf.placeholderText;
  element.setAttribute("aria-label", state.phrase("folded code"));
  element.title = state.phrase("unfold");
  element.className = "cm-foldPlaceholder";
  element.onclick = onclick;
  return element;
}
var foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM(view) {
    return widgetToDOM(view, null);
  }
}() });
var PreparedFoldWidget = class extends WidgetType {
  constructor(value) {
    super();
    this.value = value;
  }
  eq(other) {
    return this.value == other.value;
  }
  toDOM(view) {
    return widgetToDOM(view, this.value);
  }
};
var foldGutterDefaults = {
  openText: "\u2304",
  closedText: "\u203A",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
var FoldMarker = class extends GutterMarker {
  constructor(config2, open) {
    super();
    this.config = config2;
    this.open = open;
  }
  eq(other) {
    return this.config == other.config && this.open == other.open;
  }
  toDOM(view) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let span = document.createElement("span");
    span.textContent = this.open ? this.config.openText : this.config.closedText;
    span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
    return span;
  }
};
function foldGutter(config2 = {}) {
  let fullConfig = { ...foldGutterDefaults, ...config2 };
  let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
  let markers = ViewPlugin.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
        this.markers = this.buildMarkers(update.view);
    }
    buildMarkers(view) {
      let builder = new RangeSetBuilder();
      for (let line of view.viewportLineBlocks) {
        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
        if (mark)
          builder.add(line.from, line.from, mark);
      }
      return builder.finish();
    }
  });
  let { domEventHandlers } = fullConfig;
  return [
    markers,
    gutter({
      class: "cm-foldGutter",
      markers(view) {
        var _a2;
        return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
      },
      initialSpacer() {
        return new FoldMarker(fullConfig, false);
      },
      domEventHandlers: {
        ...domEventHandlers,
        click: (view, line, event) => {
          if (domEventHandlers.click && domEventHandlers.click(view, line, event))
            return true;
          let folded = findFold(view.state, line.from, line.to);
          if (folded) {
            view.dispatch({ effects: unfoldEffect.of(folded) });
            return true;
          }
          let range = foldable(view.state, line.from, line.to);
          if (range) {
            view.dispatch({ effects: foldEffect.of(range) });
            return true;
          }
          return false;
        }
      }
    }),
    codeFolding()
  ];
}
var baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var HighlightStyle = class _HighlightStyle {
  constructor(specs, options) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
    const scopeOpt = options.scope;
    this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style) => ({
      tag: style.tag,
      class: style.class || def(Object.assign({}, style, { tag: null }))
    })), {
      all
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options) {
    return new _HighlightStyle(specs, options || {});
  }
};
var highlighterFacet = /* @__PURE__ */ Facet.define();
var fallbackHighlighter = /* @__PURE__ */ Facet.define({
  combine(values2) {
    return values2.length ? [values2[0]] : null;
  }
});
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module)
      ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options === null || options === void 0 ? void 0 : options.fallback)
    ext.push(fallbackHighlighter.of(highlighter));
  else if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter));
  return ext;
}
var TreeHighlighter = class {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
    this.decoratedTo = view.viewport.to;
  }
  update(update) {
    let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
    if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
      this.decorations = this.decorations.map(update.changes);
      this.decoratedTo = decoratedToMapped;
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
      this.decoratedTo = viewport.to;
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from, to } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from2, to2, style) => {
        builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
      }, from, to);
    }
    return builder.finish();
  }
};
var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags.meta,
    color: "#404740"
  },
  {
    tag: tags.link,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.keyword,
    color: "#708"
  },
  {
    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
    color: "#219"
  },
  {
    tag: [tags.literal, tags.inserted],
    color: "#164"
  },
  {
    tag: [tags.string, tags.deleted],
    color: "#a11"
  },
  {
    tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ tags.local(tags.variableName),
    color: "#30a"
  },
  {
    tag: [tags.typeName, tags.namespace],
    color: "#085"
  },
  {
    tag: tags.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.propertyName),
    color: "#00c"
  },
  {
    tag: tags.comment,
    color: "#940"
  },
  {
    tag: tags.invalid,
    color: "#f00"
  }
]);
var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
var DefaultScanDist = 1e4;
var DefaultBrackets = "()[]{}";
var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist,
      renderMatch: defaultRenderMatch
    });
  }
});
var matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" });
var nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match) {
  let decorations2 = [];
  let mark = match.matched ? matchingMark : nonmatchingMark;
  decorations2.push(mark.range(match.start.from, match.start.to));
  if (match.end)
    decorations2.push(mark.range(match.end.from, match.end.to));
  return decorations2;
}
var bracketMatchingState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(deco, tr) {
    if (!tr.docChanged && !tr.selection)
      return deco;
    let decorations2 = [];
    let config2 = tr.state.facet(bracketMatchingConfig);
    for (let range of tr.state.selection.ranges) {
      if (!range.empty)
        continue;
      let match = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
      if (match)
        decorations2 = decorations2.concat(config2.renderMatch(match, tr.state));
    }
    return Decoration.set(decorations2, true);
  },
  provide: (f) => EditorView.decorations.from(f)
});
var bracketMatchingUnique = [
  bracketMatchingState,
  baseTheme2
];
function bracketMatching(config2 = {}) {
  return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
}
var bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node.name.length == 1) {
    let index = brackets.indexOf(node.name);
    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index + dir]];
  }
  return null;
}
function findHandle(node) {
  let hasHandle = node.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node.node) : node;
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
  let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    let matches = matchingNodes(cur2.type, dir, brackets);
    if (matches && cur2.from < cur2.to) {
      let handle = findHandle(cur2);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
        return matchMarkedBrackets(state, pos, dir, cur2, handle, matches, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
  let depth = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor2 && (dir < 0 ? cursor2.childBefore(token.from) : cursor2.childAfter(token.to)))
    do {
      if (dir < 0 ? cursor2.to <= token.from : cursor2.from >= token.to) {
        if (depth == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
          let endHandle = findHandle(cursor2);
          return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
        } else if (matchingNodes(cursor2.type, dir, brackets)) {
          depth++;
        } else if (matchingNodes(cursor2.type, -dir, brackets)) {
          if (depth == 0) {
            let endHandle = findHandle(cursor2);
            return {
              start: firstToken,
              end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
              matched: false
            };
          }
          depth--;
        }
      }
    } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text = iter.value;
    if (dir < 0)
      distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text[pos2]);
      if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth++;
      } else if (depth == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth--;
      }
    }
    if (dir > 0)
      distance += text.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
var noTokens = /* @__PURE__ */ Object.create(null);
var typeArray = [NodeType.none];
var warned = [];
var byTag = /* @__PURE__ */ Object.create(null);
var defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name2] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tags$1 = [];
  for (let name3 of tagStr.split(" ")) {
    let found = [];
    for (let part of name3.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!found.length)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          found = found.map(value);
      } else {
        if (found.length)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          found = Array.isArray(value) ? value : [value];
      }
    }
    for (let tag of found)
      tags$1.push(tag);
  }
  if (!tags$1.length)
    return 0;
  let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t2) => t2.id);
  let known = byTag[key];
  if (known)
    return known.id;
  let type = byTag[key] = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tags$1 })]
  });
  typeArray.push(type);
  return type.id;
}
var marks = {
  rtl: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
  ltr: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR }),
  auto: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
};

// node_modules/@codemirror/autocomplete/dist/index.js
var CompletionContext = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(state, pos, explicit, view) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.view = view;
    this.abortListeners = [];
    this.abortOnDocChange = false;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types2) {
    let token = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token && types2.indexOf(token.name) < 0)
      token = token.parent;
    return token ? {
      from: token.from,
      to: this.pos,
      text: this.state.sliceDoc(token.from, this.pos),
      type: token.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(type, listener, options) {
    if (type == "abort" && this.abortListeners) {
      this.abortListeners.push(listener);
      if (options && options.onDocChange)
        this.abortOnDocChange = true;
    }
  }
};
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options) {
    first[label[0]] = true;
    for (let i = 1; i < label.length; i++)
      rest[label[i]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options = list.map((o) => typeof o == "string" ? { label: o } : o);
  let [validFor, match] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return (context) => {
    let token = context.matchBefore(match);
    return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
  };
}
function ifNotIn(nodes, source) {
  return (context) => {
    for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
      if (nodes.indexOf(pos.name) > -1)
        return null;
      if (pos.type.isTop)
        break;
    }
    return source(context);
  };
}
var Option = class {
  constructor(completion, source, match, score2) {
    this.completion = completion;
    this.source = source;
    this.match = match;
    this.score = score2;
  }
};
function cur(state) {
  return state.selection.main.from;
}
function ensureAnchor(expr, start) {
  var _a2;
  let { source } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
}
var pickedCompletion = /* @__PURE__ */ Annotation.define();
function insertCompletionText(state, text, from, to) {
  let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;
  return {
    ...state.changeByRange((range) => {
      if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))
        return { range };
      let lines = state.toText(text);
      return {
        changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },
        range: EditorSelection.cursor(range.from + fromOff + lines.length)
      };
    }),
    scrollIntoView: true,
    userEvent: "input.complete"
  };
}
var SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
var FuzzyMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    this.score = 0;
    this.matched = [];
    for (let p = 0; p < pattern.length; ) {
      let char = codePointAt2(pattern, p), size = codePointSize2(char);
      this.chars.push(char);
      let part = pattern.slice(p, p + size), upper = part.toUpperCase();
      this.folded.push(codePointAt2(upper == part ? part.toLowerCase() : upper, 0));
      p += size;
    }
    this.astral = pattern.length != this.chars.length;
  }
  ret(score2, matched) {
    this.score = score2;
    this.matched = matched;
    return this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (word.length < this.pattern.length)
      return null;
    let { chars, folded, any, precise, byWord } = this;
    if (chars.length == 1) {
      let first = codePointAt2(word, 0), firstSize = codePointSize2(first);
      let score2 = firstSize == word.length ? 0 : -100;
      if (first == chars[0]) ;
      else if (first == folded[0])
        score2 += -200;
      else
        return null;
      return this.ret(score2, [0, firstSize]);
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
        let next = codePointAt2(word, i);
        if (next == chars[anyTo] || next == folded[anyTo])
          any[anyTo++] = i;
        i += codePointSize2(next);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
      let next = codePointAt2(word, i);
      if (direct < 0) {
        if (preciseTo < len && next == chars[preciseTo])
          precise[preciseTo++] = i;
        if (adjacentTo < len) {
          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i;
            adjacentEnd = i + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
        if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
          byWord[byWordTo++] = i;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type;
      i += codePointSize2(next);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
    if (direct > -1)
      return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
    if (adjacentTo == len)
      return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result = [], i = 0;
    for (let pos of positions) {
      let to = pos + (this.astral ? codePointSize2(codePointAt2(word, pos)) : 1);
      if (i && result[i - 1] == pos)
        result[i - 1] = to;
      else {
        result[i++] = pos;
        result[i++] = to;
      }
    }
    return this.ret(score2 - word.length, result);
  }
};
var StrictMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.matched = [];
    this.score = 0;
    this.folded = pattern.toLowerCase();
  }
  match(word) {
    if (word.length < this.pattern.length)
      return null;
    let start = word.slice(0, this.pattern.length);
    let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
    if (match == null)
      return null;
    this.matched = [0, start.length];
    this.score = match + (word.length == this.pattern.length ? 0 : -100);
    return this;
  }
};
var completionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      activateOnCompletion: () => false,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: defaultPositionInfo,
      filterStrict: false,
      compareCompletions: (a, b) => (a.sortText || a.label).localeCompare(b.sortText || b.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (a, b) => a && b,
      closeOnBlur: (a, b) => a && b,
      icons: (a, b) => a && b,
      tooltipClass: (a, b) => (c) => joinClass(a(c), b(c)),
      optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
      addToOptions: (a, b) => a.concat(b),
      filterStrict: (a, b) => a || b
    });
  }
});
function joinClass(a, b) {
  return a ? b ? a + " " + b : a : b;
}
function defaultPositionInfo(view, list, option, info, space4, tooltip) {
  let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
  let side = "top", offset, maxWidth;
  let spaceLeft = list.left - space4.left, spaceRight = space4.right - list.right;
  let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
  if (left && spaceLeft < Math.min(infoWidth, spaceRight))
    left = false;
  else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
    left = true;
  if (infoWidth <= (left ? spaceLeft : spaceRight)) {
    offset = Math.max(space4.top, Math.min(option.top, space4.bottom - infoHeight)) - list.top;
    maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
  } else {
    narrow = true;
    maxWidth = Math.min(
      400,
      (rtl ? list.right : space4.right - list.left) - 30
      /* Info.Margin */
    );
    let spaceBelow = space4.bottom - list.bottom;
    if (spaceBelow >= infoHeight || spaceBelow > list.top) {
      offset = option.bottom - list.top;
    } else {
      side = "bottom";
      offset = list.bottom - option.top;
    }
  }
  let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
  let scaleX = (list.right - list.left) / tooltip.offsetWidth;
  return {
    style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
  };
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice();
  if (config2.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s, _v, match) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let label = completion.displayLabel || completion.label, off = 0;
      for (let j = 0; j < match.length; ) {
        let from = match[j++], to = match[j++];
        if (from > off)
          labelElt.appendChild(document.createTextNode(label.slice(off, from)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from, to)));
        span.className = "cm-completionMatchedText";
        off = to;
      }
      if (off < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max);
    return { from: off2 * max, to: (off2 + 1) * max };
  }
  let off = Math.floor((total - selected) / max);
  return { from: total - (off + 1) * max, to: total - off * max };
}
var CompletionTooltip = class {
  constructor(view, stateField, applyCompletion2) {
    this.view = view;
    this.stateField = stateField;
    this.applyCompletion = applyCompletion2;
    this.info = null;
    this.infoDestroy = null;
    this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (pos) => this.placeInfo(pos),
      key: this
    };
    this.space = null;
    this.currentClass = "";
    let cState = view.state.field(stateField);
    let { options, selected } = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config2);
    this.optionClass = config2.optionClass;
    this.tooltipClass = config2.tooltipClass;
    this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.updateTooltipClass(view.state);
    this.dom.addEventListener("mousedown", (e) => {
      let { options: options2 } = view.state.field(stateField).open;
      for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options2.length) {
          this.applyCompletion(view, options2[+match[1]]);
          e.preventDefault();
          return;
        }
      }
    });
    this.dom.addEventListener("focusout", (e) => {
      let state = view.state.field(this.stateField, false);
      if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM)
        view.dispatch({ effects: closeCompletionEffect.of(null) });
    });
    this.showOptions(options, cState.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(options, id2) {
    if (this.list)
      this.list.remove();
    this.list = this.dom.appendChild(this.createListBox(options, id2, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(update) {
    var _a2;
    let cState = update.state.field(this.stateField);
    let prevState = update.startState.field(this.stateField);
    this.updateTooltipClass(update.state);
    if (cState != prevState) {
      let { options, selected, disabled } = cState.open;
      if (!prevState.open || prevState.open.options != options) {
        this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(options, cState.id);
      }
      this.updateSel();
      if (disabled != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled))
        this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
    }
  }
  updateTooltipClass(state) {
    let cls = this.tooltipClass(state);
    if (cls != this.currentClass) {
      for (let c of this.currentClass.split(" "))
        if (c)
          this.dom.classList.remove(c);
      for (let c of cls.split(" "))
        if (c)
          this.dom.classList.add(c);
      this.currentClass = cls;
    }
  }
  positioned(space4) {
    this.space = space4;
    if (this.info)
      this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.showOptions(open.options, cState.id);
    }
    let newSel = this.updateSelectedOption(open.selected);
    if (newSel) {
      this.destroyInfo();
      let { completion } = open.options[open.selected];
      let { info } = completion;
      if (!info)
        return;
      let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
      if (!infoResult)
        return;
      if ("then" in infoResult) {
        infoResult.then((obj) => {
          if (obj && this.view.state.field(this.stateField, false) == cState)
            this.addInfoPane(obj, completion);
        }).catch((e) => logException(this.view.state, e, "completion info"));
      } else {
        this.addInfoPane(infoResult, completion);
        newSel.setAttribute("aria-describedby", this.info.id);
      }
    }
  }
  addInfoPane(content2, completion) {
    this.destroyInfo();
    let wrap = this.info = document.createElement("div");
    wrap.className = "cm-tooltip cm-completionInfo";
    wrap.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16);
    if (content2.nodeType != null) {
      wrap.appendChild(content2);
      this.infoDestroy = null;
    } else {
      let { dom, destroy } = content2;
      wrap.appendChild(dom);
      this.infoDestroy = destroy || null;
    }
    this.dom.appendChild(wrap);
    this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(selected) {
    let set = null;
    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
      if (opt.nodeName != "LI" || !opt.id) {
        i--;
      } else if (i == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected")) {
          opt.removeAttribute("aria-selected");
          opt.removeAttribute("aria-describedby");
        }
      }
    }
    if (set)
      scrollIntoView2(this.list, set);
    return set;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    let space4 = this.space;
    if (!space4) {
      let docElt = this.dom.ownerDocument.documentElement;
      space4 = { left: 0, top: 0, right: docElt.clientWidth, bottom: docElt.clientHeight };
    }
    if (selRect.top > Math.min(space4.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space4.top, listRect.top) + 10)
      return null;
    return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space4, this.dom);
  }
  placeInfo(pos) {
    if (this.info) {
      if (pos) {
        if (pos.style)
          this.info.style.cssText = pos.style;
        this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
      } else {
        this.info.style.cssText = "top: -1e6px";
      }
    }
  }
  createListBox(options, id2, range) {
    const ul = document.createElement("ul");
    ul.id = id2;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
    ul.addEventListener("mousedown", (e) => {
      if (e.target == ul)
        e.preventDefault();
    });
    let curSection = null;
    for (let i = range.from; i < range.to; i++) {
      let { completion, match } = options[i], { section } = completion;
      if (section) {
        let name2 = typeof section == "string" ? section : section.name;
        if (name2 != curSection && (i > range.from || range.from == 0)) {
          curSection = name2;
          if (typeof section != "string" && section.header) {
            ul.appendChild(section.header(section));
          } else {
            let header = ul.appendChild(document.createElement("completion-section"));
            header.textContent = name2;
          }
        }
      }
      const li = ul.appendChild(document.createElement("li"));
      li.id = id2 + "-" + i;
      li.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls)
        li.className = cls;
      for (let source of this.optionContent) {
        let node = source(completion, this.view.state, this.view, match);
        if (node)
          li.appendChild(node);
      }
    }
    if (range.from)
      ul.classList.add("cm-completionListIncompleteTop");
    if (range.to < options.length)
      ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }
  destroyInfo() {
    if (this.info) {
      if (this.infoDestroy)
        this.infoDestroy();
      this.info.remove();
      this.info = null;
    }
  }
  destroy() {
    this.destroyInfo();
  }
};
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
}
function scrollIntoView2(container, element) {
  let parent = container.getBoundingClientRect();
  let self = element.getBoundingClientRect();
  let scaleY = parent.height / container.offsetHeight;
  if (self.top < parent.top)
    container.scrollTop -= (parent.top - self.top) / scaleY;
  else if (self.bottom > parent.bottom)
    container.scrollTop += (self.bottom - parent.bottom) / scaleY;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options = [];
  let sections = null, dynamicSectionScore = null;
  let addOption = (option) => {
    options.push(option);
    let { section } = option.completion;
    if (section) {
      if (!sections)
        sections = [];
      let name2 = typeof section == "string" ? section : section.name;
      if (!sections.some((s) => s.name == name2))
        sections.push(typeof section == "string" ? { name: name2 } : section);
    }
  };
  let conf = state.facet(completionConfig);
  for (let a of active)
    if (a.hasResult()) {
      let getMatch = a.result.getMatch;
      if (a.result.filter === false) {
        for (let option of a.result.options) {
          addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
        }
      } else {
        let pattern = state.sliceDoc(a.from, a.to), match;
        let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
        for (let option of a.result.options)
          if (match = matcher.match(option.label)) {
            let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];
            let score2 = match.score + (option.boost || 0);
            addOption(new Option(option, a.source, matched, score2));
            if (typeof option.section == "object" && option.section.rank === "dynamic") {
              let { name: name2 } = option.section;
              if (!dynamicSectionScore)
                dynamicSectionScore = /* @__PURE__ */ Object.create(null);
              dynamicSectionScore[name2] = Math.max(score2, dynamicSectionScore[name2] || -1e9);
            }
          }
      }
    }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
    let cmp = (a, b) => {
      return (a.rank === "dynamic" && b.rank === "dynamic" ? dynamicSectionScore[b.name] - dynamicSectionScore[a.name] : 0) || (typeof a.rank == "number" ? a.rank : 1e9) - (typeof b.rank == "number" ? b.rank : 1e9) || (a.name < b.name ? -1 : 1);
    };
    for (let s of sections.sort(cmp)) {
      pos -= 1e5;
      sectionOrder[s.name] = pos;
    }
    for (let option of options) {
      let { section } = option.completion;
      if (section)
        option.score += sectionOrder[typeof section == "string" ? section : section.name];
    }
  }
  let result = [], prev = null;
  let compare2 = conf.compareCompletions;
  for (let opt of options.sort((a, b) => b.score - a.score || compare2(a.completion, b.completion))) {
    let cur2 = opt.completion;
    if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost)
      result.push(opt);
    else if (score(opt.completion) > score(prev))
      result[result.length - 1] = opt;
    prev = opt.completion;
  }
  return result;
}
var CompletionDialog = class _CompletionDialog {
  constructor(options, attrs, tooltip, timestamp, selected, disabled) {
    this.options = options;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
    this.disabled = disabled;
  }
  setSelected(selected, id2) {
    return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected, this.disabled);
  }
  static build(active, state, id2, prev, conf, didSetActive) {
    if (prev && !didSetActive && active.some((s) => s.isPending))
      return prev.setDisabled();
    let options = sortOptions(active, state);
    if (!options.length)
      return prev && active.some((a) => a.isPending) ? prev.setDisabled() : null;
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev && prev.selected != selected && prev.selected != -1) {
      let selectedValue = prev.options[prev.selected].completion;
      for (let i = 0; i < options.length; i++)
        if (options[i].completion == selectedValue) {
          selected = i;
          break;
        }
    }
    return new _CompletionDialog(options, makeAttrs(id2, selected), {
      pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
      create: createTooltip,
      above: conf.aboveCursor
    }, prev ? prev.timestamp : Date.now(), selected, false);
  }
  map(changes) {
    return new _CompletionDialog(this.options, this.attrs, { ...this.tooltip, pos: changes.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new _CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
  }
};
var CompletionState = class _CompletionState {
  constructor(active, id2, open) {
    this.active = active;
    this.id = id2;
    this.open = open;
  }
  static start() {
    return new _CompletionState(none2, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr) {
    let { state } = tr, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s) => s.source == source) || new ActiveSource(
        source,
        this.active.some(
          (a) => a.state != 0
          /* State.Inactive */
        ) ? 1 : 0
        /* State.Inactive */
      );
      return value.update(tr, conf);
    });
    if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
      active = this.active;
    let open = this.open, didSet = tr.effects.some((e) => e.is(setActiveEffect));
    if (open && tr.docChanged)
      open = open.map(tr.changes);
    if (tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) || didSet)
      open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
    else if (open && open.disabled && !active.some((a) => a.isPending))
      open = null;
    if (!open && active.every((a) => !a.isPending) && active.some((a) => a.hasResult()))
      active = active.map((a) => a.hasResult() ? new ActiveSource(
        a.source,
        0
        /* State.Inactive */
      ) : a);
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs2;
  }
};
function sameResults(a, b) {
  if (a == b)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a.length && !a[iA].hasResult())
      iA++;
    while (iB < b.length && !b[iB].hasResult())
      iB++;
    let endA = iA == a.length, endB = iB == b.length;
    if (endA || endB)
      return endA == endB;
    if (a[iA++].result != b[iB++].result)
      return false;
  }
}
var baseAttrs = {
  "aria-autocomplete": "list"
};
var noAttrs2 = {};
function makeAttrs(id2, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id2
  };
  if (selected > -1)
    result["aria-activedescendant"] = id2 + "-" + selected;
  return result;
}
var none2 = [];
function getUpdateType(tr, conf) {
  if (tr.isUserEvent("input.complete")) {
    let completion = tr.annotation(pickedCompletion);
    if (completion && conf.activateOnCompletion(completion))
      return 4 | 8;
  }
  let typing = tr.isUserEvent("input.type");
  return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
}
var ActiveSource = class _ActiveSource {
  constructor(source, state, explicit = false) {
    this.source = source;
    this.state = state;
    this.explicit = explicit;
  }
  hasResult() {
    return false;
  }
  get isPending() {
    return this.state == 1;
  }
  update(tr, conf) {
    let type = getUpdateType(tr, conf), value = this;
    if (type & 8 || type & 16 && this.touches(tr))
      value = new _ActiveSource(
        value.source,
        0
        /* State.Inactive */
      );
    if (type & 4 && value.state == 0)
      value = new _ActiveSource(
        this.source,
        1
        /* State.Pending */
      );
    value = value.updateFor(tr, type);
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect))
        value = new _ActiveSource(value.source, 1, effect.value);
      else if (effect.is(closeCompletionEffect))
        value = new _ActiveSource(
          value.source,
          0
          /* State.Inactive */
        );
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  updateFor(tr, type) {
    return this.map(tr.changes);
  }
  map(changes) {
    return this;
  }
  touches(tr) {
    return tr.changes.touchesRange(cur(tr.state));
  }
};
var ActiveResult = class _ActiveResult extends ActiveSource {
  constructor(source, explicit, limit, result, from, to) {
    super(source, 3, explicit);
    this.limit = limit;
    this.result = result;
    this.from = from;
    this.to = to;
  }
  hasResult() {
    return true;
  }
  updateFor(tr, type) {
    var _a2;
    if (!(type & 3))
      return this.map(tr.changes);
    let result = this.result;
    if (result.map && !tr.changes.empty)
      result = result.map(result, tr.changes);
    let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if (pos > to || !result || type & 2 && (cur(tr.startState) == this.from || pos < this.limit))
      return new ActiveSource(
        this.source,
        type & 4 ? 1 : 0
        /* State.Inactive */
      );
    let limit = tr.changes.mapPos(this.limit);
    if (checkValid(result.validFor, tr.state, from, to))
      return new _ActiveResult(this.source, this.explicit, limit, result, from, to);
    if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false))))
      return new _ActiveResult(this.source, this.explicit, limit, result, result.from, (_a2 = result.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
    return new ActiveSource(this.source, 1, this.explicit);
  }
  map(mapping) {
    if (mapping.empty)
      return this;
    let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
    if (!result)
      return new ActiveSource(
        this.source,
        0
        /* State.Inactive */
      );
    return new _ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
  touches(tr) {
    return tr.changes.touchesRange(this.from, this.to);
  }
};
function checkValid(validFor, state, from, to) {
  if (!validFor)
    return false;
  let text = state.sliceDoc(from, to);
  return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
}
var setActiveEffect = /* @__PURE__ */ StateEffect.define({
  map(sources, mapping) {
    return sources.map((s) => s.map(mapping));
  }
});
var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
var completionState = /* @__PURE__ */ StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr) {
    return value.update(tr);
  },
  provide: (f) => [
    showTooltip.from(f, (val) => val.tooltip),
    EditorView.contentAttributes.from(f, (state) => state.attrs)
  ]
});
function applyCompletion(view, option) {
  const apply = option.completion.apply || option.completion.label;
  let result = view.state.field(completionState).active.find((a) => a.source == option.source);
  if (!(result instanceof ActiveResult))
    return false;
  if (typeof apply == "string")
    view.dispatch({
      ...insertCompletionText(view.state, apply, result.from, result.to),
      annotations: pickedCompletion.of(option.completion)
    });
  else
    apply(view, option.completion, result.from, result.to);
  return true;
}
var createTooltip = /* @__PURE__ */ completionTooltip(completionState, applyCompletion);
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
      step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let { length } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
    if (selected < 0)
      selected = by == "page" ? 0 : length - 1;
    else if (selected >= length)
      selected = by == "page" ? length - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
var acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
    return false;
  return applyCompletion(view, cState.open.options[cState.open.selected]);
};
var startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({ effects: startCompletionEffect.of(true) });
  return true;
};
var closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(
    (a) => a.state != 0
    /* State.Inactive */
  ))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
var RunningQuery = class {
  constructor(active, context) {
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
};
var MaxUpdateCount = 50;
var MinAbortTime = 1e3;
var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.pendingStart = false;
    this.composing = 0;
    for (let active of view.state.field(completionState).active)
      if (active.isPending)
        this.startQuery(active);
  }
  update(update) {
    let cState = update.state.field(completionState);
    let conf = update.state.facet(completionConfig);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
      return;
    let doesReset = update.transactions.some((tr) => {
      let type = getUpdateType(tr, conf);
      return type & 8 || (tr.selection || tr.docChanged) && !(type & 3);
    });
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (doesReset || query.context.abortOnDocChange && update.docChanged || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e) {
            logException(this.view.state, e);
          }
        }
        query.context.abortListeners = null;
        this.running.splice(i--, 1);
      } else {
        query.updates.push(...update.transactions);
      }
    }
    if (this.debounceUpdate > -1)
      clearTimeout(this.debounceUpdate);
    if (update.transactions.some((tr) => tr.effects.some((e) => e.is(startCompletionEffect))))
      this.pendingStart = true;
    let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;
    this.debounceUpdate = cState.active.some((a) => a.isPending && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), delay) : -1;
    if (this.composing != 0)
      for (let tr of update.transactions) {
        if (tr.isUserEvent("input.type"))
          this.composing = 2;
        else if (this.composing == 2 && tr.selection)
          this.composing = 3;
      }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    this.pendingStart = false;
    let { state } = this.view, cState = state.field(completionState);
    for (let active of cState.active) {
      if (active.isPending && !this.running.some((r) => r.active.source == active.source))
        this.startQuery(active);
    }
    if (this.running.length && cState.open && cState.open.disabled)
      this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  startQuery(active) {
    let { state } = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicit, this.view);
    let pending = new RunningQuery(active, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then((result) => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q) => q.done !== void 0))
      this.accept();
    else if (this.debounceAccept < 0)
      this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var _a2;
    if (this.debounceAccept > -1)
      clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (query.done === void 0)
        continue;
      this.running.splice(i--, 1);
      if (query.done) {
        let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);
        let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));
        let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : pos);
        for (let tr of query.updates)
          active = active.update(tr, conf);
        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }
      let current = cState.active.find((a) => a.source == query.active.source);
      if (current && current.isPending) {
        if (query.done == null) {
          let active = new ActiveSource(
            query.active.source,
            0
            /* State.Inactive */
          );
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (!active.isPending)
            updated.push(active);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length || cState.open && cState.open.disabled)
      this.view.dispatch({ effects: setActiveEffect.of(updated) });
  }
}, {
  eventHandlers: {
    blur(event) {
      let state = this.view.state.field(completionState, false);
      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
        let dialog = state.open && getTooltip(this.view, state.open.tooltip);
        if (!dialog || !dialog.dom.contains(event.relatedTarget))
          setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
      }
      this.composing = 0;
    }
  }
});
var windows = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform);
var commitCharacters = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event, view) {
    let field = view.state.field(completionState, false);
    if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey)
      return false;
    let option = field.open.options[field.open.selected];
    let result = field.active.find((a) => a.source == option.source);
    let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
    if (commitChars && commitChars.indexOf(event.key) > -1)
      applyCompletion(view, option);
    return false;
  }
}));
var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'\u0192'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'\u25CB'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'\u25CC'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'\u{1D465}'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'\u{1D436}'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'\u{1D461}'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'\u222A'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'\u25A1'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'\u{1F511}\uFE0E'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'\u25A2'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var FieldPos = class {
  constructor(field, line, from, to) {
    this.field = field;
    this.line = line;
    this.from = from;
    this.to = to;
  }
};
var FieldRange = class _FieldRange {
  constructor(field, from, to) {
    this.field = field;
    this.from = from;
    this.to = to;
  }
  map(changes) {
    let from = changes.mapPos(this.from, -1, MapMode.TrackDel);
    let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
    return from == null || to == null ? null : new _FieldRange(this.field, from, to);
  }
};
var Snippet = class _Snippet {
  constructor(lines, fieldPositions) {
    this.lines = lines;
    this.fieldPositions = fieldPositions;
  }
  instantiate(state, pos) {
    let text = [], lineStart = [pos];
    let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
    for (let line of this.lines) {
      if (text.length) {
        let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
        for (let i = 0; i < tabs; i++)
          indent += state.facet(indentUnit);
        lineStart.push(pos + indent.length - tabs);
        line = indent + line.slice(tabs);
      }
      text.push(line);
      pos += line.length + 1;
    }
    let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
    return { text, ranges };
  }
  static parse(template) {
    let fields = [];
    let lines = [], positions = [], m;
    for (let line of template.split(/\r\n?|\n/)) {
      while (m = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(line)) {
        let seq = m[1] ? +m[1] : null, rawName = m[2] || m[3] || "", found = -1;
        let name2 = rawName.replace(/\\[{}]/g, (m2) => m2[1]);
        for (let i = 0; i < fields.length; i++) {
          if (seq != null ? fields[i].seq == seq : name2 ? fields[i].name == name2 : false)
            found = i;
        }
        if (found < 0) {
          let i = 0;
          while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))
            i++;
          fields.splice(i, 0, { seq, name: name2 });
          found = i;
          for (let pos of positions)
            if (pos.field >= found)
              pos.field++;
        }
        for (let pos of positions)
          if (pos.line == lines.length && pos.from > m.index) {
            let snip = m[2] ? 3 + (m[1] || "").length : 2;
            pos.from -= snip;
            pos.to -= snip;
          }
        positions.push(new FieldPos(found, lines.length, m.index, m.index + name2.length));
        line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);
      }
      line = line.replace(/\\([{}])/g, (_, brace, index) => {
        for (let pos of positions)
          if (pos.line == lines.length && pos.from > index) {
            pos.from--;
            pos.to--;
          }
        return brace;
      });
      lines.push(line);
    }
    return new _Snippet(lines, positions);
  }
};
var fieldMarker = /* @__PURE__ */ Decoration.widget({ widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM() {
    let span = document.createElement("span");
    span.className = "cm-snippetFieldPosition";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}() });
var fieldRange = /* @__PURE__ */ Decoration.mark({ class: "cm-snippetField" });
var ActiveSnippet = class _ActiveSnippet {
  constructor(ranges, active) {
    this.ranges = ranges;
    this.active = active;
    this.deco = Decoration.set(ranges.map((r) => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)), true);
  }
  map(changes) {
    let ranges = [];
    for (let r of this.ranges) {
      let mapped = r.map(changes);
      if (!mapped)
        return null;
      ranges.push(mapped);
    }
    return new _ActiveSnippet(ranges, this.active);
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range) => this.ranges.some((r) => r.field == this.active && r.from <= range.from && r.to >= range.to));
  }
};
var setActive = /* @__PURE__ */ StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }
});
var moveToField = /* @__PURE__ */ StateEffect.define();
var snippetState = /* @__PURE__ */ StateField.define({
  create() {
    return null;
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setActive))
        return effect.value;
      if (effect.is(moveToField) && value)
        return new ActiveSnippet(value.ranges, effect.value);
    }
    if (value && tr.docChanged)
      value = value.map(tr.changes);
    if (value && tr.selection && !value.selectionInsideField(tr.selection))
      value = null;
    return value;
  },
  provide: (f) => EditorView.decorations.from(f, (val) => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges, field) {
  return EditorSelection.create(ranges.filter((r) => r.field == field).map((r) => EditorSelection.range(r.from, r.to)));
}
function snippet(template) {
  let snippet2 = Snippet.parse(template);
  return (editor, completion, from, to) => {
    let { text, ranges } = snippet2.instantiate(editor.state, from);
    let { main } = editor.state.selection;
    let spec = {
      changes: { from, to: to == main.from ? main.to : to, insert: Text.of(text) },
      scrollIntoView: true,
      annotations: completion ? [pickedCompletion.of(completion), Transaction.userEvent.of("input.complete")] : void 0
    };
    if (ranges.length)
      spec.selection = fieldSelection(ranges, 0);
    if (ranges.some((r) => r.field > 0)) {
      let active = new ActiveSnippet(ranges, 0);
      let effects = spec.effects = [setActive.of(active)];
      if (editor.state.field(snippetState, false) === void 0)
        effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme3]));
    }
    editor.dispatch(editor.state.update(spec));
  };
}
function moveField(dir) {
  return ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0)
      return false;
    let next = active.active + dir, last = dir > 0 && !active.ranges.some((r) => r.field == next + dir);
    dispatch(state.update({
      selection: fieldSelection(active.ranges, next),
      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),
      scrollIntoView: true
    }));
    return true;
  };
}
var clearSnippet = ({ state, dispatch }) => {
  let active = state.field(snippetState, false);
  if (!active)
    return false;
  dispatch(state.update({ effects: setActive.of(null) }));
  return true;
};
var nextSnippetField = /* @__PURE__ */ moveField(1);
var prevSnippetField = /* @__PURE__ */ moveField(-1);
var defaultSnippetKeymap = [
  { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
  { key: "Escape", run: clearSnippet }
];
var snippetKeymap = /* @__PURE__ */ Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }
});
var addSnippetKeymap = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
function snippetCompletion(template, completion) {
  return { ...completion, apply: snippet(template) };
}
var snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({
  mousedown(event, view) {
    let active = view.state.field(snippetState, false), pos;
    if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
      return false;
    let match = active.ranges.find((r) => r.from <= pos && r.to >= pos);
    if (!match || match.field == active.active)
      return false;
    view.dispatch({
      selection: fieldSelection(active.ranges, match.field),
      effects: setActive.of(active.ranges.some((r) => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),
      scrollIntoView: true
    });
    return true;
  }
});
var defaults2 = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
var closedBracket = /* @__PURE__ */ new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
var bracketState = /* @__PURE__ */ StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr) {
    value = value.map(tr.changes);
    if (tr.selection) {
      let line = tr.state.doc.lineAt(tr.selection.main.head);
      value = value.update({ filter: (from) => from >= line.from && from <= line.to });
    }
    for (let effect of tr.effects)
      if (effect.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
    return value;
  }
});
function closeBrackets() {
  return [inputHandler2, bracketState];
}
var definedClosing = "()[]{}<>\xAB\xBB\xBB\xAB\uFF3B\uFF3D\uFF5B\uFF5D";
function closing(ch) {
  for (let i = 0; i < definedClosing.length; i += 2)
    if (definedClosing.charCodeAt(i) == ch)
      return definedClosing.charAt(i + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
}
var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
var inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, insert2) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize2(codePointAt2(insert2, 0)) == 1 || from != sel.from || to != sel.to)
    return false;
  let tr = insertBracket(view.state, insert2);
  if (!tr)
    return false;
  view.dispatch(tr);
  return true;
});
var deleteBracketPair = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults2.brackets;
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty) {
      let before = prevChar(state.doc, range.head);
      for (let token of tokens) {
        if (token == before && nextChar(state.doc, range.head) == closing(codePointAt2(token, 0)))
          return {
            changes: { from: range.head - token.length, to: range.head + token.length },
            range: EditorSelection.cursor(range.head - token.length)
          };
      }
    }
    return { range: dont = range };
  });
  if (!dont)
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
  return !dont;
};
var closeBracketsKeymap = [
  { key: "Backspace", run: deleteBracketPair }
];
function insertBracket(state, bracket2) {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults2.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt2(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults2.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from) => {
    if (from == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next = doc2.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize2(codePointAt2(next, 0)));
}
function prevChar(doc2, pos) {
  let prev = doc2.sliceString(pos - 2, pos);
  return codePointSize2(codePointAt2(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next = nextChar(state.doc, range.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
      return {
        changes: { insert: open + close, from: range.head },
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty && nextChar(state.doc, range.head) == close)
      return {
        changes: { from: range.head, to: range.head + close.length, insert: close },
        range: EditorSelection.cursor(range.head + close.length)
      };
    return dont = { range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleSame(state, token, allowTriple, config2) {
  let stringPrefixes = config2.stringPrefixes || defaults2.stringPrefixes;
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
        effects: closeBracketEffect.of(range.to + token.length),
        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
      };
    let pos = range.head, next = nextChar(state.doc, pos), start;
    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        let content2 = isTriple ? token + token + token : token;
        return {
          changes: { from: pos, to: pos + content2.length, insert: content2 },
          range: EditorSelection.cursor(pos + content2.length)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
      return {
        changes: { insert: token + token + token + token, from: pos },
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
    }
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state, pos) {
  let tree = syntaxTree(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
  let node = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
  for (let i = 0; i < 5; i++) {
    let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
    let quotePos = start.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
      let first = node.firstChild;
      while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
          return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent = node.to == pos && node.parent;
    if (!parent)
      break;
    node = parent;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
    return pos;
  for (let prefix of prefixes) {
    let start = pos - prefix.length;
    if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
      return start;
  }
  return -1;
}
function autocompletion(config2 = {}) {
  return [
    commitCharacters,
    completionState,
    completionConfig.of(config2),
    completionPlugin,
    completionKeymapExt,
    baseTheme3
  ];
}
var completionKeymap = [
  { key: "Ctrl-Space", run: startCompletion },
  { mac: "Alt-`", run: startCompletion },
  { mac: "Alt-i", run: startCompletion },
  { key: "Escape", run: closeCompletion },
  { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
  { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
  { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
  { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
  { key: "Enter", run: acceptCompletion }
];
var completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
function completionStatus(state) {
  let cState = state.field(completionState, false);
  return cState && cState.active.some((a) => a.isPending) ? "pending" : cState && cState.active.some(
    (a) => a.state != 0
    /* State.Inactive */
  ) ? "active" : null;
}

// node_modules/@lezer/markdown/dist/index.js
var CompositeBlock = class _CompositeBlock {
  static create(type, value, from, parentHash, end) {
    let hash2 = parentHash + (parentHash << 8) + type + (value << 4) | 0;
    return new _CompositeBlock(type, value, from, hash2, end, [], []);
  }
  constructor(type, value, from, hash2, end, children, positions) {
    this.type = type;
    this.value = value;
    this.from = from;
    this.hash = hash2;
    this.end = end;
    this.children = children;
    this.positions = positions;
    this.hashProp = [[NodeProp.contextHash, hash2]];
  }
  addChild(child, pos) {
    if (child.prop(NodeProp.contextHash) != this.hash)
      child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);
    this.children.push(child);
    this.positions.push(pos);
  }
  toTree(nodeSet, end = this.end) {
    let last = this.children.length - 1;
    if (last >= 0)
      end = Math.max(end, this.positions[last] + this.children[last].length + this.from);
    return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({
      makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)
    });
  }
};
var Type;
(function(Type2) {
  Type2[Type2["Document"] = 1] = "Document";
  Type2[Type2["CodeBlock"] = 2] = "CodeBlock";
  Type2[Type2["FencedCode"] = 3] = "FencedCode";
  Type2[Type2["Blockquote"] = 4] = "Blockquote";
  Type2[Type2["HorizontalRule"] = 5] = "HorizontalRule";
  Type2[Type2["BulletList"] = 6] = "BulletList";
  Type2[Type2["OrderedList"] = 7] = "OrderedList";
  Type2[Type2["ListItem"] = 8] = "ListItem";
  Type2[Type2["ATXHeading1"] = 9] = "ATXHeading1";
  Type2[Type2["ATXHeading2"] = 10] = "ATXHeading2";
  Type2[Type2["ATXHeading3"] = 11] = "ATXHeading3";
  Type2[Type2["ATXHeading4"] = 12] = "ATXHeading4";
  Type2[Type2["ATXHeading5"] = 13] = "ATXHeading5";
  Type2[Type2["ATXHeading6"] = 14] = "ATXHeading6";
  Type2[Type2["SetextHeading1"] = 15] = "SetextHeading1";
  Type2[Type2["SetextHeading2"] = 16] = "SetextHeading2";
  Type2[Type2["HTMLBlock"] = 17] = "HTMLBlock";
  Type2[Type2["LinkReference"] = 18] = "LinkReference";
  Type2[Type2["Paragraph"] = 19] = "Paragraph";
  Type2[Type2["CommentBlock"] = 20] = "CommentBlock";
  Type2[Type2["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
  Type2[Type2["Escape"] = 22] = "Escape";
  Type2[Type2["Entity"] = 23] = "Entity";
  Type2[Type2["HardBreak"] = 24] = "HardBreak";
  Type2[Type2["Emphasis"] = 25] = "Emphasis";
  Type2[Type2["StrongEmphasis"] = 26] = "StrongEmphasis";
  Type2[Type2["Link"] = 27] = "Link";
  Type2[Type2["Image"] = 28] = "Image";
  Type2[Type2["InlineCode"] = 29] = "InlineCode";
  Type2[Type2["HTMLTag"] = 30] = "HTMLTag";
  Type2[Type2["Comment"] = 31] = "Comment";
  Type2[Type2["ProcessingInstruction"] = 32] = "ProcessingInstruction";
  Type2[Type2["Autolink"] = 33] = "Autolink";
  Type2[Type2["HeaderMark"] = 34] = "HeaderMark";
  Type2[Type2["QuoteMark"] = 35] = "QuoteMark";
  Type2[Type2["ListMark"] = 36] = "ListMark";
  Type2[Type2["LinkMark"] = 37] = "LinkMark";
  Type2[Type2["EmphasisMark"] = 38] = "EmphasisMark";
  Type2[Type2["CodeMark"] = 39] = "CodeMark";
  Type2[Type2["CodeText"] = 40] = "CodeText";
  Type2[Type2["CodeInfo"] = 41] = "CodeInfo";
  Type2[Type2["LinkTitle"] = 42] = "LinkTitle";
  Type2[Type2["LinkLabel"] = 43] = "LinkLabel";
  Type2[Type2["URL"] = 44] = "URL";
})(Type || (Type = {}));
var LeafBlock = class {
  /**
  @internal
  */
  constructor(start, content2) {
    this.start = start;
    this.content = content2;
    this.marks = [];
    this.parsers = [];
  }
};
var Line2 = class {
  constructor() {
    this.text = "";
    this.baseIndent = 0;
    this.basePos = 0;
    this.depth = 0;
    this.markers = [];
    this.pos = 0;
    this.indent = 0;
    this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    if (this.basePos > this.pos)
      this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let newPos = this.skipSpace(this.basePos);
    this.indent = this.countIndent(newPos, this.pos, this.indent);
    this.pos = newPos;
    this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(from) {
    return skipSpace(this.text, from);
  }
  /**
  @internal
  */
  reset(text) {
    this.text = text;
    this.baseIndent = this.basePos = this.pos = this.indent = 0;
    this.forwardInner();
    this.depth = 1;
    while (this.markers.length)
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(to) {
    this.basePos = to;
    this.baseIndent = this.countIndent(to, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(indent) {
    this.baseIndent = indent;
    this.basePos = this.findColumn(indent);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(elt2) {
    this.markers.push(elt2);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(to, from = 0, indent = 0) {
    for (let i = from; i < to; i++)
      indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
    return indent;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(goal) {
    let i = 0;
    for (let indent = 0; i < this.text.length && indent < goal; i++)
      indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
    return i;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let result = "";
    for (let i = 0; i < this.basePos; i++)
      result += " ";
    return result + this.text.slice(this.basePos);
  }
};
function skipForList(bl, cx, line) {
  if (line.pos == line.text.length || bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent)
    return true;
  if (line.indent >= line.baseIndent + 4)
    return false;
  let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);
  return size > 0 && (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) && line.text.charCodeAt(line.pos + size - 1) == bl.value;
}
var DefaultSkipMarkup = {
  [Type.Blockquote](bl, cx, line) {
    if (line.next != 62)
      return false;
    line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));
    line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));
    bl.end = cx.lineStart + line.text.length;
    return true;
  },
  [Type.ListItem](bl, _cx, line) {
    if (line.indent < line.baseIndent + bl.value && line.next > -1)
      return false;
    line.moveBaseColumn(line.baseIndent + bl.value);
    return true;
  },
  [Type.OrderedList]: skipForList,
  [Type.BulletList]: skipForList,
  [Type.Document]() {
    return true;
  }
};
function space(ch) {
  return ch == 32 || ch == 9 || ch == 10 || ch == 13;
}
function skipSpace(line, i = 0) {
  while (i < line.length && space(line.charCodeAt(i)))
    i++;
  return i;
}
function skipSpaceBack(line, i, to) {
  while (i > to && space(line.charCodeAt(i - 1)))
    i--;
  return i;
}
function isFencedCode(line) {
  if (line.next != 96 && line.next != 126)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
    pos++;
  if (pos < line.pos + 3)
    return -1;
  if (line.next == 96) {
    for (let i = pos; i < line.text.length; i++)
      if (line.text.charCodeAt(i) == 96)
        return -1;
  }
  return pos;
}
function isBlockquote(line) {
  return line.next != 62 ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;
}
function isHorizontalRule(line, cx, breaking) {
  if (line.next != 42 && line.next != 45 && line.next != 95)
    return -1;
  let count2 = 1;
  for (let pos = line.pos + 1; pos < line.text.length; pos++) {
    let ch = line.text.charCodeAt(pos);
    if (ch == line.next)
      count2++;
    else if (!space(ch))
      return -1;
  }
  if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length && cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1)
    return -1;
  return count2 < 3 ? -1 : 1;
}
function inList(cx, type) {
  for (let i = cx.stack.length - 1; i >= 0; i--)
    if (cx.stack[i].type == type)
      return true;
  return false;
}
function isBulletList(line, cx, breaking) {
  return (line.next == 45 || line.next == 43 || line.next == 42) && (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) && (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;
}
function isOrderedList(line, cx, breaking) {
  let pos = line.pos, next = line.next;
  for (; ; ) {
    if (next >= 48 && next <= 57)
      pos++;
    else
      break;
    if (pos == line.text.length)
      return -1;
    next = line.text.charCodeAt(pos);
  }
  if (pos == line.pos || pos > line.pos + 9 || next != 46 && next != 41 || pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type.OrderedList) && (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49))
    return -1;
  return pos + 1 - line.pos;
}
function isAtxHeading(line) {
  if (line.next != 35)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == 35)
    pos++;
  if (pos < line.text.length && line.text.charCodeAt(pos) != 32)
    return -1;
  let size = pos - line.pos;
  return size > 6 ? -1 : size;
}
function isSetextUnderline(line) {
  if (line.next != 45 && line.next != 61 || line.indent >= line.baseIndent + 4)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
    pos++;
  let end = pos;
  while (pos < line.text.length && space(line.text.charCodeAt(pos)))
    pos++;
  return pos == line.text.length ? end : -1;
}
var EmptyLine = /^[ \t]*$/;
var CommentEnd = /-->/;
var ProcessingEnd = /\?>/;
var HTMLBlockStyle = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, CommentEnd],
  [/^\s*<\?/, ProcessingEnd],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, EmptyLine],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, EmptyLine]
];
function isHTMLBlock(line, _cx, breaking) {
  if (line.next != 60)
    return -1;
  let rest = line.text.slice(line.pos);
  for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)
    if (HTMLBlockStyle[i][0].test(rest))
      return i;
  return -1;
}
function getListIndent(line, pos) {
  let indentAfter = line.countIndent(pos, line.pos, line.indent);
  let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);
  return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
}
function addCodeText(marks2, from, to) {
  let last = marks2.length - 1;
  if (last >= 0 && marks2[last].to == from && marks2[last].type == Type.CodeText)
    marks2[last].to = to;
  else
    marks2.push(elt(Type.CodeText, from, to));
}
var DefaultBlockParsers = {
  LinkReference: void 0,
  IndentedCode(cx, line) {
    let base2 = line.baseIndent + 4;
    if (line.indent < base2)
      return false;
    let start = line.findColumn(base2);
    let from = cx.lineStart + start, to = cx.lineStart + line.text.length;
    let marks2 = [], pendingMarks = [];
    addCodeText(marks2, from, to);
    while (cx.nextLine() && line.depth >= cx.stack.length) {
      if (line.pos == line.text.length) {
        addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
        for (let m of line.markers)
          pendingMarks.push(m);
      } else if (line.indent < base2) {
        break;
      } else {
        if (pendingMarks.length) {
          for (let m of pendingMarks) {
            if (m.type == Type.CodeText)
              addCodeText(marks2, m.from, m.to);
            else
              marks2.push(m);
          }
          pendingMarks = [];
        }
        addCodeText(marks2, cx.lineStart - 1, cx.lineStart);
        for (let m of line.markers)
          marks2.push(m);
        to = cx.lineStart + line.text.length;
        let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);
        if (codeStart < to)
          addCodeText(marks2, codeStart, to);
      }
    }
    if (pendingMarks.length) {
      pendingMarks = pendingMarks.filter((m) => m.type != Type.CodeText);
      if (pendingMarks.length)
        line.markers = pendingMarks.concat(line.markers);
    }
    cx.addNode(cx.buffer.writeElements(marks2, -from).finish(Type.CodeBlock, to - from), from);
    return true;
  },
  FencedCode(cx, line) {
    let fenceEnd = isFencedCode(line);
    if (fenceEnd < 0)
      return false;
    let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;
    let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);
    let marks2 = [elt(Type.CodeMark, from, from + len)];
    if (infoFrom < infoTo)
      marks2.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
    for (let first = true, empty2 = true, hasLine = false; cx.nextLine() && line.depth >= cx.stack.length; first = false) {
      let i = line.pos;
      if (line.indent - line.baseIndent < 4)
        while (i < line.text.length && line.text.charCodeAt(i) == ch)
          i++;
      if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {
        for (let m of line.markers)
          marks2.push(m);
        if (empty2 && hasLine)
          addCodeText(marks2, cx.lineStart - 1, cx.lineStart);
        marks2.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));
        cx.nextLine();
        break;
      } else {
        hasLine = true;
        if (!first) {
          addCodeText(marks2, cx.lineStart - 1, cx.lineStart);
          empty2 = false;
        }
        for (let m of line.markers)
          marks2.push(m);
        let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;
        if (textStart < textEnd) {
          addCodeText(marks2, textStart, textEnd);
          empty2 = false;
        }
      }
    }
    cx.addNode(cx.buffer.writeElements(marks2, -from).finish(Type.FencedCode, cx.prevLineEnd() - from), from);
    return true;
  },
  Blockquote(cx, line) {
    let size = isBlockquote(line);
    if (size < 0)
      return false;
    cx.startContext(Type.Blockquote, line.pos);
    cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);
    line.moveBase(line.pos + size);
    return null;
  },
  HorizontalRule(cx, line) {
    if (isHorizontalRule(line, cx, false) < 0)
      return false;
    let from = cx.lineStart + line.pos;
    cx.nextLine();
    cx.addNode(Type.HorizontalRule, from);
    return true;
  },
  BulletList(cx, line) {
    let size = isBulletList(line, cx, false);
    if (size < 0)
      return false;
    if (cx.block.type != Type.BulletList)
      cx.startContext(Type.BulletList, line.basePos, line.next);
    let newBase = getListIndent(line, line.pos + 1);
    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
    line.moveBaseColumn(newBase);
    return null;
  },
  OrderedList(cx, line) {
    let size = isOrderedList(line, cx, false);
    if (size < 0)
      return false;
    if (cx.block.type != Type.OrderedList)
      cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));
    let newBase = getListIndent(line, line.pos + size);
    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
    line.moveBaseColumn(newBase);
    return null;
  },
  ATXHeading(cx, line) {
    let size = isAtxHeading(line);
    if (size < 0)
      return false;
    let off = line.pos, from = cx.lineStart + off;
    let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;
    while (after > off && line.text.charCodeAt(after - 1) == line.next)
      after--;
    if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))
      after = line.text.length;
    let buf = cx.buffer.write(Type.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);
    if (after < line.text.length)
      buf.write(Type.HeaderMark, after - off, endOfSpace - off);
    let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);
    cx.nextLine();
    cx.addNode(node, from);
    return true;
  },
  HTMLBlock(cx, line) {
    let type = isHTMLBlock(line, cx, false);
    if (type < 0)
      return false;
    let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];
    let marks2 = [], trailing = end != EmptyLine;
    while (!end.test(line.text) && cx.nextLine()) {
      if (line.depth < cx.stack.length) {
        trailing = false;
        break;
      }
      for (let m of line.markers)
        marks2.push(m);
    }
    if (trailing)
      cx.nextLine();
    let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;
    let to = cx.prevLineEnd();
    cx.addNode(cx.buffer.writeElements(marks2, -from).finish(nodeType, to - from), from);
    return true;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
var LinkReferenceParser = class {
  constructor(leaf) {
    this.stage = 0;
    this.elts = [];
    this.pos = 0;
    this.start = leaf.start;
    this.advance(leaf.content);
  }
  nextLine(cx, line, leaf) {
    if (this.stage == -1)
      return false;
    let content2 = leaf.content + "\n" + line.scrub();
    let finish = this.advance(content2);
    if (finish > -1 && finish < content2.length)
      return this.complete(cx, leaf, finish);
    return false;
  }
  finish(cx, leaf) {
    if ((this.stage == 2 || this.stage == 3) && skipSpace(leaf.content, this.pos) == leaf.content.length)
      return this.complete(cx, leaf, leaf.content.length);
    return false;
  }
  complete(cx, leaf, len) {
    cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));
    return true;
  }
  nextStage(elt2) {
    if (elt2) {
      this.pos = elt2.to - this.start;
      this.elts.push(elt2);
      this.stage++;
      return true;
    }
    if (elt2 === false)
      this.stage = -1;
    return false;
  }
  advance(content2) {
    for (; ; ) {
      if (this.stage == -1) {
        return -1;
      } else if (this.stage == 0) {
        if (!this.nextStage(parseLinkLabel(content2, this.pos, this.start, true)))
          return -1;
        if (content2.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));
        this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(parseURL(content2, skipSpace(content2, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let skip = skipSpace(content2, this.pos), end = 0;
        if (skip > this.pos) {
          let title = parseLinkTitle(content2, skip, this.start);
          if (title) {
            let titleEnd = lineEnd(content2, title.to - this.start);
            if (titleEnd > 0) {
              this.nextStage(title);
              end = titleEnd;
            }
          }
        }
        if (!end)
          end = lineEnd(content2, this.pos);
        return end > 0 && end < content2.length ? end : -1;
      } else {
        return lineEnd(content2, this.pos);
      }
    }
  }
};
function lineEnd(text, pos) {
  for (; pos < text.length; pos++) {
    let next = text.charCodeAt(pos);
    if (next == 10)
      break;
    if (!space(next))
      return -1;
  }
  return pos;
}
var SetextHeadingParser = class {
  nextLine(cx, line, leaf) {
    let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);
    let next = line.next;
    if (underline < 0)
      return false;
    let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);
    cx.nextLine();
    cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [
      ...cx.parser.parseInline(leaf.content, leaf.start),
      underlineMark
    ]));
    return true;
  }
  finish() {
    return false;
  }
};
var DefaultLeafBlocks = {
  LinkReference(_, leaf) {
    return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null;
  },
  SetextHeading() {
    return new SetextHeadingParser();
  }
};
var DefaultEndLeaf = [
  (_, line) => isAtxHeading(line) >= 0,
  (_, line) => isFencedCode(line) >= 0,
  (_, line) => isBlockquote(line) >= 0,
  (p, line) => isBulletList(line, p, true) >= 0,
  (p, line) => isOrderedList(line, p, true) >= 0,
  (p, line) => isHorizontalRule(line, p, true) >= 0,
  (p, line) => isHTMLBlock(line, p, true) >= 0
];
var scanLineResult = { text: "", end: 0 };
var BlockContext = class {
  /**
  @internal
  */
  constructor(parser5, input, fragments, ranges) {
    this.parser = parser5;
    this.input = input;
    this.ranges = ranges;
    this.line = new Line2();
    this.atEnd = false;
    this.reusePlaceholders = /* @__PURE__ */ new Map();
    this.stoppedAt = null;
    this.rangeI = 0;
    this.to = ranges[ranges.length - 1].to;
    this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;
    this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);
    this.stack = [this.block];
    this.fragments = fragments.length ? new FragmentCursor2(fragments, input) : null;
    this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line } = this;
    for (; ; ) {
      for (let markI = 0; ; ) {
        let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {
          let mark = line.markers[markI++];
          this.addNode(mark.type, mark.from, mark.to);
        }
        if (!next)
          break;
        this.finishContext();
      }
      if (line.pos < line.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(line.basePos))
      return null;
    start: for (; ; ) {
      for (let type of this.parser.blockParsers)
        if (type) {
          let result = type(this, line);
          if (result != false) {
            if (result == true)
              return null;
            line.forward();
            continue start;
          }
        }
      break;
    }
    let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));
    for (let parse of this.parser.leafBlockParsers)
      if (parse) {
        let parser5 = parse(this, leaf);
        if (parser5)
          leaf.parsers.push(parser5);
      }
    lines: while (this.nextLine()) {
      if (line.pos == line.text.length)
        break;
      if (line.indent < line.baseIndent + 4) {
        for (let stop of this.parser.endLeafBlock)
          if (stop(this, line, leaf))
            break lines;
      }
      for (let parser5 of leaf.parsers)
        if (parser5.nextLine(this, line, leaf))
          return null;
      leaf.content += "\n" + line.scrub();
      for (let m of line.markers)
        leaf.marks.push(m);
    }
    this.finishLeaf(leaf);
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  reuseFragment(start) {
    if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return false;
    let taken = this.fragments.takeNodes(this);
    if (!taken)
      return false;
    this.absoluteLineStart += taken;
    this.lineStart = toRelative(this.absoluteLineStart, this.ranges);
    this.moveRangeI();
    if (this.absoluteLineStart < this.to) {
      this.lineStart++;
      this.absoluteLineStart++;
      this.readLine();
    } else {
      this.atEnd = true;
      this.readLine();
    }
    return true;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(depth = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[depth].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    this.lineStart += this.line.text.length;
    if (this.absoluteLineEnd >= this.to) {
      this.absoluteLineStart = this.absoluteLineEnd;
      this.atEnd = true;
      this.readLine();
      return false;
    } else {
      this.lineStart++;
      this.absoluteLineStart = this.absoluteLineEnd + 1;
      this.moveRangeI();
      this.readLine();
      return true;
    }
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {
      this.rangeI++;
      this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
    }
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(start) {
    let r = scanLineResult;
    r.end = start;
    if (start >= this.to) {
      r.text = "";
    } else {
      r.text = this.lineChunkAt(start);
      r.end += r.text.length;
      if (this.ranges.length > 1) {
        let textOffset = this.absoluteLineStart, rangeI = this.rangeI;
        while (this.ranges[rangeI].to < r.end) {
          rangeI++;
          let nextFrom = this.ranges[rangeI].from;
          let after = this.lineChunkAt(nextFrom);
          r.end = nextFrom + after.length;
          r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
          textOffset = r.end - r.text.length;
        }
      }
    }
    return r;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);
    this.absoluteLineEnd = end;
    line.reset(text);
    for (; line.depth < this.stack.length; line.depth++) {
      let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];
      if (!handler)
        throw new Error("Unhandled block context " + Type[cx.type]);
      let marks2 = this.line.markers.length;
      if (!handler(cx, this, line)) {
        if (this.line.markers.length > marks2)
          cx.end = this.line.markers[this.line.markers.length - 1].to;
        line.forward();
        break;
      }
      line.forward();
    }
  }
  lineChunkAt(pos) {
    let next = this.input.chunk(pos), text;
    if (!this.input.lineChunks) {
      let eol = next.indexOf("\n");
      text = eol < 0 ? next : next.slice(0, eol);
    } else {
      text = next == "\n" ? "" : next;
    }
    return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(type, start, value = 0) {
    this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);
    this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(type, start, value = 0) {
    this.startContext(this.parser.getNodeType(type), start, value);
  }
  /**
  @internal
  */
  addNode(block, from, to) {
    if (typeof block == "number")
      block = new Tree(this.parser.nodeSet.types[block], none3, none3, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);
    this.block.addChild(block, from - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(elt2) {
    this.block.addChild(elt2.toTree(this.parser.nodeSet), elt2.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(leaf, elt2) {
    this.addNode(this.buffer.writeElements(injectMarks(elt2.children, leaf.marks), -elt2.from).finish(elt2.type, elt2.to - elt2.from), elt2.from);
  }
  /**
  @internal
  */
  finishContext() {
    let cx = this.stack.pop();
    let top2 = this.stack[this.stack.length - 1];
    top2.addChild(cx.toTree(this.parser.nodeSet), cx.from - top2.from);
    this.block = top2;
  }
  finish() {
    while (this.stack.length > 1)
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(tree) {
    return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;
  }
  /**
  @internal
  */
  finishLeaf(leaf) {
    for (let parser5 of leaf.parsers)
      if (parser5.finish(this, leaf))
        return;
    let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
    this.addNode(this.buffer.writeElements(inline, -leaf.start).finish(Type.Paragraph, leaf.content.length), leaf.start);
  }
  elt(type, from, to, children) {
    if (typeof type == "string")
      return elt(this.parser.getNodeType(type), from, to, children);
    return new TreeElement(type, from);
  }
  /**
  @internal
  */
  get buffer() {
    return new Buffer(this.parser.nodeSet);
  }
};
function injectGaps(ranges, rangeI, tree, offset, dummies) {
  let rangeEnd2 = ranges[rangeI].to;
  let children = [], positions = [], start = tree.from + offset;
  function movePastNext(upto, inclusive) {
    while (inclusive ? upto >= rangeEnd2 : upto > rangeEnd2) {
      let size = ranges[rangeI + 1].from - rangeEnd2;
      offset += size;
      upto += size;
      rangeI++;
      rangeEnd2 = ranges[rangeI].to;
    }
  }
  for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {
    movePastNext(ch.from + offset, true);
    let from = ch.from + offset, node, reuse = dummies.get(ch.tree);
    if (reuse) {
      node = reuse;
    } else if (ch.to + offset > rangeEnd2) {
      node = injectGaps(ranges, rangeI, ch, offset, dummies);
      movePastNext(ch.to + offset, false);
    } else {
      node = ch.toTree();
    }
    children.push(node);
    positions.push(from - start);
  }
  movePastNext(tree.to + offset, false);
  return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : void 0);
}
var MarkdownParser = class _MarkdownParser extends Parser {
  /**
  @internal
  */
  constructor(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers) {
    super();
    this.nodeSet = nodeSet;
    this.blockParsers = blockParsers;
    this.leafBlockParsers = leafBlockParsers;
    this.blockNames = blockNames;
    this.endLeafBlock = endLeafBlock;
    this.skipContextMarkup = skipContextMarkup;
    this.inlineParsers = inlineParsers;
    this.inlineNames = inlineNames;
    this.wrappers = wrappers;
    this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let t2 of nodeSet.types)
      this.nodeTypes[t2.name] = t2.id;
  }
  createParse(input, fragments, ranges) {
    let parse = new BlockContext(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  /**
  Reconfigure the parser.
  */
  configure(spec) {
    let config2 = resolveConfig(spec);
    if (!config2)
      return this;
    let { nodeSet, skipContextMarkup } = this;
    let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;
    if (nonEmpty(config2.defineNodes)) {
      skipContextMarkup = Object.assign({}, skipContextMarkup);
      let nodeTypes2 = nodeSet.types.slice(), styles;
      for (let s of config2.defineNodes) {
        let { name: name2, block, composite, style } = typeof s == "string" ? { name: s } : s;
        if (nodeTypes2.some((t2) => t2.name == name2))
          continue;
        if (composite)
          skipContextMarkup[nodeTypes2.length] = (bl, cx, line) => composite(cx, line, bl.value);
        let id2 = nodeTypes2.length;
        let group = composite ? ["Block", "BlockContext"] : !block ? void 0 : id2 >= Type.ATXHeading1 && id2 <= Type.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"];
        nodeTypes2.push(NodeType.define({
          id: id2,
          name: name2,
          props: group && [[NodeProp.group, group]]
        }));
        if (style) {
          if (!styles)
            styles = {};
          if (Array.isArray(style) || style instanceof Tag)
            styles[name2] = style;
          else
            Object.assign(styles, style);
        }
      }
      nodeSet = new NodeSet(nodeTypes2);
      if (styles)
        nodeSet = nodeSet.extend(styleTags(styles));
    }
    if (nonEmpty(config2.props))
      nodeSet = nodeSet.extend(...config2.props);
    if (nonEmpty(config2.remove)) {
      for (let rm2 of config2.remove) {
        let block = this.blockNames.indexOf(rm2), inline = this.inlineNames.indexOf(rm2);
        if (block > -1)
          blockParsers[block] = leafBlockParsers[block] = void 0;
        if (inline > -1)
          inlineParsers[inline] = void 0;
      }
    }
    if (nonEmpty(config2.parseBlock)) {
      for (let spec2 of config2.parseBlock) {
        let found = blockNames.indexOf(spec2.name);
        if (found > -1) {
          blockParsers[found] = spec2.parse;
          leafBlockParsers[found] = spec2.leaf;
        } else {
          let pos = spec2.before ? findName(blockNames, spec2.before) : spec2.after ? findName(blockNames, spec2.after) + 1 : blockNames.length - 1;
          blockParsers.splice(pos, 0, spec2.parse);
          leafBlockParsers.splice(pos, 0, spec2.leaf);
          blockNames.splice(pos, 0, spec2.name);
        }
        if (spec2.endLeaf)
          endLeafBlock.push(spec2.endLeaf);
      }
    }
    if (nonEmpty(config2.parseInline)) {
      for (let spec2 of config2.parseInline) {
        let found = inlineNames.indexOf(spec2.name);
        if (found > -1) {
          inlineParsers[found] = spec2.parse;
        } else {
          let pos = spec2.before ? findName(inlineNames, spec2.before) : spec2.after ? findName(inlineNames, spec2.after) + 1 : inlineNames.length - 1;
          inlineParsers.splice(pos, 0, spec2.parse);
          inlineNames.splice(pos, 0, spec2.name);
        }
      }
    }
    if (config2.wrap)
      wrappers = wrappers.concat(config2.wrap);
    return new _MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
  }
  /**
  @internal
  */
  getNodeType(name2) {
    let found = this.nodeTypes[name2];
    if (found == null)
      throw new RangeError(`Unknown node type '${name2}'`);
    return found;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(text, offset) {
    let cx = new InlineContext(this, text, offset);
    outer: for (let pos = offset; pos < cx.end; ) {
      let next = cx.char(pos);
      for (let token of this.inlineParsers)
        if (token) {
          let result = token(cx, next, pos);
          if (result >= 0) {
            pos = result;
            continue outer;
          }
        }
      pos++;
    }
    return cx.resolveMarkers(0);
  }
};
function nonEmpty(a) {
  return a != null && a.length > 0;
}
function resolveConfig(spec) {
  if (!Array.isArray(spec))
    return spec;
  if (spec.length == 0)
    return null;
  let conf = resolveConfig(spec[0]);
  if (spec.length == 1)
    return conf;
  let rest = resolveConfig(spec.slice(1));
  if (!rest || !conf)
    return conf || rest;
  let conc2 = (a, b) => (a || none3).concat(b || none3);
  let wrapA = conf.wrap, wrapB = rest.wrap;
  return {
    props: conc2(conf.props, rest.props),
    defineNodes: conc2(conf.defineNodes, rest.defineNodes),
    parseBlock: conc2(conf.parseBlock, rest.parseBlock),
    parseInline: conc2(conf.parseInline, rest.parseInline),
    remove: conc2(conf.remove, rest.remove),
    wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)
  };
}
function findName(names, name2) {
  let found = names.indexOf(name2);
  if (found < 0)
    throw new RangeError(`Position specified relative to unknown parser ${name2}`);
  return found;
}
var nodeTypes = [NodeType.none];
for (let i = 1, name2; name2 = Type[i]; i++) {
  nodeTypes[i] = NodeType.define({
    id: i,
    name: name2,
    props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: name2 == "Document"
  });
}
var none3 = [];
var Buffer = class {
  constructor(nodeSet) {
    this.nodeSet = nodeSet;
    this.content = [];
    this.nodes = [];
  }
  write(type, from, to, children = 0) {
    this.content.push(type, from, to, 4 + children * 4);
    return this;
  }
  writeElements(elts, offset = 0) {
    for (let e of elts)
      e.writeTo(this, offset);
    return this;
  }
  finish(type, length) {
    return Tree.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: type,
      length
    });
  }
};
var Element = class {
  /**
  @internal
  */
  constructor(type, from, to, children = none3) {
    this.type = type;
    this.from = from;
    this.to = to;
    this.children = children;
  }
  /**
  @internal
  */
  writeTo(buf, offset) {
    let startOff = buf.content.length;
    buf.writeElements(this.children, offset);
    buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);
  }
  /**
  @internal
  */
  toTree(nodeSet) {
    return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
var TreeElement = class {
  constructor(tree, from) {
    this.tree = tree;
    this.from = from;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return none3;
  }
  writeTo(buf, offset) {
    buf.nodes.push(this.tree);
    buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);
  }
  toTree() {
    return this.tree;
  }
};
function elt(type, from, to, children) {
  return new Element(type, from, to, children);
}
var EmphasisUnderscore = { resolve: "Emphasis", mark: "EmphasisMark" };
var EmphasisAsterisk = { resolve: "Emphasis", mark: "EmphasisMark" };
var LinkStart = {};
var ImageStart = {};
var InlineDelimiter = class {
  constructor(type, from, to, side) {
    this.type = type;
    this.from = from;
    this.to = to;
    this.side = side;
  }
};
var Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
var Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Punctuation = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch (_) {
}
var DefaultInline = {
  Escape(cx, next, start) {
    if (next != 92 || start == cx.end - 1)
      return -1;
    let escaped = cx.char(start + 1);
    for (let i = 0; i < Escapable.length; i++)
      if (Escapable.charCodeAt(i) == escaped)
        return cx.append(elt(Type.Escape, start, start + 2));
    return -1;
  },
  Entity(cx, next, start) {
    if (next != 38)
      return -1;
    let m = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31));
    return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;
  },
  InlineCode(cx, next, start) {
    if (next != 96 || start && cx.char(start - 1) == 96)
      return -1;
    let pos = start + 1;
    while (pos < cx.end && cx.char(pos) == 96)
      pos++;
    let size = pos - start, curSize = 0;
    for (; pos < cx.end; pos++) {
      if (cx.char(pos) == 96) {
        curSize++;
        if (curSize == size && cx.char(pos + 1) != 96)
          return cx.append(elt(Type.InlineCode, start, pos + 1, [
            elt(Type.CodeMark, start, start + size),
            elt(Type.CodeMark, pos + 1 - size, pos + 1)
          ]));
      } else {
        curSize = 0;
      }
    }
    return -1;
  },
  HTMLTag(cx, next, start) {
    if (next != 60 || start == cx.end - 1)
      return -1;
    let after = cx.slice(start + 1, cx.end);
    let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
    if (url) {
      return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [
        elt(Type.LinkMark, start, start + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        elt(Type.URL, start + 1, start + url[0].length),
        elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)
      ]));
    }
    let comment2 = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
    if (comment2)
      return cx.append(elt(Type.Comment, start, start + 1 + comment2[0].length));
    let procInst = /^\?[^]*?\?>/.exec(after);
    if (procInst)
      return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));
    let m = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
    if (!m)
      return -1;
    return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));
  },
  Emphasis(cx, next, start) {
    if (next != 95 && next != 42)
      return -1;
    let pos = start + 1;
    while (cx.char(pos) == next)
      pos++;
    let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);
    let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
    let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
    let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
    let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
    let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);
    let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);
    return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 : 0) | (canClose ? 2 : 0)));
  },
  HardBreak(cx, next, start) {
    if (next == 92 && cx.char(start + 1) == 10)
      return cx.append(elt(Type.HardBreak, start, start + 2));
    if (next == 32) {
      let pos = start + 1;
      while (cx.char(pos) == 32)
        pos++;
      if (cx.char(pos) == 10 && pos >= start + 2)
        return cx.append(elt(Type.HardBreak, start, pos + 1));
    }
    return -1;
  },
  Link(cx, next, start) {
    return next == 91 ? cx.append(new InlineDelimiter(
      LinkStart,
      start,
      start + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(cx, next, start) {
    return next == 33 && cx.char(start + 1) == 91 ? cx.append(new InlineDelimiter(
      ImageStart,
      start,
      start + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(cx, next, start) {
    if (next != 93)
      return -1;
    for (let i = cx.parts.length - 1; i >= 0; i--) {
      let part = cx.parts[i];
      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
        if (!part.side || cx.skipSpace(part.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2))) {
          cx.parts[i] = null;
          return -1;
        }
        let content2 = cx.takeContent(i);
        let link = cx.parts[i] = finishLink(cx, content2, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);
        if (part.type == LinkStart)
          for (let j = 0; j < i; j++) {
            let p = cx.parts[j];
            if (p instanceof InlineDelimiter && p.type == LinkStart)
              p.side = 0;
          }
        return link.to;
      }
    }
    return -1;
  }
};
function finishLink(cx, content2, type, start, startPos) {
  let { text } = cx, next = cx.char(startPos), endPos = startPos;
  content2.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));
  content2.push(elt(Type.LinkMark, startPos - 1, startPos));
  if (next == 40) {
    let pos = cx.skipSpace(startPos + 1);
    let dest = parseURL(text, pos - cx.offset, cx.offset), title;
    if (dest) {
      pos = cx.skipSpace(dest.to);
      if (pos != dest.to) {
        title = parseLinkTitle(text, pos - cx.offset, cx.offset);
        if (title)
          pos = cx.skipSpace(title.to);
      }
    }
    if (cx.char(pos) == 41) {
      content2.push(elt(Type.LinkMark, startPos, startPos + 1));
      endPos = pos + 1;
      if (dest)
        content2.push(dest);
      if (title)
        content2.push(title);
      content2.push(elt(Type.LinkMark, pos, endPos));
    }
  } else if (next == 91) {
    let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);
    if (label) {
      content2.push(label);
      endPos = label.to;
    }
  }
  return elt(type, start, endPos, content2);
}
function parseURL(text, start, offset) {
  let next = text.charCodeAt(start);
  if (next == 60) {
    for (let pos = start + 1; pos < text.length; pos++) {
      let ch = text.charCodeAt(pos);
      if (ch == 62)
        return elt(Type.URL, start + offset, pos + 1 + offset);
      if (ch == 60 || ch == 10)
        return false;
    }
    return null;
  } else {
    let depth = 0, pos = start;
    for (let escaped = false; pos < text.length; pos++) {
      let ch = text.charCodeAt(pos);
      if (space(ch)) {
        break;
      } else if (escaped) {
        escaped = false;
      } else if (ch == 40) {
        depth++;
      } else if (ch == 41) {
        if (!depth)
          break;
        depth--;
      } else if (ch == 92) {
        escaped = true;
      }
    }
    return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;
  }
}
function parseLinkTitle(text, start, offset) {
  let next = text.charCodeAt(start);
  if (next != 39 && next != 34 && next != 40)
    return false;
  let end = next == 40 ? 41 : next;
  for (let pos = start + 1, escaped = false; pos < text.length; pos++) {
    let ch = text.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == end)
      return elt(Type.LinkTitle, start + offset, pos + 1 + offset);
    else if (ch == 92)
      escaped = true;
  }
  return null;
}
function parseLinkLabel(text, start, offset, requireNonWS) {
  for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {
    let ch = text.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == 93)
      return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);
    else {
      if (requireNonWS && !space(ch))
        requireNonWS = false;
      if (ch == 91)
        return false;
      else if (ch == 92)
        escaped = true;
    }
  }
  return null;
}
var InlineContext = class {
  /**
  @internal
  */
  constructor(parser5, text, offset) {
    this.parser = parser5;
    this.text = text;
    this.offset = offset;
    this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(pos) {
    return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(from, to) {
    return this.text.slice(from - this.offset, to - this.offset);
  }
  /**
  @internal
  */
  append(elt2) {
    this.parts.push(elt2);
    return elt2.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(type, from, to, open, close) {
    return this.append(new InlineDelimiter(type, from, to, (open ? 1 : 0) | (close ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let i = this.parts.length - 1; i >= 0; i--) {
      let part = this.parts[i];
      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))
        return true;
    }
    return false;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(elt2) {
    return this.append(elt2);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(from) {
    for (let i = from; i < this.parts.length; i++) {
      let close = this.parts[i];
      if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2))
        continue;
      let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
      let closeSize = close.to - close.from;
      let open, j = i - 1;
      for (; j >= from; j--) {
        let part = this.parts[j];
        if (part instanceof InlineDelimiter && part.side & 1 && part.type == close.type && // Ignore emphasis delimiters where the character count doesn't match
        !(emp && (close.side & 1 || part.side & 2) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {
          open = part;
          break;
        }
      }
      if (!open)
        continue;
      let type = close.type.resolve, content2 = [];
      let start = open.from, end = close.to;
      if (emp) {
        let size = Math.min(2, open.to - open.from, closeSize);
        start = open.to - size;
        end = close.from + size;
        type = size == 1 ? "Emphasis" : "StrongEmphasis";
      }
      if (open.type.mark)
        content2.push(this.elt(open.type.mark, start, open.to));
      for (let k = j + 1; k < i; k++) {
        if (this.parts[k] instanceof Element)
          content2.push(this.parts[k]);
        this.parts[k] = null;
      }
      if (close.type.mark)
        content2.push(this.elt(close.type.mark, close.from, end));
      let element = this.elt(type, start, end, content2);
      this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;
      let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;
      if (keep)
        this.parts.splice(i, 0, element);
      else
        this.parts[i] = element;
    }
    let result = [];
    for (let i = from; i < this.parts.length; i++) {
      let part = this.parts[i];
      if (part instanceof Element)
        result.push(part);
    }
    return result;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(type) {
    for (let i = this.parts.length - 1; i >= 0; i--) {
      let part = this.parts[i];
      if (part instanceof InlineDelimiter && part.type == type && part.side & 1)
        return i;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(startIndex) {
    let content2 = this.resolveMarkers(startIndex);
    this.parts.length = startIndex;
    return content2;
  }
  /**
  Return the delimiter at the given index. Mostly useful to get
  additional info out of a delimiter index returned by
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter).
  Returns null if there is no delimiter at this index.
  */
  getDelimiterAt(index) {
    let part = this.parts[index];
    return part instanceof InlineDelimiter ? part : null;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(from) {
    return skipSpace(this.text, from - this.offset) + this.offset;
  }
  elt(type, from, to, children) {
    if (typeof type == "string")
      return elt(this.parser.getNodeType(type), from, to, children);
    return new TreeElement(type, from);
  }
};
InlineContext.linkStart = LinkStart;
InlineContext.imageStart = ImageStart;
function injectMarks(elements, marks2) {
  if (!marks2.length)
    return elements;
  if (!elements.length)
    return marks2;
  let elts = elements.slice(), eI = 0;
  for (let mark of marks2) {
    while (eI < elts.length && elts[eI].to < mark.to)
      eI++;
    if (eI < elts.length && elts[eI].from < mark.from) {
      let e = elts[eI];
      if (e instanceof Element)
        elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));
    } else {
      elts.splice(eI++, 0, mark);
    }
  }
  return elts;
}
var NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];
var FragmentCursor2 = class {
  constructor(fragments, input) {
    this.fragments = fragments;
    this.input = input;
    this.i = 0;
    this.fragment = null;
    this.fragmentEnd = -1;
    this.cursor = null;
    if (fragments.length)
      this.fragment = fragments[this.i++];
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
    this.cursor = null;
    this.fragmentEnd = -1;
  }
  moveTo(pos, lineStart) {
    while (this.fragment && this.fragment.to <= pos)
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))
      return false;
    if (this.fragmentEnd < 0) {
      let end = this.fragment.to;
      while (end > 0 && this.input.read(end - 1, end) != "\n")
        end--;
      this.fragmentEnd = end ? end - 1 : 0;
    }
    let c = this.cursor;
    if (!c) {
      c = this.cursor = this.fragment.tree.cursor();
      c.firstChild();
    }
    let rPos = pos + this.fragment.offset;
    while (c.to <= rPos)
      if (!c.parent())
        return false;
    for (; ; ) {
      if (c.from >= rPos)
        return this.fragment.from <= lineStart;
      if (!c.childAfter(rPos))
        return false;
    }
  }
  matches(hash2) {
    let tree = this.cursor.tree;
    return tree && tree.prop(NodeProp.contextHash) == hash2;
  }
  takeNodes(cx) {
    let cur2 = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
    let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;
    let prevEnd = end, prevI = blockI;
    for (; ; ) {
      if (cur2.to - off > fragEnd) {
        if (cur2.type.isAnonymous && cur2.firstChild())
          continue;
        break;
      }
      let pos = toRelative(cur2.from - off, cx.ranges);
      if (cur2.to - off <= cx.ranges[cx.rangeI].to) {
        cx.addNode(cur2.tree, pos);
      } else {
        let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);
        cx.reusePlaceholders.set(dummy, cur2.tree);
        cx.addNode(dummy, pos);
      }
      if (cur2.type.is("Block")) {
        if (NotLast.indexOf(cur2.type.id) < 0) {
          end = cur2.to - off;
          blockI = cx.block.children.length;
        } else {
          end = prevEnd;
          blockI = prevI;
        }
        prevEnd = cur2.to - off;
        prevI = cx.block.children.length;
      }
      if (!cur2.nextSibling())
        break;
    }
    while (cx.block.children.length > blockI) {
      cx.block.children.pop();
      cx.block.positions.pop();
    }
    return end - start;
  }
};
function toRelative(abs, ranges) {
  let pos = abs;
  for (let i = 1; i < ranges.length; i++) {
    let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;
    if (gapFrom < abs)
      pos -= gapTo - gapFrom;
  }
  return pos;
}
var markdownHighlighting = styleTags({
  "Blockquote/...": tags.quote,
  HorizontalRule: tags.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": tags.heading1,
  "ATXHeading2/... SetextHeading2/...": tags.heading2,
  "ATXHeading3/...": tags.heading3,
  "ATXHeading4/...": tags.heading4,
  "ATXHeading5/...": tags.heading5,
  "ATXHeading6/...": tags.heading6,
  "Comment CommentBlock": tags.comment,
  Escape: tags.escape,
  Entity: tags.character,
  "Emphasis/...": tags.emphasis,
  "StrongEmphasis/...": tags.strong,
  "Link/... Image/...": tags.link,
  "OrderedList/... BulletList/...": tags.list,
  "BlockQuote/...": tags.quote,
  "InlineCode CodeText": tags.monospace,
  "URL Autolink": tags.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": tags.processingInstruction,
  "CodeInfo LinkLabel": tags.labelName,
  LinkTitle: tags.string,
  Paragraph: tags.content
});
var parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map((n) => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map((n) => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map((n) => DefaultInline[n]), Object.keys(DefaultInline), []);
function leftOverSpace(node, from, to) {
  let ranges = [];
  for (let n = node.firstChild, pos = from; ; n = n.nextSibling) {
    let nextPos = n ? n.from : to;
    if (nextPos > pos)
      ranges.push({ from: pos, to: nextPos });
    if (!n)
      break;
    pos = n.to;
  }
  return ranges;
}
function parseCode(config2) {
  let { codeParser, htmlParser } = config2;
  let wrap = parseMixed((node, input) => {
    let id2 = node.type.id;
    if (codeParser && (id2 == Type.CodeBlock || id2 == Type.FencedCode)) {
      let info = "";
      if (id2 == Type.FencedCode) {
        let infoNode = node.node.getChild(Type.CodeInfo);
        if (infoNode)
          info = input.read(infoNode.from, infoNode.to);
      }
      let parser5 = codeParser(info);
      if (parser5)
        return { parser: parser5, overlay: (node2) => node2.type.id == Type.CodeText, bracketed: id2 == Type.FencedCode };
    } else if (htmlParser && (id2 == Type.HTMLBlock || id2 == Type.HTMLTag || id2 == Type.CommentBlock)) {
      return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };
    }
    return null;
  });
  return { wrap };
}
var StrikethroughDelim = { resolve: "Strikethrough", mark: "StrikethroughMark" };
var Strikethrough = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": tags.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: tags.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(cx, next, pos) {
      if (next != 126 || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)
        return -1;
      let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);
      let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
      let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
      return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));
    },
    after: "Emphasis"
  }]
};
function parseRow(cx, line, startI = 0, elts, offset = 0) {
  let count2 = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;
  let parseCell = () => {
    elts.push(cx.elt("TableCell", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));
  };
  for (let i = startI; i < line.length; i++) {
    let next = line.charCodeAt(i);
    if (next == 124 && !esc) {
      if (!first || cellStart > -1)
        count2++;
      first = false;
      if (elts) {
        if (cellStart > -1)
          parseCell();
        elts.push(cx.elt("TableDelimiter", i + offset, i + offset + 1));
      }
      cellStart = cellEnd = -1;
    } else if (esc || next != 32 && next != 9) {
      if (cellStart < 0)
        cellStart = i;
      cellEnd = i + 1;
    }
    esc = !esc && next == 92;
  }
  if (cellStart > -1) {
    count2++;
    if (elts)
      parseCell();
  }
  return count2;
}
function hasPipe(str, start) {
  for (let i = start; i < str.length; i++) {
    let next = str.charCodeAt(i);
    if (next == 124)
      return true;
    if (next == 92)
      i++;
  }
  return false;
}
var delimiterLine = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
var TableParser = class {
  constructor() {
    this.rows = null;
  }
  nextLine(cx, line, leaf) {
    if (this.rows == null) {
      this.rows = false;
      let lineText;
      if ((line.next == 45 || line.next == 58 || line.next == 124) && delimiterLine.test(lineText = line.text.slice(line.pos))) {
        let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
        if (firstCount == parseRow(cx, lineText, line.pos))
          this.rows = [
            cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow),
            cx.elt("TableDelimiter", cx.lineStart + line.pos, cx.lineStart + line.text.length)
          ];
      }
    } else if (this.rows) {
      let content2 = [];
      parseRow(cx, line.text, line.pos, content2, cx.lineStart);
      this.rows.push(cx.elt("TableRow", cx.lineStart + line.pos, cx.lineStart + line.text.length, content2));
    }
    return false;
  }
  finish(cx, leaf) {
    if (!this.rows)
      return false;
    cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
    return true;
  }
};
var Table = {
  defineNodes: [
    { name: "Table", block: true },
    { name: "TableHeader", style: { "TableHeader/...": tags.heading } },
    "TableRow",
    { name: "TableCell", style: tags.content },
    { name: "TableDelimiter", style: tags.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(_, leaf) {
      return hasPipe(leaf.content, 0) ? new TableParser() : null;
    },
    endLeaf(cx, line, leaf) {
      if (leaf.parsers.some((p) => p instanceof TableParser) || !hasPipe(line.text, line.basePos))
        return false;
      let next = cx.peekLine();
      return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);
    },
    before: "SetextHeading"
  }]
};
var TaskParser = class {
  nextLine() {
    return false;
  }
  finish(cx, leaf) {
    cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [
      cx.elt("TaskMarker", leaf.start, leaf.start + 3),
      ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
    ]));
    return true;
  }
};
var TaskList = {
  defineNodes: [
    { name: "Task", block: true, style: tags.list },
    { name: "TaskMarker", style: tags.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(cx, leaf) {
      return /^\[[ xX]\][ \t]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser() : null;
    },
    after: "SetextHeading"
  }]
};
var autolinkRE = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy;
var urlRE = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy;
var lastTwoDomainWords = /[\w-]+\.[\w-]+($|\/)/;
var emailRE = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy;
var xmppResourceRE = /\/[a-zA-Z\d@.]+/gy;
function count(str, from, to, ch) {
  let result = 0;
  for (let i = from; i < to; i++)
    if (str[i] == ch)
      result++;
  return result;
}
function autolinkURLEnd(text, from) {
  urlRE.lastIndex = from;
  let m = urlRE.exec(text);
  if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf("_") > -1)
    return -1;
  let end = from + m[0].length;
  for (; ; ) {
    let last = text[end - 1], m2;
    if (/[?!.,:*_~]/.test(last) || last == ")" && count(text, from, end, ")") > count(text, from, end, "("))
      end--;
    else if (last == ";" && (m2 = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(text.slice(from, end))))
      end = from + m2.index;
    else
      break;
  }
  return end;
}
function autolinkEmailEnd(text, from) {
  emailRE.lastIndex = from;
  let m = emailRE.exec(text);
  if (!m)
    return -1;
  let last = m[0][m[0].length - 1];
  return last == "_" || last == "-" ? -1 : from + m[0].length - (last == "." ? 1 : 0);
}
var Autolink = {
  parseInline: [{
    name: "Autolink",
    parse(cx, next, absPos) {
      let pos = absPos - cx.offset;
      if (pos && /\w/.test(cx.text[pos - 1]))
        return -1;
      autolinkRE.lastIndex = pos;
      let m = autolinkRE.exec(cx.text), end = -1;
      if (!m)
        return -1;
      if (m[1] || m[2]) {
        end = autolinkURLEnd(cx.text, pos + m[0].length);
        if (end > -1 && cx.hasOpenLink) {
          let noBracket = /([^\[\]]|\[[^\]]*\])*/.exec(cx.text.slice(pos, end));
          end = pos + noBracket[0].length;
        }
      } else if (m[3]) {
        end = autolinkEmailEnd(cx.text, pos);
      } else {
        end = autolinkEmailEnd(cx.text, pos + m[0].length);
        if (end > -1 && m[0] == "xmpp:") {
          xmppResourceRE.lastIndex = end;
          m = xmppResourceRE.exec(cx.text);
          if (m)
            end = m.index + m[0].length;
        }
      }
      if (end < 0)
        return -1;
      cx.addElement(cx.elt("URL", absPos, end + cx.offset));
      return end + cx.offset;
    }
  }]
};
var GFM = [Table, TaskList, Strikethrough, Autolink];
function parseSubSuper(ch, node, mark) {
  return (cx, next, pos) => {
    if (next != ch || cx.char(pos + 1) == ch)
      return -1;
    let elts = [cx.elt(mark, pos, pos + 1)];
    for (let i = pos + 1; i < cx.end; i++) {
      let next2 = cx.char(i);
      if (next2 == ch)
        return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));
      if (next2 == 92)
        elts.push(cx.elt("Escape", i, i++ + 2));
      if (space(next2))
        break;
    }
    return -1;
  };
}
var Superscript = {
  defineNodes: [
    { name: "Superscript", style: tags.special(tags.content) },
    { name: "SuperscriptMark", style: tags.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
  }]
};
var Subscript = {
  defineNodes: [
    { name: "Subscript", style: tags.special(tags.content) },
    { name: "SubscriptMark", style: tags.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: parseSubSuper(126, "Subscript", "SubscriptMark")
  }]
};
var Emoji = {
  defineNodes: [{ name: "Emoji", style: tags.character }],
  parseInline: [{
    name: "Emoji",
    parse(cx, next, pos) {
      let match;
      if (next != 58 || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))
        return -1;
      return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match[0].length));
    }
  }]
};

// node_modules/@lezer/lr/dist/index.js
var Stack = class _Stack {
  /**
  @internal
  */
  constructor(p, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score2;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new _Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(action) {
    var _a2;
    let depth = action >> 19, type = action & 65535;
    let { parser: parser5 } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25 && this.setLookAhead(this.pos);
    let dPrec = parser5.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser5.getGoto(this.state, type, true), this.reducePos);
      if (type < parser5.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start;
    if (size >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size;
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size;
      }
    }
    let bufferBase = base2 ? this.stack[base2 - 1] : 0, count2 = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser5.minRepeatTerm || action & 131072) {
      let pos = parser5.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count2 + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser5.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base2)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(term, start, end, size = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur2 = this, top2 = this.buffer.length;
      if (top2 == 0 && cur2.parent) {
        top2 = cur2.bufferBase - cur2.parent.bufferBase;
        cur2 = cur2.parent;
      }
      if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
        if (start == end)
          return;
        if (cur2.buffer[top2 - 2] >= start) {
          cur2.buffer[top2 - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index = this.buffer.length;
      if (index > 0 && (this.buffer[index - 4] != 0 || this.buffer[index - 1] < 0)) {
        let mustMove = false;
        for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4)
              size -= 4;
          }
      }
      this.buffer[index] = term;
      this.buffer[index + 1] = start;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(action, type, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser5 } = this.p;
      this.pos = end;
      let skipped = parser5.stateFlag(
        nextState,
        1
        /* StateFlag.Skipped */
      );
      if (!skipped && (end > start || type <= parser5.maxNode))
        this.reducePos = end;
      this.pushState(nextState, skipped ? start : Math.min(start, this.reducePos));
      this.shiftContext(type, start);
      if (type <= parser5.maxNode)
        this.buffer.push(type, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode)
        this.buffer.push(type, start, end, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextStart, nextEnd);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(value, next) {
    let index = this.p.reused.length - 1;
    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(
      index,
      start,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    );
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
    while (parent && base2 == parent.bufferBase)
      parent = parent.parent;
    return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(
        sim.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(sim.state, term);
      if (action == 0)
        return false;
      if ((action & 65536) == 0)
        return true;
      sim.reduce(action);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s))
            best.push(nextStates[i], s);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: parser5 } = this.p;
    let reduce = parser5.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((reduce & 65536) == 0)
      return false;
    if (!parser5.validAction(this.state, reduce)) {
      let depth = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser5.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null)
          return false;
        reduce = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: parser5 } = this.p, seen = [];
    let explore = (state, depth) => {
      if (seen.includes(state))
        return;
      seen.push(state);
      return parser5.allActions(state, (action) => {
        if (action & (262144 | 131072)) ;
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth;
          if (rDepth > 1) {
            let term = action & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser5.getGoto(this.stack[target], term, false) >= 0)
              return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth + 1);
          if (found != null)
            return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    while (!this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    )) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser5 } = this.p;
    return parser5.data[parser5.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !parser5.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  /**
  @internal
  */
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  /**
  @internal
  */
  setLookAhead(lookAhead) {
    if (lookAhead <= this.lookAhead)
      return false;
    this.emitLookAhead();
    this.lookAhead = lookAhead;
    return true;
  }
  /**
  @internal
  */
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class _StackBufferCursor {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new _StackBufferCursor(this.stack, this.pos, this.index);
  }
};
function decodeArray(input, Type2 = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type2(value);
  }
  return array;
}
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  /**
  @internal
  */
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(offset, assoc) {
    let range = this.range, index = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index)
        return null;
      let next = this.ranges[--index];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  /**
  @internal
  */
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(n = 1) {
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  /**
  @internal
  */
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r of this.ranges) {
      if (r.from >= to)
        break;
      if (r.to > from)
        result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }
    return result;
  }
};
var TokenGroup = class {
  constructor(data2, id2) {
    this.data = data2;
    this.id = id2;
  }
  token(input, stack) {
    let { parser: parser5 } = stack.p;
    readToken(this.data, input, stack, this.id, parser5.data, parser5.tokenPrecTable);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var LocalTokenGroup = class {
  constructor(data2, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data2 == "string" ? decodeArray(data2) : data2;
  }
  token(input, stack) {
    let start = input.pos, skipped = 0;
    for (; ; ) {
      let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
      readToken(this.data, input, stack, 0, this.data, this.precTable);
      if (input.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (!atEof)
        skipped++;
      if (nextPos == null)
        break;
      input.reset(nextPos, input.token);
    }
    if (skipped) {
      input.reset(start, input.token);
      input.acceptToken(this.elseToken, skipped);
    }
  }
};
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var ExternalTokenizer = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
};
function readToken(data2, input, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
  scan: for (; ; ) {
    if ((groupMask & data2[state]) == 0)
      break;
    let accEnd = data2[state + 1];
    for (let i = state + 3; i < accEnd; i += 2)
      if ((data2[i + 1] & groupMask) > 0) {
        let term = data2[i];
        if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
          input.acceptToken(term);
          break;
        }
      }
    let next = input.next, low = 0, high = data2[state + 2];
    if (input.next < 0 && high > low && data2[accEnd + high * 3 - 3] == 65535) {
      state = data2[accEnd + high * 3 - 1];
      continue scan;
    }
    for (; low < high; ) {
      let mid = low + high >> 1;
      let index = accEnd + mid + (mid << 1);
      let from = data2[index], to = data2[index + 1] || 65536;
      if (next < from)
        high = mid;
      else if (next >= to)
        low = mid + 1;
      else {
        state = data2[index + 2];
        input.advance();
        continue scan;
      }
    }
    break;
  }
}
function findOffset(data2, start, term) {
  for (let i = start, next; (next = data2[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor2 = tree.cursor(IterMode.IncludeAnonymous);
  cursor2.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
          return side < 0 ? Math.max(0, Math.min(
            cursor2.to - 1,
            pos - 25
            /* Lookahead.Margin */
          )) : Math.min(tree.length, Math.max(
            cursor2.from + 1,
            pos + 25
            /* Lookahead.Margin */
          ));
        if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
          break;
        if (!cursor2.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor3 = class {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last], index = this.index[last];
      if (index == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top2.children[index];
      let start = this.start[last] + top2.positions[index];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser5, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser5.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser5 } = stack.p, { tokenizers } = parser5;
    let mask = parser5.stateSlot(
      stack.state,
      3
      /* ParseState.TokenizerMask */
    );
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let { parser: parser5 } = stack.p;
      for (let i = 0; i < parser5.specialized.length; i++)
        if (parser5.specialized[i] == token.value) {
          let result = parser5.specializers[i](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index) {
    for (let i = 0; i < index; i += 3)
      if (this.actions[i] == action)
        return index;
    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }
  addActions(stack, token, end, index) {
    let { state } = stack, { parser: parser5 } = stack.p, { data: data2 } = parser5;
    for (let set = 0; set < 2; set++) {
      for (let i = parser5.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ); ; i += 3) {
        if (data2[i] == 65535) {
          if (data2[i + 1] == 1) {
            i = pair(data2, i + 2);
          } else {
            if (index == 0 && data2[i + 1] == 2)
              index = this.putAction(pair(data2, i + 2), token, end, index);
            break;
          }
        }
        if (data2[i] == token)
          index = this.putAction(pair(data2, i + 1), token, end, index);
      }
    }
    return index;
  }
};
var Parse = class {
  constructor(parser5, input, fragments, ranges) {
    this.parser = parser5;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser5, this.stream);
    this.topTerm = parser5.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser5.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser5.bufferLength * 4 ? new FragmentCursor3(fragments, parser5.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s] = stacks;
      while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose)
          console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose)
          console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s) => s.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer: for (let i = 0; i < newStacks.length - 1; i++) {
        let stack = newStacks[i];
        for (let j = i + 1; j < newStacks.length; j++) {
          let other = newStacks[j];
          if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
              newStacks.splice(j--, 1);
            } else {
              newStacks.splice(i--, 1);
              continue outer;
            }
          }
        }
      }
      if (newStacks.length > 12) {
        newStacks.sort((a, b) => b.score - a.score);
        newStacks.splice(
          12,
          newStacks.length - 12
          /* Rec.MaxStackCount */
        );
      }
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos)
        this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser5 } = this;
    let base2 = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser5.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser5.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser5.stateSlot(
      stack.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser5.getName(
          defaultReduce & 65535
          /* Action.ValueMask */
        )})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end);
      if (verbose)
        console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser5.getName(
          action & 65535
          /* Action.ValueMask */
        )}`} for ${parser5.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base2 + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base2;
      for (let j = 0; j < 10 && force.forceReduce(); j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < force.score) {
        finished = force;
      }
    }
    return finished;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var id = (x) => x;
var ContextTracker = class {
  /**
  Define a context tracker.
  */
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
};
var LRParser = class _LRParser extends Parser {
  /**
  @internal
  */
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i = 0; i < this.specializerSpecs.length; i++)
      this.specialized[i] = this.specializerSpecs[i].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(state, terminal) {
    let data2 = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ), next; ; i += 3) {
        if ((next = data2[i]) == 65535) {
          if (data2[i + 1] == 1)
            next = data2[i = pair(data2, i + 2)];
          else if (data2[i + 1] == 2)
            return pair(data2, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data2, i + 1);
      }
    }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  /**
  @internal
  */
  stateFlag(state, flag) {
    return (this.stateSlot(
      state,
      0
      /* ParseState.Flags */
    ) & flag) > 0;
  }
  /**
  @internal
  */
  validAction(state, action) {
    return !!this.allActions(state, (a) => a == action ? true : null);
  }
  /**
  @internal
  */
  allActions(state, action) {
    let deflt = this.stateSlot(
      state,
      4
      /* ParseState.DefaultReduce */
    );
    let result = deflt ? action(deflt) : void 0;
    for (let i = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); result == null; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      result = action(pair(this.data, i + 1));
    }
    return result;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(config2) {
    let copy = Object.assign(Object.create(_LRParser.prototype), this);
    if (config2.props)
      copy.nodeSet = this.nodeSet.extend(...config2.props);
    if (config2.top) {
      let info = this.topRules[config2.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config2.top}`);
      copy.top = info;
    }
    if (config2.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config2.tokenizers.find((r) => r.from == t2);
        return found ? found.to : t2;
      });
    if (config2.specializers) {
      copy.specializers = this.specializers.slice();
      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
        let found = config2.specializers.find((r) => r.from == s.external);
        if (!found)
          return s;
        let spec = Object.assign(Object.assign({}, s), { external: found.to });
        copy.specializers[i] = getSpecializer(spec);
        return spec;
      });
    }
    if (config2.contextTracker)
      copy.context = config2.contextTracker;
    if (config2.dialect)
      copy.dialect = this.parseDialect(config2.dialect);
    if (config2.strict != null)
      copy.strict = config2.strict;
    if (config2.wrap)
      copy.wrappers = copy.wrappers.concat(config2.wrap);
    if (config2.bufferLength != null)
      copy.bufferLength = config2.bufferLength;
    return copy;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  /**
  @internal
  */
  parseDialect(dialect) {
    let values2 = Object.keys(this.dialects), flags = values2.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values2.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i = 0; i < values2.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values2[i]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(spec) {
    return new _LRParser(spec);
  }
};
function pair(data2, off) {
  return data2[off] | data2[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
      stack.state,
      2
      /* StateFlag.Accepting */
    ) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}

// node_modules/@lezer/html/dist/index.js
var scriptText = 55;
var StartCloseScriptTag = 1;
var styleText = 56;
var StartCloseStyleTag = 2;
var textareaText = 57;
var StartCloseTextareaTag = 3;
var EndTag = 4;
var SelfClosingEndTag = 5;
var StartTag = 6;
var StartScriptTag = 7;
var StartStyleTag = 8;
var StartTextareaTag = 9;
var StartSelfClosingTag = 10;
var StartCloseTag = 11;
var NoMatchStartCloseTag = 12;
var MismatchedStartCloseTag = 13;
var missingCloseTag = 58;
var IncompleteTag = 14;
var IncompleteCloseTag = 15;
var commentContent$1 = 59;
var Element2 = 21;
var TagName = 23;
var Attribute = 24;
var AttributeName = 25;
var AttributeValue = 27;
var UnquotedAttributeValue = 28;
var ScriptText = 29;
var StyleText = 32;
var TextareaText = 35;
var OpenTag = 37;
var CloseTag = 38;
var Dialect_noMatch = 0;
var Dialect_selfClosing = 1;
var selfClosers = {
  area: true,
  base: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
  menuitem: true
};
var implicitlyClosed = {
  dd: true,
  li: true,
  optgroup: true,
  option: true,
  p: true,
  rp: true,
  rt: true,
  tbody: true,
  td: true,
  tfoot: true,
  th: true,
  tr: true
};
var closeOnOpen = {
  dd: { dd: true, dt: true },
  dt: { dd: true, dt: true },
  li: { li: true },
  option: { option: true, optgroup: true },
  optgroup: { optgroup: true },
  p: {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    dir: true,
    div: true,
    dl: true,
    fieldset: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    menu: true,
    nav: true,
    ol: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    ul: true
  },
  rp: { rp: true, rt: true },
  rt: { rp: true, rt: true },
  tbody: { tbody: true, tfoot: true },
  td: { td: true, th: true },
  tfoot: { tbody: true },
  th: { td: true, th: true },
  thead: { tbody: true, tfoot: true },
  tr: { tr: true }
};
function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
}
var cachedName = null;
var cachedInput = null;
var cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedPos == pos && cachedInput == input) return cachedName;
  let next = input.peek(offset), name2 = "";
  for (; ; ) {
    if (!nameChar(next)) break;
    name2 += String.fromCharCode(next);
    next = input.peek(++offset);
  }
  cachedInput = input;
  cachedPos = pos;
  return cachedName = name2 ? name2.toLowerCase() : next == question || next == bang ? void 0 : null;
}
var lessThan = 60;
var greaterThan = 62;
var slash = 47;
var question = 63;
var bang = 33;
var dash = 45;
function ElementContext(name2, parent) {
  this.name = name2;
  this.parent = parent;
}
var startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];
var elementContext = new ContextTracker({
  start: null,
  shift(context, term, stack, input) {
    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
  },
  reduce(context, term) {
    return term == Element2 && context ? context.parent : context;
  },
  reuse(context, node, stack, input) {
    let type = node.type.id;
    return type == StartTag || type == OpenTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
  },
  strict: false
});
var tagStart = new ExternalTokenizer((input, stack) => {
  if (input.next != lessThan) {
    if (input.next < 0 && stack.context) input.acceptToken(missingCloseTag);
    return;
  }
  input.advance();
  let close = input.next == slash;
  if (close) input.advance();
  let name2 = tagNameAfter(input, 0);
  if (name2 === void 0) return;
  if (!name2) return input.acceptToken(close ? IncompleteCloseTag : IncompleteTag);
  let parent = stack.context ? stack.context.name : null;
  if (close) {
    if (name2 == parent) return input.acceptToken(StartCloseTag);
    if (parent && implicitlyClosed[parent]) return input.acceptToken(missingCloseTag, -2);
    if (stack.dialectEnabled(Dialect_noMatch)) return input.acceptToken(NoMatchStartCloseTag);
    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name2) return;
    input.acceptToken(MismatchedStartCloseTag);
  } else {
    if (name2 == "script") return input.acceptToken(StartScriptTag);
    if (name2 == "style") return input.acceptToken(StartStyleTag);
    if (name2 == "textarea") return input.acceptToken(StartTextareaTag);
    if (selfClosers.hasOwnProperty(name2)) return input.acceptToken(StartSelfClosingTag);
    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name2]) input.acceptToken(missingCloseTag, -1);
    else input.acceptToken(StartTag);
  }
}, { contextual: true });
var commentContent = new ExternalTokenizer((input) => {
  for (let dashes = 0, i = 0; ; i++) {
    if (input.next < 0) {
      if (i) input.acceptToken(commentContent$1);
      break;
    }
    if (input.next == dash) {
      dashes++;
    } else if (input.next == greaterThan && dashes >= 2) {
      if (i >= 3) input.acceptToken(commentContent$1, -2);
      break;
    } else {
      dashes = 0;
    }
    input.advance();
  }
});
function inForeignElement(context) {
  for (; context; context = context.parent)
    if (context.name == "svg" || context.name == "math") return true;
  return false;
}
var endTag = new ExternalTokenizer((input, stack) => {
  if (input.next == slash && input.peek(1) == greaterThan) {
    let selfClosing = stack.dialectEnabled(Dialect_selfClosing) || inForeignElement(stack.context);
    input.acceptToken(selfClosing ? SelfClosingEndTag : EndTag, 2);
  } else if (input.next == greaterThan) {
    input.acceptToken(EndTag, 1);
  }
});
function contentTokenizer(tag, textToken, endToken) {
  let lastState = 2 + tag.length;
  return new ExternalTokenizer((input) => {
    for (let state = 0, matchedLen = 0, i = 0; ; i++) {
      if (input.next < 0) {
        if (i) input.acceptToken(textToken);
        break;
      }
      if (state == 0 && input.next == lessThan || state == 1 && input.next == slash || state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {
        state++;
        matchedLen++;
      } else if (state == lastState && input.next == greaterThan) {
        if (i > matchedLen)
          input.acceptToken(textToken, -matchedLen);
        else
          input.acceptToken(endToken, -(matchedLen - 2));
        break;
      } else if ((input.next == 10 || input.next == 13) && i) {
        input.acceptToken(textToken, 1);
        break;
      } else {
        state = matchedLen = 0;
      }
      input.advance();
    }
  });
}
var scriptTokens = contentTokenizer("script", scriptText, StartCloseScriptTag);
var styleTokens = contentTokenizer("style", styleText, StartCloseStyleTag);
var textareaTokens = contentTokenizer("textarea", textareaText, StartCloseTextareaTag);
var htmlHighlighting = styleTags({
  "Text RawText IncompleteTag IncompleteCloseTag": tags.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": tags.angleBracket,
  TagName: tags.tagName,
  "MismatchedCloseTag/TagName": [tags.tagName, tags.invalid],
  AttributeName: tags.attributeName,
  "AttributeValue UnquotedAttributeValue": tags.attributeValue,
  Is: tags.definitionOperator,
  "EntityReference CharacterReference": tags.character,
  Comment: tags.blockComment,
  ProcessingInst: tags.processingInstruction,
  DoctypeDecl: tags.documentMeta
});
var parser2 = LRParser.deserialize({
  version: 14,
  states: ",xOVO!rOOO!ZQ#tO'#CrO!`Q#tO'#C{O!eQ#tO'#DOO!jQ#tO'#DRO!oQ#tO'#DTO!tOaO'#CqO#PObO'#CqO#[OdO'#CqO$kO!rO'#CqOOO`'#Cq'#CqO$rO$fO'#DUO$zQ#tO'#DWO%PQ#tO'#DXOOO`'#Dl'#DlOOO`'#DZ'#DZQVO!rOOO%UQ&rO,59^O%aQ&rO,59gO%lQ&rO,59jO%wQ&rO,59mO&SQ&rO,59oOOOa'#D_'#D_O&_OaO'#CyO&jOaO,59]OOOb'#D`'#D`O&rObO'#C|O&}ObO,59]OOOd'#Da'#DaO'VOdO'#DPO'bOdO,59]OOO`'#Db'#DbO'jO!rO,59]O'qQ#tO'#DSOOO`,59],59]OOOp'#Dc'#DcO'vO$fO,59pOOO`,59p,59pO(OQ#|O,59rO(TQ#|O,59sOOO`-E7X-E7XO(YQ&rO'#CtOOQW'#D['#D[O(hQ&rO1G.xOOOa1G.x1G.xOOO`1G/Z1G/ZO(sQ&rO1G/ROOOb1G/R1G/RO)OQ&rO1G/UOOOd1G/U1G/UO)ZQ&rO1G/XOOO`1G/X1G/XO)fQ&rO1G/ZOOOa-E7]-E7]O)qQ#tO'#CzOOO`1G.w1G.wOOOb-E7^-E7^O)vQ#tO'#C}OOOd-E7_-E7_O){Q#tO'#DQOOO`-E7`-E7`O*QQ#|O,59nOOOp-E7a-E7aOOO`1G/[1G/[OOO`1G/^1G/^OOO`1G/_1G/_O*VQ,UO,59`OOQW-E7Y-E7YOOOa7+$d7+$dOOO`7+$u7+$uOOOb7+$m7+$mOOOd7+$p7+$pOOO`7+$s7+$sO*bQ#|O,59fO*gQ#|O,59iO*lQ#|O,59lOOO`1G/Y1G/YO*qO7[O'#CwO+SOMhO'#CwOOQW1G.z1G.zOOO`1G/Q1G/QOOO`1G/T1G/TOOO`1G/W1G/WOOOO'#D]'#D]O+eO7[O,59cOOQW,59c,59cOOOO'#D^'#D^O+vOMhO,59cOOOO-E7Z-E7ZOOQW1G.}1G.}OOOO-E7[-E7[",
  stateData: ",c~O!_OS~OUSOVPOWQOXROYTO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O|_O!eZO~OgaO~OgbO~OgcO~OgdO~OgeO~O!XfOPmP![mP~O!YiOQpP![pP~O!ZlORsP![sP~OUSOVPOWQOXROYTOZqO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O!eZO~O![rO~P#gO!]sO!fuO~OgvO~OgwO~OS|OT}OiyO~OS!POT}OiyO~OS!ROT}OiyO~OS!TOT}OiyO~OS}OT}OiyO~O!XfOPmX![mX~OP!WO![!XO~O!YiOQpX![pX~OQ!ZO![!XO~O!ZlORsX![sX~OR!]O![!XO~O![!XO~P#gOg!_O~O!]sO!f!aO~OS!bO~OS!cO~Oj!dOShXThXihX~OS!fOT!gOiyO~OS!hOT!gOiyO~OS!iOT!gOiyO~OS!jOT!gOiyO~OS!gOT!gOiyO~Og!kO~Og!lO~Og!mO~OS!nO~Ol!qO!a!oO!c!pO~OS!rO~OS!sO~OS!tO~Ob!uOc!uOd!uO!a!wO!b!uO~Ob!xOc!xOd!xO!c!wO!d!xO~Ob!uOc!uOd!uO!a!{O!b!uO~Ob!xOc!xOd!xO!c!{O!d!xO~OT~cbd!ey|!e~",
  goto: "%q!aPPPPPPPPPPPPPPPPPPPPP!b!hP!nPP!zP!}#Q#T#Z#^#a#g#j#m#s#y!bP!b!bP$P$V$m$s$y%P%V%]%cPPPPPPPP%iX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "\u26A0 StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 68,
  context: elementContext,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 22, 31, 34, 37, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 30, 33, 36, 38, "OpenTag"],
    ["group", -10, 14, 15, 18, 19, 20, 21, 40, 41, 42, 43, "Entity", 17, "Entity TextContent", -3, 29, 32, 35, "TextContent Entity"],
    ["isolate", -11, 22, 30, 31, 33, 34, 36, 37, 38, 39, 42, 43, "ltr", -3, 27, 28, 40, ""]
  ],
  propSources: [htmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|caPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bXaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UVaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pTaPOv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!dpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({WaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!b`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!b`!dpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYlWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`aP!b`!dp!_^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebiSlWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXiSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vciSaP!b`!dpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!ahaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WiiSlWd!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zblWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOb!R!R7tP;=`<%l7S!Z8OYlWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{iiSlWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbiSlWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QciSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXiSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TalWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOc!R!RAwP;=`<%lAY!ZBRYlWc!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbiSlWc!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbiSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXiSc!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!cxaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYliSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_kiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_XaP!b`!dp!fQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZiSgQaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!b`!dpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!b`!dp!ePOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!b`!dpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!b`!dpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!b`!dpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!b`!dpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!b`!dpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!b`!dpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!b`!dpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!dpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO|PP!-nP;=`<%l!-Sq!-xS!dp|POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!b`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!b`|POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!b`!dp|POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!b`!dpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!b`!dpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!b`!dpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!b`!dpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!b`!dpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!b`!dpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!dpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOyPP!7TP;=`<%l!6Vq!7]V!dpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!dpyPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!b`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!b`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!b`yPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!b`!dpyPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXjSaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [scriptTokens, styleTokens, textareaTokens, endTag, tagStart, commentContent, 0, 1, 2, 3, 4, 5],
  topRules: { "Document": [0, 16] },
  dialects: { noMatch: 0, selfClosing: 515 },
  tokenPrec: 517
});
function getAttrs2(openTag, input) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let att of openTag.getChildren(Attribute)) {
    let name2 = att.getChild(AttributeName), value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);
    if (name2) attrs[input.read(name2.from, name2.to)] = !value ? "" : value.type.id == AttributeValue ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
  }
  return attrs;
}
function findTagName(openTag, input) {
  let tagNameNode = openTag.getChild(TagName);
  return tagNameNode ? input.read(tagNameNode.from, tagNameNode.to) : " ";
}
function maybeNest(node, input, tags3) {
  let attrs;
  for (let tag of tags3) {
    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs2(node.node.parent.firstChild, input))))
      return { parser: tag.parser, bracketed: true };
  }
  return null;
}
function configureNesting(tags3 = [], attributes = []) {
  let script = [], style = [], textarea = [], other = [];
  for (let tag of tags3) {
    let array = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : other;
    array.push(tag);
  }
  let attrs = attributes.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let attr of attributes) (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);
  return parseMixed((node, input) => {
    let id2 = node.type.id;
    if (id2 == ScriptText) return maybeNest(node, input, script);
    if (id2 == StyleText) return maybeNest(node, input, style);
    if (id2 == TextareaText) return maybeNest(node, input, textarea);
    if (id2 == Element2 && other.length) {
      let n = node.node, open = n.firstChild, tagName = open && findTagName(open, input), attrs2;
      if (tagName) for (let tag of other) {
        if (tag.tag == tagName && (!tag.attrs || tag.attrs(attrs2 || (attrs2 = getAttrs2(open, input))))) {
          let close = n.lastChild;
          let to = close.type.id == CloseTag ? close.from : n.to;
          if (to > open.to)
            return { parser: tag.parser, overlay: [{ from: open.to, to }] };
        }
      }
    }
    if (attrs && id2 == Attribute) {
      let n = node.node, nameNode;
      if (nameNode = n.firstChild) {
        let matches = attrs[input.read(nameNode.from, nameNode.to)];
        if (matches) for (let attr of matches) {
          if (attr.tagName && attr.tagName != findTagName(n.parent, input)) continue;
          let value = n.lastChild;
          if (value.type.id == AttributeValue) {
            let from = value.from + 1;
            let last = value.lastChild, to = value.to - (last && last.isError ? 0 : 1);
            if (to > from) return { parser: attr.parser, overlay: [{ from, to }], bracketed: true };
          } else if (value.type.id == UnquotedAttributeValue) {
            return { parser: attr.parser, overlay: [{ from: value.from, to: value.to }] };
          }
        }
      }
    }
    return null;
  });
}

// node_modules/@lezer/css/dist/index.js
var descendantOp = 122;
var Unit = 1;
var identifier = 123;
var callee = 124;
var VariableName = 2;
var queryIdentifier = 125;
var queryVariableName = 3;
var QueryCallee = 4;
var space2 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var colon = 58;
var parenL = 40;
var underscore = 95;
var bracketL = 91;
var dash2 = 45;
var period = 46;
var hash = 35;
var percent = 37;
var ampersand = 38;
var backslash = 92;
var newline = 10;
var asterisk = 42;
function isAlpha(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
function isHex(ch) {
  return isDigit(ch) || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70;
}
var identifierTokens = (id2, varName, callee2) => (input, stack) => {
  for (let inside = false, dashes = 0, i = 0; ; i++) {
    let { next } = input;
    if (isAlpha(next) || next == dash2 || next == underscore || inside && isDigit(next)) {
      if (!inside && (next != dash2 || i > 0)) inside = true;
      if (dashes === i && next == dash2) dashes++;
      input.advance();
    } else if (next == backslash && input.peek(1) != newline) {
      input.advance();
      if (isHex(input.next)) {
        do {
          input.advance();
        } while (isHex(input.next));
        if (input.next == 32) input.advance();
      } else if (input.next > -1) {
        input.advance();
      }
      inside = true;
    } else {
      if (inside) input.acceptToken(
        dashes == 2 && stack.canShift(VariableName) ? varName : next == parenL ? callee2 : id2
      );
      break;
    }
  }
};
var identifiers = new ExternalTokenizer(
  identifierTokens(identifier, VariableName, callee)
);
var queryIdentifiers = new ExternalTokenizer(
  identifierTokens(queryIdentifier, queryVariableName, QueryCallee)
);
var descendant = new ExternalTokenizer((input) => {
  if (space2.includes(input.peek(-1))) {
    let { next } = input;
    if (isAlpha(next) || next == underscore || next == hash || next == period || next == asterisk || next == bracketL || next == colon && isAlpha(input.peek(1)) || next == dash2 || next == ampersand)
      input.acceptToken(descendantOp);
  }
});
var unitToken = new ExternalTokenizer((input) => {
  if (!space2.includes(input.peek(-1))) {
    let { next } = input;
    if (next == percent) {
      input.advance();
      input.acceptToken(Unit);
    }
    if (isAlpha(next)) {
      do {
        input.advance();
      } while (isAlpha(input.next) || isDigit(input.next));
      input.acceptToken(Unit);
    }
  }
});
var cssHighlighting = styleTags({
  "AtKeyword import charset namespace keyframes media supports": tags.definitionKeyword,
  "from to selector": tags.keyword,
  NamespaceName: tags.namespace,
  KeyframeName: tags.labelName,
  KeyframeRangeName: tags.operatorKeyword,
  TagName: tags.tagName,
  ClassName: tags.className,
  PseudoClassName: tags.constant(tags.className),
  IdName: tags.labelName,
  "FeatureName PropertyName": tags.propertyName,
  AttributeName: tags.attributeName,
  NumberLiteral: tags.number,
  KeywordQuery: tags.keyword,
  UnaryQueryOp: tags.operatorKeyword,
  "CallTag ValueName": tags.atom,
  VariableName: tags.variableName,
  Callee: tags.operatorKeyword,
  Unit: tags.unit,
  "UniversalSelector NestingSelector": tags.definitionOperator,
  "MatchOp CompareOp": tags.compareOperator,
  "ChildOp SiblingOp, LogicOp": tags.logicOperator,
  BinOp: tags.arithmeticOperator,
  Important: tags.modifier,
  Comment: tags.blockComment,
  ColorLiteral: tags.color,
  "ParenthesizedContent StringLiteral": tags.string,
  ":": tags.punctuation,
  "PseudoOp #": tags.derefOperator,
  "; ,": tags.separator,
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace
});
var spec_callee = { __proto__: null, lang: 38, "nth-child": 38, "nth-last-child": 38, "nth-of-type": 38, "nth-last-of-type": 38, dir: 38, "host-context": 38, if: 84, url: 124, "url-prefix": 124, domain: 124, regexp: 124 };
var spec_queryIdentifier = { __proto__: null, or: 98, and: 98, not: 106, only: 106, layer: 170 };
var spec_QueryCallee = { __proto__: null, selector: 112, layer: 166 };
var spec_AtKeyword = { __proto__: null, "@import": 162, "@media": 174, "@charset": 178, "@namespace": 182, "@keyframes": 188, "@supports": 200, "@scope": 204 };
var spec_identifier = { __proto__: null, to: 207 };
var parser3 = LRParser.deserialize({
  version: 14,
  states: "EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a",
  stateData: "Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~",
  goto: "2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P",
  nodeNames: "\u26A0 Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles",
  maxTerm: 143,
  nodeProps: [
    ["isolate", -2, 5, 36, ""],
    ["openedBy", 20, "(", 28, "[", 31, "{"],
    ["closedBy", 21, ")", 29, "]", 32, "}"]
  ],
  propSources: [cssHighlighting],
  skippedNodes: [0, 5, 106],
  repeatNodeCount: 15,
  tokenData: "JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q",
  tokenizers: [descendant, unitToken, identifiers, queryIdentifiers, 1, 2, 3, 4, new LocalTokenGroup("m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~", 28, 129)],
  topRules: { "StyleSheet": [0, 6], "Styles": [1, 105] },
  specialized: [{ term: 124, get: (value) => spec_callee[value] || -1 }, { term: 125, get: (value) => spec_queryIdentifier[value] || -1 }, { term: 4, get: (value) => spec_QueryCallee[value] || -1 }, { term: 25, get: (value) => spec_AtKeyword[value] || -1 }, { term: 123, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 1963
});

// node_modules/@codemirror/lang-css/dist/index.js
var _properties = null;
function properties() {
  if (!_properties && typeof document == "object" && document.body) {
    let { style } = document.body, names = [], seen = /* @__PURE__ */ new Set();
    for (let prop in style)
      if (prop != "cssText" && prop != "cssFloat") {
        if (typeof style[prop] == "string") {
          if (/[A-Z]/.test(prop))
            prop = prop.replace(/[A-Z]/g, (ch) => "-" + ch.toLowerCase());
          if (!seen.has(prop)) {
            names.push(prop);
            seen.add(prop);
          }
        }
      }
    _properties = names.sort().map((name2) => ({ type: "property", label: name2, apply: name2 + ": " }));
  }
  return _properties || [];
}
var pseudoClasses = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((name2) => ({ type: "class", label: name2 }));
var values = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((name2) => ({ type: "keyword", label: name2 })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((name2) => ({ type: "constant", label: name2 })));
var tags2 = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((name2) => ({ type: "type", label: name2 }));
var atRules = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((label) => ({ type: "keyword", label }));
var identifier2 = /^(\w[\w-]*|-\w[\w-]*|)$/;
var variable = /^-(-[\w-]*)?$/;
function isVarArg(node, doc2) {
  var _a2;
  if (node.name == "(" || node.type.isError)
    node = node.parent || node;
  if (node.name != "ArgList")
    return false;
  let callee2 = (_a2 = node.parent) === null || _a2 === void 0 ? void 0 : _a2.firstChild;
  if ((callee2 === null || callee2 === void 0 ? void 0 : callee2.name) != "Callee")
    return false;
  return doc2.sliceString(callee2.from, callee2.to) == "var";
}
var VariablesByNode = /* @__PURE__ */ new NodeWeakMap();
var declSelector = ["Declaration"];
function astTop(node) {
  for (let cur2 = node; ; ) {
    if (cur2.type.isTop)
      return cur2;
    if (!(cur2 = cur2.parent))
      return node;
  }
}
function variableNames(doc2, node, isVariable) {
  if (node.to - node.from > 4096) {
    let known = VariablesByNode.get(node);
    if (known)
      return known;
    let result = [], seen = /* @__PURE__ */ new Set(), cursor2 = node.cursor(IterMode.IncludeAnonymous);
    if (cursor2.firstChild())
      do {
        for (let option of variableNames(doc2, cursor2.node, isVariable))
          if (!seen.has(option.label)) {
            seen.add(option.label);
            result.push(option);
          }
      } while (cursor2.nextSibling());
    VariablesByNode.set(node, result);
    return result;
  } else {
    let result = [], seen = /* @__PURE__ */ new Set();
    node.cursor().iterate((node2) => {
      var _a2;
      if (isVariable(node2) && node2.matchContext(declSelector) && ((_a2 = node2.node.nextSibling) === null || _a2 === void 0 ? void 0 : _a2.name) == ":") {
        let name2 = doc2.sliceString(node2.from, node2.to);
        if (!seen.has(name2)) {
          seen.add(name2);
          result.push({ label: name2, type: "variable" });
        }
      }
    });
    return result;
  }
}
var defineCSSCompletionSource = (isVariable) => (context) => {
  let { state, pos } = context, node = syntaxTree(state).resolveInner(pos, -1);
  let isDash = node.type.isError && node.from == node.to - 1 && state.doc.sliceString(node.from, node.to) == "-";
  if (node.name == "PropertyName" || (isDash || node.name == "TagName") && /^(Block|Styles)$/.test(node.resolve(node.to).name))
    return { from: node.from, options: properties(), validFor: identifier2 };
  if (node.name == "ValueName")
    return { from: node.from, options: values, validFor: identifier2 };
  if (node.name == "PseudoClassName")
    return { from: node.from, options: pseudoClasses, validFor: identifier2 };
  if (isVariable(node) || (context.explicit || isDash) && isVarArg(node, state.doc))
    return {
      from: isVariable(node) || isDash ? node.from : pos,
      options: variableNames(state.doc, astTop(node), isVariable),
      validFor: variable
    };
  if (node.name == "TagName") {
    for (let { parent } = node; parent; parent = parent.parent)
      if (parent.name == "Block")
        return { from: node.from, options: properties(), validFor: identifier2 };
    return { from: node.from, options: tags2, validFor: identifier2 };
  }
  if (node.name == "AtKeyword")
    return { from: node.from, options: atRules, validFor: identifier2 };
  if (!context.explicit)
    return null;
  let above = node.resolve(pos), before = above.childBefore(pos);
  if (before && before.name == ":" && above.name == "PseudoClassSelector")
    return { from: pos, options: pseudoClasses, validFor: identifier2 };
  if (before && before.name == ":" && above.name == "Declaration" || above.name == "ArgList")
    return { from: pos, options: values, validFor: identifier2 };
  if (above.name == "Block" || above.name == "Styles")
    return { from: pos, options: properties(), validFor: identifier2 };
  return null;
};
var cssCompletionSource = /* @__PURE__ */ defineCSSCompletionSource((n) => n.name == "VariableName");
var cssLanguage = /* @__PURE__ */ LRLanguage.define({
  name: "css",
  parser: /* @__PURE__ */ parser3.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Declaration: /* @__PURE__ */ continuedIndent()
      }),
      /* @__PURE__ */ foldNodeProp.add({
        "Block KeyframeList": foldInside
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function css() {
  return new LanguageSupport(cssLanguage, cssLanguage.data.of({ autocomplete: cssCompletionSource }));
}

// node_modules/@lezer/javascript/dist/index.js
var noSemi = 316;
var noSemiType = 317;
var incdec = 1;
var incdecPrefix = 2;
var questionDot = 3;
var JSXStartTag = 4;
var insertSemi = 318;
var spaces = 320;
var newline2 = 321;
var LineComment = 5;
var BlockComment = 6;
var Dialect_jsx = 0;
var space3 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var braceR = 125;
var semicolon = 59;
var slash2 = 47;
var star = 42;
var plus = 43;
var minus = 45;
var lt = 60;
var comma = 44;
var question2 = 63;
var dot = 46;
var bracketL2 = 91;
var trackNewline = new ContextTracker({
  start: false,
  shift(context, term) {
    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline2;
  },
  strict: false
});
var insertSemicolon = new ExternalTokenizer((input, stack) => {
  let { next } = input;
  if (next == braceR || next == -1 || stack.context)
    input.acceptToken(insertSemi);
}, { contextual: true, fallback: true });
var noSemicolon = new ExternalTokenizer((input, stack) => {
  let { next } = input, after;
  if (space3.indexOf(next) > -1) return;
  if (next == slash2 && ((after = input.peek(1)) == slash2 || after == star)) return;
  if (next != braceR && next != semicolon && next != -1 && !stack.context)
    input.acceptToken(noSemi);
}, { contextual: true });
var noSemicolonType = new ExternalTokenizer((input, stack) => {
  if (input.next == bracketL2 && !stack.context) input.acceptToken(noSemiType);
}, { contextual: true });
var operatorToken = new ExternalTokenizer((input, stack) => {
  let { next } = input;
  if (next == plus || next == minus) {
    input.advance();
    if (next == input.next) {
      input.advance();
      let mayPostfix = !stack.context && stack.canShift(incdec);
      input.acceptToken(mayPostfix ? incdec : incdecPrefix);
    }
  } else if (next == question2 && input.peek(1) == dot) {
    input.advance();
    input.advance();
    if (input.next < 48 || input.next > 57)
      input.acceptToken(questionDot);
  }
}, { contextual: true });
function identifierChar(ch, start) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 || !start && ch >= 48 && ch <= 57;
}
var jsx = new ExternalTokenizer((input, stack) => {
  if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return;
  input.advance();
  if (input.next == slash2) return;
  let back = 0;
  while (space3.indexOf(input.next) > -1) {
    input.advance();
    back++;
  }
  if (identifierChar(input.next, true)) {
    input.advance();
    back++;
    while (identifierChar(input.next, false)) {
      input.advance();
      back++;
    }
    while (space3.indexOf(input.next) > -1) {
      input.advance();
      back++;
    }
    if (input.next == comma) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!identifierChar(input.next, true)) return;
        break;
      }
      if (input.next != "extends".charCodeAt(i)) break;
      input.advance();
      back++;
    }
  }
  input.acceptToken(JSXStartTag, -back);
});
var jsHighlight = styleTags({
  "get set async static": tags.modifier,
  "for while do if else switch try catch finally return throw break continue default case defer": tags.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": tags.operatorKeyword,
  "let var const using function class extends": tags.definitionKeyword,
  "import export from": tags.moduleKeyword,
  "with debugger new": tags.keyword,
  TemplateString: tags.special(tags.string),
  super: tags.atom,
  BooleanLiteral: tags.bool,
  this: tags.self,
  null: tags.null,
  Star: tags.modifier,
  VariableName: tags.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": tags.function(tags.variableName),
  VariableDefinition: tags.definition(tags.variableName),
  Label: tags.labelName,
  PropertyName: tags.propertyName,
  PrivatePropertyName: tags.special(tags.propertyName),
  "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
  "FunctionDeclaration/VariableDefinition": tags.function(tags.definition(tags.variableName)),
  "ClassDeclaration/VariableDefinition": tags.definition(tags.className),
  "NewExpression/VariableName": tags.className,
  PropertyDefinition: tags.definition(tags.propertyName),
  PrivatePropertyDefinition: tags.definition(tags.special(tags.propertyName)),
  UpdateOp: tags.updateOperator,
  "LineComment Hashbang": tags.lineComment,
  BlockComment: tags.blockComment,
  Number: tags.number,
  String: tags.string,
  Escape: tags.escape,
  ArithOp: tags.arithmeticOperator,
  LogicOp: tags.logicOperator,
  BitOp: tags.bitwiseOperator,
  CompareOp: tags.compareOperator,
  RegExp: tags.regexp,
  Equals: tags.definitionOperator,
  Arrow: tags.function(tags.punctuation),
  ": Spread": tags.punctuation,
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace,
  "InterpolationStart InterpolationEnd": tags.special(tags.brace),
  ".": tags.derefOperator,
  ", ;": tags.separator,
  "@": tags.meta,
  TypeName: tags.typeName,
  TypeDefinition: tags.definition(tags.typeName),
  "type enum interface implements namespace module declare": tags.definitionKeyword,
  "abstract global Privacy readonly override": tags.modifier,
  "is keyof unique infer asserts": tags.operatorKeyword,
  JSXAttributeValue: tags.attributeValue,
  JSXText: tags.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags.angleBracket,
  "JSXIdentifier JSXNameSpacedName": tags.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags.attributeName,
  "JSXBuiltin/JSXIdentifier": tags.standard(tags.tagName)
});
var spec_identifier2 = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, defer: 471, for: 476, of: 485, while: 488, with: 492, do: 496, if: 500, else: 502, switch: 506, case: 512, try: 518, catch: 522, finally: 526, return: 530, throw: 534, break: 538, continue: 542, debugger: 546 };
var spec_word = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 };
var spec_LessThan = { __proto__: null, "<": 193 };
var parser4 = LRParser.deserialize({
  version: 14,
  states: "$F|Q%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3YQ(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ |QpO'#GbO$!dQ!dO,5<sO$!kQ`O'#K[O9eQ`O'#K[O$!yQ`O,5<uO$#aQ!dO'#C{O!,TQMhO,5<tO$#kQ`O'#GZO$$PQ`O,5<tO$$UQ!dO'#GWO$$cQ!dO'#K]O$$mQ`O'#K]O!&zQMhO'#K]O$$rQ`O,5<xO$$wQlO'#JvO$%RQpO'#GcO#$`QpO'#GcO$%dQ`O'#GgO!3oQ`O'#GkO$%iQ!0LrO'#ItO$%tQpO,5<|OOQ!0Lp,5<|,5<|O$%{QpO'#GcO$&YQpO'#GdO$&kQpO'#GdO$&pQMjO,5=XO$'QQMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$'bQ`O'#IyO$'vQ`O,5@UO$(OQ`O,59aOOQ!0Lh,59i,59iO$(TQ`O,5@VO$)TQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)vQMjO,5<kO$*iQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*sQ`O,5<vO$*xQMjO,5<{O$+YQ`O'#KPO!$wQlO1G2RO$+_Q`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$+dQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$-fQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$/jQMhO'#EkOOQ!0Lb,5@T,5@TO$/wQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$0YQ`O1G0uO$0_Q`O'#CiO$0jQ`O'#KeO$0rQ`O,5=|O$0wQ`O'#KeO$0|Q`O'#KeO$1[Q`O'#JRO$1jQ`O,5AOO$1rQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1yQ`O1G3fO$2OQ`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$2TQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$2YQ`O1G3SO$2bQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$2jQMhO,5=tO9kQ`O,5=tO$%dQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2xQ`O'#KcO$3TQ`O,5=wOOQ[1G.k1G.kO$3YQ!0LrO1G.kO@zQ`O1G.kO$3eQ`O1G.kO9uQ!0LrO1G.kO$5mQ!fO,5AQO$5zQ`O,5AQO9eQ`O,5AQO$6VQlO,5>PO$6^Q`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$6cQlO1G3uO$:gQlO'#HtOOQ[1G3x1G3xO$:tQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:|QlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$?TQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$?YQ?MtO,5:XOOQO,5;`,5;`O$?dQpO'#IeO$?zQ`O,5@aOOQ!0Lf1G/r1G/rO$@SQpO'#IkO$@^Q`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$@fQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$@mQ!0LrO1G0mO$@xQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$AWQ!0LrO1G0mOOQO1G0^1G0^O$AlQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$AvQ!bO,5<iO$BOQ!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$BYQ`O1G5zO$BbQ`O1G6YO$BjQ!fO1G6ZO9eQ`O,5?UO$BtQ!0MxO1G6WO%[QlO1G6WO$CUQ!0LrO1G6WO$CgQ`O1G6VO$CgQ`O1G6VO9eQ`O1G6VO$CoQ`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$DTQ`O,5?XO$+YQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$DcQ`O7+(eO$DnQMhO7+(eO$D|Q!0MzO,5=XO$GXQ!0MzO,5=ZO$IdQ!0MzO,5=XO$KuQ!0MzO,5=ZO$NWQ!0MzO,59uO%!]Q!0MzO,5<kO%$hQ!0MzO,5<mO%&sQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%)UQ!0MxO7+&aO%)xQlO'#IfO%*VQ`O,5@cO%*_Q!fO,5@cOOQ!0Lf1G0P1G0PO%*iQ`O7+&jOOQ!0Lf7+&j7+&jO%*nQ?MtO,5:fO%[QlO7+&zO%*xQ?MtO,5:bO%+VQ?MtO,5:jO%+aQ?MtO,5:lO%+kQMhO'#IiO%+uQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+}Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%,YQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%,_Q!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%,fQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%-YQMhO1G2fP%-aQ`O'#IrPOQ!0Lh-E<p-E<pO%-}QMjO,5?aOOQ!0Lh-E<s-E<sO%.pQMjO,5?cOOQ!0Lh-E<u-E<uO%.zQ!dO1G2wO%/RQ!dO'#CrO%/iQMhO'#KSO$$wQlO'#JvOOQ!0Lh1G2_1G2_O%/sQ`O'#IqO%0[Q`O,5@vO%0[Q`O,5@vO%0dQ`O,5@vO%0oQ`O,5@vOOQO1G2a1G2aO%0}QMjO1G2`O$+YQ`O'#K[O!,TQMhO1G2`O%1_Q(CWO'#IsO%1lQ`O,5@wO!&zQMhO,5@wO%1tQ!dO,5@wOOQ!0Lh1G2d1G2dO%4UQ!fO'#CiO%4`Q`O,5=POOQ!0Lb,5<},5<}O%4hQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%4sQpO,5<}OOQ!0Lb,5=R,5=RO$+YQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$wQlO,5=PO%5RQ`O,5=OO%5^QpO,5=OO!,TQMhO'#IuO%6WQMjO1G2sO!,TQMhO'#IwO%6yQMjO1G2uO%7TQMjO1G5qO%7_QMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%7lQ`O1G2ZO!,TQMhO1G2bO%7qQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%8eQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%8jQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$DfQ`O7+(eO%8tQ!0MvO'#CiO%9XQ!0MvO,5=SO%9lQ`O,5=SO%9tQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9yQ`O'#JQO%:bQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%:bQ`O,5APO%:jQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:oQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:tQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:yQ!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%;TQ`O'#KbO%;`Q`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<rQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<yQ`O1G3`O%=UQMhO1G3`O9uQ!0LrO1G3bO$%dQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%=dQ`O'#JPO%=xQ`O,5@}O%>QQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%>]Q`O7+$VO%[QlO1G6lO%[QlO1G6mO%>bQ!0LrO1G6lO%>lQlO1G3kO%>sQ`O1G3kO%>xQlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%?PQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%?^Q`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%?cQpO1G5|O%?}Q?MtO1G0zO%@XQ`O1G0zOOQO1G/s1G/sO%@dQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$AlQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@nQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@yQ!0LrO7+&XO%AXQ!0MxO7++rO%[QlO7++rO%AiQ`O7++qO%AiQ`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AqQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%BPQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%BXQ`O<<LPO%BdQ!0MzO,5?aO%DoQ!0MzO,5?cO%FzQ!0MzO1G2`O%I]Q!0MzO1G2sO%KhQ!0MzO1G2uO%MsQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%M}Q`O1G5}OOQ!0Lf<<JU<<JUO%NVQ?MtO1G0uO&!^Q?MtO1G1PO&!eQ?MtO1G1PO&$fQ?MtO1G1PO&$mQ?MtO1G1PO&&nQ?MtO1G1PO&(oQ?MtO1G1PO&(vQ?MtO1G1PO&(}Q?MtO1G1PO&+OQ?MtO1G1PO&+VQ?MtO1G1PO&+^Q!0MxO<<JfO&-UQ?MtO1G1PO&.RQ?MvO1G1PO&/UQ?MvO'#JlO&1[Q?MtO1G1cO&1iQ?MtO1G0UO&1sQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1}Q`O1G1tO&2SQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&2^Q!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&2eQ`O,5?]O9eQ`O,5?]O$+YQ`O,5?]OOQO-E<o-E<oO&2sQ`O1G6bO&2sQ`O1G6bO&2{Q`O1G6bO&3WQMjO7+'zO&3hQ!dO,5?_O&3rQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3wQ!dO1G6cO&4RQ`O1G6cO&4ZQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%4hQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&4`QpO1G2iO&4nQ`O1G2kO$+YQ`O1G2jOCwQ`O1G2jO$$wQlO1G2kO&4vQ`O1G2jO&5jQMjO,5?aOOQ!0Lh-E<t-E<tO&6]QMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&6gQMjO7++]O&6qQMjO7++]OOQ!0Lh1G/c1G/cO&7OQ`O1G/cOOQ!0Lh7+'u7+'uO&7TQMjO7+'|O&7eQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&8XQ`O1G0zO!&zQMhO'#IzO&8^Q`O,5@xO&:`Q!fO<<LPO!&zQMhO1G2nO&:gQ!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:xQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;lQ`O,5?lO&;qQ`O,5?lOOQO-E=O-E=OO&<PQ`O1G6kO&<PQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&<XQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:yQ!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&<^QpO'#I|O&<iQ`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<qQpO,5=uOOQ[,5=u,5=uO&<xQpO'#EgO&=PQpO'#GeO&=UQ`O7+(zO&=ZQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&=cQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$%dQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=nQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=yQ`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&>RQ`O7+,WO&>WQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&>]Q`O7+)VO&>bQlO7+)VO&>iQ`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>nQ`O,5>aOOQ[,5>c,5>cO&>sQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>xQ?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$AlQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&?SQ!0LrO<<IsO&?_Q!0MxO<= ^O&?oQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?wQ!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&@OQ`OANAkO%[QlOANAkO&@WQ!0MzO7+'zO&BiQ!0MzO,5?aO&DtQ!0MzO,5?cO&GPQ!0MzO7+'|O&IbQ!fO1G4lO&IlQ?MtO7+&aO&KpQ?MvO,5=XO&MwQ?MvO,5=ZO&NXQ?MvO,5=XO&NiQ?MvO,5=ZO&NyQ?MvO,59uO'#PQ?MvO,5<kO'%SQ?MvO,5<mO''hQ?MvO,5<{O')^Q?MtO7+'kO')kQ?MtO7+'mO')xQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')}QMjO<<K}OOQO1G4w1G4wO'*UQ`O1G4wO'*aQ`O1G4wO'*oQ`O7++|O'*oQ`O7++|O!&zQMhO1G4yO'*wQ!dO1G4yO'+RQ`O7++}O'+ZQ`O7+(VO'+fQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+pQ`O7+(VO!&zQMhO7+(VO$+YQ`O7+(UO'+uQ`O7+(VOCwQ`O7+(UO'+}QMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O',XQ!dO,5?fOOQO-E<x-E<xO',cQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',sQ`O1G5WO',xQ`O7+,VO',xQ`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO'-QQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO'-VQ`O,5?hOOQO-E<z-E<zO'-bQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-lQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&=UQ`O<<LfO'-qQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$%dQ`O<<LhO9`Q`O<<LhO'-yQpO1G5VO'.UQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'.^Q`O<= rO'.cQ`O<= sOOQ[<<Lq<<LqO'.hQ`O<<LqO'.mQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.tQ`O<<JQO'/PQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$AlQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'/ZQ!fOG27VO4UQ!fOG27VO'/bQ`OG27VO'/jQ?MtO<<JfO'/wQ?MvO1G2`O'1mQ?MvO,5?aO'3pQ?MvO,5?cO'5sQ?MvO1G2sO'7vQ?MvO1G2uO'9yQ?MtO<<KXO':WQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO':eQ`O7+*cO':pQ`O<= hO':xQ!dO7+*eOOQ!0Lb<<Kq<<KqO$+YQ`O<<KqOCwQ`O<<KqO';SQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO';_Q!dO<<KqOOQ!0Lb<<Kp<<KpO';iQ`O<<KqO!&zQMhO<<KqO$+YQ`O<<KpO';nQMjOANDcO';xQ!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO'<YQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO'<bQ`O7+,SO'<jQ`O1G2kO&=UQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<oQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$%dQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<wQ`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$AlQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<|Q!fOLD,qO'=TQ?MvO7+'zO'>yQ?MvO,5?aO'@|Q?MvO,5?cO'CPQ?MvO7+'|O'DuQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$+YQ`OANA]OCwQ`OANA]O'EVQ!dOANA]OOQ!0LbANAZANAZO'E^Q`OANA]O!&zQMhOANA]O'EiQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EsQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&=UQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'E}Q?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'FXQ!0MzOG27TOOQ!0LbG26wG26wO$+YQ`OG26wO'HjQ`OG26wOCwQ`OG26wO'HuQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&=UQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$+YQ`OLD,cOCwQ`OLD,cO'H|Q`OLD,cO'IXQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'I`Q?MvOG27TOOQ!0Lb!$( }!$( }O$+YQ`O!$( }OCwQ`O!$( }O'KUQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$+YQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$+YQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'KaQ!fO'#JrO'KhQ!L^O'#DvO'KoQlO'#EOO'KvQ!fO'#CiO'N^Q!fO'#CiO!)[QlO'#EQO'NnQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!qQ`O,5<iO!)[QlO,5;eO(!yQMhO,5;eO($dQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!yQMhO'#GmO!&zQMhO'#GoO(!yQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!yQMhO'#GPO!&zQMhO'#GRO(!yQMhO'#GRO!&zQMhO'#GaO(!yQMhO'#GaO!)[QlO,5:jO($kQpO'#D_O($uQpO'#JvO!)[QlO,5@oO'NnQlO1G0uO(%PQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO(%ZQ!dO'#CrO!&zQMhO,5<tO(!yQMhO,5<tO'NnQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!yQMhO1G2`O!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO!&zQMhO1G2bO(!yQMhO1G2bO'NnQlO7+'mO'NnQlO7+&aO!&zQMhOANAiO(!yQMhOANAiO(%nQ`O'#EoO(%sQ`O'#EoO(%{Q`O'#F]O(&QQ`O'#EyO(&VQ`O'#KTO(&bQ`O'#KRO(&mQ`O,5;ZO(&rQMjO,5<eO(&yQ`O'#GYO('OQ`O'#GYO('TQ`O,5<eO(']Q`O,5<gO('eQ`O,5;ZO('mQ?MtO1G1`O('tQ`O,5<tO('yQ`O,5<tO((OQ`O,5<vO((TQ`O,5<vO((YQ`O1G2RO((_Q`O1G0uO((dQMjO<<K}O((kQMjO<<K}O((rQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.zQ!dO1G2wO%.zQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]",
  stateData: "()x~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<ZO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<[O!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<VO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S*YO!_*ZO!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op*`O![*^O(T*XO!k)OP~P!1uO#k*aO~O!l*bO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T*dO(VTO(YUO(a$uO(y$}O(z%PO~O![*gO!Y)PP~P!3tOr*sOs!nO!S*iO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO(e!mO~O!^*pO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*xO#`*wOg(_X!](_X~O!]*yOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*|O~Og)}O(T&ZO~O!l+SO~O(T(vO~Op+WO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+XO~O!S%hO![+ZO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+]O![+[O(VTO(YUO(e(|O~O!^(xP~P!9|O!]+^Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+gO!_'`O%i+fO~O!g+iOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+tO%j+uO(T+qO(VTO(YUO!^)XP~O!]+vO`)WX~O[+zO~O`+{O~O!_&PO(T%gO(U!lO`)WP~O%j,OO~P;SOh%VO#`,SO~Oh%VOn,VO!_$|O~O!_,XO~O!Q,ZO!_XO~O%n%vO~O!x,`O~Oe,eO~Ob,fO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,kO`,jO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,jOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,pOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,vO~O!_,xO~O&o,zO&q,{OP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-QO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-VO#`-UOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-XO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(VTO(YUO(aVO(o[O~O(T=QO~P#$qO!]-]O!^(iX~O!^-_O~O!g-VO#`-UO!]#hX!^#hX~O!]-`O!^(xX~O!^-bO~O!c-cO!d-cO(U!lO~P#$`O!^-fO~P'_On-iO!_'`O~O!Y-nO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-sO#`-qO~PChO!c-uO!d-uO(U!lO~PDWOa%nO#`-qO'z%nO~Oa%nO!g#vO#`-qO'z%nO~Oa%nO!g#vO!p-sO#`-qO'z%nO(r'pO~O(P'xO(Q'xO(R-zO~Ov-{O~O!Y'Wa!]'Wa~P!:tO![.PO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.TO!_%iO(T%gO!Y'^X!]'^X~O#`.VO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.ZO(T%gO~Op.`O!S%hO![.]O!_%iO!|]O#i._O#j.]O(T%gO!]'aX!k'aX~OR.dO!l#xO~Oh%VOn.gO!_'`O%i.fO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>]O!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].tO!k(kX~P!:tO!k.wO~O!Y.yO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO#z<gO#{<hO(aVO(r$YO(y#|O(z#}O~O$O.{O~P#BwO#S$dO#`<nO$Q<nO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>]O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/POg(pX~P!1WOg/RO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/SO$_/SO~O$]/TO$_/TO~O!g)hO#`/UO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/VO~O!_)kO$Z/XO$])jO$_)jO$f/YO~O!]<iO!^(fX~P#BwO!^/ZO~O!g)hO$f({X~O$f/]O~Ov/^O~P!&zOx)yO(b)zO(c/aO~O!S/dO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SOp%WO![/mO!](^O(T/lO!Y(vP!Y)PP~P!1uOr*sO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO~Os<}O!S/nO![+[O!^*pO(e<|O!^(xP~P$ [O!k/oO~P#/sO!]/pO!g#vO(r'pO!k)OX~O!k/uO~OnoX!QoX'yoX(yoX(zoX~O!g#vO!koX~P$#OOp/wO!S%hO![*^O!_%iO(T%gO!k)OP~O#k/xO~O!Y$zX!]$zX!g%RX~P!0SO!]/yO!Y)PX~P#/sO!g/{O~O!Y/}O~OpkO(T0OO~P.iOh%VOr0TO!g#vO!l%eO(r'pO~O!g+iO~Oa%nO!]0XO'z%nO~O!^0ZO~P!5iO!c0[O!d0[O(U!lO~P#$`Os!nO!S0]O(VTO(YUO(e!mO~O#[0_O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*yOg(^a~Og0hO~On0jO#`0iOg(_a!](_a~OR0kO!Q0kO!S0lO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$(cO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$)_O!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$*QO#k0oO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0rO~O!]+^Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$+oOh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0{O%]0|O(T0zO~P$.VO!g+iOa(]a!_(]a'z(]a!](]a~O#k1SO~O[]X!]fX!^fX~O!]1TO!^)XX~O!^1VO~O[1WO~Ob1YO(T+qO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+vO`)Wa~O!k1]O~P!:tO[1`O~O`1aO~O#`1fO~On1iO!_$|O~O(e(|O!^)UP~Oh%VOn1rO!_1oO%i1qO~O[1|O!]1zO!^)VX~O!^1}O~O`2POa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2SO&[2TOa(gX~P$3pOj2SO#`$eO&[2TO~Oa2VO~P%[Oa2XO~O&e2[OP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2bO!^2`O&j2aO~P`O!_XO!l2dO~O&q,{OP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2jO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2pO(e!mO!]'XX!^'XX~P@nO!]-]O!^(ia~O!]'_X!^'_X~P!9|O!]-`O!^(xa~O!^2wO~P'_Oa%nO#`3QO'z%nO~Oa%nO!g#vO#`3QO'z%nO~Oa%nO!g#vO!p3UO#`3QO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3WO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3]O#j3[O(T%gO~O!S%hO!_%iO#j3[O(T%gO~On3dO!_'`O%i3cO~Oh%VOn3dO!_'`O%i3cO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$(cO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$)_O#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$*QO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3lO!]'YX!k'YX~P%[O!].tO!k(ka~O!].tO!k(ka~P!:tO!Y3oO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/POg(pa~OSfO!_4TO$d4UO~O!^4YO~Ov4ZO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4]O~P!&zO!S4^O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%-fO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%.XO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SOp%WO(T=WO~P!1uOp4bO!S%hO![4aO!_%iO(T%gO!]'eX!k'eX~O!]/pO!k)Oa~O!]/pO!g#vO!k)Oa~O!]/pO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4jO!Y'gX!]'gX~P!3tO!]/yO!Y)Pa~O!]/yO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%2OOj4oO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4tO!l%eO(r'pO~Or4yO!g#vO(r'pO~Os!nO!S4zO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%5oO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%6bOg(_i!](_i~P!1WO#`5QOg(_i!](_i~P!1WO!k5VO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5ZO~O!]5[O!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5_OaoX!_oX'zoX!]oX~P$#OOp5`O(T#nO~O%^5_O~Ob5fO%j5gO(T+qO(VTO(YUO!]'tX!^'tX~O!]1TO!^)Xa~O[5kO~O`5lO~O[5pO~Oa%nO'z%nO~P#/sO!]5uO#`5wO!^)UX~O!^5xO~Or6OOs!nO!S*iO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!pO#W!pO#X!pO#[5}O#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5|O~P%;eOn6TO!_1oO%i6SO~Oh%VOn6TO!_1oO%i6SO~Ob6[O(T#nO(VTO(YUO!]'sX!^'sX~O!]1zO!^)Va~O(VTO(YUO(e6^O~O`6bO~Oj6eO&[6fO~PNXO!k6gO~P%[Oa6iO~Oa6iO~P%[Ob2bO!^6nO&j2aO~P`O!g6pO~O!g6rOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6sO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6|O'z%nO~Oa%nO!g#vO#`6|O'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7TO(T%gO~O!_'`O%i7WO~On7[O!_'`O%i7WO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%-fO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%.XO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%5oO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%6bO!]'Ya!k'Ya~P!:tO!].tO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%NdO#n<_O~P%NdOP$[OR#zOr<kO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!lO#r<aO~P&!lOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<eO~P&&uO#x#mi~P&&uO#v<cO~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&)UO#z<gO~P&)UOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO(y#mi(z#mi~P&,QOn>^O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&,QO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$+oOg']a!]']a~P!1WO!^7nO~O!]'da!^'da~P#BwO!Y7oO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/pO!k)Oi~O!]/pO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7vO~O!]/yO!Y)Pi~P#/sO!]/yO!Y)Pi~O!Y7yO~Oh%VOr8OO!l%eO(r'pO~Oj8QO!g#vO~Or8TO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&5RO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5tOg(_q!](_q~P!1WO#`8VOg(_q!](_q~P!1WO!Y8WO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6rO~O!]5[O!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7WO~P&8fO%^8[Oa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8^O~Ob8`O(T+qO(VTO(YUO~O!]1TO!^)Xi~O`8dO~O(e(|O!]'pX!^'pX~O!]5uO!^)Ua~O!^8nO~P%;eO(o!sO~P$&YO#[8oO~O!_1oO~O!_1oO%i8qO~On8tO!_1oO%i8qO~O[8yO!]'sa!^'sa~O!]1zO!^)Vi~O!k8}O~O!k9OO~O!k9RO~O!k9RO~P%[Oa9TO~O!g9UO~O!k9VO~O!](wi!^(wi~P#BwOa%nO#`9_O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9bO~P&8fO!_'`O%i9bO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&5RO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5tO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&IyO(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&LQOn>^O!Q*OO'y*PO(z%PO~P&IyOn>^O!Q*OO'y*PO(y$}O~P&LQOR0kO!Q0kO!S0lO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>^O!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P''VO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9oO~O$O9pO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/pO!k)Oq~O!Y'gi!]'gi~P#/sO!]/yO!Y)Pq~Or9wO!g#vO(r'pO~O[9yO!Y9xO~P#/sO!Y9xO~Oj:PO!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:UO~O!]1TO!^)Xq~O`:YO~O#`:ZO!]'pa!^'pa~O!]5uO!^)Ui~P#BwO!S:]O~O!_1oO%i:`O~O(VTO(YUO(e:eO~O!]1zO!^)Vq~O!k:hO~O!k:iO~O!k:jO~O!k:jO~P%[O#`:mO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:rO~P&8fO!_'`O%i:rO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P''VO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/pO!k)Oy~O!Y'gq!]'gq~P#/sOr:|O!g#vO(r'pO~O[;QO!Y;PO~P#/sO!Y;PO~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1TO!^)Xy~O!]5uO!^)Uq~O(T;XO~O!_1oO%i;[O~O!k;_O~O%i;dO~P&8fOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P''VO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P''VOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;hO~P#/sOr;iO!g#vO(r'pO~O[;kO!Y;hO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;tO!g#vO(r'pO~O!Y;uO~P#/sOr;|O!g#vO(r'pO~O!Y;}O~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P''VOr<QO!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%2OOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'LTOP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_XO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]<iO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<tO!S${O!_$|O!i>WO!l$xO#j<zO$W%`O$t<vO$v<xO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!yOr!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'LTO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<^O~O!g#vO#k<^O~O#`<nO~Oj<bO~O#`=OO!](wX!^(wX~O#`<nO!](uX!^(uX~O#k=PO~Og=RO~P!1WO#k=XO~O#k=YO~Og=RO(T&ZO~O!g#vO#k=ZO~O!g#vO#k=PO~O$O=[O~P#BwO#k=]O~O#k=^O~O#k=cO~O#k=dO~O#k=eO~O#k=fO~O$O=gO~P!1WO$O=hO~P!1WOl=sO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~",
  goto: "$9Y)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2iI[I[!2n!5z!:h!:h!>gPPP!>oI[PPPPPPPPP!BOP!C]PPI[!DnPI[PI[I[I[I[I[PI[!FQP!I[P!LbP!Lf!Lp!Lt!LtP!IXP!Lx!LxP#!OP#!SI[PI[#!Y#%_CjA^PA^PA^A^P#&lA^A^#)OA^#+vA^#.SA^A^#.r#1W#1W#1]#1f#1W#1qPP#1WPA^#2ZA^#6YA^A^6mPPP#:_PPP#:x#:xP#:xP#;`#:xPP#;fP#;]P#;]#;y#;]#<e#<k#<n)aP#<q)aP#<z#<z#<zP)aP)aP)aP)aPP)aP#=Q#=TP#=T)aP#=XP#=[P)aP)aP)aP)aP)aP)a)aPP#=b#=h#=s#=y#>P#>V#>]#>k#>q#>{#?R#?]#?c#?s#?y#@k#@}#AT#AZ#Ai#BO#Cs#DR#DY#Et#FS#Gt#HS#HY#H`#Hf#Hp#Hv#H|#IW#Ij#IpPPPPPPPPPPP#IvPPPPPPP#Jk#Mx$ b$ i$ qPPP$']P$'f$*_$0x$0{$1O$1}$2Q$2X$2aP$2g$2jP$3W$3[$4S$5b$5g$5}PP$6S$6Y$6^$6a$6e$6i$7e$7|$8e$8i$8l$8o$8y$8|$9Q$9UR!|RoqOXst!Z#d%m&r&t&u&w,s,x2[2_Y!vQ'`-e1o5{Q%tvQ%|yQ&T|Q&j!VS'W!e-]Q'f!iS'l!r!yU*k$|*Z*oQ+o%}S+|&V&WQ,d&dQ-c'_Q-m'gQ-u'mQ0[*qQ1b,OQ1y,eR<{<Y%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_S#q]<V!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU+P%]<s<tQ+t&PQ,f&gQ,m&oQ0x+gQ0}+iQ1Y+uQ2R,kQ3`.gQ5`0|Q5f1TQ6[1zQ7Y3dQ8`5gR9e7['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S!S!nQ!r!v!y!z$|'W'_'`'l'm'n*k*o*q*r-]-c-e-u0[0_1o5{5}%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q&X|Q'U!eS'[%i-`Q+t&PQ,P&WQ,f&gQ0n+SQ1Y+uQ1_+{Q2Q,jQ2R,kQ5f1TQ5o1aQ6[1zQ6_1|Q6`2PQ8`5gQ8c5lQ8|6bQ:X8dQ:f8yQ;V:YR<}*ZrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R,h&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>R>S[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ%wxQ%{yW&Q|&V&W,OQ&_!TQ'c!hQ'e!iQ(q#sS+n%|%}Q+r&PQ,_&bQ,c&dS-l'f'gQ.i(rQ1R+oQ1X+uQ1Z+vQ1^+zQ1t,`S1x,d,eQ2|-mQ5e1TQ5i1WQ5n1`Q6Z1yQ8_5gQ8b5kQ8f5pQ:T8^R;T:U!U$zi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y!^%yy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{Q+h%wQ,T&[Q,W&]Q,b&dQ.h(qQ1s,_U1w,c,d,eQ3e.iQ6U1tS6Y1x1yQ8x6Z#f>T#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o>U<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hW%Ti%V*y>PS&[!Q&iQ&]!RQ&^!SU*}%[%d=sR,R&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^T)z$u){V+P%]<s<tW'[!e%i*Z-`S(}#y#zQ+c%rQ+y&SS.b(m(nQ1j,XQ5T0kR8i5u'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.|.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ'Y!eR2q-]!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*k*o*q*r-]-c-e-u0[0_1o5{5}R1l,ZnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&y!^Q'v!xS(s#u<^Q+l%zQ,]&_Q,^&aQ-j'dQ-w'oS.r(x=PS0q+X=ZQ1P+mQ1n,[Q2c,zQ2e,{Q2m-WQ2z-kQ2}-oS5Y0r=eQ5a1QS5d1S=fQ6t2oQ6x2{Q6}3SQ8]5bQ9Y6vQ9Z6yQ9^7OR:l9V$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vS(o#p'iQ)P#zS+b%q.|S.c(n(pR3^.d'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS#q]<VQ&t!XQ&u!YQ&w![Q&x!]R2Z,vQ'a!hQ+e%wQ-h'cS.e(q+hQ2x-gW3b.h.i0w0yQ6w2yW7U3_3a3e5^U9a7V7X7ZU:q9c9d9fS;b:p:sQ;p;cR;x;qU!wQ'`-eT5y1o5{!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,s,x.[2[2_]!pQ!r'`-e1o5{T#q]<V%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S(}#y#zS.b(m(n!s=l$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU$fd)_,mS(p#p'iU*v%R(w4OU0m+O.n7gQ5^0xQ7V3`Q9d7YR:s9em!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}Q't!uS(f#g2US-s'k'wQ/s*]Q0R*jQ3U-vQ4f/tQ4r0TQ4s0UQ4x0^Q7r4`S7}4t4vS8R4y4{Q9r7sQ9v7yQ9{8OQ:Q8TS:{9w9xS;g:|;PS;s;h;iS;{;t;uS<P;|;}R<S<QQ#wbQ's!uS(e#g2US(g#m+WQ+Y%fQ+j%xQ+p&OU-r'k't'wQ.W(fU/r*]*`/wQ0S*jQ0V*lQ1O+kQ1u,aS3R-s-vQ3Z.`S4e/s/tQ4n0PS4q0R0^Q4u0WQ6W1vQ7P3US7q4`4bQ7u4fU7|4r4x4{Q8P4wQ8v6XS9q7r7sQ9u7yQ9}8RQ:O8SQ:c8wQ:y9rS:z9v9xQ;S:QQ;^:dS;f:{;PS;r;g;hS;z;s;uS<O;{;}Q<R<PQ<T<SQ=o=jQ={=tR=|=uV!wQ'`-e%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S#wz!j!r=i$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=o>R%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{S&Oz!jQ+k%yQ,a&dW1v,b,c,d,eU6X1w1x1yS8w6Y6ZQ:d8x!r=j$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ=t>QR=u>R%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ,n&o!p=k$Z$n)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=n'XU']!e%i*ZR2s-`%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ,m&oQ0x+gQ3`.gQ7Y3dR9e7[!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!P<d)^)q-Z.|2k2n3p3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!T<f)^)q-Z.|2k2n3p3v3w3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!^$Zc#Y%q(S(Y(t(y)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<WQ4_/kz>S)^)q-Z.|2k2n3p4P4X6u7b7k7l8k9X9g9m9n;W;`=vQ>X>ZR>Y>['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS$oh$pR4U/U'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_!s>Q$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*i+]+g,p,s,x-i.g/V/n0]0l1r2S2T2V2X2[2_2a3d4T4z6T6e6f6i7[8t9T!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^Q+T%aQ/c*Oo4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!U$yi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>YQ*c$zU*l$|*Z*oQ+U%bQ0W*m#f=q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n=r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hQ=w>TQ=x>UQ=y>VR=z>W!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hnoOXst!Z#d%m&r&t&u&w,s,x2[2_S*f${*YQ-R'OQ-S'QR4i/y%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q,U&]Q1h,WQ5s1gR8h5tV*n$|*Z*oU*n$|*Z*oT5z1o5{S0P*i/nQ4w0]T8S4z:]Q+j%xQ0V*lQ1O+kQ1u,aQ6W1vQ8v6XQ:c8wR;^:d!U%Oi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Yx*R$v)e*S*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>OS0`*t0a#f<o#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<p<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!d=S(u)c*[*e.j.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[`=T3}7c7f7j9h:t:w;yS=_.l3iT=`7e9k!U%Qi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y|*T$v)e*U*t+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>OS0b*u0c#f<q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!h=U(u)c*[*e.k.l.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[d=V3}7d7e7j9h9i:t:u:w;yS=a.m3jT=b7f9lrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q&f!UR,p&ornOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R&f!UQ,Y&^R1d,RsnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q1p,_S6R1s1tU8p6P6Q6US:_8r8sS;Y:^:aQ;m;ZR;w;nQ&m!VR,i&iR6_1|R:f8yW&Q|&V&W,OR1Z+vQ&r!WR,s&sR,y&xT2],x2_R,}&yQ,|&yR2f,}Q'y!{R-y'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/`){Q#UVR(Q#UQ#XWU(W#X(X.QQ(X#YR.Q(YQ-^'YR2r-^Q.u(yS3m.u3nR3n.vQ-e'`R2v-eY!rQ'`-e1o5{R'j!rQ/Q)eR4S/QU#_W%h*YU(_#_(`.RQ(`#`R.R(ZQ-a']R2t-at`OXst!V!Z#d%m&i&k&r&t&u&w,s,x2[2_S#hZ%eU#r`#h.[R.[(jQ(k#jQ.X(gW.a(k.X3X7RQ3X.YR7R3YQ)n$lR/W)nQ$phR)t$pQ$`cU)a$`-|<jQ-|<WR<j)qQ/q*]W4c/q4d7t9sU4d/r/s/tS7t4e4fR9s7u$e*Q$v(u)c)e*[*e*t*u+Q+R+V.l.m.o.p.q/_/g/i/k/v/|0d0e0v1e3f3g3h3}4R4[4g4h4l4|5O5R5S5W5r7]7^7_7`7e7f7h7i7j7p7w7z8U8X8Z9h9i9j9t9|:R:S:t:u:v:w:x:};R;e;j;v;y=p=}>O>Z>[Q/z*eU4k/z4m7xQ4m/|R7x4lS*o$|*ZR0Y*ox*S$v)e*t*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>O!d.j(u)c*[*e.l.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/h*S.j7ca7c3}7e7f7j9h:t:w;yQ0a*tQ3i.lU4}0a3i9kR9k7e|*U$v)e*t*u+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>O!h.k(u)c*[*e.l.m.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/j*U.k7de7d3}7e7f7j9h9i:t:u:w;yQ0c*uQ3j.mU5P0c3j9lR9l7fQ*z%UR0g*zQ5]0vR8Y5]Q+_%kR0u+_Q5v1jS8j5v:[R:[8kQ,[&_R1m,[Q5{1oR8m5{Q1{,fS6]1{8zR8z6_Q1U+rW5h1U5j8a:VQ5j1XQ8a5iR:V8bQ+w&QR1[+wQ2_,xR6m2_YrOXst#dQ&v!ZQ+a%mQ,r&rQ,t&tQ,u&uQ,w&wQ2Y,sS2],x2_R6l2[Q%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+`%lQ+l%zQ,Q&XQ,h&mQ-P&|W-p'k's't'wQ-w'oQ0X*nQ1P+mQ1c,PS2O,i,lQ2g-OQ2h-RQ2i-SQ2}-oW3P-r-s-v-xQ5a1QQ5m1_Q5q1eQ6V1uQ6a2QQ6k2ZU6z3O3R3UQ6}3SQ8]5bQ8e5oQ8g5rQ8l5zQ8u6WQ8{6`S9[6{7PQ9^7OQ:W8cQ:b8vQ:g8|Q:n9]Q;U:XQ;]:cQ;a:oQ;l;VR;o;^Q%zyQ'd!iQ'o!uU+m%{%|%}Q-W'VU-k'e'f'gS-o'k'uQ0Q*jS1Q+n+oQ2o-YS2{-l-mQ3S-tS4p0R0UQ5b1RQ6v2uQ6y2|Q7O3TU7{4r4s4vQ9z7}R;O9{S$wi>PR*{%VU%Ui%V>PR0f*yQ$viS(u#v+iS)c$b$cQ)e$dQ*[$xS*e${*YQ*t%OQ*u%QQ+Q%^Q+R%_Q+V%cQ.l<oQ.m<qQ.o<uQ.p<wQ.q<yQ/_)yQ/g*RQ/i*TQ/k*VQ/v*aS/|*g/mQ0d*wQ0e*xl0v+f,V.f1i1q3c6S7W8q9b:`:r;[;dQ1e,SQ3f=SQ3g=UQ3h=XS3}<l<mQ4R/PS4[/d4^Q4g/xQ4h/yQ4l/{Q4|0`Q5O0bQ5R0iQ5S0jQ5W0oQ5r1fQ7]=]Q7^=_Q7_=aQ7`=cQ7e<pQ7f<rQ7h<vQ7i<xQ7j<zQ7p4_Q7w4jQ7z4oQ8U5QQ8X5[Q8Z5_Q9h=YQ9i=TQ9j=VQ9t7vQ9|8QQ:R8VQ:S8[Q:t=^Q:u=`Q:v=bQ:w=dQ:x9pQ:}9yQ;R:PQ;e=gQ;j;QQ;v;kQ;y=hQ=p>PQ=}>XQ>O>YQ>Z>]R>[>^Q+O%]Q.n<sR7g<tnpOXst!Z#d%m&r&t&u&w,s,x2[2_Q!fPS#fZ#oQ&|!`W'h!o*i0]4zQ(P#SQ)Q#{Q)r$nS,l&k&nQ,q&oQ-O&{S-T'T/nQ-g'bQ.x)OQ/[)sQ0s+]Q0y+gQ2W,pQ2y-iQ3a.gQ4W/VQ5U0lQ6Q1rQ6c2SQ6d2TQ6h2VQ6j2XQ6o2aQ7Z3dQ7m4TQ8s6TQ9P6eQ9Q6fQ9S6iQ9f7[Q:a8tR:k9T#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*i+]+g,p,s,x-i.g/n0]0l1r2S2T2V2X2[2_2a3d4z6T6e6f6i7[8t9TQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/V4TQ+d%tQ+x&RS-Z'X2pQ-x'rS-}(T.PQ.S(]Q.U(dQ.s(xQ.v(zQ.z<UQ.|<XQ.}<YQ/O<]Q/b)}Q0p+XQ2k-UQ2n-XQ3O-qQ3V.VQ3k.tQ3p<^Q3q<_Q3r<`Q3s<aQ3t<bQ3u<cQ3v<dQ3w<eQ3x<fQ3y<gQ3z<hQ3{.{Q3|<kQ4P<nQ4Q<{Q4X<iQ5X0rQ5c1SQ6u=OQ6{3QQ7Q3WQ7a3lQ7b=PQ7k=RQ7l=ZQ8k5wQ9X6sQ9]6|Q9g=[Q9m=eQ9n=fQ:o9_Q;W:ZQ;`:mQ<W#SR=v>SR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}S'V!e-]U*j$|*Z*oS-Y'W'_S0U*k*qQ0^*rQ2u-cQ4v0[R4{0_R({#xQ!fQT-d'`-e]!qQ!r'`-e1o5{Q#p]R'i<VR)f$dY!uQ'`-e1o5{Q'k!rS'u!v!yS'w!z5}S-t'l'mQ-v'nR3T-uT#kZ%eS#jZ%eS%km,oU(g#h#i#lS.Y(h(iQ.^(jQ0t+^Q3Y.ZU3Z.[.]._S7S3[3]R9`7Td#^W#W#Z%h(T(^*Y+Z.T/mr#gZm#h#i#l%e(h(i(j+^.Z.[.]._3[3]7TS*]$x*bQ/t*^Q2U,oQ2l-VQ4`/pQ6q2dQ7s4aQ9W6rT=m'X+[V#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Z/mS-['X+[T.O(T.TV'^!e%i*ZQ$lfR)x$qT)m$l)nR4V/UT*_$x*bT*h${*YQ0w+fQ1g,VQ3_.fQ5t1iQ6P1qQ7X3cQ8r6SQ9c7WQ:^8qQ:p9bQ;Z:`Q;c:rQ;n;[R;q;dnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&l!VR,h&itmOXst!U!V!Z#d%m&i&r&t&u&w,s,x2[2_R,o&oT%lm,oR1k,XR,g&gQ&U|S+}&V&WR1^,OR+s&PT&p!W&sT&q!W&sT2^,x2_",
  nodeNames: "\u26A0 ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 380,
  context: trackNewline,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 237, 243, 245, 247, 249, 252, 258, 264, 266, 268, 270, 272, 274, 275, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [jsHighlight],
  skippedNodes: [0, 5, 6, 278],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [noSemicolon, noSemicolonType, operatorToken, jsx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, insertSemicolon, new LocalTokenGroup("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~", 141, 340), new LocalTokenGroup("j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~", 25, 323)],
  topRules: { "Script": [0, 7], "SingleExpression": [1, 276], "SingleClassItem": [2, 277] },
  dialects: { jsx: 0, ts: 15175 },
  dynamicPrecedences: { "80": 1, "82": 1, "94": 1, "169": 1, "199": 1 },
  specialized: [{ term: 327, get: (value) => spec_identifier2[value] || -1 }, { term: 343, get: (value) => spec_word[value] || -1 }, { term: 95, get: (value) => spec_LessThan[value] || -1 }],
  tokenPrec: 15201
});

// node_modules/@codemirror/lang-javascript/dist/index.js
var snippets = [
  /* @__PURE__ */ snippetCompletion("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("try {\n	${}\n} catch (${error}) {\n	${}\n}", {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n} else {\n	${}\n}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("class ${name} {\n	constructor(${params}) {\n		${}\n	}\n}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
];
var typescriptSnippets = /* @__PURE__ */ snippets.concat([
  /* @__PURE__ */ snippetCompletion("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]);
var cache = /* @__PURE__ */ new NodeWeakMap();
var ScopeNodes = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function defID(type) {
  return (node, def) => {
    let id2 = node.node.getChild("VariableDefinition");
    if (id2)
      def(id2, type);
    return true;
  };
}
var functionContext = ["FunctionDeclaration"];
var gatherCompletions = {
  FunctionDeclaration: /* @__PURE__ */ defID("function"),
  ClassDeclaration: /* @__PURE__ */ defID("class"),
  ClassExpression: () => true,
  EnumDeclaration: /* @__PURE__ */ defID("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ defID("type"),
  NamespaceDeclaration: /* @__PURE__ */ defID("namespace"),
  VariableDefinition(node, def) {
    if (!node.matchContext(functionContext))
      def(node, "variable");
  },
  TypeDefinition(node, def) {
    def(node, "type");
  },
  __proto__: null
};
function getScope(doc2, node) {
  let cached = cache.get(node);
  if (cached)
    return cached;
  let completions = [], top2 = true;
  function def(node2, type) {
    let name2 = doc2.sliceString(node2.from, node2.to);
    completions.push({ label: name2, type });
  }
  node.cursor(IterMode.IncludeAnonymous).iterate((node2) => {
    if (top2) {
      top2 = false;
    } else if (node2.name) {
      let gather = gatherCompletions[node2.name];
      if (gather && gather(node2, def) || ScopeNodes.has(node2.name))
        return false;
    } else if (node2.to - node2.from > 8192) {
      for (let c of getScope(doc2, node2.node))
        completions.push(c);
      return false;
    }
  });
  cache.set(node, completions);
  return completions;
}
var Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
var dontComplete = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function localCompletionSource(context) {
  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);
  if (dontComplete.indexOf(inner.name) > -1)
    return null;
  let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));
  if (!isWord && !context.explicit)
    return null;
  let options = [];
  for (let pos = inner; pos; pos = pos.parent) {
    if (ScopeNodes.has(pos.name))
      options = options.concat(getScope(context.state.doc, pos));
  }
  return {
    options,
    from: isWord ? inner.from : context.pos,
    validFor: Identifier
  };
}
var javascriptLanguage = /* @__PURE__ */ LRLanguage.define({
  name: "javascript",
  parser: /* @__PURE__ */ parser4.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        IfStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: flatIndent,
        SwitchBody: (context) => {
          let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
          return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
        },
        Block: /* @__PURE__ */ delimitedIndent({ closing: "}" }),
        ArrowFunction: (cx) => cx.baseIndent + cx.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ continuedIndent({ except: /^\s*{/ }),
        JSXElement(context) {
          let closed = /^\s*<\//.test(context.textAfter);
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
        },
        JSXEscape(context) {
          let closed = /\s*\}/.test(context.textAfter);
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(context) {
          return context.column(context.node.from) + context.unit;
        }
      }),
      /* @__PURE__ */ foldNodeProp.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": foldInside,
        BlockComment(tree) {
          return { from: tree.from + 2, to: tree.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
var jsxSublanguage = {
  test: (node) => /^JSX/.test(node.name),
  facet: /* @__PURE__ */ defineLanguageFacet({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
};
var typescriptLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "ts" }, "typescript");
var jsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ sublanguageProp.add((n) => n.isTop ? [jsxSublanguage] : void 0)]
});
var tsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ sublanguageProp.add((n) => n.isTop ? [jsxSublanguage] : void 0)]
}, "typescript");
var kwCompletion = (name2) => ({ label: name2, type: "keyword" });
var keywords = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(kwCompletion);
var typescriptKeywords = /* @__PURE__ */ keywords.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(kwCompletion));
function javascript(config2 = {}) {
  let lang = config2.jsx ? config2.typescript ? tsxLanguage : jsxLanguage : config2.typescript ? typescriptLanguage : javascriptLanguage;
  let completions = config2.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);
  return new LanguageSupport(lang, [
    javascriptLanguage.data.of({
      autocomplete: ifNotIn(dontComplete, completeFromList(completions))
    }),
    javascriptLanguage.data.of({
      autocomplete: localCompletionSource
    }),
    config2.jsx ? autoCloseTags : []
  ]);
}
function findOpenTag(node) {
  for (; ; ) {
    if (node.name == "JSXOpenTag" || node.name == "JSXSelfClosingTag" || node.name == "JSXFragmentTag")
      return node;
    if (node.name == "JSXEscape" || !node.parent)
      return null;
    node = node.parent;
  }
}
function elementName(doc2, tree, max = doc2.length) {
  for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {
    if (ch.name == "JSXIdentifier" || ch.name == "JSXBuiltin" || ch.name == "JSXNamespacedName" || ch.name == "JSXMemberExpression")
      return doc2.sliceString(ch.from, Math.min(ch.to, max));
  }
  return "";
}
var android2 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
var autoCloseTags = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {
  if ((android2 ? view.composing : view.compositionStarted) || view.state.readOnly || from != to || text != ">" && text != "/" || !javascriptLanguage.isActiveAt(view.state, from, -1))
    return false;
  let base2 = defaultInsert(), { state } = base2;
  let closeTags = state.changeByRange((range) => {
    var _a2;
    let { head } = range, around = syntaxTree(state).resolveInner(head - 1, -1), name2;
    if (around.name == "JSXStartTag")
      around = around.parent;
    if (state.doc.sliceString(head - 1, head) != text || around.name == "JSXAttributeValue" && around.to > head) ;
    else if (text == ">" && around.name == "JSXFragmentTag") {
      return { range, changes: { from: head, insert: `</>` } };
    } else if (text == "/" && around.name == "JSXStartCloseTag") {
      let empty2 = around.parent, base3 = empty2.parent;
      if (base3 && empty2.from == head - 2 && ((name2 = elementName(state.doc, base3.firstChild, head)) || ((_a2 = base3.firstChild) === null || _a2 === void 0 ? void 0 : _a2.name) == "JSXFragmentTag")) {
        let insert2 = `${name2}>`;
        return { range: EditorSelection.cursor(head + insert2.length, -1), changes: { from: head, insert: insert2 } };
      }
    } else if (text == ">") {
      let openTag = findOpenTag(around);
      if (openTag && openTag.name == "JSXOpenTag" && !/^\/?>|^<\//.test(state.doc.sliceString(head, head + 2)) && (name2 = elementName(state.doc, openTag, head)))
        return { range, changes: { from: head, insert: `</${name2}>` } };
    }
    return { range };
  });
  if (closeTags.changes.empty)
    return false;
  view.dispatch([
    base2,
    state.update(closeTags, { userEvent: "input.complete", scrollIntoView: true })
  ]);
  return true;
});

// node_modules/@codemirror/lang-html/dist/index.js
var Targets = ["_blank", "_self", "_top", "_parent"];
var Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
var Methods = ["get", "post", "put", "delete"];
var Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
var Bool = ["true", "false"];
var S = {};
var Tags = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Targets,
      hreflang: null
    }
  },
  abbr: S,
  address: S,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: S,
  aside: S,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: S,
  base: { attrs: { href: null, target: Targets } },
  bdi: S,
  bdo: S,
  blockquote: { attrs: { cite: null } },
  body: S,
  br: S,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Encs,
      formmethod: Methods,
      formnovalidate: ["novalidate"],
      formtarget: Targets,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: S,
  center: S,
  cite: S,
  code: S,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: S,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: S,
  div: S,
  dl: S,
  dt: S,
  em: S,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: S,
  figure: S,
  footer: S,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Charsets,
      autocomplete: ["on", "off"],
      enctype: Encs,
      method: Methods,
      novalidate: ["novalidate"],
      target: Targets
    }
  },
  h1: S,
  h2: S,
  h3: S,
  h4: S,
  h5: S,
  h6: S,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: S,
  hgroup: S,
  hr: S,
  html: {
    attrs: { manifest: null }
  },
  i: S,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Encs,
      formmethod: Methods,
      formnovalidate: ["novalidate"],
      formtarget: Targets,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: S,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: S,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: S,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Charsets,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: S,
  noscript: S,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: S,
  param: { attrs: { name: null, value: null } },
  pre: S,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: S,
  rt: S,
  ruby: S,
  samp: S,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Charsets
    }
  },
  section: S,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: S,
  source: { attrs: { src: null, type: null, media: null } },
  span: S,
  strong: S,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: S,
  summary: S,
  sup: S,
  table: S,
  tbody: S,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: S,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: S,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: S,
  time: { attrs: { datetime: null } },
  title: S,
  tr: S,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: S,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: S
};
var GlobalAttrs = {
  accesskey: null,
  class: null,
  contenteditable: Bool,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Bool,
  autocorrect: Bool,
  autocapitalize: Bool,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Bool,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Bool,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Bool,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Bool,
  "aria-hidden": Bool,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Bool,
  "aria-multiselectable": Bool,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Bool,
  "aria-relevant": null,
  "aria-required": Bool,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
};
var eventAttributes = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((n) => "on" + n);
for (let a of eventAttributes)
  GlobalAttrs[a] = null;
var Schema = class {
  constructor(extraTags, extraAttrs) {
    this.tags = { ...Tags, ...extraTags };
    this.globalAttrs = { ...GlobalAttrs, ...extraAttrs };
    this.allTags = Object.keys(this.tags);
    this.globalAttrNames = Object.keys(this.globalAttrs);
  }
};
Schema.default = /* @__PURE__ */ new Schema();
function elementName2(doc2, tree, max = doc2.length) {
  if (!tree)
    return "";
  let tag = tree.firstChild;
  let name2 = tag && tag.getChild("TagName");
  return name2 ? doc2.sliceString(name2.from, Math.min(name2.to, max)) : "";
}
function findParentElement(tree, skip = false) {
  for (; tree; tree = tree.parent)
    if (tree.name == "Element") {
      if (skip)
        skip = false;
      else
        return tree;
    }
  return null;
}
function allowedChildren(doc2, tree, schema) {
  let parentInfo = schema.tags[elementName2(doc2, findParentElement(tree))];
  return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
}
function openTags(doc2, tree) {
  let open = [];
  for (let parent = findParentElement(tree); parent && !parent.type.isTop; parent = findParentElement(parent.parent)) {
    let tagName = elementName2(doc2, parent);
    if (tagName && parent.lastChild.name == "CloseTag")
      break;
    if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to))
      open.push(tagName);
  }
  return open;
}
var identifier3 = /^[:\-\.\w\u00b7-\uffff]*$/;
function completeTag(state, schema, tree, from, to) {
  let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
  let parent = findParentElement(tree, tree.name == "StartTag" || tree.name == "TagName");
  return {
    from,
    to,
    options: allowedChildren(state.doc, parent, schema).map((tagName) => ({ label: tagName, type: "type" })).concat(openTags(state.doc, tree).map((tag, i) => ({
      label: "/" + tag,
      apply: "/" + tag + end,
      type: "type",
      boost: 99 - i
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function completeCloseTag(state, tree, from, to) {
  let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
  return {
    from,
    to,
    options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: "type", boost: 99 - i })),
    validFor: identifier3
  };
}
function completeStartTag(state, schema, tree, pos) {
  let options = [], level = 0;
  for (let tagName of allowedChildren(state.doc, tree, schema))
    options.push({ label: "<" + tagName, type: "type" });
  for (let open of openTags(state.doc, tree))
    options.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
  return { from: pos, to: pos, options, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeAttrName(state, schema, tree, from, to) {
  let elt2 = findParentElement(tree), info = elt2 ? schema.tags[elementName2(state.doc, elt2)] : null;
  let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];
  let names = info && info.globalAttrs === false ? localAttrs : localAttrs.length ? localAttrs.concat(schema.globalAttrNames) : schema.globalAttrNames;
  return {
    from,
    to,
    options: names.map((attrName) => ({ label: attrName, type: "property" })),
    validFor: identifier3
  };
}
function completeAttrValue(state, schema, tree, from, to) {
  var _a2;
  let nameNode = (_a2 = tree.parent) === null || _a2 === void 0 ? void 0 : _a2.getChild("AttributeName");
  let options = [], token = void 0;
  if (nameNode) {
    let attrName = state.sliceDoc(nameNode.from, nameNode.to);
    let attrs = schema.globalAttrs[attrName];
    if (!attrs) {
      let elt2 = findParentElement(tree), info = elt2 ? schema.tags[elementName2(state.doc, elt2)] : null;
      attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
    }
    if (attrs) {
      let base2 = state.sliceDoc(from, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
      if (/^['"]/.test(base2)) {
        token = base2[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
        quoteStart = "";
        quoteEnd = state.sliceDoc(to, to + 1) == base2[0] ? "" : base2[0];
        base2 = base2.slice(1);
        from++;
      } else {
        token = /^[^\s<>='"]*$/;
      }
      for (let value of attrs)
        options.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
    }
  }
  return { from, to, options, validFor: token };
}
function htmlCompletionFor(schema, context) {
  let { state, pos } = context, tree = syntaxTree(state).resolveInner(pos, -1), around = tree.resolve(pos);
  for (let scan = pos, before; around == tree && (before = tree.childBefore(scan)); ) {
    let last = before.lastChild;
    if (!last || !last.type.isError || last.from < last.to)
      break;
    around = tree = before;
    scan = last.from;
  }
  if (tree.name == "TagName") {
    return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos) : completeTag(state, schema, tree, tree.from, pos);
  } else if (tree.name == "StartTag" || tree.name == "IncompleteTag") {
    return completeTag(state, schema, tree, pos, pos);
  } else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
    return completeCloseTag(state, tree, pos, pos);
  } else if (tree.name == "OpenTag" || tree.name == "SelfClosingTag" || tree.name == "AttributeName") {
    return completeAttrName(state, schema, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
  } else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
    return completeAttrValue(state, schema, tree, tree.name == "Is" ? pos : tree.from, pos);
  } else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
    return completeStartTag(state, schema, tree, pos);
  } else {
    return null;
  }
}
function htmlCompletionSource(context) {
  return htmlCompletionFor(Schema.default, context);
}
function htmlCompletionSourceWith(config2) {
  let { extraTags, extraGlobalAttributes: extraAttrs } = config2;
  let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
  return (context) => htmlCompletionFor(schema, context);
}
var jsonParser = /* @__PURE__ */ javascriptLanguage.parser.configure({ top: "SingleExpression" });
var defaultNesting = [
  {
    tag: "script",
    attrs: (attrs) => attrs.type == "text/typescript" || attrs.lang == "ts",
    parser: typescriptLanguage.parser
  },
  {
    tag: "script",
    attrs: (attrs) => attrs.type == "text/babel" || attrs.type == "text/jsx",
    parser: jsxLanguage.parser
  },
  {
    tag: "script",
    attrs: (attrs) => attrs.type == "text/typescript-jsx",
    parser: tsxLanguage.parser
  },
  {
    tag: "script",
    attrs(attrs) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(attrs.type);
    },
    parser: jsonParser
  },
  {
    tag: "script",
    attrs(attrs) {
      return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
    },
    parser: javascriptLanguage.parser
  },
  {
    tag: "style",
    attrs(attrs) {
      return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
    },
    parser: cssLanguage.parser
  }
];
var defaultAttrs = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ cssLanguage.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ eventAttributes.map((name2) => ({ name: name2, parser: javascriptLanguage.parser })));
var htmlPlain = /* @__PURE__ */ LRLanguage.define({
  name: "html",
  parser: /* @__PURE__ */ parser2.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Element(context) {
          let after = /^(\s*)(<\/)?/.exec(context.textAfter);
          if (context.node.to <= context.pos + after[0].length)
            return context.continue();
          return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(context) {
          return context.column(context.node.from) + context.unit;
        },
        Document(context) {
          if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
            return context.continue();
          let endElt = null, close;
          for (let cur2 = context.node; ; ) {
            let last = cur2.lastChild;
            if (!last || last.name != "Element" || last.to != cur2.to)
              break;
            endElt = cur2 = last;
          }
          if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
            return context.lineIndent(endElt.from) + context.unit;
          return null;
        }
      }),
      /* @__PURE__ */ foldNodeProp.add({
        Element(node) {
          let first = node.firstChild, last = node.lastChild;
          if (!first || first.name != "OpenTag")
            return null;
          return { from: first.to, to: last.name == "CloseTag" ? last.from : node.to };
        }
      }),
      /* @__PURE__ */ bracketMatchingHandle.add({
        "OpenTag CloseTag": (node) => node.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-_"
  }
});
var htmlLanguage = /* @__PURE__ */ htmlPlain.configure({
  wrap: /* @__PURE__ */ configureNesting(defaultNesting, defaultAttrs)
});
function html(config2 = {}) {
  let dialect = "", wrap;
  if (config2.matchClosingTags === false)
    dialect = "noMatch";
  if (config2.selfClosingTags === true)
    dialect = (dialect ? dialect + " " : "") + "selfClosing";
  if (config2.nestedLanguages && config2.nestedLanguages.length || config2.nestedAttributes && config2.nestedAttributes.length)
    wrap = configureNesting((config2.nestedLanguages || []).concat(defaultNesting), (config2.nestedAttributes || []).concat(defaultAttrs));
  let lang = wrap ? htmlPlain.configure({ wrap, dialect }) : dialect ? htmlLanguage.configure({ dialect }) : htmlLanguage;
  return new LanguageSupport(lang, [
    htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config2) }),
    config2.autoCloseTags !== false ? autoCloseTags2 : [],
    javascript().support,
    css().support
  ]);
}
var selfClosers2 = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "));
var autoCloseTags2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, text, insertTransaction) => {
  if (view.composing || view.state.readOnly || from != to || text != ">" && text != "/" || !htmlLanguage.isActiveAt(view.state, from, -1))
    return false;
  let base2 = insertTransaction(), { state } = base2;
  let closeTags = state.changeByRange((range) => {
    var _a2, _b, _c;
    let didType = state.doc.sliceString(range.from - 1, range.to) == text;
    let { head } = range, after = syntaxTree(state).resolveInner(head, -1), name2;
    if (didType && text == ">" && after.name == "EndTag") {
      let tag = after.parent;
      if (((_b = (_a2 = tag.parent) === null || _a2 === void 0 ? void 0 : _a2.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name2 = elementName2(state.doc, tag.parent, head)) && !selfClosers2.has(name2)) {
        let to2 = head + (state.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
        let insert2 = `</${name2}>`;
        return { range, changes: { from: head, to: to2, insert: insert2 } };
      }
    } else if (didType && text == "/" && after.name == "IncompleteCloseTag") {
      let tag = after.parent;
      if (after.from == head - 2 && ((_c = tag.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name2 = elementName2(state.doc, tag, head)) && !selfClosers2.has(name2)) {
        let to2 = head + (state.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
        let insert2 = `${name2}>`;
        return {
          range: EditorSelection.cursor(head + insert2.length, -1),
          changes: { from: head, to: to2, insert: insert2 }
        };
      }
    }
    return { range };
  });
  if (closeTags.changes.empty)
    return false;
  view.dispatch([
    base2,
    state.update(closeTags, {
      userEvent: "input.complete",
      scrollIntoView: true
    })
  ]);
  return true;
});

// node_modules/@codemirror/lang-markdown/dist/index.js
var data = /* @__PURE__ */ defineLanguageFacet({ commentTokens: { block: { open: "<!--", close: "-->" } } });
var headingProp = /* @__PURE__ */ new NodeProp();
var commonmark = /* @__PURE__ */ parser.configure({
  props: [
    /* @__PURE__ */ foldNodeProp.add((type) => {
      return !type.is("Block") || type.is("Document") || isHeading(type) != null || isList(type) ? void 0 : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });
    }),
    /* @__PURE__ */ headingProp.add(isHeading),
    /* @__PURE__ */ indentNodeProp.add({
      Document: () => null
    }),
    /* @__PURE__ */ languageDataProp.add({
      Document: data
    })
  ]
});
function isHeading(type) {
  let match = /^(?:ATX|Setext)Heading(\d)$/.exec(type.name);
  return match ? +match[1] : void 0;
}
function isList(type) {
  return type.name == "OrderedList" || type.name == "BulletList";
}
function findSectionEnd(headerNode, level) {
  let last = headerNode;
  for (; ; ) {
    let next = last.nextSibling, heading2;
    if (!next || (heading2 = isHeading(next.type)) != null && heading2 <= level)
      break;
    last = next;
  }
  return last.to;
}
var headerIndent = /* @__PURE__ */ foldService.of((state, start, end) => {
  for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {
    if (node.from < start)
      break;
    let heading2 = node.type.prop(headingProp);
    if (heading2 == null)
      continue;
    let upto = findSectionEnd(node, heading2);
    if (upto > end)
      return { from: end, to: upto };
  }
  return null;
});
function mkLang(parser5) {
  return new Language(data, parser5, [], "markdown");
}
var commonmarkLanguage = /* @__PURE__ */ mkLang(commonmark);
var extended = /* @__PURE__ */ commonmark.configure([GFM, Subscript, Superscript, Emoji, {
  props: [
    /* @__PURE__ */ foldNodeProp.add({
      Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })
    })
  ]
}]);
var markdownLanguage = /* @__PURE__ */ mkLang(extended);
function getCodeParser(languages, defaultLanguage) {
  return (info) => {
    if (info && languages) {
      let found = null;
      info = /\S*/.exec(info)[0];
      if (typeof languages == "function")
        found = languages(info);
      else
        found = LanguageDescription.matchLanguageName(languages, info, true);
      if (found instanceof LanguageDescription)
        return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());
      else if (found)
        return found.parser;
    }
    return defaultLanguage ? defaultLanguage.parser : null;
  };
}
var Context = class {
  constructor(node, from, to, spaceBefore, spaceAfter, type, item) {
    this.node = node;
    this.from = from;
    this.to = to;
    this.spaceBefore = spaceBefore;
    this.spaceAfter = spaceAfter;
    this.type = type;
    this.item = item;
  }
  blank(maxWidth, trailing = true) {
    let result = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (maxWidth != null) {
      while (result.length < maxWidth)
        result += " ";
      return result;
    } else {
      for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)
        result += " ";
      return result + (trailing ? this.spaceAfter : "");
    }
  }
  marker(doc2, add2) {
    let number2 = this.node.name == "OrderedList" ? String(+itemNumber(this.item, doc2)[2] + add2) : "";
    return this.spaceBefore + number2 + this.type + this.spaceAfter;
  }
};
function getContext(node, doc2) {
  let nodes = [], context = [];
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    if (cur2.name == "FencedCode")
      return context;
    if (cur2.name == "ListItem" || cur2.name == "Blockquote")
      nodes.push(cur2);
  }
  for (let i = nodes.length - 1; i >= 0; i--) {
    let node2 = nodes[i], match;
    let line = doc2.lineAt(node2.from), startPos = node2.from - line.from;
    if (node2.name == "Blockquote" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {
      context.push(new Context(node2, startPos, startPos + match[0].length, "", match[1], ">", null));
    } else if (node2.name == "ListItem" && node2.parent.name == "OrderedList" && (match = /^( *)\d+([.)])( *)/.exec(line.text.slice(startPos)))) {
      let after = match[3], len = match[0].length;
      if (after.length >= 4) {
        after = after.slice(0, after.length - 4);
        len -= 4;
      }
      context.push(new Context(node2.parent, startPos, startPos + len, match[1], after, match[2], node2));
    } else if (node2.name == "ListItem" && node2.parent.name == "BulletList" && (match = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(line.text.slice(startPos)))) {
      let after = match[4], len = match[0].length;
      if (after.length > 4) {
        after = after.slice(0, after.length - 4);
        len -= 4;
      }
      let type = match[2];
      if (match[3])
        type += match[3].replace(/[xX]/, " ");
      context.push(new Context(node2.parent, startPos, startPos + len, match[1], after, type, node2));
    }
  }
  return context;
}
function itemNumber(item, doc2) {
  return /^(\s*)(\d+)(?=[.)])/.exec(doc2.sliceString(item.from, item.from + 10));
}
function renumberList(after, doc2, changes, offset = 0) {
  for (let prev = -1, node = after; ; ) {
    if (node.name == "ListItem") {
      let m = itemNumber(node, doc2);
      let number2 = +m[2];
      if (prev >= 0) {
        if (number2 != prev + 1)
          return;
        changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });
      }
      prev = number2;
    }
    let next = node.nextSibling;
    if (!next)
      break;
    node = next;
  }
}
function normalizeIndent(content2, state) {
  let blank = /^[ \t]*/.exec(content2)[0].length;
  if (!blank || state.facet(indentUnit) != "	")
    return content2;
  let col = countColumn(content2, 4, blank);
  let space4 = "";
  for (let i = col; i > 0; ) {
    if (i >= 4) {
      space4 += "	";
      i -= 4;
    } else {
      space4 += " ";
      i--;
    }
  }
  return space4 + content2.slice(blank);
}
var insertNewlineContinueMarkupCommand = (config2 = {}) => ({ state, dispatch }) => {
  let tree = syntaxTree(state), { doc: doc2 } = state;
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty || !markdownLanguage.isActiveAt(state, range.from, -1) && !markdownLanguage.isActiveAt(state, range.from, 1))
      return dont = { range };
    let pos = range.from, line = doc2.lineAt(pos);
    let context = getContext(tree.resolveInner(pos, -1), doc2);
    while (context.length && context[context.length - 1].from > pos - line.from)
      context.pop();
    if (!context.length)
      return dont = { range };
    let inner = context[context.length - 1];
    if (inner.to - inner.spaceAfter.length > pos - line.from)
      return dont = { range };
    let emptyLine = pos >= inner.to - inner.spaceAfter.length && !/\S/.test(line.text.slice(inner.to));
    if (inner.item && emptyLine) {
      let first = inner.node.firstChild, second = inner.node.getChild("ListItem", "ListItem");
      if (first.to >= pos || second && second.to < pos || line.from > 0 && !/[^\s>]/.test(doc2.lineAt(line.from - 1).text) || config2.nonTightLists === false) {
        let next = context.length > 1 ? context[context.length - 2] : null;
        let delTo, insert3 = "";
        if (next && next.item) {
          delTo = line.from + next.from;
          insert3 = next.marker(doc2, 1);
        } else {
          delTo = line.from + (next ? next.to : 0);
        }
        let changes3 = [{ from: delTo, to: pos, insert: insert3 }];
        if (inner.node.name == "OrderedList")
          renumberList(inner.item, doc2, changes3, -2);
        if (next && next.node.name == "OrderedList")
          renumberList(next.item, doc2, changes3);
        return { range: EditorSelection.cursor(delTo + insert3.length), changes: changes3 };
      } else {
        let insert3 = blankLine(context, state, line);
        return {
          range: EditorSelection.cursor(pos + insert3.length + 1),
          changes: { from: line.from, insert: insert3 + state.lineBreak }
        };
      }
    }
    if (inner.node.name == "Blockquote" && emptyLine && line.from) {
      let prevLine = doc2.lineAt(line.from - 1), quoted = />\s*$/.exec(prevLine.text);
      if (quoted && quoted.index == inner.from) {
        let changes3 = state.changes([
          { from: prevLine.from + quoted.index, to: prevLine.to },
          { from: line.from + inner.from, to: line.to }
        ]);
        return { range: range.map(changes3), changes: changes3 };
      }
    }
    let changes2 = [];
    if (inner.node.name == "OrderedList")
      renumberList(inner.item, doc2, changes2);
    let continued = inner.item && inner.item.from < line.from;
    let insert2 = "";
    if (!continued || /^[\s\d.)\-+*>]*/.exec(line.text)[0].length >= inner.to) {
      for (let i = 0, e = context.length - 1; i <= e; i++) {
        insert2 += i == e && !continued ? context[i].marker(doc2, 1) : context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert2.length : null);
      }
    }
    let from = pos;
    while (from > line.from && /\s/.test(line.text.charAt(from - line.from - 1)))
      from--;
    insert2 = normalizeIndent(insert2, state);
    if (nonTightList(inner.node, state.doc))
      insert2 = blankLine(context, state, line) + state.lineBreak + insert2;
    changes2.push({ from, to: pos, insert: state.lineBreak + insert2 });
    return { range: EditorSelection.cursor(from + insert2.length + 1), changes: changes2 };
  });
  if (dont)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var insertNewlineContinueMarkup = /* @__PURE__ */ insertNewlineContinueMarkupCommand();
function isMark(node) {
  return node.name == "QuoteMark" || node.name == "ListMark";
}
function nonTightList(node, doc2) {
  if (node.name != "OrderedList" && node.name != "BulletList")
    return false;
  let first = node.firstChild, second = node.getChild("ListItem", "ListItem");
  if (!second)
    return false;
  let line1 = doc2.lineAt(first.to), line2 = doc2.lineAt(second.from);
  let empty2 = /^[\s>]*$/.test(line1.text);
  return line1.number + (empty2 ? 0 : 1) < line2.number;
}
function blankLine(context, state, line) {
  let insert2 = "";
  for (let i = 0, e = context.length - 2; i <= e; i++) {
    insert2 += context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert2.length : null, i < e);
  }
  return normalizeIndent(insert2, state);
}
function contextNodeForDelete(tree, pos) {
  let node = tree.resolveInner(pos, -1), scan = pos;
  if (isMark(node)) {
    scan = node.from;
    node = node.parent;
  }
  for (let prev; prev = node.childBefore(scan); ) {
    if (isMark(prev)) {
      scan = prev.from;
    } else if (prev.name == "OrderedList" || prev.name == "BulletList") {
      node = prev.lastChild;
      scan = node.to;
    } else {
      break;
    }
  }
  return node;
}
var deleteMarkupBackward = ({ state, dispatch }) => {
  let tree = syntaxTree(state);
  let dont = null, changes = state.changeByRange((range) => {
    let pos = range.from, { doc: doc2 } = state;
    if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {
      let line = doc2.lineAt(pos);
      let context = getContext(contextNodeForDelete(tree, pos), doc2);
      if (context.length) {
        let inner = context[context.length - 1];
        let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);
        if (pos - line.from > spaceEnd && !/\S/.test(line.text.slice(spaceEnd, pos - line.from)))
          return {
            range: EditorSelection.cursor(line.from + spaceEnd),
            changes: { from: line.from + spaceEnd, to: pos }
          };
        if (pos - line.from == spaceEnd && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!inner.item || line.from <= inner.item.from || !/\S/.test(line.text.slice(0, inner.to)))) {
          let start = line.from + inner.from;
          if (inner.item && inner.node.from < inner.item.from && /\S/.test(line.text.slice(inner.from, inner.to))) {
            let insert2 = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));
            if (start == line.from)
              insert2 = normalizeIndent(insert2, state);
            return {
              range: EditorSelection.cursor(start + insert2.length),
              changes: { from: start, to: line.from + inner.to, insert: insert2 }
            };
          }
          if (start < pos)
            return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };
        }
      }
    }
    return dont = { range };
  });
  if (dont)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete" }));
  return true;
};
var markdownKeymap = [
  { key: "Enter", run: insertNewlineContinueMarkup },
  { key: "Backspace", run: deleteMarkupBackward }
];
var htmlNoMatch = /* @__PURE__ */ html({ matchClosingTags: false });
function markdown(config2 = {}) {
  let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser: parser5 } = commonmarkLanguage, completeHTMLTags = true, pasteURLAsLink: pasteURL = true, htmlTagLanguage = htmlNoMatch } = config2;
  if (!(parser5 instanceof MarkdownParser))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let extensions = config2.extensions ? [config2.extensions] : [];
  let support = [htmlTagLanguage.support, headerIndent], defaultCode;
  if (pasteURL)
    support.push(pasteURLAsLink);
  if (defaultCodeLanguage instanceof LanguageSupport) {
    support.push(defaultCodeLanguage.support);
    defaultCode = defaultCodeLanguage.language;
  } else if (defaultCodeLanguage) {
    defaultCode = defaultCodeLanguage;
  }
  let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : void 0;
  extensions.push(parseCode({ codeParser, htmlParser: htmlTagLanguage.language.parser }));
  if (addKeymap)
    support.push(Prec.high(keymap.of(markdownKeymap)));
  let lang = mkLang(parser5.configure(extensions));
  if (completeHTMLTags)
    support.push(lang.data.of({ autocomplete: htmlTagCompletion }));
  return new LanguageSupport(lang, support);
}
function htmlTagCompletion(context) {
  let { state, pos } = context, m = /<[:\-\.\w\u00b7-\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));
  if (!m)
    return null;
  let tree = syntaxTree(state).resolveInner(pos, -1);
  while (tree && !tree.type.isTop) {
    if (tree.name == "CodeBlock" || tree.name == "FencedCode" || tree.name == "ProcessingInstructionBlock" || tree.name == "CommentBlock" || tree.name == "Link" || tree.name == "Image")
      return null;
    tree = tree.parent;
  }
  return {
    from: pos - m[0].length,
    to: pos,
    options: htmlTagCompletions(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
var _tagCompletions = null;
function htmlTagCompletions() {
  if (_tagCompletions)
    return _tagCompletions;
  let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));
  return _tagCompletions = result ? result.options : [];
}
var nonPlainText = /code|horizontalrule|html|link|comment|processing|escape|entity|image|mark|url/i;
var pasteURLAsLink = /* @__PURE__ */ EditorView.domEventHandlers({
  paste: (event, view) => {
    var _a2;
    let { main } = view.state.selection;
    if (main.empty)
      return false;
    let link = (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain");
    if (!link || !/^(https?:\/\/|mailto:|xmpp:|www\.)/.test(link))
      return false;
    if (/^www\./.test(link))
      link = "https://" + link;
    if (!markdownLanguage.isActiveAt(view.state, main.from, 1))
      return false;
    let tree = syntaxTree(view.state), crossesNode = false;
    tree.iterate({
      from: main.from,
      to: main.to,
      enter: (node) => {
        if (node.from > main.from || nonPlainText.test(node.name))
          crossesNode = true;
      },
      leave: (node) => {
        if (node.to < main.to)
          crossesNode = true;
      }
    });
    if (crossesNode)
      return false;
    view.dispatch({
      changes: [{ from: main.from, insert: "[" }, { from: main.to, insert: `](${link})` }],
      userEvent: "input.paste",
      scrollIntoView: true
    });
    return true;
  }
});

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let { state } = target, line = state.doc.lineAt(state.selection.main.from), config2 = getConfig(target.state, line.from);
  return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
var toggleLineComment = /* @__PURE__ */ command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
var toggleBlockComment = /* @__PURE__ */ command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
var toggleBlockCommentByLine = /* @__PURE__ */ command(
  (o, s) => changeBlockComment(o, s, selectedLineRanges(s)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data2 = state.languageDataAt("commentTokens", pos, 1);
  return data2.length ? data2[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r.from);
    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
    if (toLine.from > fromLine.from && toLine.from == r.to)
      toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from)
      ranges[last].to = toLine.to;
    else
      ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r) => getConfig(state, r.from).block);
  if (!tokens.every((c) => c))
    return null;
  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
  if (option != 2 && !comments.every((c) => c)) {
    return { changes: state.changes(ranges.map((range, i) => {
      if (comments[i])
        return [];
      return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
    })) };
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i = 0, comment2; i < comments.length; i++)
      if (comment2 = comments[i]) {
        let token = tokens[i], { open, close } = comment2;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  ranges: for (let { from, to } of ranges) {
    let startI = lines.length, minIndent = 1e9, token;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (token == void 0) {
        token = getConfig(state, line.from).line;
        if (!token)
          continue ranges;
      }
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent == line.length;
        let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line, comment: comment2, token, indent, empty: empty2, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i = startI; i < lines.length; i++)
        if (lines[i].indent < lines[i].line.text.length)
          lines[i].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let { line, token, indent, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line.from + indent, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let { line, comment: comment2, token } of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2, to = from + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from, to });
      }
    return { changes };
  }
  return null;
}
var fromHistory = /* @__PURE__ */ Annotation.define();
var isolateHistory = /* @__PURE__ */ Annotation.define();
var invertedEffects = /* @__PURE__ */ Facet.define();
var historyConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
    });
  }
});
var historyField_ = /* @__PURE__ */ StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config2 = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config2.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config2, tr);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function history(config2 = {}) {
  return [
    historyField_,
    historyConfig.of(config2),
    EditorView.domEventHandlers({
      beforeinput(e, view) {
        let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection2) {
  return function({ state, dispatch }) {
    if (!selection2 && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection2);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
var undo = /* @__PURE__ */ cmd(0, false);
var redo = /* @__PURE__ */ cmd(1, false);
var undoSelection = /* @__PURE__ */ cmd(0, true);
var redoSelection = /* @__PURE__ */ cmd(1, true);
var HistEvent = class _HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a2, _b, _c;
    return {
      changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(json) {
    return new _HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr, selection2) {
    let effects = none4;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none4);
  }
  static selection(selections) {
    return new _HistEvent(void 0, none4, void 0, void 0, selections);
  }
};
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a, b) {
  let ranges = [], isAdjacent2 = false;
  a.iterChangedRanges((f, t2) => ranges.push(f, t2));
  b.iterChangedRanges((_f, _t, f, t2) => {
    for (let i = 0; i < ranges.length; ) {
      let from = ranges[i++], to = ranges[i++];
      if (t2 >= from && f <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a, b) {
  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b);
}
var none4 = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection2) {
  if (!branch.length) {
    return [HistEvent.selection([selection2])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection2))
      return branch;
    sels.push(selection2);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none4;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none4;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none4, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class _HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config2, tr) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none4));
    } else {
      done = updateBranch(done, done.length, config2.minDepth, event);
    }
    return new _HistoryState(done, none4, time, userEvent);
  }
  addSelection(selection2, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none4;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection2))
      return this;
    return new _HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1], selection2 = event.selectionsAfter[0] || (event.startSelection ? event.startSelection.map(event.changes.invertedDesc, 1) : state.selection);
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch), selection: selection2 }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none4 : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest, selection: selection2 }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = /* @__PURE__ */ new HistoryState(none4, none4);
var historyKeymap = [
  { key: "Mod-z", run: undo, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection2) {
  return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection2 = updateSel(state.selection, how);
  if (selection2.eq(state.selection, true))
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? /* @__PURE__ */ new Intl.Segmenter(void 0, { granularity: "word" }) : null;
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match, newPos;
  if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection2 = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection2.eq(state.selection))
    return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection2), { effects: effect });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space4 = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space4 && start.head != line.from + space4)
      moved = EditorSelection.cursor(line.from + space4);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
  let found = false, selection2 = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(target, how) {
  let selection2 = updateSel(target.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection2.eq(target.state.selection))
    return false;
  target.dispatch(setSel(target.state, selection2));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
var cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
var cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
var selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
var selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
var selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
var selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
var selectParentSyntax = ({ state, dispatch }) => {
  let selection2 = updateSel(state.selection, (range) => {
    let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
    if (range.empty) {
      let stackBefore = tree.resolveStack(range.from, -1);
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
        stack = stackBefore;
    }
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let { node } = cur2;
      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur2.next)
        return EditorSelection.range(node.to, node.from);
    }
    return range;
  });
  if (selection2.eq(state.selection))
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
function addCursorVertically(view, forward) {
  let { state } = view, sel = state.selection, ranges = state.selection.ranges.slice();
  for (let range of state.selection.ranges) {
    let line = state.doc.lineAt(range.head);
    if (forward ? line.to < view.state.doc.length : line.from > 0)
      for (let cur2 = range; ; ) {
        let next = view.moveVertically(cur2, forward);
        if (next.head < line.from || next.head > line.to) {
          if (!ranges.some((r) => r.head == next.head))
            ranges.push(next);
          break;
        } else if (next.head == cur2.head) {
          break;
        } else {
          cur2 = next;
        }
      }
  }
  if (ranges.length == sel.ranges.length)
    return false;
  view.dispatch(setSel(state, EditorSelection.create(ranges, ranges.length - 1)));
  return true;
}
var addCursorAbove = (view) => addCursorVertically(view, false);
var addCursorBelow = (view) => addCursorVertically(view, true);
var simplifySelection = ({ state, dispatch }) => {
  let cur2 = state.selection, selection2 = null;
  if (cur2.ranges.length > 1)
    selection2 = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty)
    selection2 = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection2)
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from, to } = range;
    if (from == to) {
      let towards = by(range);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    } else {
      from = skipAtomic(target, from, false);
      to = skipAtomic(target, to, true);
    }
    return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos)
          pos = forward ? to : from;
      });
  return pos;
}
var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
  let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak2(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
      targetPos = findClusterBreak2(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
var deleteCharBackward = (view) => deleteByChar(view, false, true);
var deleteCharForward = (view) => deleteByChar(view, true, false);
var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
  let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak2(line.text, pos - line.from, forward) + line.from;
    let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar2 != " " || pos != range.head)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (range) => {
  let lineEnd2 = view.lineBlockAt(range.head).to;
  return range.head < lineEnd2 ? lineEnd2 : Math.min(view.state.doc.length, range.head + 1);
});
var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
var splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak2(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak2(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r of block.ranges)
        ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  let changeSet = state.changes(changes);
  dispatch(state.update({
    changes: changeSet,
    selection: state.selection.map(changeSet, forward ? 1 : -1),
    scrollIntoView: true,
    userEvent: "input.copyline"
  }));
  return true;
}
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return { from, to };
  }));
  let selection2 = updateSel(state.selection, (range) => {
    let dist2 = void 0;
    if (view.lineWrapping) {
      let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (pos)
        dist2 = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
    }
    return view.moveVertically(range, true, dist2);
  }).map(changes);
  view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
    return { from: before.to, to: after.from };
  return null;
}
var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof)
        from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx, from);
      if (indent == null)
        indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from, to } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert2 = ["", indentString(state, indent)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent = getIndentation(context, line.from);
    if (indent == null)
      return;
    if (!/\S/.test(line.text))
      indent = 0;
    let cur2 = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur2 != norm || range.from < line.from + cur2.length) {
      updated[line.from] = indent;
      changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
var indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
var indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space4 = /^\s*/.exec(line.text)[0];
    if (!space4)
      return;
    let col = countColumn(space4, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space4.length && keep < insert2.length && space4.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space4.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
var toggleTabFocusMode = (view) => {
  view.setTabFocusMode();
  return true;
};
var insertTab = ({ state, dispatch }) => {
  if (state.selection.ranges.some((r) => !r.empty))
    return indentMore({ state, dispatch });
  dispatch(state.update(state.replaceSelection("	"), { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
var standardKeymap = /* @__PURE__ */ [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward, preventDefault: true },
  { key: "Delete", run: deleteCharForward, preventDefault: true },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward, preventDefault: true },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward, preventDefault: true },
  { mac: "Mod-Backspace", run: deleteLineBoundaryBackward, preventDefault: true },
  { mac: "Mod-Delete", run: deleteLineBoundaryForward, preventDefault: true }
].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
var defaultKeymap = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Mod-Alt-ArrowUp", run: addCursorAbove },
  { key: "Mod-Alt-ArrowDown", run: addCursorBelow },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
].concat(standardKeymap);
var indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
var SearchCursor = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text, query, from = 0, to = text.length, normalize, test) {
    this.test = test;
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from, to);
    this.bufferStart = from;
    this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt2(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize2(next);
      let norm = this.normalize(str);
      if (norm.length)
        for (let i = 0, pos = start; ; i++) {
          let code = norm.charCodeAt(i);
          let match = this.match(code, pos, this.bufferPos + this.bufferStart);
          if (i == norm.length - 1) {
            if (match) {
              this.value = match;
              return this;
            }
            break;
          }
          if (pos == start && i < str.length && str.charCodeAt(i) == code)
            pos++;
        }
    }
  }
  match(code, pos, end) {
    let match = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let index = this.matches[i], keep = false;
      if (this.query.charCodeAt(index) == code) {
        if (index == this.query.length - 1) {
          match = { from: this.matches[i + 1], to: end };
        } else {
          this.matches[i]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i, 2);
        i -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1)
        match = { from: pos, to: end };
      else
        this.matches.push(1, pos);
    }
    if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
      match = null;
    return match;
  }
};
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
var empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text, query, options, from = 0, to = text.length) {
    this.text = text;
    this.to = to;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text, query, options, from, to);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.iter = text.iter();
    let startLine = text.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text, from);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to = from + match[0].length;
        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
        if (from == this.curLineStart + this.curLine.length)
          this.nextLine();
        if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          return this;
        }
        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class _FlattenedDoc {
  constructor(from, text) {
    this.from = from;
    this.text = text;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc2, from, to) {
    let cached = flattened.get(doc2);
    if (!cached || cached.from >= to || cached.to <= from) {
      let flat = new _FlattenedDoc(from, doc2.sliceString(from, to));
      flattened.set(doc2, flat);
      return flat;
    }
    if (cached.from == from && cached.to == to)
      return cached;
    let { text, from: cachedFrom } = cached;
    if (cachedFrom > from) {
      text = doc2.sliceString(from, cachedFrom) + text;
      cachedFrom = from;
    }
    if (cached.to < to)
      text += doc2.sliceString(cached.to, to);
    flattened.set(doc2, new _FlattenedDoc(cachedFrom, text));
    return new _FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text, query, options, from, to) {
    this.text = text;
    this.to = to;
    this.done = false;
    this.value = empty;
    this.matchPos = toCharEnd(text, from);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(
      from + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off) {
        this.re.lastIndex = off + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match) {
        let from = this.flat.from + match.index, to = from + match[0].length;
        if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
          return this;
        }
      }
      if (this.flat.to == this.to) {
        this.done = true;
        return this;
      }
      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a2) {
    return false;
  }
}
function toCharEnd(text, pos) {
  if (pos >= text.length)
    return pos;
  let line = text.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++;
  return pos;
}
var gotoLine = (view) => {
  let { state } = view;
  let line = String(state.doc.lineAt(view.state.selection.main.head).number);
  let { close, result } = showDialog(view, {
    label: state.phrase("Go to line"),
    input: { type: "text", name: "line", value: line },
    focus: true,
    submitLabel: state.phrase("go")
  });
  result.then((form) => {
    let match = form && /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(form.elements["line"].value);
    if (!match) {
      view.dispatch({ effects: close });
      return;
    }
    let startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent2] = match;
    let col = cl ? +cl.slice(1) : 0;
    let line2 = ln ? +ln : startLine.number;
    if (ln && percent2) {
      let pc = line2 / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line2 = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line2 = line2 * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
    let selection2 = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
    view.dispatch({
      effects: [close, EditorView.scrollIntoView(selection2.from, { y: "center" })],
      selection: selection2
    });
  });
  return true;
};
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var highlightConfig = /* @__PURE__ */ Facet.define({
  combine(options) {
    return combineConfig(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a, b) => a || b,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options)
    ext.push(highlightConfig.of(options));
  return ext;
}
var matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
var mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check, state, from, to) {
  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
}
function insideWord(check, state, from, to) {
  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
}
var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range.from, range.to);
        check = state.charCategorizer(range.head);
        if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
          return Decoration.none;
      } else {
        query = state.sliceDoc(range.from, range.to);
        if (!query)
          return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor2 = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor2.next().done) {
        let { from, to } = cursor2.value;
        if (!check || insideWordBoundaries(check, state, from, to)) {
          if (range.empty && from <= range.from && to >= range.to)
            deco.push(mainMatchDeco.range(from, to));
          else if (from >= range.to || to <= range.from)
            deco.push(matchDeco.range(from, to));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var selectWord = ({ state, dispatch }) => {
  let { selection: selection2 } = state;
  let newSel = EditorSelection.create(selection2.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection2.mainIndex);
  if (newSel.eq(selection2))
    return false;
  dispatch(state.update({ selection: newSel }));
  return true;
};
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor2.next();
    if (cursor2.done) {
      if (cycled)
        return null;
      cursor2 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r) => r.from == cursor2.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor2.value.from);
        if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to)
          continue;
      }
      return cursor2.value;
    }
  }
}
var selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({ state, dispatch });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
    return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
    effects: EditorView.scrollIntoView(range.to)
  }));
  return true;
};
var searchConfigFacet = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view),
      scrollToMatch: (range) => EditorView.scrollIntoView(range)
    });
  }
});
function search(config2) {
  return config2 ? [searchConfigFacet.of(config2), searchExtensions] : searchExtensions;
}
var SearchQuery = class {
  /**
  Create a query object.
  */
  constructor(config2) {
    this.search = config2.search;
    this.caseSensitive = !!config2.caseSensitive;
    this.literal = !!config2.literal;
    this.regexp = !!config2.regexp;
    this.replace = config2.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.unquote(this.search);
    this.wholeWord = !!config2.wholeWord;
    this.test = config2.test;
  }
  /**
  @internal
  */
  unquote(text) {
    return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord && this.test == other.test;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from = 0, to) {
    let st = state.doc ? state : EditorState.create({ doc: state });
    if (to == null)
      to = st.doc.length;
    return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
  }
};
var QueryType2 = class {
  constructor(spec) {
    this.spec = spec;
  }
};
function wrapStringTest(test, state, inner) {
  return (from, to, buffer, bufferPos) => {
    if (inner && !inner(from, to, buffer, bufferPos))
      return false;
    let match = from >= bufferPos && to <= bufferPos + buffer.length ? buffer.slice(from - bufferPos, to - bufferPos) : state.doc.sliceString(from, to);
    return test(match, state, from, to);
  };
}
function stringCursor(spec, state, from, to) {
  let test;
  if (spec.wholeWord)
    test = stringWordTest(state.doc, state.charCategorizer(state.selection.main.head));
  if (spec.test)
    test = wrapStringTest(spec.test, state, test);
  return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), test);
}
function stringWordTest(doc2, categorizer) {
  return (from, to, buf, bufPos) => {
    if (bufPos > from || bufPos + buf.length < to) {
      bufPos = Math.max(0, from - 2);
      buf = doc2.sliceString(bufPos, Math.min(doc2.length, to + 2));
    }
    return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
  };
}
var StringQuery = class extends QueryType2 {
  constructor(spec) {
    super(spec);
  }
  nextMatch(state, curFrom, curTo) {
    let cursor2 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
    if (cursor2.done) {
      let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
      cursor2 = stringCursor(this.spec, state, 0, end).nextOverlapping();
    }
    return cursor2.done || cursor2.value.from == curFrom && cursor2.value.to == curTo ? null : cursor2.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from, to) {
    for (let pos = to; ; ) {
      let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
      let cursor2 = stringCursor(this.spec, state, start, pos), range = null;
      while (!cursor2.nextOverlapping().done)
        range = cursor2.value;
      if (range)
        return range;
      if (start == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(state, curFrom, curTo) {
    let found = this.prevMatchInRange(state, 0, curFrom);
    if (!found)
      found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
    return found && (found.from != curFrom || found.to != curTo) ? found : null;
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(state, limit) {
    let cursor2 = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from, to, add2) {
    let cursor2 = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
    while (!cursor2.next().done)
      add2(cursor2.value.from, cursor2.value.to);
  }
};
function wrapRegexpTest(test, state, inner) {
  return (from, to, match) => {
    return (!inner || inner(from, to, match)) && test(match[0], state, from, to);
  };
}
function regexpCursor(spec, state, from, to) {
  let test;
  if (spec.wholeWord)
    test = regexpWordTest(state.charCategorizer(state.selection.main.head));
  if (spec.test)
    test = wrapRegexpTest(spec.test, state, test);
  return new RegExpCursor(state.doc, spec.search, { ignoreCase: !spec.caseSensitive, test }, from, to);
}
function charBefore(str, index) {
  return str.slice(findClusterBreak2(str, index, false), index);
}
function charAfter(str, index) {
  return str.slice(index, findClusterBreak2(str, index));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
}
var RegExpQuery = class extends QueryType2 {
  nextMatch(state, curFrom, curTo) {
    let cursor2 = regexpCursor(this.spec, state, curTo, state.doc.length).next();
    if (cursor2.done)
      cursor2 = regexpCursor(this.spec, state, 0, curFrom).next();
    return cursor2.done ? null : cursor2.value;
  }
  prevMatchInRange(state, from, to) {
    for (let size = 1; ; size++) {
      let start = Math.max(
        from,
        to - size * 1e4
        /* FindPrev.ChunkSize */
      );
      let cursor2 = regexpCursor(this.spec, state, start, to), range = null;
      while (!cursor2.next().done)
        range = cursor2.value;
      if (range && (start == from || range.from > start + 10))
        return range;
      if (start == from)
        return null;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(result) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (m, i) => {
      if (i == "&")
        return result.match[0];
      if (i == "$")
        return "$";
      for (let l = i.length; l > 0; l--) {
        let n = +i.slice(0, l);
        if (n > 0 && n < result.match.length)
          return result.match[n] + i.slice(l);
      }
      return m;
    });
  }
  matchAll(state, limit) {
    let cursor2 = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from, to, add2) {
    let cursor2 = regexpCursor(this.spec, state, Math.max(
      0,
      from - 250
      /* RegExp.HighlightMargin */
    ), Math.min(to + 250, state.doc.length));
    while (!cursor2.next().done)
      add2(cursor2.value.from, cursor2.value.to);
  }
};
var setSearchQuery = /* @__PURE__ */ StateEffect.define();
var togglePanel = /* @__PURE__ */ StateEffect.define();
var searchState = /* @__PURE__ */ StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSearchQuery))
        value = new SearchState(effect.value.create(), value.panel);
      else if (effect.is(togglePanel))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
});
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" });
var selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
      let { from, to } = ranges[i];
      while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
        to = ranges[++i].to;
      query.highlight(view.state, from, to, (from2, to2) => {
        let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
        builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
  };
}
var findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { to } = view.state.selection.main;
  let next = query.nextMatch(view.state, to, to);
  if (!next)
    return false;
  let selection2 = EditorSelection.single(next.from, next.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection: selection2,
    effects: [announceMatch(view, next), config2.scrollToMatch(selection2.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view, { from } = state.selection.main;
  let prev = query.prevMatch(state, from, from);
  if (!prev)
    return false;
  let selection2 = EditorSelection.single(prev.from, prev.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection: selection2,
    effects: [announceMatch(view, prev), config2.scrollToMatch(selection2.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
var selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let { from, to } = sel.main;
  let ranges = [], main = 0;
  for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur2.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur2.value.from == from)
      main = ranges.length;
    ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main),
    userEvent: "select.search.matches"
  }));
  return true;
};
var replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view, { from, to } = state.selection.main;
  if (state.readOnly)
    return false;
  let match = query.nextMatch(state, from, from);
  if (!match)
    return false;
  let next = match;
  let changes = [], selection2, replacement;
  let effects = [];
  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({ from: next.from, to: next.to, insert: replacement });
    next = query.nextMatch(state, next.from, next.to);
    effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
  }
  let changeSet = view.state.changes(changes);
  if (next) {
    selection2 = EditorSelection.single(next.from, next.to).map(changeSet);
    effects.push(announceMatch(view, next));
    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view));
  }
  view.dispatch({
    changes: changeSet,
    selection: selection2,
    effects,
    userEvent: "input.replace"
  });
  return true;
});
var replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state, 1e9).map((match) => {
    let { from, to } = match;
    return { from, to, insert: query.getReplacement(match) };
  });
  if (!changes.length)
    return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a2, _b, _c, _d, _e;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config2 = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
    regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config2.regexp,
    wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config2.wholeWord
  });
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel);
  return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
  let input = getSearchInput(view);
  if (input && input == view.root.activeElement)
    input.select();
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let searchInput = getSearchInput(view);
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
var searchKeymap = [
  { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
  { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: selectSelectionMatches },
  { key: "Mod-Alt-g", run: gotoLine },
  { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
];
var SearchPanel = class {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: query.regexp,
      onchange: this.commit
    });
    this.wordField = crelt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: query.wholeWord,
      onchange: this.commit
    });
    function button(name2, onclick, content2) {
      return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
    }
    this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      crelt("label", null, [this.wordField, phrase(view, "by word")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
      ],
      crelt("button", {
        name: "close",
        onclick: () => closeSearchPanel(view),
        "aria-label": phrase(view, "close"),
        type: "button"
      }, ["\xD7"])
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e) {
    if (runScopeHandlers(this.view, e, "search-panel")) {
      e.preventDefault();
    } else if (e.keyCode == 13 && e.target == this.searchField) {
      e.preventDefault();
      (e.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e.keyCode == 13 && e.target == this.replaceField) {
      e.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr of update.transactions)
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
          this.setQuery(effect.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
    this.wordField.checked = query.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
};
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
  let line = view.state.doc.lineAt(from), lineEnd2 = view.state.doc.lineAt(to).to;
  let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd2, to + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);
  if (start != line.from) {
    for (let i = 0; i < AnnounceMargin; i++)
      if (!Break.test(text[i + 1]) && Break.test(text[i])) {
        text = text.slice(i);
        break;
      }
  }
  if (end != lineEnd2) {
    for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
      if (!Break.test(text[i - 1]) && Break.test(text[i])) {
        text = text.slice(0, i);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var searchExtensions = [
  searchState,
  /* @__PURE__ */ Prec.low(searchHighlighter),
  baseTheme4
];

// node_modules/@codemirror/theme-one-dark/dist/index.js
var chalky = "#e5c07b";
var coral = "#e06c75";
var cyan = "#56b6c2";
var invalid = "#ffffff";
var ivory = "#abb2bf";
var stone = "#7d8799";
var malibu = "#61afef";
var sage = "#98c379";
var whiskey = "#d19a66";
var violet = "#c678dd";
var darkBackground = "#21252b";
var highlightBackground = "#2c313a";
var background = "#282c34";
var tooltipBackground = "#353a42";
var selection = "#3E4451";
var cursor = "#528bff";
var oneDarkTheme = /* @__PURE__ */ EditorView.theme({
  "&": {
    color: ivory,
    backgroundColor: background
  },
  ".cm-content": {
    caretColor: cursor
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
  ".cm-panels": { backgroundColor: darkBackground, color: ivory },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: background,
    color: stone,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: highlightBackground
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: tooltipBackground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: tooltipBackground,
    borderBottomColor: tooltipBackground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: highlightBackground,
      color: ivory
    }
  }
}, { dark: true });
var oneDarkHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags.keyword,
    color: violet
  },
  {
    tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName],
    color: coral
  },
  {
    tag: [/* @__PURE__ */ tags.function(tags.variableName), tags.labelName],
    color: malibu
  },
  {
    tag: [tags.color, /* @__PURE__ */ tags.constant(tags.name), /* @__PURE__ */ tags.standard(tags.name)],
    color: whiskey
  },
  {
    tag: [/* @__PURE__ */ tags.definition(tags.name), tags.separator],
    color: ivory
  },
  {
    tag: [tags.typeName, tags.className, tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
    color: chalky
  },
  {
    tag: [tags.operator, tags.operatorKeyword, tags.url, tags.escape, tags.regexp, tags.link, /* @__PURE__ */ tags.special(tags.string)],
    color: cyan
  },
  {
    tag: [tags.meta, tags.comment],
    color: stone
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.link,
    color: stone,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    fontWeight: "bold",
    color: coral
  },
  {
    tag: [tags.atom, tags.bool, /* @__PURE__ */ tags.special(tags.variableName)],
    color: whiskey
  },
  {
    tag: [tags.processingInstruction, tags.string, tags.inserted],
    color: sage
  },
  {
    tag: tags.invalid,
    color: invalid
  }
]);
var oneDark = [oneDarkTheme, /* @__PURE__ */ syntaxHighlighting(oneDarkHighlightStyle)];
export {
  Compartment,
  Decoration,
  EditorSelection,
  EditorState,
  EditorView,
  HighlightStyle,
  Language,
  LanguageDescription,
  LanguageSupport,
  SearchQuery,
  SelectionRange,
  StateEffect,
  StateField,
  Text,
  Transaction,
  ViewPlugin,
  ViewUpdate,
  WidgetType,
  acceptCompletion,
  autocompletion,
  bracketMatching,
  closeBrackets,
  closeBracketsKeymap,
  codeFolding,
  completionKeymap,
  completionStatus,
  copyLineDown,
  copyLineUp,
  crosshairCursor,
  cursorDocEnd,
  cursorDocStart,
  cursorLineBoundaryBackward,
  cursorLineBoundaryForward,
  defaultKeymap,
  deleteLine,
  drawSelection,
  dropCursor,
  findNext,
  findPrevious,
  foldAll,
  foldCode,
  foldGutter,
  foldService,
  gotoLine,
  highlightActiveLineGutter,
  highlightSelectionMatches,
  highlightSpecialChars,
  history,
  historyKeymap,
  indentLess,
  indentMore,
  indentOnInput,
  indentUnit,
  indentWithTab,
  insertTab,
  keymap,
  tags as languageTags,
  lineNumbers,
  markdown,
  markdownLanguage,
  moveLineDown,
  moveLineUp,
  oneDark,
  rectangularSelection,
  replaceAll,
  replaceNext,
  search,
  searchKeymap,
  selectAll,
  selectLine,
  selectMatches,
  selectParentSyntax,
  selectSelectionMatches,
  simplifySelection,
  snippetCompletion,
  standardKeymap,
  startCompletion,
  syntaxHighlighting,
  toggleComment,
  unfoldAll,
  unfoldCode
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXJpam4vZmluZC1jbHVzdGVyLWJyZWFrL3NyYy9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbW9kL3NyYy9zdHlsZS1tb2QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jcmVsdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsZXplci9tYXJrZG93bi9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGV6ZXIvbHIvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxlemVyL2h0bWwvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxlemVyL2Nzcy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWNzcy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGV6ZXIvamF2YXNjcmlwdC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWphdmFzY3JpcHQvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1odG1sL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmctbWFya2Rvd24vZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc2VhcmNoL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3RoZW1lLW9uZS1kYXJrL2Rpc3QvaW5kZXguanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIFRoZXNlIGFyZSBmaWxsZWQgd2l0aCByYW5nZXMgKHJhbmdlRnJvbVtpXSB1cCB0byBidXQgbm90IGluY2x1ZGluZ1xuLy8gcmFuZ2VUb1tpXSkgb2YgY29kZSBwb2ludHMgdGhhdCBjb3VudCBhcyBleHRlbmRpbmcgY2hhcmFjdGVycy5cbmxldCByYW5nZUZyb20gPSBbXSwgcmFuZ2VUbyA9IFtdXG5cbjsoKCkgPT4ge1xuICAvLyBDb21wcmVzc2VkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHcmFwaGVtZV9DbHVzdGVyX0JyZWFrPUV4dGVuZFxuICAvLyBpbmZvcm1hdGlvbiBmcm9tXG4gIC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvUHVibGljLzE2LjAuMC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtQcm9wZXJ0eS50eHQuXG4gIC8vIEVhY2ggcGFpciBvZiBlbGVtZW50cyByZXByZXNlbnRzIGEgcmFuZ2UsIGFzIGFuIG9mZmV0IGZyb20gdGhlXG4gIC8vIHByZXZpb3VzIHJhbmdlIGFuZCBhIGxlbmd0aC4gTnVtYmVycyBhcmUgaW4gYmFzZS0zNiwgd2l0aCB0aGUgZW1wdHlcbiAgLy8gc3RyaW5nIGJlaW5nIGEgc2hvcnRoYW5kIGZvciAxLlxuICBsZXQgbnVtYmVycyA9IFwibGMsMzQsN24sNyw3YiwxOSwsLCwyLCwyLCwsMjAsYiwxYyxsLGcsLDJ0LDcsMiw2LDIsMiwsNCx6LCx1LHIsMmosYiwxbSw5LDksLG8sNCwsOSwsMywsNSwxNywzLDNiLGYsLHcsMWosLCwsNCw4LDQsLDMsNyxhLDIsdCwsMW0sLCwsMiw0LDgsLDksLGEsMixxLCwyLDIsMWwsLDQsMiw0LDIsMiwzLDMsLHUsMiwzLCxiLDIsMWwsLDQsNSwsMiw0LCxrLDIsbSw2LCwsMW0sLCwyLCw0LDgsLDcsMyxhLDIsdSwsMW4sLCwsYywsOSwsMTQsLDMsLDFsLDMsNSwzLCw0LDcsMixiLDIsdCwsMW0sLDIsLDIsLDMsLDUsMiw3LDIsYiwyLHMsMiwxbCwyLCwsMiw0LDgsLDksLGEsMix0LCwyMCwsNCwsMiwzLCwsOCwsMjksLDIsNyxjLDgsMnEsLDIsOSxiLDYsMjIsMixyLCwsLCwsMWosZSwsNSwsMiw1LGIsLDEwLDksLDJ1LDQsLDYsLDIsMiwyLHAsMiw0LDMsZyw0LGQsLDIsMiw2LCxmLCxqaiwzLHFhLDMsdCwzLHQsMix1LDIsMXMsMiwsNyw4LCwyLGIsOSwsMTksMywzYiwyLHksLDNhLDMsNCwyLDksLDYsMyw2MywyLDIsLDFtLCwsNywsLCwsMiw4LDYsYSwyLCwxYyxoLDFyLDQsMWMsNywsLDUsLDE0LDksYywyLHcsNCwyLDIsLDMsMWssLCwyLDMsLCwzLDFtLDgsMiwyLDQ4LDMsLGQsLDcsNCwsNiwsMywyLDVpLDFtLCw1LGVrLCw1Zix4LDJkYSwzLDN4LCwybyx3LGZlLDYsMngsMixuOXcsNCwsYSx3LDIsMjgsMiw3aywsMywsNCwscCwyLDUsLDQ3LDIscSxpLGQsLDEyLDgscCxiLDFhLDMsMWMsLDIsNCwyLDIsMTMsLDF2LDYsMiwyLDIsMixjLCw4LCwxYiwsMWYsLCwzLDIsMiw1LDIsLCwxNiwyLDgsLDZtLCwyLCw0LCxmbjQsLGtoLGcsZyxnLGE2LDIsZ3QsLDZhLCw0NSw1LDFhZSwzLCwyLDUsNCwxNCwzLDQsLDRsLDIsZngsNCxhciwyLDQ5LGIsNHcsLDFpLGYsMWssMywxZCw0LDIsMiwxeCwzLDEwLDUsLDgsMXEsLGMsMiwxZyw5LGEsNCwyLCwybiwzLDIsLCwyLDYsLDRnLCwzLDgsbCwyLDFsLDIsLCwsLG0sLGUsNywzLDUsNWYsOCwyLDMsLCxuLCwyOSwsMiw2LCwsMiwsLDIsLDIsNmosLDIsNCw2LDIsLDIsciwyLDJkLDgsMiwsLDIsMnksLCwsMiw2LCwsMnQsMywyLDQsLDUsNzcsOSwsMiw2dCwsYSwyLCwsNCwsNDAsNCwyLDIsNCwsdyxhLDE0LDYsMiw0LDgsLDksNiwyLDMsMWEsZCwsMixiYSw3LCw2LCwsMmEsbSwyLDcsLDIsLDIsM2UsNiwzLCwsMiwsNywsLDIwLDIsMywsLCw5biwyLGYwYiw1LDFuLDcsdDQsLDFyLDQsMjksLGY1aywyLDQzcSwsLDMsNCw1LDgsOCwyLDcsdSw0LDQ0LDMsMWl6LDFqLDQsMWUsOCwsZSwsbSw1LCxmLDExcyw3LCxoLDIsNywsMiwsNSw3OSw3LGM1LDQsMTVzLDcsMzEsNywyNDAsNSxneDdrLDJvLDNrLDZvXCIuc3BsaXQoXCIsXCIpLm1hcChzID0+IHMgPyBwYXJzZUludChzLCAzNikgOiAxKVxuICBmb3IgKGxldCBpID0gMCwgbiA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aDsgaSsrKVxuICAgIChpICUgMiA/IHJhbmdlVG8gOiByYW5nZUZyb20pLnB1c2gobiA9IG4gKyBudW1iZXJzW2ldKVxufSkoKVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlbmRpbmdDaGFyKGNvZGUpIHtcbiAgaWYgKGNvZGUgPCA3NjgpIHJldHVybiBmYWxzZVxuICBmb3IgKGxldCBmcm9tID0gMCwgdG8gPSByYW5nZUZyb20ubGVuZ3RoOzspIHtcbiAgICBsZXQgbWlkID0gKGZyb20gKyB0bykgPj4gMVxuICAgIGlmIChjb2RlIDwgcmFuZ2VGcm9tW21pZF0pIHRvID0gbWlkXG4gICAgZWxzZSBpZiAoY29kZSA+PSByYW5nZVRvW21pZF0pIGZyb20gPSBtaWQgKyAxXG4gICAgZWxzZSByZXR1cm4gdHJ1ZVxuICAgIGlmIChmcm9tID09IHRvKSByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1JlZ2lvbmFsSW5kaWNhdG9yKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gMHgxRjFFNiAmJiBjb2RlIDw9IDB4MUYxRkZcbn1cblxuZnVuY3Rpb24gY2hlY2soY29kZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlRnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyYW5nZVRvW2ldID4gY29kZSkgcmV0dXJuIHJhbmdlRnJvbVtpXSA8PSBjb2RlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IFpXSiA9IDB4MjAwZFxuXG5leHBvcnQgZnVuY3Rpb24gZmluZENsdXN0ZXJCcmVhayhzdHIsIHBvcywgZm9yd2FyZCA9IHRydWUsIGluY2x1ZGVFeHRlbmRpbmcgPSB0cnVlKSB7XG4gIHJldHVybiAoZm9yd2FyZCA/IG5leHRDbHVzdGVyQnJlYWsgOiBwcmV2Q2x1c3RlckJyZWFrKShzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZylcbn1cblxuZnVuY3Rpb24gbmV4dENsdXN0ZXJCcmVhayhzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZykge1xuICBpZiAocG9zID09IHN0ci5sZW5ndGgpIHJldHVybiBwb3NcbiAgLy8gSWYgcG9zIGlzIGluIHRoZSBtaWRkbGUgb2YgYSBzdXJyb2dhdGUgcGFpciwgbW92ZSB0byBpdHMgc3RhcnRcbiAgaWYgKHBvcyAmJiBzdXJyb2dhdGVMb3coc3RyLmNoYXJDb2RlQXQocG9zKSkgJiYgc3Vycm9nYXRlSGlnaChzdHIuY2hhckNvZGVBdChwb3MgLSAxKSkpIHBvcy0tXG4gIGxldCBwcmV2ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpXG4gIHBvcyArPSBjb2RlUG9pbnRTaXplKHByZXYpXG4gIHdoaWxlIChwb3MgPCBzdHIubGVuZ3RoKSB7XG4gICAgbGV0IG5leHQgPSBjb2RlUG9pbnRBdChzdHIsIHBvcylcbiAgICBpZiAocHJldiA9PSBaV0ogfHwgbmV4dCA9PSBaV0ogfHwgaW5jbHVkZUV4dGVuZGluZyAmJiBpc0V4dGVuZGluZ0NoYXIobmV4dCkpIHtcbiAgICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKG5leHQpXG4gICAgICBwcmV2ID0gbmV4dFxuICAgIH0gZWxzZSBpZiAoaXNSZWdpb25hbEluZGljYXRvcihuZXh0KSkge1xuICAgICAgbGV0IGNvdW50QmVmb3JlID0gMCwgaSA9IHBvcyAtIDJcbiAgICAgIHdoaWxlIChpID49IDAgJiYgaXNSZWdpb25hbEluZGljYXRvcihjb2RlUG9pbnRBdChzdHIsIGkpKSkgeyBjb3VudEJlZm9yZSsrOyBpIC09IDIgfVxuICAgICAgaWYgKGNvdW50QmVmb3JlICUgMiA9PSAwKSBicmVha1xuICAgICAgZWxzZSBwb3MgKz0gMlxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9zXG59XG5cbmZ1bmN0aW9uIHByZXZDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpIHtcbiAgd2hpbGUgKHBvcyA+IDApIHtcbiAgICBsZXQgZm91bmQgPSBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zIC0gMiwgaW5jbHVkZUV4dGVuZGluZylcbiAgICBpZiAoZm91bmQgPCBwb3MpIHJldHVybiBmb3VuZFxuICAgIHBvcy0tXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyLCBwb3MpIHtcbiAgbGV0IGNvZGUwID0gc3RyLmNoYXJDb2RlQXQocG9zKVxuICBpZiAoIXN1cnJvZ2F0ZUhpZ2goY29kZTApIHx8IHBvcyArIDEgPT0gc3RyLmxlbmd0aCkgcmV0dXJuIGNvZGUwXG4gIGxldCBjb2RlMSA9IHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpXG4gIGlmICghc3Vycm9nYXRlTG93KGNvZGUxKSkgcmV0dXJuIGNvZGUwXG4gIHJldHVybiAoKGNvZGUwIC0gMHhkODAwKSA8PCAxMCkgKyAoY29kZTEgLSAweGRjMDApICsgMHgxMDAwMFxufVxuXG5mdW5jdGlvbiBzdXJyb2dhdGVMb3coY2gpIHsgcmV0dXJuIGNoID49IDB4REMwMCAmJiBjaCA8IDB4RTAwMCB9XG5mdW5jdGlvbiBzdXJyb2dhdGVIaWdoKGNoKSB7IHJldHVybiBjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERDMDAgfVxuZnVuY3Rpb24gY29kZVBvaW50U2l6ZShjb2RlKSB7IHJldHVybiBjb2RlIDwgMHgxMDAwMCA/IDEgOiAyIH1cbiIsICJpbXBvcnQgeyBmaW5kQ2x1c3RlckJyZWFrIGFzIGZpbmRDbHVzdGVyQnJlYWskMSB9IGZyb20gJ0BtYXJpam4vZmluZC1jbHVzdGVyLWJyZWFrJztcblxuLyoqXG5UaGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIGRvY3VtZW50cy4gQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgVGV4dCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBsaW5lIGRlc2NyaXB0aW9uIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBsaW5lQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgcG9zaXRpb24gJHtwb3N9IGluIGRvY3VtZW50IG9mIGxlbmd0aCAke3RoaXMubGVuZ3RofWApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIocG9zLCBmYWxzZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiAoMS1iYXNlZCkgbGluZSBudW1iZXIuXG4gICAgKi9cbiAgICBsaW5lKG4pIHtcbiAgICAgICAgaWYgKG4gPCAxIHx8IG4gPiB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbGluZSBudW1iZXIgJHtufSBpbiAke3RoaXMubGluZXN9LWxpbmUgZG9jdW1lbnRgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKG4sIHRydWUsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIHRleHQgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoMCwgZnJvbSwgcGFydHMsIDIgLyogT3Blbi5UbyAqLyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8gfCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSh0bywgdGhpcy5sZW5ndGgsIHBhcnRzLCAxIC8qIE9wZW4uRnJvbSAqLyk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMubGVuZ3RoLCB0aGlzLmxlbmd0aCwgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKGZyb20sIHRvLCBwYXJ0cywgMCk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0byAtIGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyB0ZXh0IGlzIGVxdWFsIHRvIGFub3RoZXIgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob3RoZXIubGVuZ3RoICE9IHRoaXMubGVuZ3RoIHx8IG90aGVyLmxpbmVzICE9IHRoaXMubGluZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgMSksIGVuZCA9IHRoaXMubGVuZ3RoIC0gdGhpcy5zY2FuSWRlbnRpY2FsKG90aGVyLCAtMSk7XG4gICAgICAgIGxldCBhID0gbmV3IFJhd1RleHRDdXJzb3IodGhpcyksIGIgPSBuZXcgUmF3VGV4dEN1cnNvcihvdGhlcik7XG4gICAgICAgIGZvciAobGV0IHNraXAgPSBzdGFydCwgcG9zID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgYS5uZXh0KHNraXApO1xuICAgICAgICAgICAgYi5uZXh0KHNraXApO1xuICAgICAgICAgICAgc2tpcCA9IDA7XG4gICAgICAgICAgICBpZiAoYS5saW5lQnJlYWsgIT0gYi5saW5lQnJlYWsgfHwgYS5kb25lICE9IGIuZG9uZSB8fCBhLnZhbHVlICE9IGIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcG9zICs9IGEudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuZG9uZSB8fCBwb3MgPj0gZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdGV4dC4gV2hlbiBgZGlyYCBpcyBgLTFgLCBpdGVyYXRpb24gaGFwcGVuc1xuICAgIGZyb20gZW5kIHRvIHN0YXJ0LiBUaGlzIHdpbGwgcmV0dXJuIGxpbmVzIGFuZCB0aGUgYnJlYWtzIGJldHdlZW5cbiAgICB0aGVtIGFzIHNlcGFyYXRlIHN0cmluZ3MuXG4gICAgKi9cbiAgICBpdGVyKGRpciA9IDEpIHsgcmV0dXJuIG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMsIGRpcik7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgYSByYW5nZSBvZiB0aGUgdGV4dC4gV2hlbiBgZnJvbWAgPiBgdG9gLCB0aGVcbiAgICBpdGVyYXRvciB3aWxsIHJ1biBpbiByZXZlcnNlLlxuICAgICovXG4gICAgaXRlclJhbmdlKGZyb20sIHRvID0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIG5ldyBQYXJ0aWFsVGV4dEN1cnNvcih0aGlzLCBmcm9tLCB0byk7IH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBjdXJzb3IgdGhhdCBpdGVyYXRlcyBvdmVyIHRoZSBnaXZlbiByYW5nZSBvZiBsaW5lcyxcbiAgICBfd2l0aG91dF8gcmV0dXJuaW5nIHRoZSBsaW5lIGJyZWFrcyBiZXR3ZWVuLCBhbmQgeWllbGRpbmcgZW1wdHlcbiAgICBzdHJpbmdzIGZvciBlbXB0eSBsaW5lcy5cbiAgICBcbiAgICBXaGVuIGBmcm9tYCBhbmQgYHRvYCBhcmUgZ2l2ZW4sIHRoZXkgc2hvdWxkIGJlIDEtYmFzZWQgbGluZSBudW1iZXJzLlxuICAgICovXG4gICAgaXRlckxpbmVzKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBpbm5lcjtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5uZXIgPSB0aGlzLml0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRvID0gdGhpcy5saW5lcyArIDE7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmxpbmUoZnJvbSkuZnJvbTtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyUmFuZ2Uoc3RhcnQsIE1hdGgubWF4KHN0YXJ0LCB0byA9PSB0aGlzLmxpbmVzICsgMSA/IHRoaXMubGVuZ3RoIDogdG8gPD0gMSA/IDAgOiB0aGlzLmxpbmUodG8gLSAxKS50bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZUN1cnNvcihpbm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcsIHVzaW5nIG5ld2xpbmUgY2hhcmFjdGVycyB0b1xuICAgIHNlcGFyYXRlIGxpbmVzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLnNsaWNlU3RyaW5nKDApOyB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGUgZG9jdW1lbnQgdG8gYW4gYXJyYXkgb2YgbGluZXMgKHdoaWNoIGNhbiBiZVxuICAgIGRlc2VyaWFsaXplZCBhZ2FpbiB2aWEgW2BUZXh0Lm9mYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0Xm9mKSkuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmZsYXR0ZW4obGluZXMpO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgVGV4dGAgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBsaW5lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBvZih0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIGRvY3VtZW50IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGluZVwiKTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEgJiYgIXRleHRbMF0pXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovID8gbmV3IFRleHRMZWFmKHRleHQpIDogVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdCh0ZXh0LCBbXSkpO1xuICAgIH1cbn1cbi8vIExlYXZlcyBzdG9yZSBhbiBhcnJheSBvZiBsaW5lIHN0cmluZ3MuIFRoZXJlIGFyZSBhbHdheXMgbGluZSBicmVha3Ncbi8vIGJldHdlZW4gdGhlc2Ugc3RyaW5ncy4gTGVhdmVzIGFyZSBsaW1pdGVkIGluIHNpemUgYW5kIGhhdmUgdG8gYmVcbi8vIGNvbnRhaW5lZCBpbiBUZXh0Tm9kZSBpbnN0YW5jZXMgZm9yIGJpZ2dlciBkb2N1bWVudHMuXG5jbGFzcyBUZXh0TGVhZiBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGxlbmd0aCA9IHRleHRMZW5ndGgodGV4dCkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldCBsaW5lcygpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnRleHRbaV0sIGVuZCA9IG9mZnNldCArIHN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGxpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmUob2Zmc2V0LCBlbmQsIGxpbmUsIHN0cmluZyk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZnJvbSA8PSAwICYmIHRvID49IHRoaXMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgVGV4dExlYWYoc2xpY2VUZXh0KHRoaXMudGV4dCwgZnJvbSwgdG8pLCBNYXRoLm1pbih0bywgdGhpcy5sZW5ndGgpIC0gTWF0aC5tYXgoMCwgZnJvbSkpO1xuICAgICAgICBpZiAob3BlbiAmIDEgLyogT3Blbi5Gcm9tICovKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRhcmdldC5wb3AoKTtcbiAgICAgICAgICAgIGxldCBqb2luZWQgPSBhcHBlbmRUZXh0KHRleHQudGV4dCwgcHJldi50ZXh0LnNsaWNlKCksIDAsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChqb2luZWQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZCwgcHJldi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1pZCA9IGpvaW5lZC5sZW5ndGggPj4gMTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKDAsIG1pZCkpLCBuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKG1pZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmKSlcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgbGluZXMgPSBhcHBlbmRUZXh0KHRoaXMudGV4dCwgYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHNsaWNlVGV4dCh0aGlzLnRleHQsIDAsIGZyb20pKSwgdG8pO1xuICAgICAgICBsZXQgbmV3TGVuID0gdGhpcy5sZW5ndGggKyB0ZXh0Lmxlbmd0aCAtICh0byAtIGZyb20pO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihsaW5lcywgbmV3TGVuKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQobGluZXMsIFtdKSwgbmV3TGVuKTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMudGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnRleHQpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbCgpIHsgcmV0dXJuIDA7IH1cbiAgICBzdGF0aWMgc3BsaXQodGV4dCwgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBwYXJ0ID0gW10sIGxlbiA9IC0xO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHBhcnQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxlbiArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBPcGVuLkZyb20gKi8gOiAwKSB8IChlbmQgPj0gdG8gPyAyIC8qIE9wZW4uVG8gKi8gOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIGVuZCA8PSB0byAmJiAhY2hpbGRPcGVuKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWNvbXBvc2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRhcmdldCwgY2hpbGRPcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGlmICh0ZXh0LmxpbmVzIDwgdGhpcy5saW5lcylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSBjaGFuZ2Ugb25seSBhZmZlY3RzIG9uZSBjaGlsZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQncyBzaXplIHJlbWFpbnMgaW4gdGhlIGFjY2VwdGFibGUgcmFuZ2UsIG9ubHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjaGlsZFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHBvcyAmJiB0byA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSBjaGlsZC5yZXBsYWNlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsTGluZXMgPSB0aGlzLmxpbmVzIC0gY2hpbGQubGluZXMgKyB1cGRhdGVkLmxpbmVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5saW5lcyA8ICh0b3RhbExpbmVzID4+ICg1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8gLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQubGluZXMgPiAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29weSA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlbaV0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZShjb3B5LCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHBvcywgZW5kLCB1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UoZnJvbSwgdG8sIHRleHQpO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLnNsaWNlU3RyaW5nKGZyb20gLSBwb3MsIHRvIC0gcG9zLCBsaW5lU2VwKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgIGNoaWxkLmZsYXR0ZW4odGFyZ2V0KTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbChvdGhlciwgZGlyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVGV4dE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBsZXQgW2lBLCBpQiwgZUEsIGVCXSA9IGRpciA+IDAgPyBbMCwgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIG90aGVyLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgICAgIDogW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIC0xXTtcbiAgICAgICAgZm9yICg7OyBpQSArPSBkaXIsIGlCICs9IGRpcikge1xuICAgICAgICAgICAgaWYgKGlBID09IGVBIHx8IGlCID09IGVCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2hBID0gdGhpcy5jaGlsZHJlbltpQV0sIGNoQiA9IG90aGVyLmNoaWxkcmVuW2lCXTtcbiAgICAgICAgICAgIGlmIChjaEEgIT0gY2hCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggKyBjaEEuc2NhbklkZW50aWNhbChjaEIsIGRpcik7XG4gICAgICAgICAgICBsZW5ndGggKz0gY2hBLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb20oY2hpbGRyZW4sIGxlbmd0aCA9IGNoaWxkcmVuLnJlZHVjZSgobCwgY2gpID0+IGwgKyBjaC5sZW5ndGggKyAxLCAtMSkpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBsaW5lcyArPSBjaC5saW5lcztcbiAgICAgICAgaWYgKGxpbmVzIDwgMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgIGxldCBmbGF0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaC5mbGF0dGVuKGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihmbGF0LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaHVuayA9IE1hdGgubWF4KDMyIC8qIFRyZWUuQnJhbmNoICovLCBsaW5lcyA+PiA1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8pLCBtYXhDaHVuayA9IGNodW5rIDw8IDEsIG1pbkNodW5rID0gY2h1bmsgPj4gMTtcbiAgICAgICAgbGV0IGNodW5rZWQgPSBbXSwgY3VycmVudExpbmVzID0gMCwgY3VycmVudExlbiA9IC0xLCBjdXJyZW50Q2h1bmsgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkKGNoaWxkKSB7XG4gICAgICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgICAgIGlmIChjaGlsZC5saW5lcyA+IG1heENodW5rICYmIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGNoaWxkLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBhZGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5saW5lcyA+IG1pbkNodW5rICYmIChjdXJyZW50TGluZXMgPiBtaW5DaHVuayB8fCAhY3VycmVudExpbmVzKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dExlYWYgJiYgY3VycmVudExpbmVzICYmXG4gICAgICAgICAgICAgICAgKGxhc3QgPSBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIFRleHRMZWFmICYmXG4gICAgICAgICAgICAgICAgY2hpbGQubGluZXMgKyBsYXN0LmxpbmVzIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdID0gbmV3IFRleHRMZWFmKGxhc3QudGV4dC5jb25jYXQoY2hpbGQudGV4dCksIGxhc3QubGVuZ3RoICsgMSArIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudExpbmVzICsgY2hpbGQubGluZXMgPiBjaHVuaylcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuay5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGluZXMgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjaHVua2VkLnB1c2goY3VycmVudENodW5rLmxlbmd0aCA9PSAxID8gY3VycmVudENodW5rWzBdIDogVGV4dE5vZGUuZnJvbShjdXJyZW50Q2h1bmssIGN1cnJlbnRMZW4pKTtcbiAgICAgICAgICAgIGN1cnJlbnRMZW4gPSAtMTtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lcyA9IGN1cnJlbnRDaHVuay5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgYWRkKGNoaWxkKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGNodW5rZWQubGVuZ3RoID09IDEgPyBjaHVua2VkWzBdIDogbmV3IFRleHROb2RlKGNodW5rZWQsIGxlbmd0aCk7XG4gICAgfVxufVxuVGV4dC5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgVGV4dExlYWYoW1wiXCJdLCAwKTtcbmZ1bmN0aW9uIHRleHRMZW5ndGgodGV4dCkge1xuICAgIGxldCBsZW5ndGggPSAtMTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpXG4gICAgICAgIGxlbmd0aCArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmZ1bmN0aW9uIGFwcGVuZFRleHQodGV4dCwgdGFyZ2V0LCBmcm9tID0gMCwgdG8gPSAxZTkpIHtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMCwgZmlyc3QgPSB0cnVlOyBpIDwgdGV4dC5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0ZXh0W2ldLCBlbmQgPSBwb3MgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA+PSBmcm9tKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgdG8gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20pXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoZnJvbSAtIHBvcyk7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbdGFyZ2V0Lmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc2xpY2VUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGFwcGVuZFRleHQodGV4dCwgW1wiXCJdLCBmcm9tLCB0byk7XG59XG5jbGFzcyBSYXdUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBkaXIgPSAxKSB7XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdGV4dF07XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IFtkaXIgPiAwID8gMSA6ICh0ZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyB0ZXh0LnRleHQubGVuZ3RoIDogdGV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDFdO1xuICAgIH1cbiAgICBuZXh0SW5uZXIoc2tpcCwgZGlyKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMubm9kZXNbbGFzdF0sIG9mZnNldFZhbHVlID0gdGhpcy5vZmZzZXRzW2xhc3RdLCBvZmZzZXQgPSBvZmZzZXRWYWx1ZSA+PiAxO1xuICAgICAgICAgICAgbGV0IHNpemUgPSB0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRvcC50ZXh0Lmxlbmd0aCA6IHRvcC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IChkaXIgPiAwID8gc2l6ZSA6IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdCAtIDFdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgob2Zmc2V0VmFsdWUgJiAxKSA9PSAoZGlyID4gMCA/IDAgOiAxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9wIGluc3RhbmNlb2YgVGV4dExlYWYpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLnRleHRbb2Zmc2V0ICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Lmxlbmd0aCA+IE1hdGgubWF4KDAsIHNraXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBza2lwID09IDAgPyBuZXh0IDogZGlyID4gMCA/IG5leHQuc2xpY2Uoc2tpcCkgOiBuZXh0LnNsaWNlKDAsIG5leHQubGVuZ3RoIC0gc2tpcCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5bb2Zmc2V0ICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA+IG5leHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XS0tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKGRpciA+IDAgPyAxIDogKG5leHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IG5leHQudGV4dC5sZW5ndGggOiBuZXh0LmNoaWxkcmVuLmxlbmd0aCkgPDwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgaWYgKHNraXAgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRJbm5lcigtc2tpcCwgKC10aGlzLmRpcikpO1xuICAgICAgICAgICAgc2tpcCA9IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmRpcik7XG4gICAgfVxufVxuY2xhc3MgUGFydGlhbFRleHRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRleHQsIHN0YXJ0ID4gZW5kID8gLTEgOiAxKTtcbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydCA+IGVuZCA/IHRleHQubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy5mcm9tID0gTWF0aC5taW4oc3RhcnQsIGVuZCk7XG4gICAgICAgIHRoaXMudG8gPSBNYXRoLm1heChzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xuICAgICAgICBpZiAoZGlyIDwgMCA/IHRoaXMucG9zIDw9IHRoaXMuZnJvbSA6IHRoaXMucG9zID49IHRoaXMudG8pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHNraXAgKz0gTWF0aC5tYXgoMCwgZGlyIDwgMCA/IHRoaXMucG9zIC0gdGhpcy50byA6IHRoaXMuZnJvbSAtIHRoaXMucG9zKTtcbiAgICAgICAgbGV0IGxpbWl0ID0gZGlyIDwgMCA/IHRoaXMucG9zIC0gdGhpcy5mcm9tIDogdGhpcy50byAtIHRoaXMucG9zO1xuICAgICAgICBpZiAoc2tpcCA+IGxpbWl0KVxuICAgICAgICAgICAgc2tpcCA9IGxpbWl0O1xuICAgICAgICBsaW1pdCAtPSBza2lwO1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gdGhpcy5jdXJzb3IubmV4dChza2lwKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gKHZhbHVlLmxlbmd0aCArIHNraXApICogZGlyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUubGVuZ3RoIDw9IGxpbWl0ID8gdmFsdWUgOiBkaXIgPCAwID8gdmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gbGltaXQpIDogdmFsdWUuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgICB0aGlzLmRvbmUgPSAhdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgaWYgKHNraXAgPCAwKVxuICAgICAgICAgICAgc2tpcCA9IE1hdGgubWF4KHNraXAsIHRoaXMuZnJvbSAtIHRoaXMucG9zKTtcbiAgICAgICAgZWxzZSBpZiAoc2tpcCA+IDApXG4gICAgICAgICAgICBza2lwID0gTWF0aC5taW4oc2tpcCwgdGhpcy50byAtIHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dElubmVyKHNraXAsIHRoaXMuY3Vyc29yLmRpcik7XG4gICAgfVxuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiB0aGlzLmN1cnNvci5saW5lQnJlYWsgJiYgdGhpcy52YWx1ZSAhPSBcIlwiOyB9XG59XG5jbGFzcyBMaW5lQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lcikge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IHRydWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBsZXQgeyBkb25lLCBsaW5lQnJlYWssIHZhbHVlIH0gPSB0aGlzLmlubmVyLm5leHQoc2tpcCk7XG4gICAgICAgIGlmIChkb25lICYmIHRoaXMuYWZ0ZXJCcmVhaykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZUJyZWFrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZnRlckJyZWFrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFRleHQucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLml0ZXIoKTsgfTtcbiAgICBSYXdUZXh0Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gUGFydGlhbFRleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxuICAgICAgICBMaW5lQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbn1cbi8qKlxuVGhpcyB0eXBlIGRlc2NyaWJlcyBhIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBJdCBpcyBjcmVhdGVkXG5vbi1kZW1hbmQgd2hlbiBsaW5lcyBhcmUgW3F1ZXJpZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dC5saW5lQXQpLlxuKi9cbmNsYXNzIExpbmUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIChfYmVmb3JlXyB0aGUgbGluZSBicmVhayxcbiAgICBvciBhdCB0aGUgZW5kIG9mIGRvY3VtZW50IGZvciB0aGUgbGFzdCBsaW5lKS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGlzIGxpbmUncyBsaW5lIG51bWJlciAoMS1iYXNlZCkuXG4gICAgKi9cbiAgICBudW1iZXIsIFxuICAgIC8qKlxuICAgIFRoZSBsaW5lJ3MgY29udGVudC5cbiAgICAqL1xuICAgIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgbGluZSAobm90IGluY2x1ZGluZyBhbnkgbGluZSBicmVhayBhZnRlciBpdCkuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50byAtIHRoaXMuZnJvbTsgfVxufVxuZnVuY3Rpb24gY2xpcCh0ZXh0LCBmcm9tLCB0bykge1xuICAgIGZyb20gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgZnJvbSkpO1xuICAgIHJldHVybiBbZnJvbSwgTWF0aC5tYXgoZnJvbSwgTWF0aC5taW4odGV4dC5sZW5ndGgsIHRvKSldO1xufVxuXG4vKipcblJldHVybnMgYSBuZXh0IGdyYXBoZW1lIGNsdXN0ZXIgYnJlYWsgX2FmdGVyXyAobm90IGVxdWFsIHRvKVxuYHBvc2AsIGlmIGBmb3J3YXJkYCBpcyB0cnVlLCBvciBiZWZvcmUgb3RoZXJ3aXNlLiBSZXR1cm5zIGBwb3NgXG5pdHNlbGYgaWYgbm8gZnVydGhlciBjbHVzdGVyIGJyZWFrIGlzIGF2YWlsYWJsZSBpbiB0aGUgc3RyaW5nLlxuTW92ZXMgYWNyb3NzIHN1cnJvZ2F0ZSBwYWlycywgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgKHdoZW5cbmBpbmNsdWRlRXh0ZW5kaW5nYCBpcyB0cnVlKSwgY2hhcmFjdGVycyBqb2luZWQgd2l0aCB6ZXJvLXdpZHRoXG5qb2luZXJzLCBhbmQgZmxhZyBlbW9qaS5cbiovXG5mdW5jdGlvbiBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgcG9zLCBmb3J3YXJkID0gdHJ1ZSwgaW5jbHVkZUV4dGVuZGluZyA9IHRydWUpIHtcbiAgICByZXR1cm4gZmluZENsdXN0ZXJCcmVhayQxKHN0ciwgcG9zLCBmb3J3YXJkLCBpbmNsdWRlRXh0ZW5kaW5nKTtcbn1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUxvdyhjaCkgeyByZXR1cm4gY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhFMDAwOyB9XG5mdW5jdGlvbiBzdXJyb2dhdGVIaWdoKGNoKSB7IHJldHVybiBjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERDMDA7IH1cbi8qKlxuRmluZCB0aGUgY29kZSBwb2ludCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gYSBzdHJpbmcgKGxpa2UgdGhlXG5bYGNvZGVQb2ludEF0YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2NvZGVQb2ludEF0KVxuc3RyaW5nIG1ldGhvZCkuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyLCBwb3MpIHtcbiAgICBsZXQgY29kZTAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghc3Vycm9nYXRlSGlnaChjb2RlMCkgfHwgcG9zICsgMSA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgbGV0IGNvZGUxID0gc3RyLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKCFzdXJyb2dhdGVMb3coY29kZTEpKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgcmV0dXJuICgoY29kZTAgLSAweGQ4MDApIDw8IDEwKSArIChjb2RlMSAtIDB4ZGMwMCkgKyAweDEwMDAwO1xufVxuLyoqXG5HaXZlbiBhIFVuaWNvZGUgY29kZXBvaW50LCByZXR1cm4gdGhlIEphdmFTY3JpcHQgc3RyaW5nIHRoYXRcbnJlc3ByZXNlbnRzIGl0IChsaWtlXG5bYFN0cmluZy5mcm9tQ29kZVBvaW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2Zyb21Db2RlUG9pbnQpKS5cbiovXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA8PSAweGZmZmYpXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweGQ4MDAsIChjb2RlICYgMTAyMykgKyAweGRjMDApO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHBvc2l0aW9ucyBhIGNoYXJhY3RlciB0YWtlcyB1cCBpbiBhIEphdmFTY3JpcHQgc3RyaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVQb2ludFNpemUoY29kZSkgeyByZXR1cm4gY29kZSA8IDB4MTAwMDAgPyAxIDogMjsgfVxuXG5jb25zdCBEZWZhdWx0U3BsaXQgPSAvXFxyXFxuP3xcXG4vO1xuLyoqXG5EaXN0aW5ndWlzaGVzIGRpZmZlcmVudCB3YXlzIGluIHdoaWNoIHBvc2l0aW9ucyBjYW4gYmUgbWFwcGVkLlxuKi9cbnZhciBNYXBNb2RlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWFwTW9kZSkge1xuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRvIGEgdmFsaWQgbmV3IHBvc2l0aW9uLCBldmVuIHdoZW4gaXRzIGNvbnRleHRcbiAgICB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlNpbXBsZVwiXSA9IDBdID0gXCJTaW1wbGVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiBkZWxldGlvbiBoYXBwZW5zIGFjcm9zcyB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0RlbFwiXSA9IDFdID0gXCJUcmFja0RlbFwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2JlZm9yZV8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0JlZm9yZVwiXSA9IDJdID0gXCJUcmFja0JlZm9yZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2FmdGVyXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQWZ0ZXJcIl0gPSAzXSA9IFwiVHJhY2tBZnRlclwiO1xucmV0dXJuIE1hcE1vZGV9KShNYXBNb2RlIHx8IChNYXBNb2RlID0ge30pKTtcbi8qKlxuQSBjaGFuZ2UgZGVzY3JpcHRpb24gaXMgYSB2YXJpYW50IG9mIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldClcbnRoYXQgZG9lc24ndCBzdG9yZSB0aGUgaW5zZXJ0ZWQgdGV4dC4gQXMgc3VjaCwgaXQgY2FuJ3QgYmVcbmFwcGxpZWQsIGJ1dCBpcyBjaGVhcGVyIHRvIHN0b3JlIGFuZCBtYW5pcHVsYXRlLlxuKi9cbmNsYXNzIENoYW5nZURlc2Mge1xuICAgIC8vIFNlY3Rpb25zIGFyZSBlbmNvZGVkIGFzIHBhaXJzIG9mIGludGVnZXJzLiBUaGUgZmlyc3QgaXMgdGhlXG4gICAgLy8gbGVuZ3RoIGluIHRoZSBjdXJyZW50IGRvY3VtZW50LCBhbmQgdGhlIHNlY29uZCBpcyAtMSBmb3JcbiAgICAvLyB1bmFmZmVjdGVkIHNlY3Rpb25zLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgcmVwbGFjZW1lbnQgY29udGVudFxuICAgIC8vIG90aGVyd2lzZS4gU28gYW4gaW5zZXJ0aW9uIHdvdWxkIGJlICgwLCBuPjApLCBhIGRlbGV0aW9uIChuPjAsXG4gICAgLy8gMCksIGFuZCBhIHJlcGxhY2VtZW50IHR3byBwb3NpdGl2ZSBudW1iZXJzLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZWN0aW9ucykge1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnNlY3Rpb25zW2ldO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBhZnRlciB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IG5ld0xlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGlucyA8IDAgPyB0aGlzLnNlY3Rpb25zW2ldIDogaW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZhbHNlIHdoZW4gdGhlcmUgYXJlIGFjdHVhbCBjaGFuZ2VzIGluIHRoaXMgc2V0LlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAyICYmIHRoaXMuc2VjdGlvbnNbMV0gPCAwOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB1bmNoYW5nZWQgcGFydHMgbGVmdCBieSB0aGVzZSBjaGFuZ2VzLiBgcG9zQWBcbiAgICBwcm92aWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHJhbmdlIGluIHRoZSBvbGQgZG9jdW1lbnQsIGBwb3NCYFxuICAgIHRoZSBuZXcgcG9zaXRpb24gaW4gdGhlIGNoYW5nZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpdGVyR2FwcyhmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgZihwb3NBLCBwb3NCLCBsZW4pO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBjaGFuZ2VkIGJ5IHRoZXNlIGNoYW5nZXMuIChTZWVcbiAgICBbYENoYW5nZVNldC5pdGVyQ2hhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzKSBmb3IgYVxuICAgIHZhcmlhbnQgdGhhdCBhbHNvIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSBpbnNlcnRlZCB0ZXh0LilcbiAgICBgZnJvbUFgL2B0b0FgIHByb3ZpZGVzIHRoZSBleHRlbnQgb2YgdGhlIGNoYW5nZSBpbiB0aGUgc3RhcnRpbmdcbiAgICBkb2N1bWVudCwgYGZyb21CYC9gdG9CYCB0aGUgZXh0ZW50IG9mIHRoZSByZXBsYWNlbWVudCBpbiB0aGVcbiAgICBjaGFuZ2VkIGRvY3VtZW50LlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgKHdoaWNoIGFyZSBrZXB0XG4gICAgc2VwYXJhdGUgZm9yIFtwb3NpdGlvbiBtYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MubWFwUG9zKSkgYXJlXG4gICAgcmVwb3J0ZWQgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VkUmFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGludmVydGVkIGZvcm0gb2YgdGhlc2UgY2hhbmdlcy5cbiAgICAqL1xuICAgIGdldCBpbnZlcnRlZERlc2MoKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChpbnMsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcHV0ZSB0aGUgY29tYmluZWQgZWZmZWN0IG9mIGFwcGx5aW5nIGFub3RoZXIgc2V0IG9mIGNoYW5nZXNcbiAgICBhZnRlciB0aGlzIG9uZS4gVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhpcyBzZXQgc2hvdWxkXG4gICAgbWF0Y2ggdGhlIGxlbmd0aCBiZWZvcmUgYG90aGVyYC5cbiAgICAqL1xuICAgIGNvbXBvc2VEZXNjKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlcik7IH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBkZXNjcmlwdGlvbiwgd2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggdGhlIHNhbWUgZG9jdW1lbnRcbiAgICBhcyBgb3RoZXJgLCBvdmVyIGFub3RoZXIgc2V0IG9mIGNoYW5nZXMsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgYXBwbGllZCBhZnRlciBpdC4gV2hlbiBgYmVmb3JlYCBpcyB0cnVlLCBtYXAgYXMgaWYgdGhlIGNoYW5nZXNcbiAgICBpbiBgdGhpc2AgaGFwcGVuZWQgYmVmb3JlIHRoZSBvbmVzIGluIGBvdGhlcmAuXG4gICAgKi9cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUpOyB9XG4gICAgbWFwUG9zKHBvcywgYXNzb2MgPSAtMSwgbW9kZSA9IE1hcE1vZGUuU2ltcGxlKSB7XG4gICAgICAgIGxldCBwb3NBID0gMCwgcG9zQiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZEEgPSBwb3NBICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc0IgKyAocG9zIC0gcG9zQSk7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPSBNYXBNb2RlLlNpbXBsZSAmJiBlbmRBID49IHBvcyAmJlxuICAgICAgICAgICAgICAgICAgICAobW9kZSA9PSBNYXBNb2RlLlRyYWNrRGVsICYmIHBvc0EgPCBwb3MgJiYgZW5kQSA+IHBvcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PSBNYXBNb2RlLlRyYWNrQmVmb3JlICYmIHBvc0EgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0FmdGVyICYmIGVuZEEgPiBwb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcyB8fCBlbmRBID09IHBvcyAmJiBhc3NvYyA8IDAgJiYgIWxlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA9PSBwb3NBIHx8IGFzc29jIDwgMCA/IHBvc0IgOiBwb3NCICsgaW5zO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+IHBvc0EpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtwb3N9IGlzIG91dCBvZiByYW5nZSBmb3IgY2hhbmdlc2V0IG9mIGxlbmd0aCAke3Bvc0F9YCk7XG4gICAgICAgIHJldHVybiBwb3NCO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZXNlIGNoYW5nZXMgdG91Y2ggYSBnaXZlbiByYW5nZS4gV2hlbiBvbmUgb2YgdGhlXG4gICAgY2hhbmdlcyBlbnRpcmVseSBjb3ZlcnMgdGhlIHJhbmdlLCB0aGUgc3RyaW5nIGBcImNvdmVyXCJgIGlzXG4gICAgcmV0dXJuZWQuXG4gICAgKi9cbiAgICB0b3VjaGVzUmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGggJiYgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmQgPSBwb3MgKyBsZW47XG4gICAgICAgICAgICBpZiAoaW5zID49IDAgJiYgcG9zIDw9IHRvICYmIGVuZCA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPCBmcm9tICYmIGVuZCA+IHRvID8gXCJjb3ZlclwiIDogdHJ1ZTtcbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IChyZXN1bHQgPyBcIiBcIiA6IFwiXCIpICsgbGVuICsgKGlucyA+PSAwID8gXCI6XCIgKyBpbnMgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2UgZGVzYyB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnM7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2UgZGVzYyBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZFxuICAgIGJ5IFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikgfHwganNvbi5sZW5ndGggJSAyIHx8IGpzb24uc29tZShhID0+IHR5cGVvZiBhICE9IFwibnVtYmVyXCIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlRGVzY1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc2VjdGlvbnMpIHsgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTsgfVxufVxuLyoqXG5BIGNoYW5nZSBzZXQgcmVwcmVzZW50cyBhIGdyb3VwIG9mIG1vZGlmaWNhdGlvbnMgdG8gYSBkb2N1bWVudC4gSXRcbnN0b3JlcyB0aGUgZG9jdW1lbnQgbGVuZ3RoLCBhbmQgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBkb2N1bWVudHNcbndpdGggZXhhY3RseSB0aGF0IGxlbmd0aC5cbiovXG5jbGFzcyBDaGFuZ2VTZXQgZXh0ZW5kcyBDaGFuZ2VEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN0aW9ucywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRlZCkge1xuICAgICAgICBzdXBlcihzZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0ZWQgPSBpbnNlcnRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgdGhlIGNoYW5nZXMgdG8gYSBkb2N1bWVudCwgcmV0dXJuaW5nIHRoZSBtb2RpZmllZFxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPSBkb2MubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcHBseWluZyBjaGFuZ2Ugc2V0IHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCAoZnJvbUEsIHRvQSwgZnJvbUIsIF90b0IsIHRleHQpID0+IGRvYyA9IGRvYy5yZXBsYWNlKGZyb21CLCBmcm9tQiArICh0b0EgLSBmcm9tQSksIHRleHQpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBfYmVmb3JlXyB0aGUgY2hhbmdlcywgcmV0dXJuIGFcbiAgICBjaGFuZ2Ugc2V0IHRoYXQgcmVwcmVzZW50cyB0aGUgaW52ZXJzZSBvZiB0aGlzIHNldCwgd2hpY2ggY291bGRcbiAgICBiZSB1c2VkIHRvIGdvIGZyb20gdGhlIGRvY3VtZW50IGNyZWF0ZWQgYnkgdGhlIGNoYW5nZXMgYmFjayB0b1xuICAgIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIGJlZm9yZSB0aGUgY2hhbmdlcy5cbiAgICAqL1xuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gdGhpcy5zZWN0aW9ucy5zbGljZSgpLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gc2VjdGlvbnNbaV0sIGlucyA9IHNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2ldID0gaW5zO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2kgKyAxXSA9IGxlbjtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBpID4+IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2gobGVuID8gZG9jLnNsaWNlKHBvcywgcG9zICsgbGVuKSA6IFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21iaW5lIHR3byBzdWJzZXF1ZW50IGNoYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LiBgb3RoZXJgXG4gICAgbXVzdCBzdGFydCBpbiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYHRoaXNgLiBJZiBgdGhpc2AgZ29lc1xuICAgIGBkb2NBYCBcdTIxOTIgYGRvY0JgIGFuZCBgb3RoZXJgIHJlcHJlc2VudHMgYGRvY0JgIFx1MjE5MiBgZG9jQ2AsIHRoZVxuICAgIHJldHVybmVkIHZhbHVlIHdpbGwgcmVwcmVzZW50IHRoZSBjaGFuZ2UgYGRvY0FgIFx1MjE5MiBgZG9jQ2AuXG4gICAgKi9cbiAgICBjb21wb3NlKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlciwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiBhbm90aGVyIGNoYW5nZSBzZXQgc3RhcnRpbmcgaW4gdGhlIHNhbWUgZG9jdW1lbnQsIG1hcHMgdGhpc1xuICAgIGNoYW5nZSBzZXQgb3ZlciB0aGUgb3RoZXIsIHByb2R1Y2luZyBhIG5ldyBjaGFuZ2Ugc2V0IHRoYXQgY2FuIGJlXG4gICAgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYXBwbHlpbmcgYG90aGVyYC4gV2hlblxuICAgIGBiZWZvcmVgIGlzIGB0cnVlYCwgb3JkZXIgY2hhbmdlcyBhcyBpZiBgdGhpc2AgY29tZXMgYmVmb3JlXG4gICAgYG90aGVyYCwgb3RoZXJ3aXNlICh0aGUgZGVmYXVsdCkgdHJlYXQgYG90aGVyYCBhcyBjb21pbmcgZmlyc3QuXG4gICAgXG4gICAgR2l2ZW4gdHdvIGNoYW5nZXMgYEFgIGFuZCBgQmAsIGBBLmNvbXBvc2UoQi5tYXAoQSkpYCBhbmRcbiAgICBgQi5jb21wb3NlKEEubWFwKEIsIHRydWUpKWAgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIGRvY3VtZW50LiBUaGlzXG4gICAgcHJvdmlkZXMgYSBiYXNpYyBmb3JtIG9mIFtvcGVyYXRpb25hbFxuICAgIHRyYW5zZm9ybWF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRpb25hbF90cmFuc2Zvcm1hdGlvbiksXG4gICAgYW5kIGNhbiBiZSB1c2VkIGZvciBjb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4gICAgKi9cbiAgICBtYXAob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGNoYW5nZWQgcmFuZ2VzIGluIHRoZSBkb2N1bWVudCwgY2FsbGluZyBgZmAgZm9yXG4gICAgZWFjaCwgd2l0aCB0aGUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50IChgZnJvbUFgLWB0b0FgKVxuICAgIGFuZCB0aGUgcmFuZ2UgdGhhdCByZXBsYWNlcyBpdCBpbiB0aGUgbmV3IGRvY3VtZW50XG4gICAgKGBmcm9tQmAtYHRvQmApLlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgYXJlIHJlcG9ydGVkXG4gICAgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW2NoYW5nZSBkZXNjcmlwdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjKSBmb3IgdGhpcyBjaGFuZ2VcbiAgICBzZXQuXG4gICAgKi9cbiAgICBnZXQgZGVzYygpIHsgcmV0dXJuIENoYW5nZURlc2MuY3JlYXRlKHRoaXMuc2VjdGlvbnMpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaWx0ZXIocmFuZ2VzKSB7XG4gICAgICAgIGxldCByZXN1bHRTZWN0aW9ucyA9IFtdLCByZXN1bHRJbnNlcnRlZCA9IFtdLCBmaWx0ZXJlZFNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBpdGVyID0gbmV3IFNlY3Rpb25JdGVyKHRoaXMpO1xuICAgICAgICBkb25lOiBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gcmFuZ2VzLmxlbmd0aCA/IDFlOSA6IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IG5leHQgfHwgcG9zID09IG5leHQgJiYgaXRlci5sZW4gPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBuZXh0IC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGxldCBpbnMgPSBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMDtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIGlucyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucyA+IDApXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChyZXN1bHRJbnNlcnRlZCwgcmVzdWx0U2VjdGlvbnMsIGl0ZXIudGV4dCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmQgPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgZW5kIC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDApO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogbmV3IENoYW5nZVNldChyZXN1bHRTZWN0aW9ucywgcmVzdWx0SW5zZXJ0ZWQpLFxuICAgICAgICAgICAgZmlsdGVyZWQ6IENoYW5nZURlc2MuY3JlYXRlKGZpbHRlcmVkU2VjdGlvbnMpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBzZXQgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2ldLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gobGVuKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucyA9PSAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0uY29uY2F0KHRoaXMuaW5zZXJ0ZWRbaSA+PiAxXS50b0pTT04oKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIHNldCBmb3IgdGhlIGdpdmVuIGNoYW5nZXMsIGZvciBhIGRvY3VtZW50IG9mIHRoZVxuICAgIGdpdmVuIGxlbmd0aCwgdXNpbmcgYGxpbmVTZXBgIGFzIGxpbmUgc2VwYXJhdG9yLlxuICAgICovXG4gICAgc3RhdGljIG9mKGNoYW5nZXMsIGxlbmd0aCwgbGluZVNlcCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ZWQgPSBbXSwgcG9zID0gMDtcbiAgICAgICAgbGV0IHRvdGFsID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gZmx1c2goZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCFmb3JjZSAmJiAhc2VjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW5ndGgpXG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuZ3RoIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc2V0Lm1hcCh0b3RhbCkpIDogc2V0O1xuICAgICAgICAgICAgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGluc2VydGVkID0gW107XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Moc3BlYykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3BlYykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWIgb2Ygc3BlYylcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhzdWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLmxlbmd0aCAhPSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3RoIChnb3QgJHtzcGVjLmxlbmd0aH0sIGV4cGVjdGVkICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNwZWMubWFwKHRvdGFsKSkgOiBzcGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gPSBmcm9tLCBpbnNlcnQgfSA9IHNwZWM7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiB0byB8fCBmcm9tIDwgMCB8fCB0byA+IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY2hhbmdlIHJhbmdlICR7ZnJvbX0gdG8gJHt0b30gKGluIGRvYyBvZiBsZW5ndGggJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGxldCBpbnNUZXh0ID0gIWluc2VydCA/IFRleHQuZW1wdHkgOiB0eXBlb2YgaW5zZXJ0ID09IFwic3RyaW5nXCIgPyBUZXh0Lm9mKGluc2VydC5zcGxpdChsaW5lU2VwIHx8IERlZmF1bHRTcGxpdCkpIDogaW5zZXJ0O1xuICAgICAgICAgICAgICAgIGxldCBpbnNMZW4gPSBpbnNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0byAmJiBpbnNMZW4gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBmcm9tIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgdG8gLSBmcm9tLCBpbnNMZW4pO1xuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnRlZCwgc2VjdGlvbnMsIGluc1RleHQpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MoY2hhbmdlcyk7XG4gICAgICAgIGZsdXNoKCF0b3RhbCk7XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGNoYW5nZXNldCBvZiB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICAgICovXG4gICAgc3RhdGljIGVtcHR5KGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChsZW5ndGggPyBbbGVuZ3RoLCAtMV0gOiBbXSwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2VzZXQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWQgYnlcbiAgICBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0LnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0ganNvbltpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0LCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXJ0KSB8fCB0eXBlb2YgcGFydFswXSAhPSBcIm51bWJlclwiIHx8IHBhcnQuc29tZSgoZSwgaSkgPT4gaSAmJiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnRbMF0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGkpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRbaV0gPSBUZXh0Lm9mKHBhcnQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgaW5zZXJ0ZWRbaV0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnMsIGZvcmNlSm9pbiA9IGZhbHNlKSB7XG4gICAgaWYgKGxlbiA9PSAwICYmIGlucyA8PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxhc3QgPSBzZWN0aW9ucy5sZW5ndGggLSAyO1xuICAgIGlmIChsYXN0ID49IDAgJiYgaW5zIDw9IDAgJiYgaW5zID09IHNlY3Rpb25zW2xhc3QgKyAxXSlcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgIGVsc2UgaWYgKGxhc3QgPj0gMCAmJiBsZW4gPT0gMCAmJiBzZWN0aW9uc1tsYXN0XSA9PSAwKVxuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIGVsc2UgaWYgKGZvcmNlSm9pbikge1xuICAgICAgICBzZWN0aW9uc1tsYXN0XSArPSBsZW47XG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG59XG5mdW5jdGlvbiBhZGRJbnNlcnQodmFsdWVzLCBzZWN0aW9ucywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgaW5kZXggPSAoc2VjdGlvbnMubGVuZ3RoIC0gMikgPj4gMTtcbiAgICBpZiAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0gPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdLmFwcGVuZCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAodmFsdWVzLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgdmFsdWVzLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyQ2hhbmdlcyhkZXNjLCBmLCBpbmRpdmlkdWFsKSB7XG4gICAgbGV0IGluc2VydGVkID0gZGVzYy5pbnNlcnRlZDtcbiAgICBmb3IgKGxldCBwb3NBID0gMCwgcG9zQiA9IDAsIGkgPSAwOyBpIDwgZGVzYy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK10sIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgIHBvc0EgKz0gbGVuO1xuICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZW5kQSA9IHBvc0EsIGVuZEIgPSBwb3NCLCB0ZXh0ID0gVGV4dC5lbXB0eTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBlbmRBICs9IGxlbjtcbiAgICAgICAgICAgICAgICBlbmRCICs9IGlucztcbiAgICAgICAgICAgICAgICBpZiAoaW5zICYmIGluc2VydGVkKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5hcHBlbmQoaW5zZXJ0ZWRbKGkgLSAyKSA+PiAxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGl2aWR1YWwgfHwgaSA9PSBkZXNjLnNlY3Rpb25zLmxlbmd0aCB8fCBkZXNjLnNlY3Rpb25zW2kgKyAxXSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgICAgICBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmKHBvc0EsIGVuZEEsIHBvc0IsIGVuZEIsIHRleHQpO1xuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgICAgICBwb3NCID0gZW5kQjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFNldChzZXRBLCBzZXRCLCBiZWZvcmUsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICAvLyBQcm9kdWNlIGEgY29weSBvZiBzZXRBIHRoYXQgYXBwbGllcyB0byB0aGUgZG9jdW1lbnQgYWZ0ZXIgc2V0QlxuICAgIC8vIGhhcyBiZWVuIGFwcGxpZWQgKGFzc3VtaW5nIGJvdGggc3RhcnQgYXQgdGhlIHNhbWUgZG9jdW1lbnQpLlxuICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnQgPSBta1NldCA/IFtdIDogbnVsbDtcbiAgICBsZXQgYSA9IG5ldyBTZWN0aW9uSXRlcihzZXRBKSwgYiA9IG5ldyBTZWN0aW9uSXRlcihzZXRCKTtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYm90aCBzZXRzIGluIHBhcmFsbGVsLiBpbnNlcnRlZCB0cmFja3MsIGZvciBjaGFuZ2VzXG4gICAgLy8gaW4gQSB0aGF0IGhhdmUgdG8gYmUgcHJvY2Vzc2VkIHBpZWNlLWJ5LXBpZWNlLCB3aGV0aGVyIHRoZWlyXG4gICAgLy8gY29udGVudCBoYXMgYmVlbiBpbnNlcnRlZCBhbHJlYWR5LCBhbmQgcmVmZXJzIHRvIHRoZSBzZWN0aW9uXG4gICAgLy8gaW5kZXguXG4gICAgZm9yIChsZXQgaW5zZXJ0ZWQgPSAtMTs7KSB7XG4gICAgICAgIGlmIChhLmRvbmUgJiYgYi5sZW4gfHwgYi5kb25lICYmIGEubGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA9PSAtMSAmJiBiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgLy8gTW92ZSBhY3Jvc3MgcmFuZ2VzIHNraXBwZWQgYnkgYm90aCBzZXRzLlxuICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuLCBiLmxlbik7XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgIGEuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5pbnMgPj0gMCAmJiAoYS5pbnMgPCAwIHx8IGluc2VydGVkID09IGEuaSB8fCBhLm9mZiA9PSAwICYmIChiLmxlbiA8IGEubGVuIHx8IGIubGVuID09IGEubGVuICYmICFiZWZvcmUpKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIGNoYW5nZSBpbiBCIHRoYXQgY29tZXMgYmVmb3JlIHRoZSBuZXh0IGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gQSAob3JkZXJlZCBieSBzdGFydCBwb3MsIHRoZW4gbGVuLCB0aGVuIGJlZm9yZSBmbGFnKSwgc2tpcFxuICAgICAgICAgICAgLy8gdGhhdCAoYW5kIHByb2Nlc3MgYW55IGNoYW5nZXMgaW4gQSBpdCBjb3ZlcnMpLlxuICAgICAgICAgICAgbGV0IGxlbiA9IGIubGVuO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYi5pbnMsIC0xKTtcbiAgICAgICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2UgPSBNYXRoLm1pbihhLmxlbiwgbGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoYS5pbnMgPj0gMCAmJiBpbnNlcnRlZCA8IGEuaSAmJiBhLmxlbiA8PSBwaWVjZSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBhLmlucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhLmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEuZm9yd2FyZChwaWVjZSk7XG4gICAgICAgICAgICAgICAgbGVuIC09IHBpZWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPj0gMCkge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgcGFydCBvZiBhIGNoYW5nZSBpbiBBIHVwIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gbm9uLWRlbGV0aW9uIGNoYW5nZSBpbiBCIChpZiBvdmVybGFwcGluZykuXG4gICAgICAgICAgICBsZXQgbGVuID0gMCwgbGVmdCA9IGEubGVuO1xuICAgICAgICAgICAgd2hpbGUgKGxlZnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4obGVmdCwgYi5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGllY2U7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gcGllY2U7XG4gICAgICAgICAgICAgICAgICAgIGIuZm9yd2FyZChwaWVjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIuaW5zID09IDAgJiYgYi5sZW4gPCBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gYi5sZW47XG4gICAgICAgICAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNlcnRlZCA8IGEuaSA/IGEuaW5zIDogMCk7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc2VydGVkIDwgYS5pKVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHQpO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhLmk7XG4gICAgICAgICAgICBhLmZvcndhcmQoYS5sZW4gLSBsZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ID8gQ2hhbmdlU2V0LmNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0KSA6IENoYW5nZURlc2MuY3JlYXRlKHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNldHMoc2V0QSwgc2V0QiwgbWtTZXQgPSBmYWxzZSkge1xuICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgIGxldCBpbnNlcnQgPSBta1NldCA/IFtdIDogbnVsbDtcbiAgICBsZXQgYSA9IG5ldyBTZWN0aW9uSXRlcihzZXRBKSwgYiA9IG5ldyBTZWN0aW9uSXRlcihzZXRCKTtcbiAgICBmb3IgKGxldCBvcGVuID0gZmFsc2U7Oykge1xuICAgICAgICBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IENoYW5nZVNldC5jcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBDaGFuZ2VEZXNjLmNyZWF0ZShzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPT0gMCkgeyAvLyBEZWxldGlvbiBpbiBBXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLmxlbiwgMCwgb3Blbik7XG4gICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmxlbiA9PSAwICYmICFiLmRvbmUpIHsgLy8gSW5zZXJ0aW9uIGluIEJcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGIuaW5zLCBvcGVuKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRvbmUgfHwgYi5kb25lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbjIsIGIubGVuKSwgc2VjdGlvbkxlbiA9IHNlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBpbnNCID0gYi5pbnMgPT0gLTEgPyAtMSA6IGIub2ZmID8gMCA6IGIuaW5zO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zQiwgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydCAmJiBpbnNCKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGxlbiwgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dEJpdChsZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBiLm9mZiA/IDAgOiBiLmlucywgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydCAmJiAhYi5vZmYpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BlbiA9IChhLmlucyA+IGxlbiB8fCBiLmlucyA+PSAwICYmIGIubGVuID4gbGVuKSAmJiAob3BlbiB8fCBzZWN0aW9ucy5sZW5ndGggPiBzZWN0aW9uTGVuKTtcbiAgICAgICAgICAgIGEuZm9yd2FyZDIobGVuKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2VjdGlvbkl0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNldCkge1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCB7IHNlY3Rpb25zIH0gPSB0aGlzLnNldDtcbiAgICAgICAgaWYgKHRoaXMuaSA8IHNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sZW4gPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgICAgICB0aGlzLmlucyA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW5zID0gLTI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmYgPSAwO1xuICAgIH1cbiAgICBnZXQgZG9uZSgpIHsgcmV0dXJuIHRoaXMuaW5zID09IC0yOyB9XG4gICAgZ2V0IGxlbjIoKSB7IHJldHVybiB0aGlzLmlucyA8IDAgPyB0aGlzLmxlbiA6IHRoaXMuaW5zOyB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIGxldCB7IGluc2VydGVkIH0gPSB0aGlzLnNldCwgaW5kZXggPSAodGhpcy5pIC0gMikgPj4gMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IGluc2VydGVkLmxlbmd0aCA/IFRleHQuZW1wdHkgOiBpbnNlcnRlZFtpbmRleF07XG4gICAgfVxuICAgIHRleHRCaXQobGVuKSB7XG4gICAgICAgIGxldCB7IGluc2VydGVkIH0gPSB0aGlzLnNldCwgaW5kZXggPSAodGhpcy5pIC0gMikgPj4gMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IGluc2VydGVkLmxlbmd0aCAmJiAhbGVuID8gVGV4dC5lbXB0eVxuICAgICAgICAgICAgOiBpbnNlcnRlZFtpbmRleF0uc2xpY2UodGhpcy5vZmYsIGxlbiA9PSBudWxsID8gdW5kZWZpbmVkIDogdGhpcy5vZmYgKyBsZW4pO1xuICAgIH1cbiAgICBmb3J3YXJkKGxlbikge1xuICAgICAgICBpZiAobGVuID09IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gLT0gbGVuO1xuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcndhcmQyKGxlbikge1xuICAgICAgICBpZiAodGhpcy5pbnMgPT0gLTEpXG4gICAgICAgICAgICB0aGlzLmZvcndhcmQobGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuID09IHRoaXMuaW5zKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnMgLT0gbGVuO1xuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbkEgc2luZ2xlIHNlbGVjdGlvbiByYW5nZS4gV2hlblxuW2BhbGxvd011bHRpcGxlU2VsZWN0aW9uc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpXG5pcyBlbmFibGVkLCBhIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uKSBtYXkgaG9sZFxubXVsdGlwbGUgcmFuZ2VzLiBCeSBkZWZhdWx0LCBzZWxlY3Rpb25zIGhvbGQgZXhhY3RseSBvbmUgcmFuZ2UuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG8sIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYW5jaG9yIG9mIHRoZSByYW5nZVx1MjAxNHRoZSBzaWRlIHRoYXQgZG9lc24ndCBtb3ZlIHdoZW4geW91XG4gICAgZXh0ZW5kIGl0LlxuICAgICovXG4gICAgZ2V0IGFuY2hvcigpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XG4gICAgLyoqXG4gICAgVGhlIGhlYWQgb2YgdGhlIHJhbmdlLCB3aGljaCBpcyBtb3ZlZCB3aGVuIHRoZSByYW5nZSBpc1xuICAgIFtleHRlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5leHRlbmQpLlxuICAgICovXG4gICAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMzIgLyogUmFuZ2VGbGFnLkludmVydGVkICovID8gdGhpcy5mcm9tIDogdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiBgYW5jaG9yYCBhbmQgYGhlYWRgIGFyZSBhdCB0aGUgc2FtZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZnJvbSA9PSB0aGlzLnRvOyB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIGN1cnNvciB0aGF0IGlzIGV4cGxpY2l0bHkgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgIGNoYXJhY3RlciBvbiBvbmUgb2YgaXRzIHNpZGVzLCB0aGlzIHJldHVybnMgdGhlIHNpZGUuIC0xIG1lYW5zXG4gICAgdGhlIGNoYXJhY3RlciBiZWZvcmUgaXRzIHBvc2l0aW9uLCAxIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIsIGFuZCAwXG4gICAgbWVhbnMgbm8gYXNzb2NpYXRpb24uXG4gICAgKi9cbiAgICBnZXQgYXNzb2MoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgOCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gPyAtMSA6IHRoaXMuZmxhZ3MgJiAxNiAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyA/IDEgOiAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBsZXZlbCBhc3NvY2lhdGVkIHdpdGggdGhpcyBjdXJzb3IsIGlmXG4gICAgYW55LlxuICAgICovXG4gICAgZ2V0IGJpZGlMZXZlbCgpIHtcbiAgICAgICAgbGV0IGxldmVsID0gdGhpcy5mbGFncyAmIDcgLyogUmFuZ2VGbGFnLkJpZGlMZXZlbE1hc2sgKi87XG4gICAgICAgIHJldHVybiBsZXZlbCA9PSA3ID8gbnVsbCA6IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZ29hbCBjb2x1bW4gKHN0b3JlZCB2ZXJ0aWNhbCBvZmZzZXQpIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgY3Vyc29yLiBUaGlzIGlzIHVzZWQgdG8gcHJlc2VydmUgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIHdoZW5cbiAgICBbbW92aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgYWNyb3NzXG4gICAgbGluZXMgb2YgZGlmZmVyZW50IGxlbmd0aC5cbiAgICAqL1xuICAgIGdldCBnb2FsQ29sdW1uKCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmZsYWdzID4+IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi87XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSAxNjc3NzIxNSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHRocm91Z2ggYSBjaGFuZ2UsIHByb2R1Y2luZyBhIHZhbGlkIHJhbmdlIGluIHRoZVxuICAgIHVwZGF0ZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIGZyb20gPSB0byA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCBhc3NvYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gY2hhbmdlLm1hcFBvcyh0aGlzLmZyb20sIDEpO1xuICAgICAgICAgICAgdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMudG8sIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0aGlzLmZyb20gJiYgdG8gPT0gdGhpcy50byA/IHRoaXMgOiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyByYW5nZSB0byBjb3ZlciBhdCBsZWFzdCBgZnJvbWAgdG8gYHRvYC5cbiAgICAqL1xuICAgIGV4dGVuZChmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPD0gdGhpcy5hbmNob3IgJiYgdG8gPj0gdGhpcy5hbmNob3IpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IGhlYWQgPSBNYXRoLmFicyhmcm9tIC0gdGhpcy5hbmNob3IpID4gTWF0aC5hYnModG8gLSB0aGlzLmFuY2hvcikgPyBmcm9tIDogdG87XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodGhpcy5hbmNob3IsIGhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgcmFuZ2UgdG8gYW5vdGhlciByYW5nZS5cbiAgICAqL1xuICAgIGVxKG90aGVyLCBpbmNsdWRlQXNzb2MgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IgPT0gb3RoZXIuYW5jaG9yICYmIHRoaXMuaGVhZCA9PSBvdGhlci5oZWFkICYmIHRoaXMuZ29hbENvbHVtbiA9PSBvdGhlci5nb2FsQ29sdW1uICYmXG4gICAgICAgICAgICAoIWluY2x1ZGVBc3NvYyB8fCAhdGhpcy5lbXB0eSB8fCB0aGlzLmFzc29jID09IG90aGVyLmFzc29jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB7IGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZCB9OyB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSByYW5nZSB0byBhIGBTZWxlY3Rpb25SYW5nZWBcbiAgICBpbnN0YW5jZS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgU2VsZWN0aW9uUmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoanNvbi5hbmNob3IsIGpzb24uaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb25SYW5nZShmcm9tLCB0bywgZmxhZ3MpO1xuICAgIH1cbn1cbi8qKlxuQW4gZWRpdG9yIHNlbGVjdGlvbiBob2xkcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb24gcmFuZ2VzLlxuKi9cbmNsYXNzIEVkaXRvclNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlcyBpbiB0aGUgc2VsZWN0aW9uLCBzb3J0ZWQgYnkgcG9zaXRpb24uIFJhbmdlcyBjYW5ub3RcbiAgICBvdmVybGFwIChidXQgdGhleSBtYXkgdG91Y2gsIGlmIHRoZXkgYXJlbid0IGVtcHR5KS5cbiAgICAqL1xuICAgIHJhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIGluZGV4IG9mIHRoZSBfbWFpbl8gcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbiAod2hpY2ggaXNcbiAgICB1c3VhbGx5IHRoZSByYW5nZSB0aGF0IHdhcyBhZGRlZCBsYXN0KS5cbiAgICAqL1xuICAgIG1haW5JbmRleCkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5tYWluSW5kZXggPSBtYWluSW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHNlbGVjdGlvbiB0aHJvdWdoIGEgY2hhbmdlLiBVc2VkIHRvIGFkanVzdCB0aGUgc2VsZWN0aW9uXG4gICAgcG9zaXRpb24gZm9yIGNoYW5nZXMuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGlmIChjaGFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUodGhpcy5yYW5nZXMubWFwKHIgPT4gci5tYXAoY2hhbmdlLCBhc3NvYykpLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBzZWxlY3Rpb24gdG8gYW5vdGhlciBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQsIHJhbmdlc1xuICAgIGFyZSBjb21wYXJlZCBvbmx5IGJ5IHBvc2l0aW9uLiBXaGVuIGBpbmNsdWRlQXNzb2NgIGlzIHRydWUsXG4gICAgY3Vyc29yIHJhbmdlcyBtdXN0IGFsc28gaGF2ZSB0aGUgc2FtZVxuICAgIFtgYXNzb2NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmFzc29jKSB2YWx1ZS5cbiAgICAqL1xuICAgIGVxKG90aGVyLCBpbmNsdWRlQXNzb2MgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoICE9IG90aGVyLnJhbmdlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMubWFpbkluZGV4ICE9IG90aGVyLm1haW5JbmRleClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5yYW5nZXNbaV0uZXEob3RoZXIucmFuZ2VzW2ldLCBpbmNsdWRlQXNzb2MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UuIFVzdWFsbHksIHlvdSBzaG91bGQgbWFrZSBzdXJlXG4gICAgeW91ciBjb2RlIGFwcGxpZXMgdG8gX2FsbF8gcmFuZ2VzLCBieSB1c2luZyBtZXRob2RzIGxpa2VcbiAgICBbYGNoYW5nZUJ5UmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYW5nZUJ5UmFuZ2UpLlxuICAgICovXG4gICAgZ2V0IG1haW4oKSB7IHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLm1haW5JbmRleF07IH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIHNlbGVjdGlvbiBvbmx5IGhhcyBvbmUgcmFuZ2UuIFJldHVybnMgYSBzZWxlY3Rpb25cbiAgICBob2xkaW5nIG9ubHkgdGhlIG1haW4gcmFuZ2UgZnJvbSB0aGlzIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGFzU2luZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMubGVuZ3RoID09IDEgPyB0aGlzIDogbmV3IEVkaXRvclNlbGVjdGlvbihbdGhpcy5tYWluXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHNlbGVjdGlvbiB3aXRoIGFuIGV4dHJhIHJhbmdlLlxuICAgICovXG4gICAgYWRkUmFuZ2UocmFuZ2UsIG1haW4gPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0uY29uY2F0KHRoaXMucmFuZ2VzKSwgbWFpbiA/IDAgOiB0aGlzLm1haW5JbmRleCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhbm90aGVyIHJhbmdlLCBhbmQgdGhlbiBub3JtYWxpemUgdGhlXG4gICAgc2VsZWN0aW9uIHRvIG1lcmdlIGFuZCBzb3J0IHJhbmdlcyBpZiBuZWNlc3NhcnkuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UocmFuZ2UsIHdoaWNoID0gdGhpcy5tYWluSW5kZXgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgIHJhbmdlc1t3aGljaF0gPSByYW5nZTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzZWxlY3Rpb24gdG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG9cbiAgICBKU09OLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyByYW5nZXM6IHRoaXMucmFuZ2VzLm1hcChyID0+IHIudG9KU09OKCkpLCBtYWluOiB0aGlzLm1haW5JbmRleCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIUFycmF5LmlzQXJyYXkoanNvbi5yYW5nZXMpIHx8IHR5cGVvZiBqc29uLm1haW4gIT0gXCJudW1iZXJcIiB8fCBqc29uLm1haW4gPj0ganNvbi5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclNlbGVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oanNvbi5yYW5nZXMubWFwKChyKSA9PiBTZWxlY3Rpb25SYW5nZS5mcm9tSlNPTihyKSksIGpzb24ubWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBob2xkaW5nIGEgc2luZ2xlIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHNpbmdsZShhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oW0VkaXRvclNlbGVjdGlvbi5yYW5nZShhbmNob3IsIGhlYWQpXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNvcnQgYW5kIG1lcmdlIHRoZSBnaXZlbiBzZXQgb2YgcmFuZ2VzLCBjcmVhdGluZyBhIHZhbGlkXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBzZWxlY3Rpb24gbmVlZHMgYXQgbGVhc3Qgb25lIHJhbmdlXCIpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwb3MgOiByYW5nZS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ubm9ybWFsaXplZChyYW5nZXMuc2xpY2UoKSwgbWFpbkluZGV4KTtcbiAgICAgICAgICAgIHBvcyA9IHJhbmdlLnRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHNlbGVjdGlvbiByYW5nZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIFlvdSBjYW5cbiAgICBzYWZlbHkgaWdub3JlIHRoZSBvcHRpb25hbCBhcmd1bWVudHMgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGN1cnNvcihwb3MsIGFzc29jID0gMCwgYmlkaUxldmVsLCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUocG9zLCBwb3MsIChhc3NvYyA9PSAwID8gMCA6IGFzc29jIDwgMCA/IDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMTYgLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8pIHxcbiAgICAgICAgICAgIChiaWRpTGV2ZWwgPT0gbnVsbCA/IDcgOiBNYXRoLm1pbig2LCBiaWRpTGV2ZWwpKSB8XG4gICAgICAgICAgICAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHJhbmdlKGFuY2hvciwgaGVhZCwgZ29hbENvbHVtbiwgYmlkaUxldmVsKSB7XG4gICAgICAgIGxldCBmbGFncyA9ICgoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMTY3NzcyMTUgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLykgPDwgNiAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLykgfFxuICAgICAgICAgICAgKGJpZGlMZXZlbCA9PSBudWxsID8gNyA6IE1hdGgubWluKDYsIGJpZGlMZXZlbCkpO1xuICAgICAgICByZXR1cm4gaGVhZCA8IGFuY2hvciA/IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShoZWFkLCBhbmNob3IsIDMyIC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyB8IDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovIHwgZmxhZ3MpXG4gICAgICAgICAgICA6IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShhbmNob3IsIGhlYWQsIChoZWFkID4gYW5jaG9yID8gOCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gOiAwKSB8IGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplZChyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgbGV0IG1haW4gPSByYW5nZXNbbWFpbkluZGV4XTtcbiAgICAgICAgcmFuZ2VzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIG1haW5JbmRleCA9IHJhbmdlcy5pbmRleE9mKG1haW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldLCBwcmV2ID0gcmFuZ2VzW2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcHJldi50byA6IHJhbmdlLmZyb20gPCBwcmV2LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBwcmV2LmZyb20sIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHByZXYudG8pO1xuICAgICAgICAgICAgICAgIGlmIChpIDw9IG1haW5JbmRleClcbiAgICAgICAgICAgICAgICAgICAgbWFpbkluZGV4LS07XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIHJhbmdlLmFuY2hvciA+IHJhbmdlLmhlYWQgPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24ocmFuZ2VzLCBtYWluSW5kZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZG9jTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcG9pbnRzIG91dHNpZGUgb2YgZG9jdW1lbnRcIik7XG59XG5cbmxldCBuZXh0SUQgPSAwO1xuLyoqXG5BIGZhY2V0IGlzIGEgbGFiZWxlZCB2YWx1ZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbiBlZGl0b3JcbnN0YXRlLiBJdCB0YWtlcyBpbnB1dHMgZnJvbSBhbnkgbnVtYmVyIG9mIGV4dGVuc2lvbnMsIGFuZCBjb21iaW5lc1xudGhvc2UgaW50byBhIHNpbmdsZSBvdXRwdXQgdmFsdWUuXG5cbkV4YW1wbGVzIG9mIHVzZXMgb2YgZmFjZXRzIGFyZSB0aGUgW3RhYlxuc2l6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSwgW2VkaXRvclxuYXR0cmlidXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdG9yQXR0cmlidXRlcyksIGFuZCBbdXBkYXRlXG5saXN0ZW5lcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnVwZGF0ZUxpc3RlbmVyKS5cblxuTm90ZSB0aGF0IGBGYWNldGAgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGFueXdoZXJlIHdoZXJlXG5bYEZhY2V0UmVhZGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldFJlYWRlcikgaXMgZXhwZWN0ZWQuXG4qL1xuY2xhc3MgRmFjZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tYmluZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlSW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZSwgaXNTdGF0aWMsIGVuYWJsZXMpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lID0gY29tYmluZTtcbiAgICAgICAgdGhpcy5jb21wYXJlSW5wdXQgPSBjb21wYXJlSW5wdXQ7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGNvbWJpbmUoW10pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB0eXBlb2YgZW5hYmxlcyA9PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVzKHRoaXMpIDogZW5hYmxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIGZhY2V0IHJlYWRlciBmb3IgdGhpcyBmYWNldCwgd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAgICBbcmVhZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5mYWNldCkgaXQgYnV0IG5vdCB0byBkZWZpbmUgdmFsdWVzIGZvciBpdC5cbiAgICAqL1xuICAgIGdldCByZWFkZXIoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGZhY2V0LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0KGNvbmZpZy5jb21iaW5lIHx8ICgoYSkgPT4gYSksIGNvbmZpZy5jb21wYXJlSW5wdXQgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnLmNvbXBhcmUgfHwgKCFjb25maWcuY29tYmluZSA/IHNhbWVBcnJheSA6IChhLCBiKSA9PiBhID09PSBiKSwgISFjb25maWcuc3RhdGljLCBjb25maWcuZW5hYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhpcyBmYWNldC5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihbXSwgdGhpcywgMCAvKiBQcm92aWRlci5TdGF0aWMgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIGEgdmFsdWUgZm9yIHRoZSBmYWNldCBmcm9tIGFcbiAgICBzdGF0ZS4gWW91IG11c3QgdGFrZSBjYXJlIHRvIGRlY2xhcmUgdGhlIHBhcnRzIG9mIHRoZSBzdGF0ZSB0aGF0XG4gICAgdGhpcyB2YWx1ZSBkZXBlbmRzIG9uLCBzaW5jZSB5b3VyIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGFnYWluXG4gICAgZm9yIGEgbmV3IHN0YXRlIHdoZW4gb25lIG9mIHRob3NlIHBhcnRzIGNoYW5nZWQuXG4gICAgXG4gICAgSW4gY2FzZXMgd2hlcmUgeW91ciB2YWx1ZSBkZXBlbmRzIG9ubHkgb24gYSBzaW5nbGUgZmllbGQsIHlvdSdsbFxuICAgIHdhbnQgdG8gdXNlIHRoZSBbYGZyb21gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0LmZyb20pIG1ldGhvZCBpbnN0ZWFkLlxuICAgICovXG4gICAgY29tcHV0ZShkZXBzLCBnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoZGVwcywgdGhpcywgMSAvKiBQcm92aWRlci5TaW5nbGUgKi8sIGdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyB6ZXJvIG9yIG1vcmUgdmFsdWVzIGZvciB0aGlzXG4gICAgZmFjZXQgZnJvbSBhIHN0YXRlLlxuICAgICovXG4gICAgY29tcHV0ZU4oZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDIgLyogUHJvdmlkZXIuTXVsdGkgKi8sIGdldCk7XG4gICAgfVxuICAgIGZyb20oZmllbGQsIGdldCkge1xuICAgICAgICBpZiAoIWdldClcbiAgICAgICAgICAgIGdldCA9IHggPT4geDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZShbZmllbGRdLCBzdGF0ZSA9PiBnZXQoc3RhdGUuZmllbGQoZmllbGQpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8IGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGUsIGkpID0+IGUgPT09IGJbaV0pO1xufVxuY2xhc3MgRmFjZXRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoZGVwZW5kZW5jaWVzLCBmYWNldCwgdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgfVxuICAgIGR5bmFtaWNTbG90KGFkZHJlc3Nlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBnZXR0ZXIgPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgY29tcGFyZSA9IHRoaXMuZmFjZXQuY29tcGFyZUlucHV0O1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmlkLCBpZHggPSBhZGRyZXNzZXNbaWRdID4+IDEsIG11bHRpID0gdGhpcy50eXBlID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi87XG4gICAgICAgIGxldCBkZXBEb2MgPSBmYWxzZSwgZGVwU2VsID0gZmFsc2UsIGRlcEFkZHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKGRlcCA9PSBcImRvY1wiKVxuICAgICAgICAgICAgICAgIGRlcERvYyA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChkZXAgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICBkZXBTZWwgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoKCgoX2EgPSBhZGRyZXNzZXNbZGVwLmlkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgJiAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIGRlcEFkZHJzLnB1c2goYWRkcmVzc2VzW2RlcC5pZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRlcERvYyAmJiB0ci5kb2NDaGFuZ2VkKSB8fCAoZGVwU2VsICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpIHx8IGVuc3VyZUFsbChzdGF0ZSwgZGVwQWRkcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGkgPyAhY29tcGFyZUFycmF5KG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0sIGNvbXBhcmUpIDogIWNvbXBhcmUobmV3VmFsLCBzdGF0ZS52YWx1ZXNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCwgb2xkQWRkciA9IG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkQWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBnZXRBZGRyKG9sZFN0YXRlLCBvbGRBZGRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwIGluc3RhbmNlb2YgRmFjZXQgPyBvbGRTdGF0ZS5mYWNldChkZXApID09PSBzdGF0ZS5mYWNldChkZXApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXAgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkID8gb2xkU3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgPT0gc3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KSB8fCAobXVsdGkgPyBjb21wYXJlQXJyYXkobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsLCBjb21wYXJlKSA6IGNvbXBhcmUobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlQXJyYXkoYSwgYiwgY29tcGFyZSkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFjb21wYXJlKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5zdXJlQWxsKHN0YXRlLCBhZGRycykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgYWRkciBvZiBhZGRycylcbiAgICAgICAgaWYgKGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpICYgMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi8pXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNGYWNldFNsb3QoYWRkcmVzc2VzLCBmYWNldCwgcHJvdmlkZXJzKSB7XG4gICAgbGV0IHByb3ZpZGVyQWRkcnMgPSBwcm92aWRlcnMubWFwKHAgPT4gYWRkcmVzc2VzW3AuaWRdKTtcbiAgICBsZXQgcHJvdmlkZXJUeXBlcyA9IHByb3ZpZGVycy5tYXAocCA9PiBwLnR5cGUpO1xuICAgIGxldCBkeW5hbWljID0gcHJvdmlkZXJBZGRycy5maWx0ZXIocCA9PiAhKHAgJiAxKSk7XG4gICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1tmYWNldC5pZF0gPj4gMTtcbiAgICBmdW5jdGlvbiBnZXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3ZpZGVyQWRkcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldEFkZHIoc3RhdGUsIHByb3ZpZGVyQWRkcnNbaV0pO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyVHlwZXNbaV0gPT0gMiAvKiBQcm92aWRlci5NdWx0aSAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWwgb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWNldC5jb21iaW5lKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgYWRkciBvZiBwcm92aWRlckFkZHJzKVxuICAgICAgICAgICAgICAgIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpO1xuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICBpZiAoIWVuc3VyZUFsbChzdGF0ZSwgZHluYW1pYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIHN0YXRlLnZhbHVlc1tpZHhdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIHJlY29uZmlndXJlKHN0YXRlLCBvbGRTdGF0ZSkge1xuICAgICAgICAgICAgbGV0IGRlcENoYW5nZWQgPSBlbnN1cmVBbGwoc3RhdGUsIHByb3ZpZGVyQWRkcnMpO1xuICAgICAgICAgICAgbGV0IG9sZFByb3ZpZGVycyA9IG9sZFN0YXRlLmNvbmZpZy5mYWNldHNbZmFjZXQuaWRdLCBvbGRWYWx1ZSA9IG9sZFN0YXRlLmZhY2V0KGZhY2V0KTtcbiAgICAgICAgICAgIGlmIChvbGRQcm92aWRlcnMgJiYgIWRlcENoYW5nZWQgJiYgc2FtZUFycmF5KHByb3ZpZGVycywgb2xkUHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IGluaXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBzdGF0aWM6IHRydWUgfSk7XG4vKipcbkZpZWxkcyBjYW4gc3RvcmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpbiBhbiBlZGl0b3Igc3RhdGUsIGFuZFxua2VlcCBpdCBpbiBzeW5jIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YXRlRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIGNyZWF0ZUYsIHVwZGF0ZUYsIGNvbXBhcmVGLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZUYgPSBjcmVhdGVGO1xuICAgICAgICB0aGlzLnVwZGF0ZUYgPSB1cGRhdGVGO1xuICAgICAgICB0aGlzLmNvbXBhcmVGID0gY29tcGFyZUY7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm92aWRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RhdGUgZmllbGQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNvbmZpZykge1xuICAgICAgICBsZXQgZmllbGQgPSBuZXcgU3RhdGVGaWVsZChuZXh0SUQrKywgY29uZmlnLmNyZWF0ZSwgY29uZmlnLnVwZGF0ZSwgY29uZmlnLmNvbXBhcmUgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm92aWRlKVxuICAgICAgICAgICAgZmllbGQucHJvdmlkZXMgPSBjb25maWcucHJvdmlkZShmaWVsZCk7XG4gICAgICAgIHJldHVybiBmaWVsZDtcbiAgICB9XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0ID0gc3RhdGUuZmFjZXQoaW5pdEZpZWxkKS5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKTtcbiAgICAgICAgcmV0dXJuICgoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmNyZWF0ZSkgfHwgdGhpcy5jcmVhdGVGKShzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1t0aGlzLmlkXSA+PiAxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IHN0YXRlLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudXBkYXRlRihvbGRWYWwsIHRyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlRihvbGRWYWwsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdCA9IHN0YXRlLmZhY2V0KGluaXRGaWVsZCksIG9sZEluaXQgPSBvbGRTdGF0ZS5mYWNldChpbml0RmllbGQpLCByZUluaXQ7XG4gICAgICAgICAgICAgICAgaWYgKChyZUluaXQgPSBpbml0LmZpbmQoaSA9PiBpLmZpZWxkID09IHRoaXMpKSAmJiByZUluaXQgIT0gb2xkSW5pdC5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHJlSW5pdC5jcmVhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1t0aGlzLmlkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkU3RhdGUuZmllbGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyB0aGlzIGZpZWxkIGFuZCBvdmVycmlkZXMgdGhlXG4gICAgd2F5IGl0IGlzIGluaXRpYWxpemVkLiBDYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gcHJvdmlkZSBhXG4gICAgbm9uLWRlZmF1bHQgc3RhcnRpbmcgdmFsdWUgZm9yIHRoZSBmaWVsZC5cbiAgICAqL1xuICAgIGluaXQoY3JlYXRlKSB7XG4gICAgICAgIHJldHVybiBbdGhpcywgaW5pdEZpZWxkLm9mKHsgZmllbGQ6IHRoaXMsIGNyZWF0ZSB9KV07XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXRlIGZpZWxkIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhc1xuICAgIFtgRXh0ZW5zaW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FeHRlbnNpb24pIHZhbHVlcyB0byBlbmFibGUgdGhlIGZpZWxkIGluIGFcbiAgICBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBleHRlbnNpb24oKSB7IHJldHVybiB0aGlzOyB9XG59XG5jb25zdCBQcmVjXyA9IHsgbG93ZXN0OiA0LCBsb3c6IDMsIGRlZmF1bHQ6IDIsIGhpZ2g6IDEsIGhpZ2hlc3Q6IDAgfTtcbmZ1bmN0aW9uIHByZWModmFsdWUpIHtcbiAgICByZXR1cm4gKGV4dCkgPT4gbmV3IFByZWNFeHRlbnNpb24oZXh0LCB2YWx1ZSk7XG59XG4vKipcbkJ5IGRlZmF1bHQgZXh0ZW5zaW9ucyBhcmUgcmVnaXN0ZXJlZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgZm91bmRcbmluIHRoZSBmbGF0dGVuZWQgZm9ybSBvZiBuZXN0ZWQgYXJyYXkgdGhhdCB3YXMgcHJvdmlkZWQuXG5JbmRpdmlkdWFsIGV4dGVuc2lvbiB2YWx1ZXMgY2FuIGJlIGFzc2lnbmVkIGEgcHJlY2VkZW5jZSB0b1xub3ZlcnJpZGUgdGhpcy4gRXh0ZW5zaW9ucyB0aGF0IGRvIG5vdCBoYXZlIGEgcHJlY2VkZW5jZSBzZXQgZ2V0XG50aGUgcHJlY2VkZW5jZSBvZiB0aGUgbmVhcmVzdCBwYXJlbnQgd2l0aCBhIHByZWNlZGVuY2UsIG9yXG5bYGRlZmF1bHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlByZWMuZGVmYXVsdCkgaWYgdGhlcmUgaXMgbm8gc3VjaCBwYXJlbnQuIFRoZVxuZmluYWwgb3JkZXJpbmcgb2YgZXh0ZW5zaW9ucyBpcyBkZXRlcm1pbmVkIGJ5IGZpcnN0IHNvcnRpbmcgYnlcbnByZWNlZGVuY2UgYW5kIHRoZW4gYnkgb3JkZXIgd2l0aGluIGVhY2ggcHJlY2VkZW5jZS5cbiovXG5jb25zdCBQcmVjID0ge1xuICAgIC8qKlxuICAgIFRoZSBoaWdoZXN0IHByZWNlZGVuY2UgbGV2ZWwsIGZvciBleHRlbnNpb25zIHRoYXQgc2hvdWxkIGVuZCB1cFxuICAgIG5lYXIgdGhlIHN0YXJ0IG9mIHRoZSBwcmVjZWRlbmNlIG9yZGVyaW5nLlxuICAgICovXG4gICAgaGlnaGVzdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaGVzdCksXG4gICAgLyoqXG4gICAgQSBoaWdoZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UsIGZvciBleHRlbnNpb25zIHRoYXQgc2hvdWxkXG4gICAgY29tZSBiZWZvcmUgdGhvc2Ugd2l0aCBkZWZhdWx0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBoaWdoOiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5oaWdoKSxcbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCBwcmVjZWRlbmNlLCB3aGljaCBpcyBhbHNvIHVzZWQgZm9yIGV4dGVuc2lvbnNcbiAgICB3aXRob3V0IGFuIGV4cGxpY2l0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBkZWZhdWx0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5kZWZhdWx0KSxcbiAgICAvKipcbiAgICBBIGxvd2VyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgbG93OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5sb3cpLFxuICAgIC8qKlxuICAgIFRoZSBsb3dlc3QgcHJlY2VkZW5jZSBsZXZlbC4gTWVhbnQgZm9yIHRoaW5ncyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBlbmQgb2YgdGhlIGV4dGVuc2lvbiBvcmRlci5cbiAgICAqL1xuICAgIGxvd2VzdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18ubG93ZXN0KVxufTtcbmNsYXNzIFByZWNFeHRlbnNpb24ge1xuICAgIGNvbnN0cnVjdG9yKGlubmVyLCBwcmVjKSB7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5wcmVjID0gcHJlYztcbiAgICB9XG59XG4vKipcbkV4dGVuc2lvbiBjb21wYXJ0bWVudHMgY2FuIGJlIHVzZWQgdG8gbWFrZSBhIGNvbmZpZ3VyYXRpb25cbmR5bmFtaWMuIEJ5IFt3cmFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5vZikgcGFydCBvZiB5b3VyXG5jb25maWd1cmF0aW9uIGluIGEgY29tcGFydG1lbnQsIHlvdSBjYW4gbGF0ZXJcbltyZXBsYWNlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50LnJlY29uZmlndXJlKSB0aGF0IHBhcnQgdGhyb3VnaCBhXG50cmFuc2FjdGlvbi5cbiovXG5jbGFzcyBDb21wYXJ0bWVudCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY29tcGFydG1lbnQgdG8gYWRkIHRvIHlvdXIgW3N0YXRlXG4gICAgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZUNvbmZpZy5leHRlbnNpb25zKS5cbiAgICAqL1xuICAgIG9mKGV4dCkgeyByZXR1cm4gbmV3IENvbXBhcnRtZW50SW5zdGFuY2UodGhpcywgZXh0KTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0aGF0XG4gICAgcmVjb25maWd1cmVzIHRoaXMgY29tcGFydG1lbnQuXG4gICAgKi9cbiAgICByZWNvbmZpZ3VyZShjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBDb21wYXJ0bWVudC5yZWNvbmZpZ3VyZS5vZih7IGNvbXBhcnRtZW50OiB0aGlzLCBleHRlbnNpb246IGNvbnRlbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY3VycmVudCBjb250ZW50IG9mIHRoZSBjb21wYXJ0bWVudCBpbiB0aGUgc3RhdGUsIG9yXG4gICAgYHVuZGVmaW5lZGAgaWYgaXQgaXNuJ3QgcHJlc2VudC5cbiAgICAqL1xuICAgIGdldChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGUuY29uZmlnLmNvbXBhcnRtZW50cy5nZXQodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgQ29tcGFydG1lbnRJbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3IoY29tcGFydG1lbnQsIGlubmVyKSB7XG4gICAgICAgIHRoaXMuY29tcGFydG1lbnQgPSBjb21wYXJ0bWVudDtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgIH1cbn1cbmNsYXNzIENvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIGNvbXBhcnRtZW50cywgZHluYW1pY1Nsb3RzLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cykge1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50cyA9IGNvbXBhcnRtZW50cztcbiAgICAgICAgdGhpcy5keW5hbWljU2xvdHMgPSBkeW5hbWljU2xvdHM7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuc3RhdGljVmFsdWVzID0gc3RhdGljVmFsdWVzO1xuICAgICAgICB0aGlzLmZhY2V0cyA9IGZhY2V0cztcbiAgICAgICAgdGhpcy5zdGF0dXNUZW1wbGF0ZSA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5zdGF0dXNUZW1wbGF0ZS5sZW5ndGggPCBkeW5hbWljU2xvdHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5zdGF0dXNUZW1wbGF0ZS5wdXNoKDAgLyogU2xvdFN0YXR1cy5VbnJlc29sdmVkICovKTtcbiAgICB9XG4gICAgc3RhdGljRmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmFkZHJlc3NbZmFjZXQuaWRdO1xuICAgICAgICByZXR1cm4gYWRkciA9PSBudWxsID8gZmFjZXQuZGVmYXVsdCA6IHRoaXMuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV07XG4gICAgfVxuICAgIHN0YXRpYyByZXNvbHZlKGJhc2UsIGNvbXBhcnRtZW50cywgb2xkU3RhdGUpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBsZXQgZmFjZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IG5ld0NvbXBhcnRtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgZXh0IG9mIGZsYXR0ZW4oYmFzZSwgY29tcGFydG1lbnRzLCBuZXdDb21wYXJ0bWVudHMpKSB7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZClcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChleHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIChmYWNldHNbZXh0LmZhY2V0LmlkXSB8fCAoZmFjZXRzW2V4dC5mYWNldC5pZF0gPSBbXSkpLnB1c2goZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWRkcmVzcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBzdGF0aWNWYWx1ZXMgPSBbXTtcbiAgICAgICAgbGV0IGR5bmFtaWNTbG90cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGFkZHJlc3NbZmllbGQuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBmaWVsZC5zbG90KGEpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2xkRmFjZXRzID0gb2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLmNvbmZpZy5mYWNldHM7XG4gICAgICAgIGZvciAobGV0IGlkIGluIGZhY2V0cykge1xuICAgICAgICAgICAgbGV0IHByb3ZpZGVycyA9IGZhY2V0c1tpZF0sIGZhY2V0ID0gcHJvdmlkZXJzWzBdLmZhY2V0O1xuICAgICAgICAgICAgbGV0IG9sZFByb3ZpZGVycyA9IG9sZEZhY2V0cyAmJiBvbGRGYWNldHNbaWRdIHx8IFtdO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVycy5ldmVyeShwID0+IHAudHlwZSA9PSAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLykpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IChzdGF0aWNWYWx1ZXMubGVuZ3RoIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICBpZiAoc2FtZUFycmF5KG9sZFByb3ZpZGVycywgcHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaChvbGRTdGF0ZS5mYWNldChmYWNldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmFjZXQuY29tYmluZShwcm92aWRlcnMubWFwKHAgPT4gcC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaChvbGRTdGF0ZSAmJiBmYWNldC5jb21wYXJlKHZhbHVlLCBvbGRTdGF0ZS5mYWNldChmYWNldCkpID8gb2xkU3RhdGUuZmFjZXQoZmFjZXQpIDogdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgb2YgcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NbcC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaChwLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NbcC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IHAuZHluYW1pY1Nsb3QoYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZHluYW1pY0ZhY2V0U2xvdChhLCBmYWNldCwgcHJvdmlkZXJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGR5bmFtaWMgPSBkeW5hbWljU2xvdHMubWFwKGYgPT4gZihhZGRyZXNzKSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZmlndXJhdGlvbihiYXNlLCBuZXdDb21wYXJ0bWVudHMsIGR5bmFtaWMsIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcywgZmFjZXRzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmbGF0dGVuKGV4dGVuc2lvbiwgY29tcGFydG1lbnRzLCBuZXdDb21wYXJ0bWVudHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW1tdLCBbXSwgW10sIFtdLCBbXV07XG4gICAgbGV0IHNlZW4gPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gaW5uZXIoZXh0LCBwcmVjKSB7XG4gICAgICAgIGxldCBrbm93biA9IHNlZW4uZ2V0KGV4dCk7XG4gICAgICAgIGlmIChrbm93biAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa25vd24gPD0gcHJlYylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgZm91bmQgPSByZXN1bHRba25vd25dLmluZGV4T2YoZXh0KTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrbm93bl0uc3BsaWNlKGZvdW5kLCAxKTtcbiAgICAgICAgICAgIGlmIChleHQgaW5zdGFuY2VvZiBDb21wYXJ0bWVudEluc3RhbmNlKVxuICAgICAgICAgICAgICAgIG5ld0NvbXBhcnRtZW50cy5kZWxldGUoZXh0LmNvbXBhcnRtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLnNldChleHQsIHByZWMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHQpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBlIG9mIGV4dClcbiAgICAgICAgICAgICAgICBpbm5lcihlLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBDb21wYXJ0bWVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAobmV3Q29tcGFydG1lbnRzLmhhcyhleHQuY29tcGFydG1lbnQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBEdXBsaWNhdGUgdXNlIG9mIGNvbXBhcnRtZW50IGluIGV4dGVuc2lvbnNgKTtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gY29tcGFydG1lbnRzLmdldChleHQuY29tcGFydG1lbnQpIHx8IGV4dC5pbm5lcjtcbiAgICAgICAgICAgIG5ld0NvbXBhcnRtZW50cy5zZXQoZXh0LmNvbXBhcnRtZW50LCBjb250ZW50KTtcbiAgICAgICAgICAgIGlubmVyKGNvbnRlbnQsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIFByZWNFeHRlbnNpb24pIHtcbiAgICAgICAgICAgIGlubmVyKGV4dC5pbm5lciwgZXh0LnByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LnByb3ZpZGVzKVxuICAgICAgICAgICAgICAgIGlubmVyKGV4dC5wcm92aWRlcywgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgRmFjZXRQcm92aWRlcikge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWNdLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGlmIChleHQuZmFjZXQuZXh0ZW5zaW9ucylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQuZmFjZXQuZXh0ZW5zaW9ucywgUHJlY18uZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGV4dC5leHRlbnNpb247XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZXh0ZW5zaW9uIHZhbHVlIGluIGV4dGVuc2lvbiBzZXQgKCR7ZXh0fSkuIFRoaXMgc29tZXRpbWVzIGhhcHBlbnMgYmVjYXVzZSBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgQGNvZGVtaXJyb3Ivc3RhdGUgYXJlIGxvYWRlZCwgYnJlYWtpbmcgaW5zdGFuY2VvZiBjaGVja3MuYCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbm5lcihleHRlbnNpb24sIFByZWNfLmRlZmF1bHQpO1xuICAgIHJldHVybiByZXN1bHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSB7XG4gICAgaWYgKGFkZHIgJiAxKVxuICAgICAgICByZXR1cm4gMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovO1xuICAgIGxldCBpZHggPSBhZGRyID4+IDE7XG4gICAgbGV0IHN0YXR1cyA9IHN0YXRlLnN0YXR1c1tpZHhdO1xuICAgIGlmIChzdGF0dXMgPT0gNCAvKiBTbG90U3RhdHVzLkNvbXB1dGluZyAqLylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgYmV0d2VlbiBmaWVsZHMgYW5kL29yIGZhY2V0c1wiKTtcbiAgICBpZiAoc3RhdHVzICYgMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovKVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIHN0YXRlLnN0YXR1c1tpZHhdID0gNCAvKiBTbG90U3RhdHVzLkNvbXB1dGluZyAqLztcbiAgICBsZXQgY2hhbmdlZCA9IHN0YXRlLmNvbXB1dGVTbG90KHN0YXRlLCBzdGF0ZS5jb25maWcuZHluYW1pY1Nsb3RzW2lkeF0pO1xuICAgIHJldHVybiBzdGF0ZS5zdGF0dXNbaWR4XSA9IDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLyB8IGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBnZXRBZGRyKHN0YXRlLCBhZGRyKSB7XG4gICAgcmV0dXJuIGFkZHIgJiAxID8gc3RhdGUuY29uZmlnLnN0YXRpY1ZhbHVlc1thZGRyID4+IDFdIDogc3RhdGUudmFsdWVzW2FkZHIgPj4gMV07XG59XG5cbmNvbnN0IGxhbmd1YWdlRGF0YSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHYgPT4gdiksXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGxpbmVTZXBhcmF0b3IgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IHVuZGVmaW5lZCxcbiAgICBzdGF0aWM6IHRydWVcbn0pO1xuY29uc3QgY2hhbmdlRmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25GaWx0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB0cmFuc2FjdGlvbkV4dGVuZGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgcmVhZE9ubHkgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IGZhbHNlXG59KTtcblxuLyoqXG5Bbm5vdGF0aW9ucyBhcmUgdGFnZ2VkIHZhbHVlcyB0aGF0IGFyZSB1c2VkIHRvIGFkZCBtZXRhZGF0YSB0b1xudHJhbnNhY3Rpb25zIGluIGFuIGV4dGVuc2libGUgd2F5LiBUaGV5IHNob3VsZCBiZSB1c2VkIHRvIG1vZGVsXG50aGluZ3MgdGhhdCBlZmZlY3QgdGhlIGVudGlyZSB0cmFuc2FjdGlvbiAoc3VjaCBhcyBpdHMgW3RpbWVcbnN0YW1wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnRpbWUpIG9yIGluZm9ybWF0aW9uIGFib3V0IGl0c1xuW29yaWdpbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl51c2VyRXZlbnQpKS4gRm9yIGVmZmVjdHMgdGhhdCBoYXBwZW5cbl9hbG9uZ3NpZGVfIHRoZSBvdGhlciBjaGFuZ2VzIG1hZGUgYnkgdGhlIHRyYW5zYWN0aW9uLCBbc3RhdGVcbmVmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGFyZSBtb3JlIGFwcHJvcHJpYXRlLlxuKi9cbmNsYXNzIEFubm90YXRpb24ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGFubm90YXRpb24gdHlwZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBvZiB0aGlzIGFubm90YXRpb24uXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyB0eXBlIG9mIGFubm90YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKCkgeyByZXR1cm4gbmV3IEFubm90YXRpb25UeXBlKCk7IH1cbn1cbi8qKlxuTWFya2VyIHRoYXQgaWRlbnRpZmllcyBhIHR5cGUgb2YgW2Fubm90YXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQW5ub3RhdGlvbikuXG4qL1xuY2xhc3MgQW5ub3RhdGlvblR5cGUge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGFubm90YXRpb24uXG4gICAgKi9cbiAgICBvZih2YWx1ZSkgeyByZXR1cm4gbmV3IEFubm90YXRpb24odGhpcywgdmFsdWUpOyB9XG59XG4vKipcblJlcHJlc2VudGF0aW9uIG9mIGEgdHlwZSBvZiBzdGF0ZSBlZmZlY3QuIERlZmluZWQgd2l0aFxuW2BTdGF0ZUVmZmVjdC5kZWZpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmRlZmluZSkuXG4qL1xuY2xhc3MgU3RhdGVFZmZlY3RUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBgYW55YCB0eXBlcyBpbiB0aGVzZSBmdW5jdGlvbiB0eXBlcyBhcmUgdGhlcmUgdG8gd29ya1xuICAgIC8vIGFyb3VuZCBUeXBlU2NyaXB0IGlzc3VlICMzNzYzMSwgd2hlcmUgdGhlIHR5cGUgZ3VhcmQgb25cbiAgICAvLyBgU3RhdGVFZmZlY3QuaXNgIG15c3RlcmlvdXNseSBzdG9wcyB3b3JraW5nIHdoZW4gdGhlc2UgcHJvcGVybHlcbiAgICAvLyBoYXZlIHR5cGUgYFZhbHVlYC5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3N0YXRlIGVmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdCkgaW5zdGFuY2Ugb2YgdGhpc1xuICAgIHR5cGUuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkgeyByZXR1cm4gbmV3IFN0YXRlRWZmZWN0KHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5TdGF0ZSBlZmZlY3RzIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBhZGRpdGlvbmFsIGVmZmVjdHNcbmFzc29jaWF0ZWQgd2l0aCBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5lZmZlY3RzKS4gVGhleVxuYXJlIG9mdGVuIHVzZWZ1bCB0byBtb2RlbCBjaGFuZ2VzIHRvIGN1c3RvbSBbc3RhdGVcbmZpZWxkc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkKSwgd2hlbiB0aG9zZSBjaGFuZ2VzIGFyZW4ndCBpbXBsaWNpdCBpblxuZG9jdW1lbnQgb3Igc2VsZWN0aW9uIGNoYW5nZXMuXG4qL1xuY2xhc3MgU3RhdGVFZmZlY3Qge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBlZmZlY3QuXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIGVmZmVjdCB0aHJvdWdoIGEgcG9zaXRpb24gbWFwcGluZy4gV2lsbCByZXR1cm5cbiAgICBgdW5kZWZpbmVkYCB3aGVuIHRoYXQgZW5kcyB1cCBkZWxldGluZyB0aGUgZWZmZWN0LlxuICAgICovXG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IG1hcHBlZCA9IHRoaXMudHlwZS5tYXAodGhpcy52YWx1ZSwgbWFwcGluZyk7XG4gICAgICAgIHJldHVybiBtYXBwZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1hcHBlZCA9PSB0aGlzLnZhbHVlID8gdGhpcyA6IG5ldyBTdGF0ZUVmZmVjdCh0aGlzLnR5cGUsIG1hcHBlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgZWZmZWN0IG9iamVjdCBpcyBvZiBhIGdpdmVuXG4gICAgW3R5cGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RUeXBlKS5cbiAgICAqL1xuICAgIGlzKHR5cGUpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlOyB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGVmZmVjdCB0eXBlLiBUaGUgdHlwZSBwYXJhbWV0ZXIgaW5kaWNhdGVzIHRoZSB0eXBlXG4gICAgb2YgdmFsdWVzIHRoYXQgaGlzIGVmZmVjdCBob2xkcy4gSXQgc2hvdWxkIGJlIGEgdHlwZSB0aGF0XG4gICAgZG9lc24ndCBpbmNsdWRlIGB1bmRlZmluZWRgLCBzaW5jZSB0aGF0IGlzIHVzZWQgaW5cbiAgICBbbWFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdC5tYXApIHRvIGluZGljYXRlIHRoYXQgYW4gZWZmZWN0IGlzXG4gICAgcmVtb3ZlZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGVFZmZlY3RUeXBlKHNwZWMubWFwIHx8ICh2ID0+IHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGFuIGFycmF5IG9mIGVmZmVjdHMgdGhyb3VnaCBhIGNoYW5nZSBzZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFwRWZmZWN0cyhlZmZlY3RzLCBtYXBwaW5nKSB7XG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGVmZmVjdC5tYXAobWFwcGluZyk7XG4gICAgICAgICAgICBpZiAobWFwcGVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1hcHBlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcblRoaXMgZWZmZWN0IGNhbiBiZSB1c2VkIHRvIHJlY29uZmlndXJlIHRoZSByb290IGV4dGVuc2lvbnMgb2ZcbnRoZSBlZGl0b3IuIERvaW5nIHRoaXMgd2lsbCBkaXNjYXJkIGFueSBleHRlbnNpb25zXG5bYXBwZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3ReYXBwZW5kQ29uZmlnKSwgYnV0IGRvZXMgbm90IHJlc2V0XG50aGUgY29udGVudCBvZiBbcmVjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50LnJlY29uZmlndXJlKVxuY29tcGFydG1lbnRzLlxuKi9cblN0YXRlRWZmZWN0LnJlY29uZmlndXJlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5BcHBlbmQgZXh0ZW5zaW9ucyB0byB0aGUgdG9wLWxldmVsIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGVkaXRvci5cbiovXG5TdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcbkNoYW5nZXMgdG8gdGhlIGVkaXRvciBzdGF0ZSBhcmUgZ3JvdXBlZCBpbnRvIHRyYW5zYWN0aW9ucy5cblR5cGljYWxseSwgYSB1c2VyIGFjdGlvbiBjcmVhdGVzIGEgc2luZ2xlIHRyYW5zYWN0aW9uLCB3aGljaCBtYXlcbmNvbnRhaW4gYW55IG51bWJlciBvZiBkb2N1bWVudCBjaGFuZ2VzLCBtYXkgY2hhbmdlIHRoZSBzZWxlY3Rpb24sXG5vciBoYXZlIG90aGVyIGVmZmVjdHMuIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGJ5IGNhbGxpbmdcbltgRWRpdG9yU3RhdGUudXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpLCBvciBpbW1lZGlhdGVseVxuZGlzcGF0Y2ggb25lIGJ5IGNhbGxpbmdcbltgRWRpdG9yVmlldy5kaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKS5cbiovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXRlIGZyb20gd2hpY2ggdGhlIHRyYW5zYWN0aW9uIHN0YXJ0cy5cbiAgICAqL1xuICAgIHN0YXJ0U3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBkb2N1bWVudCBjaGFuZ2VzIG1hZGUgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGNoYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24gc2V0IGJ5IHRoaXMgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiBpdFxuICAgIGRvZXNuJ3QgZXhwbGljaXRseSBzZXQgYSBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIFRoZSBlZmZlY3RzIGFkZGVkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGVmZmVjdHMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYW5ub3RhdGlvbnMsIFxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyIHRoaXNcbiAgICB0cmFuc2FjdGlvbiBpcyBkaXNwYXRjaGVkLlxuICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gc3RhcnRTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3O1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX2RvYyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICAgICAgY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBjaGFuZ2VzLm5ld0xlbmd0aCk7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbnMuc29tZSgoYSkgPT4gYS50eXBlID09IFRyYW5zYWN0aW9uLnRpbWUpKVxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi50aW1lLm9mKERhdGUubm93KCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oc3RhcnRTdGF0ZSwgY2hhbmdlcywgc2VsZWN0aW9uLCBlZmZlY3RzLCBhbm5vdGF0aW9ucywgc2Nyb2xsSW50b1ZpZXcpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IGRvY3VtZW50IHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29udHJhcnkgdG9cbiAgICBbYC5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpYC5kb2NgLCBhY2Nlc3NpbmcgdGhpcyB3b24ndFxuICAgIGZvcmNlIHRoZSBlbnRpcmUgbmV3IHN0YXRlIHRvIGJlIGNvbXB1dGVkIHJpZ2h0IGF3YXksIHNvIGl0IGlzXG4gICAgcmVjb21tZW5kZWQgdGhhdCBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB1c2UgdGhpcyBnZXR0ZXJcbiAgICB3aGVuIHRoZXkgbmVlZCB0byBsb29rIGF0IHRoZSBuZXcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgbmV3RG9jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9jIHx8ICh0aGlzLl9kb2MgPSB0aGlzLmNoYW5nZXMuYXBwbHkodGhpcy5zdGFydFN0YXRlLmRvYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHNlbGVjdGlvbiBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIElmXG4gICAgW2B0aGlzLnNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2VsZWN0aW9uKSBpcyB1bmRlZmluZWQsXG4gICAgdGhpcyB3aWxsIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uLm1hcCkgdGhlIHN0YXJ0IHN0YXRlJ3NcbiAgICBjdXJyZW50IHNlbGVjdGlvbiB0aHJvdWdoIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IG5ld1NlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uIHx8IHRoaXMuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFwKHRoaXMuY2hhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgc3RhdGUgY3JlYXRlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbXB1dGVkIG9uIGRlbWFuZFxuICAgIChidXQgcmV0YWluZWQgZm9yIHN1YnNlcXVlbnQgYWNjZXNzKSwgc28gaXQgaXMgcmVjb21tZW5kZWQgbm90IHRvXG4gICAgYWNjZXNzIGl0IGluIFt0cmFuc2FjdGlvblxuICAgIGZpbHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpIHdoZW4gcG9zc2libGUuXG4gICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhdGUpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBhbm5vdGF0aW9uIHR5cGUsIGlmIGFueS5cbiAgICAqL1xuICAgIGFubm90YXRpb24odHlwZSkge1xuICAgICAgICBmb3IgKGxldCBhbm4gb2YgdGhpcy5hbm5vdGF0aW9ucylcbiAgICAgICAgICAgIGlmIChhbm4udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBhbm4udmFsdWU7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBjaGFuZ2VkIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkgeyByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgdHJhbnNhY3Rpb24gcmVjb25maWd1cmVzIHRoZSBzdGF0ZVxuICAgICh0aHJvdWdoIGEgW2NvbmZpZ3VyYXRpb24gY29tcGFydG1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQpIG9yXG4gICAgd2l0aCBhIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uXG4gICAgW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5yZWNvbmZpZ3VyZSkuXG4gICAgKi9cbiAgICBnZXQgcmVjb25maWd1cmVkKCkgeyByZXR1cm4gdGhpcy5zdGFydFN0YXRlLmNvbmZpZyAhPSB0aGlzLnN0YXRlLmNvbmZpZzsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGEgW3VzZXJcbiAgICBldmVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl51c2VyRXZlbnQpIGFubm90YXRpb24gdGhhdCBpcyBlcXVhbCB0b1xuICAgIG9yIG1vcmUgc3BlY2lmaWMgdGhhbiBgZXZlbnRgLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRyYW5zYWN0aW9uXG4gICAgaGFzIGBcInNlbGVjdC5wb2ludGVyXCJgIGFzIHVzZXIgZXZlbnQsIGBcInNlbGVjdFwiYCBhbmRcbiAgICBgXCJzZWxlY3QucG9pbnRlclwiYCB3aWxsIG1hdGNoIGl0LlxuICAgICovXG4gICAgaXNVc2VyRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLmFubm90YXRpb24oVHJhbnNhY3Rpb24udXNlckV2ZW50KTtcbiAgICAgICAgcmV0dXJuICEhKGUgJiYgKGUgPT0gZXZlbnQgfHwgZS5sZW5ndGggPiBldmVudC5sZW5ndGggJiYgZS5zbGljZSgwLCBldmVudC5sZW5ndGgpID09IGV2ZW50ICYmIGVbZXZlbnQubGVuZ3RoXSA9PSBcIi5cIikpO1xuICAgIH1cbn1cbi8qKlxuQW5ub3RhdGlvbiB1c2VkIHRvIHN0b3JlIHRyYW5zYWN0aW9uIHRpbWVzdGFtcHMuIEF1dG9tYXRpY2FsbHlcbmFkZGVkIHRvIGV2ZXJ5IHRyYW5zYWN0aW9uLCBob2xkaW5nIGBEYXRlLm5vdygpYC5cbiovXG5UcmFuc2FjdGlvbi50aW1lID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBhc3NvY2lhdGUgYSB0cmFuc2FjdGlvbiB3aXRoIGEgdXNlciBpbnRlcmZhY2VcbmV2ZW50LiBIb2xkcyBhIHN0cmluZyBpZGVudGlmeWluZyB0aGUgZXZlbnQsIHVzaW5nIGFcbmRvdC1zZXBhcmF0ZWQgZm9ybWF0IHRvIHN1cHBvcnQgYXR0YWNoaW5nIG1vcmUgc3BlY2lmaWNcbmluZm9ybWF0aW9uLiBUaGUgZXZlbnRzIHVzZWQgYnkgdGhlIGNvcmUgbGlicmFyaWVzIGFyZTpcblxuIC0gYFwiaW5wdXRcImAgd2hlbiBjb250ZW50IGlzIGVudGVyZWRcbiAgIC0gYFwiaW5wdXQudHlwZVwiYCBmb3IgdHlwZWQgaW5wdXRcbiAgICAgLSBgXCJpbnB1dC50eXBlLmNvbXBvc2VcImAgZm9yIGNvbXBvc2l0aW9uXG4gICAtIGBcImlucHV0LnBhc3RlXCJgIGZvciBwYXN0ZWQgaW5wdXRcbiAgIC0gYFwiaW5wdXQuZHJvcFwiYCB3aGVuIGFkZGluZyBjb250ZW50IHdpdGggZHJhZy1hbmQtZHJvcFxuICAgLSBgXCJpbnB1dC5jb21wbGV0ZVwiYCB3aGVuIGF1dG9jb21wbGV0aW5nXG4gLSBgXCJkZWxldGVcImAgd2hlbiB0aGUgdXNlciBkZWxldGVzIGNvbnRlbnRcbiAgIC0gYFwiZGVsZXRlLnNlbGVjdGlvblwiYCB3aGVuIGRlbGV0aW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmZvcndhcmRcImAgd2hlbiBkZWxldGluZyBmb3J3YXJkIGZyb20gdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuYmFja3dhcmRcImAgd2hlbiBkZWxldGluZyBiYWNrd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmN1dFwiYCB3aGVuIGN1dHRpbmcgdG8gdGhlIGNsaXBib2FyZFxuIC0gYFwibW92ZVwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWRcbiAgIC0gYFwibW92ZS5kcm9wXCJgIHdoZW4gY29udGVudCBpcyBtb3ZlZCB3aXRoaW4gdGhlIGVkaXRvciB0aHJvdWdoIGRyYWctYW5kLWRyb3BcbiAtIGBcInNlbGVjdFwiYCB3aGVuIGV4cGxpY2l0bHkgY2hhbmdpbmcgdGhlIHNlbGVjdGlvblxuICAgLSBgXCJzZWxlY3QucG9pbnRlclwiYCB3aGVuIHNlbGVjdGluZyB3aXRoIGEgbW91c2Ugb3Igb3RoZXIgcG9pbnRpbmcgZGV2aWNlXG4gLSBgXCJ1bmRvXCJgIGFuZCBgXCJyZWRvXCJgIGZvciBoaXN0b3J5IGFjdGlvbnNcblxuVXNlIFtgaXNVc2VyRXZlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLmlzVXNlckV2ZW50KSB0byBjaGVja1xud2hldGhlciB0aGUgYW5ub3RhdGlvbiBtYXRjaGVzIGEgZ2l2ZW4gZXZlbnQuXG4qL1xuVHJhbnNhY3Rpb24udXNlckV2ZW50ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyB3aGV0aGVyIGEgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFkZGVkIHRvXG50aGUgdW5kbyBoaXN0b3J5IG9yIG5vdC5cbiovXG5UcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiBpbmRpY2F0aW5nICh3aGVuIHByZXNlbnQgYW5kIHRydWUpIHRoYXQgYSB0cmFuc2FjdGlvblxucmVwcmVzZW50cyBhIGNoYW5nZSBtYWRlIGJ5IHNvbWUgb3RoZXIgYWN0b3IsIG5vdCB0aGUgdXNlci4gVGhpc1xuaXMgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIHRhZyBvdGhlciBwZW9wbGUncyBjaGFuZ2VzIGluXG5jb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4qL1xuVHJhbnNhY3Rpb24ucmVtb3RlID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG5mdW5jdGlvbiBqb2luUmFuZ2VzKGEsIGIpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICBsZXQgZnJvbSwgdG87XG4gICAgICAgIGlmIChpQSA8IGEubGVuZ3RoICYmIChpQiA9PSBiLmxlbmd0aCB8fCBiW2lCXSA+PSBhW2lBXSkpIHtcbiAgICAgICAgICAgIGZyb20gPSBhW2lBKytdO1xuICAgICAgICAgICAgdG8gPSBhW2lBKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlCIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZyb20gPSBiW2lCKytdO1xuICAgICAgICAgICAgdG8gPSBiW2lCKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCB8fCByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdIDwgZnJvbSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyb20sIHRvKTtcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IHRvKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVHJhbnNhY3Rpb24oYSwgYiwgc2VxdWVudGlhbCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbWFwRm9yQSwgbWFwRm9yQiwgY2hhbmdlcztcbiAgICBpZiAoc2VxdWVudGlhbCkge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzO1xuICAgICAgICBtYXBGb3JCID0gQ2hhbmdlU2V0LmVtcHR5KGIuY2hhbmdlcy5sZW5ndGgpO1xuICAgICAgICBjaGFuZ2VzID0gYS5jaGFuZ2VzLmNvbXBvc2UoYi5jaGFuZ2VzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcEZvckEgPSBiLmNoYW5nZXMubWFwKGEuY2hhbmdlcyk7XG4gICAgICAgIG1hcEZvckIgPSBhLmNoYW5nZXMubWFwRGVzYyhiLmNoYW5nZXMsIHRydWUpO1xuICAgICAgICBjaGFuZ2VzID0gYS5jaGFuZ2VzLmNvbXBvc2UobWFwRm9yQSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNlbGVjdGlvbjogYi5zZWxlY3Rpb24gPyBiLnNlbGVjdGlvbi5tYXAobWFwRm9yQikgOiAoX2EgPSBhLnNlbGVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcChtYXBGb3JBKSxcbiAgICAgICAgZWZmZWN0czogU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhhLmVmZmVjdHMsIG1hcEZvckEpLmNvbmNhdChTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGIuZWZmZWN0cywgbWFwRm9yQikpLFxuICAgICAgICBhbm5vdGF0aW9uczogYS5hbm5vdGF0aW9ucy5sZW5ndGggPyBhLmFubm90YXRpb25zLmNvbmNhdChiLmFubm90YXRpb25zKSA6IGIuYW5ub3RhdGlvbnMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBhLnNjcm9sbEludG9WaWV3IHx8IGIuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWMsIGRvY1NpemUpIHtcbiAgICBsZXQgc2VsID0gc3BlYy5zZWxlY3Rpb24sIGFubm90YXRpb25zID0gYXNBcnJheShzcGVjLmFubm90YXRpb25zKTtcbiAgICBpZiAoc3BlYy51c2VyRXZlbnQpXG4gICAgICAgIGFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuY29uY2F0KFRyYW5zYWN0aW9uLnVzZXJFdmVudC5vZihzcGVjLnVzZXJFdmVudCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5nZXM6IHNwZWMuY2hhbmdlcyBpbnN0YW5jZW9mIENoYW5nZVNldCA/IHNwZWMuY2hhbmdlc1xuICAgICAgICAgICAgOiBDaGFuZ2VTZXQub2Yoc3BlYy5jaGFuZ2VzIHx8IFtdLCBkb2NTaXplLCBzdGF0ZS5mYWNldChsaW5lU2VwYXJhdG9yKSksXG4gICAgICAgIHNlbGVjdGlvbjogc2VsICYmIChzZWwgaW5zdGFuY2VvZiBFZGl0b3JTZWxlY3Rpb24gPyBzZWwgOiBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKHNlbC5hbmNob3IsIHNlbC5oZWFkKSksXG4gICAgICAgIGVmZmVjdHM6IGFzQXJyYXkoc3BlYy5lZmZlY3RzKSxcbiAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiAhIXNwZWMuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBzcGVjcywgZmlsdGVyKSB7XG4gICAgbGV0IHMgPSByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3MubGVuZ3RoID8gc3BlY3NbMF0gOiB7fSwgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgaWYgKHNwZWNzLmxlbmd0aCAmJiBzcGVjc1swXS5maWx0ZXIgPT09IGZhbHNlKVxuICAgICAgICBmaWx0ZXIgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNwZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzcGVjc1tpXS5maWx0ZXIgPT09IGZhbHNlKVxuICAgICAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgICAgIGxldCBzZXEgPSAhIXNwZWNzW2ldLnNlcXVlbnRpYWw7XG4gICAgICAgIHMgPSBtZXJnZVRyYW5zYWN0aW9uKHMsIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjc1tpXSwgc2VxID8gcy5jaGFuZ2VzLm5ld0xlbmd0aCA6IHN0YXRlLmRvYy5sZW5ndGgpLCBzZXEpO1xuICAgIH1cbiAgICBsZXQgdHIgPSBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIHMuY2hhbmdlcywgcy5zZWxlY3Rpb24sIHMuZWZmZWN0cywgcy5hbm5vdGF0aW9ucywgcy5zY3JvbGxJbnRvVmlldyk7XG4gICAgcmV0dXJuIGV4dGVuZFRyYW5zYWN0aW9uKGZpbHRlciA/IGZpbHRlclRyYW5zYWN0aW9uKHRyKSA6IHRyKTtcbn1cbi8vIEZpbmlzaCBhIHRyYW5zYWN0aW9uIGJ5IGFwcGx5aW5nIGZpbHRlcnMgaWYgbmVjZXNzYXJ5LlxuZnVuY3Rpb24gZmlsdGVyVHJhbnNhY3Rpb24odHIpIHtcbiAgICBsZXQgc3RhdGUgPSB0ci5zdGFydFN0YXRlO1xuICAgIC8vIENoYW5nZSBmaWx0ZXJzXG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgZm9yIChsZXQgZmlsdGVyIG9mIHN0YXRlLmZhY2V0KGNoYW5nZUZpbHRlcikpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZmlsdGVyKHRyKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHRydWUgPyB2YWx1ZSA6IGpvaW5SYW5nZXMocmVzdWx0LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMsIGJhY2s7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBiYWNrID0gdHIuY2hhbmdlcy5pbnZlcnRlZERlc2M7XG4gICAgICAgICAgICBjaGFuZ2VzID0gQ2hhbmdlU2V0LmVtcHR5KHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkID0gdHIuY2hhbmdlcy5maWx0ZXIocmVzdWx0KTtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBmaWx0ZXJlZC5jaGFuZ2VzO1xuICAgICAgICAgICAgYmFjayA9IGZpbHRlcmVkLmZpbHRlcmVkLm1hcERlc2MoZmlsdGVyZWQuY2hhbmdlcykuaW52ZXJ0ZWREZXNjO1xuICAgICAgICB9XG4gICAgICAgIHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBjaGFuZ2VzLCB0ci5zZWxlY3Rpb24gJiYgdHIuc2VsZWN0aW9uLm1hcChiYWNrKSwgU3RhdGVFZmZlY3QubWFwRWZmZWN0cyh0ci5lZmZlY3RzLCBiYWNrKSwgdHIuYW5ub3RhdGlvbnMsIHRyLnNjcm9sbEludG9WaWV3KTtcbiAgICB9XG4gICAgLy8gVHJhbnNhY3Rpb24gZmlsdGVyc1xuICAgIGxldCBmaWx0ZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25GaWx0ZXIpO1xuICAgIGZvciAobGV0IGkgPSBmaWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBmaWx0ZXJlZCA9IGZpbHRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZmlsdGVyZWQgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIHRyID0gZmlsdGVyZWQ7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyZWQpICYmIGZpbHRlcmVkLmxlbmd0aCA9PSAxICYmIGZpbHRlcmVkWzBdIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkWzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ciA9IHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgYXNBcnJheShmaWx0ZXJlZCksIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gZXh0ZW5kVHJhbnNhY3Rpb24odHIpIHtcbiAgICBsZXQgc3RhdGUgPSB0ci5zdGFydFN0YXRlLCBleHRlbmRlcnMgPSBzdGF0ZS5mYWNldCh0cmFuc2FjdGlvbkV4dGVuZGVyKSwgc3BlYyA9IHRyO1xuICAgIGZvciAobGV0IGkgPSBleHRlbmRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGV4dGVuc2lvbiA9IGV4dGVuZGVyc1tpXSh0cik7XG4gICAgICAgIGlmIChleHRlbnNpb24gJiYgT2JqZWN0LmtleXMoZXh0ZW5zaW9uKS5sZW5ndGgpXG4gICAgICAgICAgICBzcGVjID0gbWVyZ2VUcmFuc2FjdGlvbihzcGVjLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgZXh0ZW5zaW9uLCB0ci5jaGFuZ2VzLm5ld0xlbmd0aCksIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYyA9PSB0ciA/IHRyIDogVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCB0ci5jaGFuZ2VzLCB0ci5zZWxlY3Rpb24sIHNwZWMuZWZmZWN0cywgc3BlYy5hbm5vdGF0aW9ucywgc3BlYy5zY3JvbGxJbnRvVmlldyk7XG59XG5jb25zdCBub25lID0gW107XG5mdW5jdGlvbiBhc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBub25lIDogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5cbi8qKlxuVGhlIGNhdGVnb3JpZXMgcHJvZHVjZWQgYnkgYSBbY2hhcmFjdGVyXG5jYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpLiBUaGVzZSBhcmUgdXNlZFxuZG8gdGhpbmdzIGxpa2Ugc2VsZWN0aW5nIGJ5IHdvcmQuXG4qL1xudmFyIENoYXJDYXRlZ29yeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENoYXJDYXRlZ29yeSkge1xuICAgIC8qKlxuICAgIFdvcmQgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJXb3JkXCJdID0gMF0gPSBcIldvcmRcIjtcbiAgICAvKipcbiAgICBXaGl0ZXNwYWNlLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIlNwYWNlXCJdID0gMV0gPSBcIlNwYWNlXCI7XG4gICAgLyoqXG4gICAgQW55dGhpbmcgZWxzZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJPdGhlclwiXSA9IDJdID0gXCJPdGhlclwiO1xucmV0dXJuIENoYXJDYXRlZ29yeX0pKENoYXJDYXRlZ29yeSB8fCAoQ2hhckNhdGVnb3J5ID0ge30pKTtcbmNvbnN0IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyID0gL1tcXHUwMGRmXFx1MDU4N1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTMwNDAtXFx1MzA5ZlxcdTMwYTAtXFx1MzBmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWFjMDAtXFx1ZDdhZl0vO1xubGV0IHdvcmRDaGFyO1xudHJ5IHtcbiAgICB3b3JkQ2hhciA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV9dXCIsIFwidVwiKTtcbn1cbmNhdGNoIChfKSB7IH1cbmZ1bmN0aW9uIGhhc1dvcmRDaGFyKHN0cikge1xuICAgIGlmICh3b3JkQ2hhcilcbiAgICAgICAgcmV0dXJuIHdvcmRDaGFyLnRlc3Qoc3RyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2ggPSBzdHJbaV07XG4gICAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJiAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBtYWtlQ2F0ZWdvcml6ZXIod29yZENoYXJzKSB7XG4gICAgcmV0dXJuIChjaGFyKSA9PiB7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChjaGFyKSlcbiAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuU3BhY2U7XG4gICAgICAgIGlmIChoYXNXb3JkQ2hhcihjaGFyKSlcbiAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuV29yZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY2hhci5pbmRleE9mKHdvcmRDaGFyc1tpXSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuT3RoZXI7XG4gICAgfTtcbn1cblxuLyoqXG5UaGUgZWRpdG9yIHN0YXRlIGNsYXNzIGlzIGEgcGVyc2lzdGVudCAoaW1tdXRhYmxlKSBkYXRhIHN0cnVjdHVyZS5cblRvIHVwZGF0ZSBhIHN0YXRlLCB5b3UgW2NyZWF0ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpIGFcblt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbiksIHdoaWNoIHByb2R1Y2VzIGEgX25ld18gc3RhdGVcbmluc3RhbmNlLCB3aXRob3V0IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuXG5BcyBzdWNoLCBfbmV2ZXJfIG11dGF0ZSBwcm9wZXJ0aWVzIG9mIGEgc3RhdGUgZGlyZWN0bHkuIFRoYXQnbGxcbmp1c3QgYnJlYWsgdGhpbmdzLlxuKi9cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbmZpZywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2MsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHNlbGVjdGlvbiwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB2YWx1ZXMsIGNvbXB1dGVTbG90LCB0cikge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBjb25maWcuc3RhdHVzVGVtcGxhdGUuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5jb21wdXRlU2xvdCA9IGNvbXB1dGVTbG90O1xuICAgICAgICAvLyBGaWxsIGluIHRoZSBjb21wdXRlZCBzdGF0ZSBpbW1lZGlhdGVseSwgc28gdGhhdCBmdXJ0aGVyIHF1ZXJpZXNcbiAgICAgICAgLy8gZm9yIGl0IG1hZGUgZHVyaW5nIHRoZSB1cGRhdGUgcmV0dXJuIHRoaXMgc3RhdGVcbiAgICAgICAgaWYgKHRyKVxuICAgICAgICAgICAgdHIuX3N0YXRlID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5keW5hbWljU2xvdHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGkgPDwgMSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVNsb3QgPSBudWxsO1xuICAgIH1cbiAgICBmaWVsZChmaWVsZCwgcmVxdWlyZSA9IHRydWUpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2ZpZWxkLmlkXTtcbiAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlcXVpcmUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGaWVsZCBpcyBub3QgcHJlc2VudCBpbiB0aGlzIHN0YXRlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGFkZHIpO1xuICAgICAgICByZXR1cm4gZ2V0QWRkcih0aGlzLCBhZGRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSB0aGF0IHVwZGF0ZXMgdGhpc1xuICAgIHN0YXRlLiBBbnkgbnVtYmVyIG9mIFt0cmFuc2FjdGlvbiBzcGVjc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpXG4gICAgY2FuIGJlIHBhc3NlZC4gVW5sZXNzXG4gICAgW2BzZXF1ZW50aWFsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VxdWVudGlhbCkgaXMgc2V0LCB0aGVcbiAgICBbY2hhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuY2hhbmdlcykgKGlmIGFueSkgb2YgZWFjaCBzcGVjXG4gICAgYXJlIGFzc3VtZWQgdG8gc3RhcnQgaW4gdGhlIF9jdXJyZW50XyBkb2N1bWVudCAobm90IHRoZSBkb2N1bWVudFxuICAgIHByb2R1Y2VkIGJ5IHByZXZpb3VzIHNwZWNzKSwgYW5kIGl0c1xuICAgIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgYW5kXG4gICAgW2VmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIGFyZSBhc3N1bWVkIHRvIHJlZmVyXG4gICAgdG8gdGhlIGRvY3VtZW50IGNyZWF0ZWQgYnkgaXRzIF9vd25fIGNoYW5nZXMuIFRoZSByZXN1bHRpbmdcbiAgICB0cmFuc2FjdGlvbiBjb250YWlucyB0aGUgY29tYmluZWQgZWZmZWN0IG9mIGFsbCB0aGUgZGlmZmVyZW50XG4gICAgc3BlY3MuIEZvciBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pLCBsYXRlclxuICAgIHNwZWNzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGVhcmxpZXIgb25lcy5cbiAgICAqL1xuICAgIHVwZGF0ZSguLi5zcGVjcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVRyYW5zYWN0aW9uKHRoaXMsIHNwZWNzLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseVRyYW5zYWN0aW9uKHRyKSB7XG4gICAgICAgIGxldCBjb25mID0gdGhpcy5jb25maWcsIHsgYmFzZSwgY29tcGFydG1lbnRzIH0gPSBjb25mO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhDb21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZikge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMgPSBuZXcgTWFwO1xuICAgICAgICAgICAgICAgICAgICBjb25mLmNvbXBhcnRtZW50cy5mb3JFYWNoKCh2YWwsIGtleSkgPT4gY29tcGFydG1lbnRzLnNldChrZXksIHZhbCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcGFydG1lbnRzLnNldChlZmZlY3QudmFsdWUuY29tcGFydG1lbnQsIGVmZmVjdC52YWx1ZS5leHRlbnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LnJlY29uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJhc2UgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJhc2UgPSBhc0FycmF5KGJhc2UpLmNvbmNhdChlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydFZhbHVlcztcbiAgICAgICAgaWYgKCFjb25mKSB7XG4gICAgICAgICAgICBjb25mID0gQ29uZmlndXJhdGlvbi5yZXNvbHZlKGJhc2UsIGNvbXBhcnRtZW50cywgdGhpcyk7XG4gICAgICAgICAgICBsZXQgaW50ZXJtZWRpYXRlU3RhdGUgPSBuZXcgRWRpdG9yU3RhdGUoY29uZiwgdGhpcy5kb2MsIHRoaXMuc2VsZWN0aW9uLCBjb25mLmR5bmFtaWNTbG90cy5tYXAoKCkgPT4gbnVsbCksIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC5yZWNvbmZpZ3VyZShzdGF0ZSwgdGhpcyksIG51bGwpO1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSBpbnRlcm1lZGlhdGVTdGF0ZS52YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IHRyLnN0YXJ0U3RhdGUudmFsdWVzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRyLnN0YXJ0U3RhdGUuZmFjZXQoYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpID8gdHIubmV3U2VsZWN0aW9uIDogdHIubmV3U2VsZWN0aW9uLmFzU2luZ2xlKCk7XG4gICAgICAgIG5ldyBFZGl0b3JTdGF0ZShjb25mLCB0ci5uZXdEb2MsIHNlbGVjdGlvbiwgc3RhcnRWYWx1ZXMsIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC51cGRhdGUoc3RhdGUsIHRyKSwgdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb24gc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpIHRoYXRcbiAgICByZXBsYWNlcyBldmVyeSBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnRvVGV4dCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiAoeyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgdGV4dC5sZW5ndGgpIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGNoYW5nZXMgYW5kIGEgbmV3IHNlbGVjdGlvbiBieSBydW5uaW5nIHRoZSBnaXZlblxuICAgIGZ1bmN0aW9uIGZvciBlYWNoIHJhbmdlIGluIHRoZSBhY3RpdmUgc2VsZWN0aW9uLiBUaGUgZnVuY3Rpb25cbiAgICBjYW4gcmV0dXJuIGFuIG9wdGlvbmFsIHNldCBvZiBjaGFuZ2VzIChpbiB0aGUgY29vcmRpbmF0ZSBzcGFjZVxuICAgIG9mIHRoZSBzdGFydCBkb2N1bWVudCksIHBsdXMgYW4gdXBkYXRlZCByYW5nZSAoaW4gdGhlIGNvb3JkaW5hdGVcbiAgICBzcGFjZSBvZiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIGNhbGwncyBvd24gY2hhbmdlcykuIFRoaXNcbiAgICBtZXRob2Qgd2lsbCBtZXJnZSBhbGwgdGhlIGNoYW5nZXMgYW5kIHJhbmdlcyBpbnRvIGEgc2luZ2xlXG4gICAgY2hhbmdlc2V0IGFuZCBzZWxlY3Rpb24sIGFuZCByZXR1cm4gaXQgYXMgYSBbdHJhbnNhY3Rpb25cbiAgICBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYyksIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG9cbiAgICBbYHVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKS5cbiAgICAqL1xuICAgIGNoYW5nZUJ5UmFuZ2UoZikge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGxldCByZXN1bHQxID0gZihzZWwucmFuZ2VzWzBdKTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0MS5jaGFuZ2VzKSwgcmFuZ2VzID0gW3Jlc3VsdDEucmFuZ2VdO1xuICAgICAgICBsZXQgZWZmZWN0cyA9IGFzQXJyYXkocmVzdWx0MS5lZmZlY3RzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZihzZWwucmFuZ2VzW2ldKTtcbiAgICAgICAgICAgIGxldCBuZXdDaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdC5jaGFuZ2VzKSwgbmV3TWFwcGVkID0gbmV3Q2hhbmdlcy5tYXAoY2hhbmdlcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKylcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSByYW5nZXNbal0ubWFwKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBsZXQgbWFwQnkgPSBjaGFuZ2VzLm1hcERlc2MobmV3Q2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyZXN1bHQucmFuZ2UubWFwKG1hcEJ5KSk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcy5jb21wb3NlKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBlZmZlY3RzID0gU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhlZmZlY3RzLCBuZXdNYXBwZWQpLmNvbmNhdChTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGFzQXJyYXkocmVzdWx0LmVmZmVjdHMpLCBtYXBCeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc2VsLm1haW5JbmRleCksXG4gICAgICAgICAgICBlZmZlY3RzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldCkgZnJvbSB0aGUgZ2l2ZW4gY2hhbmdlXG4gICAgZGVzY3JpcHRpb24sIHRha2luZyB0aGUgc3RhdGUncyBkb2N1bWVudCBsZW5ndGggYW5kIGxpbmVcbiAgICBzZXBhcmF0b3IgaW50byBhY2NvdW50LlxuICAgICovXG4gICAgY2hhbmdlcyhzcGVjID0gW10pIHtcbiAgICAgICAgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpXG4gICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgcmV0dXJuIENoYW5nZVNldC5vZihzcGVjLCB0aGlzLmRvYy5sZW5ndGgsIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2luZyB0aGUgc3RhdGUncyBbbGluZVxuICAgIHNlcGFyYXRvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKSwgY3JlYXRlIGFcbiAgICBbYFRleHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQpIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIHRvVGV4dChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFRleHQub2Yoc3RyaW5nLnNwbGl0KHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLlxuICAgICovXG4gICAgc2xpY2VEb2MoZnJvbSA9IDAsIHRvID0gdGhpcy5kb2MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgdGhpcy5saW5lQnJlYWspO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3RhdGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0KS5cbiAgICAqL1xuICAgIGZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFjZXQuZGVmYXVsdDtcbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzdGF0ZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsIHlvdSBjYW4gcGFzcyB0aGVtIGluIGFzIGFuIG9iamVjdFxuICAgIG1hcHBpbmcgcHJvcGVydHkgbmFtZXMgKGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LCB3aGljaCBzaG91bGRcbiAgICBub3QgdXNlIGBkb2NgIG9yIGBzZWxlY3Rpb25gKSB0byBmaWVsZHMuXG4gICAgKi9cbiAgICB0b0pTT04oZmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBkb2M6IHRoaXMuc2xpY2VEb2MoKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmllbGRzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRlRmllbGQgJiYgdGhpcy5jb25maWcuYWRkcmVzc1t2YWx1ZS5pZF0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsdWUuc3BlYy50b0pTT04odGhpcy5maWVsZChmaWVsZHNbcHJvcF0pLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGF0ZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgZGVzZXJpYWxpemVkLCBwYXNzIHRoZSBzYW1lIG9iamVjdCB5b3UgcGFzc2VkXG4gICAgdG8gW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgd2hlbiBzZXJpYWxpemluZyBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24sIGNvbmZpZyA9IHt9LCBmaWVsZHMpIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmRvYyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclN0YXRlXCIpO1xuICAgICAgICBsZXQgZmllbGRJbml0ID0gW107XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW3Byb3BdLCB2YWx1ZSA9IGpzb25bcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5pdC5wdXNoKGZpZWxkLmluaXQoc3RhdGUgPT4gZmllbGQuc3BlYy5mcm9tSlNPTih2YWx1ZSwgc3RhdGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgIGRvYzoganNvbi5kb2MsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnNlbGVjdGlvbiksXG4gICAgICAgICAgICBleHRlbnNpb25zOiBjb25maWcuZXh0ZW5zaW9ucyA/IGZpZWxkSW5pdC5jb25jYXQoW2NvbmZpZy5leHRlbnNpb25zXSkgOiBmaWVsZEluaXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZS4gWW91J2xsIHVzdWFsbHkgb25seSBuZWVkIHRoaXMgd2hlblxuICAgIGluaXRpYWxpemluZyBhbiBlZGl0b3JcdTIwMTR1cGRhdGVkIHN0YXRlcyBhcmUgY3JlYXRlZCBieSBhcHBseWluZ1xuICAgIHRyYW5zYWN0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uLnJlc29sdmUoY29uZmlnLmV4dGVuc2lvbnMgfHwgW10sIG5ldyBNYXApO1xuICAgICAgICBsZXQgZG9jID0gY29uZmlnLmRvYyBpbnN0YW5jZW9mIFRleHQgPyBjb25maWcuZG9jXG4gICAgICAgICAgICA6IFRleHQub2YoKGNvbmZpZy5kb2MgfHwgXCJcIikuc3BsaXQoY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9ICFjb25maWcuc2VsZWN0aW9uID8gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZSgwKVxuICAgICAgICAgICAgOiBjb25maWcuc2VsZWN0aW9uIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gY29uZmlnLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShjb25maWcuc2VsZWN0aW9uLmFuY2hvciwgY29uZmlnLnNlbGVjdGlvbi5oZWFkKTtcbiAgICAgICAgY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2MubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSlcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5hc1NpbmdsZSgpO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclN0YXRlKGNvbmZpZ3VyYXRpb24sIGRvYywgc2VsZWN0aW9uLCBjb25maWd1cmF0aW9uLmR5bmFtaWNTbG90cy5tYXAoKCkgPT4gbnVsbCksIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC5jcmVhdGUoc3RhdGUpLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgKGluIGNvbHVtbnMpIG9mIGEgdGFiIGluIHRoZSBkb2N1bWVudCwgZGV0ZXJtaW5lZCBieVxuICAgIHRoZSBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIGZhY2V0LlxuICAgICovXG4gICAgZ2V0IHRhYlNpemUoKSB7IHJldHVybiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLnRhYlNpemUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwcm9wZXIgW2xpbmUtYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvcilcbiAgICBzdHJpbmcgZm9yIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBcIlxcblwiOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgIFtjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnJlYWRPbmx5KSB0byBiZSByZWFkLW9ubHkuXG4gICAgKi9cbiAgICBnZXQgcmVhZE9ubHkoKSB7IHJldHVybiB0aGlzLmZhY2V0KHJlYWRPbmx5KTsgfVxuICAgIC8qKlxuICAgIExvb2sgdXAgYSB0cmFuc2xhdGlvbiBmb3IgdGhlIGdpdmVuIHBocmFzZSAodmlhIHRoZVxuICAgIFtgcGhyYXNlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecGhyYXNlcykgZmFjZXQpLCBvciByZXR1cm4gdGhlXG4gICAgb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHRyYW5zbGF0aW9uIGlzIGZvdW5kLlxuICAgIFxuICAgIElmIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwYXNzZWQsIHRoZXkgd2lsbCBiZSBpbnNlcnRlZCBpblxuICAgIHBsYWNlIG9mIG1hcmtlcnMgbGlrZSBgJDFgIChmb3IgdGhlIGZpcnN0IHZhbHVlKSBhbmQgYCQyYCwgZXRjLlxuICAgIEEgc2luZ2xlIGAkYCBpcyBlcXVpdmFsZW50IHRvIGAkMWAsIGFuZCBgJCRgIHdpbGwgcHJvZHVjZSBhXG4gICAgbGl0ZXJhbCBkb2xsYXIgc2lnbi5cbiAgICAqL1xuICAgIHBocmFzZShwaHJhc2UsIC4uLmluc2VydCkge1xuICAgICAgICBmb3IgKGxldCBtYXAgb2YgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBwaHJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcGhyYXNlID0gbWFwW3BocmFzZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChpbnNlcnQubGVuZ3RoKVxuICAgICAgICAgICAgcGhyYXNlID0gcGhyYXNlLnJlcGxhY2UoL1xcJChcXCR8XFxkKikvZywgKG0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBcIiRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICAgICAgICAgIGxldCBuID0gKyhpIHx8IDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhbiB8fCBuID4gaW5zZXJ0Lmxlbmd0aCA/IG0gOiBpbnNlcnRbbiAtIDFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwaHJhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHZhbHVlcyBmb3IgYSBnaXZlbiBsYW5ndWFnZSBkYXRhIGZpZWxkLCBwcm92aWRlZCBieSB0aGVcbiAgICB0aGUgW2BsYW5ndWFnZURhdGFgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxhbmd1YWdlRGF0YSkgZmFjZXQuXG4gICAgXG4gICAgRXhhbXBsZXMgb2YgbGFuZ3VhZ2UgZGF0YSBmaWVsZHMgYXJlLi4uXG4gICAgXG4gICAgLSBbYFwiY29tbWVudFRva2Vuc1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBmb3Igc3BlY2lmeWluZ1xuICAgICAgY29tbWVudCBzeW50YXguXG4gICAgLSBbYFwiYXV0b2NvbXBsZXRlXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hdXRvY29tcGxldGlvbl5jb25maWcub3ZlcnJpZGUpXG4gICAgICBmb3IgcHJvdmlkaW5nIGxhbmd1YWdlLXNwZWNpZmljIGNvbXBsZXRpb24gc291cmNlcy5cbiAgICAtIFtgXCJ3b3JkQ2hhcnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBmb3IgYWRkaW5nXG4gICAgICBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiB3b3JkcyBpbiB0aGlzXG4gICAgICBsYW5ndWFnZS5cbiAgICAtIFtgXCJjbG9zZUJyYWNrZXRzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5DbG9zZUJyYWNrZXRDb25maWcpIGNvbnRyb2xzXG4gICAgICBicmFja2V0IGNsb3NpbmcgYmVoYXZpb3IuXG4gICAgKi9cbiAgICBsYW5ndWFnZURhdGFBdChuYW1lLCBwb3MsIHNpZGUgPSAtMSkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IHByb3ZpZGVyIG9mIHRoaXMuZmFjZXQobGFuZ3VhZ2VEYXRhKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcmVzdWx0IG9mIHByb3ZpZGVyKHRoaXMsIHBvcywgc2lkZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJlc3VsdFtuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gY2F0ZWdvcml6ZSBzdHJpbmdzIChleHBlY3RlZCB0b1xuICAgIHJlcHJlc2VudCBhIHNpbmdsZSBbZ3JhcGhlbWUgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKSlcbiAgICBpbnRvIG9uZSBvZjpcbiAgICBcbiAgICAgLSBXb3JkIChjb250YWlucyBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyIG9yIGEgY2hhcmFjdGVyXG4gICAgICAgZXhwbGljaXRseSBsaXN0ZWQgaW4gdGhlIGxvY2FsIGxhbmd1YWdlJ3MgYFwid29yZENoYXJzXCJgXG4gICAgICAgbGFuZ3VhZ2UgZGF0YSwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nKVxuICAgICAtIFNwYWNlIChjb250YWlucyBvbmx5IHdoaXRlc3BhY2UpXG4gICAgIC0gT3RoZXIgKGFueXRoaW5nIGVsc2UpXG4gICAgKi9cbiAgICBjaGFyQ2F0ZWdvcml6ZXIoYXQpIHtcbiAgICAgICAgbGV0IGNoYXJzID0gdGhpcy5sYW5ndWFnZURhdGFBdChcIndvcmRDaGFyc1wiLCBhdCk7XG4gICAgICAgIHJldHVybiBtYWtlQ2F0ZWdvcml6ZXIoY2hhcnMubGVuZ3RoID8gY2hhcnNbMF0gOiBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIG1lYW5pbmcgdGhlIHJhbmdlXG4gICAgY29udGFpbmluZyBhbGwgW3dvcmRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpIGNoYXJhY3RlcnNcbiAgICBhcm91bmQgaXQuIElmIG5vIHdvcmQgY2hhcmFjdGVycyBhcmUgYWRqYWNlbnQgdG8gdGhlIHBvc2l0aW9uLFxuICAgIHRoaXMgcmV0dXJucyBudWxsLlxuICAgICovXG4gICAgd29yZEF0KHBvcykge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tLCBsZW5ndGggfSA9IHRoaXMuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgY2F0ID0gdGhpcy5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gZnJvbSwgZW5kID0gcG9zIC0gZnJvbTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIHN0YXJ0LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UocHJldiwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXJ0ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZW5kIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgZW5kKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShlbmQsIG5leHQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVuZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0ID09IGVuZCA/IG51bGwgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoc3RhcnQgKyBmcm9tLCBlbmQgKyBmcm9tKTtcbiAgICB9XG59XG4vKipcbkEgZmFjZXQgdGhhdCwgd2hlbiBlbmFibGVkLCBjYXVzZXMgdGhlIGVkaXRvciB0byBhbGxvdyBtdWx0aXBsZVxucmFuZ2VzIHRvIGJlIHNlbGVjdGVkLiBCZSBjYXJlZnVsIHRob3VnaCwgYmVjYXVzZSBieSBkZWZhdWx0IHRoZVxuZWRpdG9yIHJlbGllcyBvbiB0aGUgbmF0aXZlIERPTSBzZWxlY3Rpb24sIHdoaWNoIGNhbm5vdCBoYW5kbGVcbm11bHRpcGxlIHNlbGVjdGlvbnMuIEFuIGV4dGVuc2lvbiBsaWtlXG5bYGRyYXdTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbikgY2FuIGJlIHVzZWQgdG8gbWFrZVxuc2Vjb25kYXJ5IHNlbGVjdGlvbnMgdmlzaWJsZSB0byB0aGUgdXNlci5cbiovXG5FZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zO1xuLyoqXG5Db25maWd1cmVzIHRoZSB0YWIgc2l6ZSB0byB1c2UgaW4gdGhpcyBzdGF0ZS4gVGhlIGZpcnN0XG4oaGlnaGVzdC1wcmVjZWRlbmNlKSB2YWx1ZSBvZiB0aGUgZmFjZXQgaXMgdXNlZC4gSWYgbm8gdmFsdWUgaXNcbmdpdmVuLCB0aGlzIGRlZmF1bHRzIHRvIDQuXG4qL1xuRWRpdG9yU3RhdGUudGFiU2l6ZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogNFxufSk7XG4vKipcblRoZSBsaW5lIHNlcGFyYXRvciB0byB1c2UuIEJ5IGRlZmF1bHQsIGFueSBvZiBgXCJcXG5cImAsIGBcIlxcclxcblwiYFxuYW5kIGBcIlxcclwiYCBpcyB0cmVhdGVkIGFzIGEgc2VwYXJhdG9yIHdoZW4gc3BsaXR0aW5nIGxpbmVzLCBhbmRcbmxpbmVzIGFyZSBqb2luZWQgd2l0aCBgXCJcXG5cImAuXG5cbldoZW4geW91IGNvbmZpZ3VyZSBhIHZhbHVlIGhlcmUsIG9ubHkgdGhhdCBwcmVjaXNlIHNlcGFyYXRvclxud2lsbCBiZSB1c2VkLCBhbGxvd2luZyB5b3UgdG8gcm91bmQtdHJpcCBkb2N1bWVudHMgdGhyb3VnaCB0aGVcbmVkaXRvciB3aXRob3V0IG5vcm1hbGl6aW5nIGxpbmUgc2VwYXJhdG9ycy5cbiovXG5FZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yID0gbGluZVNlcGFyYXRvcjtcbi8qKlxuVGhpcyBmYWNldCBjb250cm9scyB0aGUgdmFsdWUgb2YgdGhlXG5bYHJlYWRPbmx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5yZWFkT25seSkgZ2V0dGVyLCB3aGljaCBpc1xuY29uc3VsdGVkIGJ5IGNvbW1hbmRzIGFuZCBleHRlbnNpb25zIHRoYXQgaW1wbGVtZW50IGVkaXRpbmdcbmZ1bmN0aW9uYWxpdHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhleSBzaG91bGQgYXBwbHkuIEl0XG5kZWZhdWx0cyB0byBmYWxzZSwgYnV0IHdoZW4gaXRzIGhpZ2hlc3QtcHJlY2VkZW5jZSB2YWx1ZSBpc1xuYHRydWVgLCBzdWNoIGZ1bmN0aW9uYWxpdHkgZGlzYWJsZXMgaXRzZWxmLlxuXG5Ob3QgdG8gYmUgY29uZnVzZWQgd2l0aFxuW2BFZGl0b3JWaWV3LmVkaXRhYmxlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdGFibGUpLCB3aGljaFxuY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yJ3MgRE9NIGlzIHNldCB0byBiZSBlZGl0YWJsZSAoYW5kXG50aHVzIGZvY3VzYWJsZSkuXG4qL1xuRWRpdG9yU3RhdGUucmVhZE9ubHkgPSByZWFkT25seTtcbi8qKlxuUmVnaXN0ZXJzIHRyYW5zbGF0aW9uIHBocmFzZXMuIFRoZVxuW2BwaHJhc2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnBocmFzZSkgbWV0aG9kIHdpbGwgbG9vayB0aHJvdWdoXG5hbGwgb2JqZWN0cyByZWdpc3RlcmVkIHdpdGggdGhpcyBmYWNldCB0byBmaW5kIHRyYW5zbGF0aW9ucyBmb3Jcbml0cyBhcmd1bWVudC5cbiovXG5FZGl0b3JTdGF0ZS5waHJhc2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tcGFyZShhLCBiKSB7XG4gICAgICAgIGxldCBrQSA9IE9iamVjdC5rZXlzKGEpLCBrQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga0EubGVuZ3RoID09IGtCLmxlbmd0aCAmJiBrQS5ldmVyeShrID0+IGFba10gPT0gYltrXSk7XG4gICAgfVxufSk7XG4vKipcbkEgZmFjZXQgdXNlZCB0byByZWdpc3RlciBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIHByb3ZpZGVycy5cbiovXG5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGEgPSBsYW5ndWFnZURhdGE7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgY2hhbmdlIGZpbHRlcnMsIHdoaWNoIGFyZSBjYWxsZWQgZm9yIGVhY2hcbnRyYW5zYWN0aW9uICh1bmxlc3MgZXhwbGljaXRseVxuW2Rpc2FibGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpKSwgYW5kIGNhbiBzdXBwcmVzc1xucGFydCBvZiB0aGUgdHJhbnNhY3Rpb24ncyBjaGFuZ2VzLlxuXG5TdWNoIGEgZnVuY3Rpb24gY2FuIHJldHVybiBgdHJ1ZWAgdG8gaW5kaWNhdGUgdGhhdCBpdCBkb2Vzbid0XG53YW50IHRvIGRvIGFueXRoaW5nLCBgZmFsc2VgIHRvIGNvbXBsZXRlbHkgc3RvcCB0aGUgY2hhbmdlcyBpblxudGhlIHRyYW5zYWN0aW9uLCBvciBhIHNldCBvZiByYW5nZXMgaW4gd2hpY2ggY2hhbmdlcyBzaG91bGQgYmVcbnN1cHByZXNzZWQuIFN1Y2ggcmFuZ2VzIGFyZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLFxud2l0aCBlYWNoIHBhaXIgb2YgdHdvIG51bWJlcnMgaW5kaWNhdGluZyB0aGUgc3RhcnQgYW5kIGVuZCBvZiBhXG5yYW5nZS4gU28gZm9yIGV4YW1wbGUgYFsxMCwgMjAsIDEwMCwgMTEwXWAgc3VwcHJlc3NlcyBjaGFuZ2VzXG5iZXR3ZWVuIDEwIGFuZCAyMCwgYW5kIGJldHdlZW4gMTAwIGFuZCAxMTAuXG4qL1xuRWRpdG9yU3RhdGUuY2hhbmdlRmlsdGVyID0gY2hhbmdlRmlsdGVyO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGEgaG9vayB0aGF0IGdldHMgYSBjaGFuY2UgdG8gdXBkYXRlIG9yXG5yZXBsYWNlIHRyYW5zYWN0aW9uIHNwZWNzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkLiBUaGlzIHdpbGxcbm9ubHkgYmUgYXBwbGllZCBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZVxuW2BmaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpIHNldCB0byBgZmFsc2VgLiBZb3VcbmNhbiBlaXRoZXIgcmV0dXJuIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHNwZWMgKHBvc3NpYmx5IHRoZSBpbnB1dFxudHJhbnNhY3Rpb24pLCBvciBhbiBhcnJheSBvZiBzcGVjcyAod2hpY2ggd2lsbCBiZSBjb21iaW5lZCBpblxudGhlIHNhbWUgd2F5IGFzIHRoZSBhcmd1bWVudHMgdG9cbltgRWRpdG9yU3RhdGUudXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpKS5cblxuV2hlbiBwb3NzaWJsZSwgaXQgaXMgcmVjb21tZW5kZWQgdG8gYXZvaWQgYWNjZXNzaW5nXG5bYFRyYW5zYWN0aW9uLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSkgaW4gYSBmaWx0ZXIsXG5zaW5jZSBpdCB3aWxsIGZvcmNlIGNyZWF0aW9uIG9mIGEgc3RhdGUgdGhhdCB3aWxsIHRoZW4gYmVcbmRpc2NhcmRlZCBhZ2FpbiwgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFjdHVhbGx5IGZpbHRlcmVkLlxuXG4oVGhpcyBmdW5jdGlvbmFsaXR5IHNob3VsZCBiZSB1c2VkIHdpdGggY2FyZS4gSW5kaXNjcmltaW5hdGVseVxubW9kaWZ5aW5nIHRyYW5zYWN0aW9uIGlzIGxpa2VseSB0byBicmVhayBzb21ldGhpbmcgb3IgZGVncmFkZVxudGhlIHVzZXIgZXhwZXJpZW5jZS4pXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIgPSB0cmFuc2FjdGlvbkZpbHRlcjtcbi8qKlxuVGhpcyBpcyBhIG1vcmUgbGltaXRlZCBmb3JtIG9mXG5bYHRyYW5zYWN0aW9uRmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlciksXG53aGljaCBjYW4gb25seSBhZGRcblthbm5vdGF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuYW5ub3RhdGlvbnMpIGFuZFxuW2VmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpLiBfQnV0XywgdGhpcyB0eXBlXG5vZiBmaWx0ZXIgcnVucyBldmVuIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgZGlzYWJsZWQgcmVndWxhclxuW2ZpbHRlcmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSwgbWFraW5nIGl0IHN1aXRhYmxlXG5mb3IgZWZmZWN0cyB0aGF0IGRvbid0IG5lZWQgdG8gdG91Y2ggdGhlIGNoYW5nZXMgb3Igc2VsZWN0aW9uLFxuYnV0IGRvIHdhbnQgdG8gcHJvY2VzcyBldmVyeSB0cmFuc2FjdGlvbi5cblxuRXh0ZW5kZXJzIHJ1biBfYWZ0ZXJfIGZpbHRlcnMsIHdoZW4gYm90aCBhcmUgcHJlc2VudC5cbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkV4dGVuZGVyID0gdHJhbnNhY3Rpb25FeHRlbmRlcjtcbkNvbXBhcnRtZW50LnJlY29uZmlndXJlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuXG4vKipcblV0aWxpdHkgZnVuY3Rpb24gZm9yIGNvbWJpbmluZyBiZWhhdmlvcnMgdG8gZmlsbCBpbiBhIGNvbmZpZ1xub2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgcHJvdmlkZWQgY29uZmlncy4gYGRlZmF1bHRzYCBzaG91bGQgaG9sZFxuZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCBvcHRpb25hbCBmaWVsZHMgaW4gYENvbmZpZ2AuXG5cblRoZSBmdW5jdGlvbiB3aWxsLCBieSBkZWZhdWx0LCBlcnJvclxud2hlbiBhIGZpZWxkIGdldHMgdHdvIHZhbHVlcyB0aGF0IGFyZW4ndCBgPT09YC1lcXVhbCwgYnV0IHlvdSBjYW5cbnByb3ZpZGUgY29tYmluZSBmdW5jdGlvbnMgcGVyIGZpZWxkIHRvIGRvIHNvbWV0aGluZyBlbHNlLlxuKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb25maWcoY29uZmlncywgZGVmYXVsdHMsIC8vIFNob3VsZCBob2xkIG9ubHkgdGhlIG9wdGlvbmFsIHByb3BlcnRpZXMgb2YgQ29uZmlnLCBidXQgSSBoYXZlbid0IG1hbmFnZWQgdG8gZXhwcmVzcyB0aGF0XG5jb21iaW5lID0ge30pIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb25maWdba2V5XSwgY3VycmVudCA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgOyAvLyBObyBjb25mbGljdFxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY29tYmluZSwga2V5KSlcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNvbWJpbmVba2V5XShjdXJyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlnIG1lcmdlIGNvbmZsaWN0IGZvciBmaWVsZCBcIiArIGtleSk7XG4gICAgICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdHMpXG4gICAgICAgIGlmIChyZXN1bHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuRWFjaCByYW5nZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2YWx1ZSwgd2hpY2ggbXVzdCBpbmhlcml0IGZyb21cbnRoaXMgY2xhc3MuXG4qL1xuY2xhc3MgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHZhbHVlIHdpdGggYW5vdGhlciB2YWx1ZS4gVXNlZCB3aGVuIGNvbXBhcmluZ1xuICAgIHJhbmdlc2V0cy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gY29tcGFyZXMgYnkgaWRlbnRpdHkuXG4gICAgVW5sZXNzIHlvdSBhcmUgb25seSBjcmVhdGluZyBhIGZpeGVkIG51bWJlciBvZiB1bmlxdWUgaW5zdGFuY2VzXG4gICAgb2YgeW91ciB2YWx1ZSB0eXBlLCBpdCBpcyBhIGdvb2QgaWRlYSB0byBpbXBsZW1lbnQgdGhpc1xuICAgIHByb3Blcmx5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMgPT0gb3RoZXI7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIHdpdGggdGhpcyB2YWx1ZS5cbiAgICAqL1xuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkgeyByZXR1cm4gUmFuZ2UuY3JlYXRlKGZyb20sIHRvLCB0aGlzKTsgfVxufVxuUmFuZ2VWYWx1ZS5wcm90b3R5cGUuc3RhcnRTaWRlID0gUmFuZ2VWYWx1ZS5wcm90b3R5cGUuZW5kU2lkZSA9IDA7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tEZWw7XG5mdW5jdGlvbiBjbXBWYWwoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgYS5jb25zdHJ1Y3RvciA9PSBiLmNvbnN0cnVjdG9yICYmIGEuZXEoYik7XG59XG4vKipcbkEgcmFuZ2UgYXNzb2NpYXRlcyBhIHZhbHVlIHdpdGggYSByYW5nZSBvZiBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgSXRzIGVuZCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmFuZ2UuXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY21wUmFuZ2UoYSwgYikge1xuICAgIHJldHVybiBhLmZyb20gLSBiLmZyb20gfHwgYS52YWx1ZS5zdGFydFNpZGUgLSBiLnZhbHVlLnN0YXJ0U2lkZTtcbn1cbmNsYXNzIENodW5rIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgdmFsdWUsIFxuICAgIC8vIENodW5rcyBhcmUgbWFya2VkIHdpdGggdGhlIGxhcmdlc3QgcG9pbnQgdGhhdCBvY2N1cnNcbiAgICAvLyBpbiB0aGVtIChvciAtMSBmb3Igbm8gcG9pbnRzKSwgc28gdGhhdCBzY2FucyB0aGF0IGFyZVxuICAgIC8vIG9ubHkgaW50ZXJlc3RlZCBpbiBwb2ludHMgKHN1Y2ggYXMgdGhlXG4gICAgLy8gaGVpZ2h0bWFwLXJlbGF0ZWQgbG9naWMpIGNhbiBza2lwIHJhbmdlLW9ubHkgY2h1bmtzLlxuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvW3RoaXMudG8ubGVuZ3RoIC0gMV07IH1cbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUuIFVzZSB0aGUgcmFuZ2VzJ1xuICAgIC8vIGBmcm9tYCBwb3Mgd2hlbiBgZW5kID09IGZhbHNlYCwgYHRvYCB3aGVuIGBlbmQgPT0gdHJ1ZWAuXG4gICAgZmluZEluZGV4KHBvcywgc2lkZSwgZW5kLCBzdGFydEF0ID0gMCkge1xuICAgICAgICBsZXQgYXJyID0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbG8gPSBzdGFydEF0LCBoaSA9IGFyci5sZW5ndGg7Oykge1xuICAgICAgICAgICAgaWYgKGxvID09IGhpKVxuICAgICAgICAgICAgICAgIHJldHVybiBsbztcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICAgICAgICAgIGxldCBkaWZmID0gYXJyW21pZF0gLSBwb3MgfHwgKGVuZCA/IHRoaXMudmFsdWVbbWlkXS5lbmRTaWRlIDogdGhpcy52YWx1ZVttaWRdLnN0YXJ0U2lkZSkgLSBzaWRlO1xuICAgICAgICAgICAgaWYgKG1pZCA9PSBsbylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA+PSAwID8gbG8gOiBoaTtcbiAgICAgICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJldHdlZW4ob2Zmc2V0LCBmcm9tLCB0bywgZikge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maW5kSW5kZXgoZnJvbSwgLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8sIHRydWUpLCBlID0gdGhpcy5maW5kSW5kZXgodG8sIDEwMDAwMDAwMDAgLyogQy5GYXIgKi8sIGZhbHNlLCBpKTsgaSA8IGU7IGkrKylcbiAgICAgICAgICAgIGlmIChmKHRoaXMuZnJvbVtpXSArIG9mZnNldCwgdGhpcy50b1tpXSArIG9mZnNldCwgdGhpcy52YWx1ZVtpXSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFwKG9mZnNldCwgY2hhbmdlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSBbXSwgZnJvbSA9IFtdLCB0byA9IFtdLCBuZXdQb3MgPSAtMSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gdGhpcy52YWx1ZVtpXSwgY3VyRnJvbSA9IHRoaXMuZnJvbVtpXSArIG9mZnNldCwgY3VyVG8gPSB0aGlzLnRvW2ldICsgb2Zmc2V0LCBuZXdGcm9tLCBuZXdUbztcbiAgICAgICAgICAgIGlmIChjdXJGcm9tID09IGN1clRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUsIHZhbC5tYXBNb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIG5ld0Zyb20gPSBuZXdUbyA9IG1hcHBlZDtcbiAgICAgICAgICAgICAgICBpZiAodmFsLnN0YXJ0U2lkZSAhPSB2YWwuZW5kU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdUbyA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RvIDwgbmV3RnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0Zyb20gPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlKTtcbiAgICAgICAgICAgICAgICBuZXdUbyA9IGNoYW5nZXMubWFwUG9zKGN1clRvLCB2YWwuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Zyb20gPiBuZXdUbyB8fCBuZXdGcm9tID09IG5ld1RvICYmIHZhbC5zdGFydFNpZGUgPiAwICYmIHZhbC5lbmRTaWRlIDw9IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChuZXdUbyAtIG5ld0Zyb20gfHwgdmFsLmVuZFNpZGUgLSB2YWwuc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobmV3UG9zIDwgMClcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBuZXdGcm9tO1xuICAgICAgICAgICAgaWYgKHZhbC5wb2ludClcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBuZXdUbyAtIG5ld0Zyb20pO1xuICAgICAgICAgICAgdmFsdWUucHVzaCh2YWwpO1xuICAgICAgICAgICAgZnJvbS5wdXNoKG5ld0Zyb20gLSBuZXdQb3MpO1xuICAgICAgICAgICAgdG8ucHVzaChuZXdUbyAtIG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFwcGVkOiB2YWx1ZS5sZW5ndGggPyBuZXcgQ2h1bmsoZnJvbSwgdG8sIHZhbHVlLCBtYXhQb2ludCkgOiBudWxsLCBwb3M6IG5ld1BvcyB9O1xuICAgIH1cbn1cbi8qKlxuQSByYW5nZSBzZXQgc3RvcmVzIGEgY29sbGVjdGlvbiBvZiBbcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBpbiBhXG53YXkgdGhhdCBtYWtlcyB0aGVtIGVmZmljaWVudCB0byBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0Lm1hcCkgYW5kXG5bdXBkYXRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0LnVwZGF0ZSkuIFRoaXMgaXMgYW4gaW1tdXRhYmxlIGRhdGFcbnN0cnVjdHVyZS5cbiovXG5jbGFzcyBSYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVua1BvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVuaywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBuZXh0TGF5ZXIsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IGNodW5rUG9zO1xuICAgICAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbmV4dExheWVyO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jaHVuay5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gbGFzdCA8IDAgPyAwIDogTWF0aC5tYXgodGhpcy5jaHVua0VuZChsYXN0KSwgdGhpcy5uZXh0TGF5ZXIubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiByYW5nZXMgaW4gdGhlIHNldC5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5uZXh0TGF5ZXIuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgY2h1bmsgb2YgdGhpcy5jaHVuaylcbiAgICAgICAgICAgIHNpemUgKz0gY2h1bmsudmFsdWUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVua0VuZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaHVua1Bvc1tpbmRleF0gKyB0aGlzLmNodW5rW2luZGV4XS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgcmFuZ2Ugc2V0LCBvcHRpb25hbGx5IGFkZGluZyBuZXcgcmFuZ2VzIG9yIGZpbHRlcmluZ1xuICAgIG91dCBleGlzdGluZyBvbmVzLlxuICAgIFxuICAgIChOb3RlOiBUaGUgdHlwZSBwYXJhbWV0ZXIgaXMganVzdCB0aGVyZSBhcyBhIGtsdWRnZSB0byB3b3JrXG4gICAgYXJvdW5kIFR5cGVTY3JpcHQgdmFyaWFuY2UgaXNzdWVzIHRoYXQgcHJldmVudGVkIGBSYW5nZVNldDxYPmBcbiAgICBmcm9tIGJlaW5nIGEgc3VidHlwZSBvZiBgUmFuZ2VTZXQ8WT5gIHdoZW4gYFhgIGlzIGEgc3VidHlwZSBvZlxuICAgIGBZYC4pXG4gICAgKi9cbiAgICB1cGRhdGUodXBkYXRlU3BlYykge1xuICAgICAgICBsZXQgeyBhZGQgPSBbXSwgc29ydCA9IGZhbHNlLCBmaWx0ZXJGcm9tID0gMCwgZmlsdGVyVG8gPSB0aGlzLmxlbmd0aCB9ID0gdXBkYXRlU3BlYztcbiAgICAgICAgbGV0IGZpbHRlciA9IHVwZGF0ZVNwZWMuZmlsdGVyO1xuICAgICAgICBpZiAoYWRkLmxlbmd0aCA9PSAwICYmICFmaWx0ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHNvcnQpXG4gICAgICAgICAgICBhZGQgPSBhZGQuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBhZGQubGVuZ3RoID8gUmFuZ2VTZXQub2YoYWRkKSA6IHRoaXM7XG4gICAgICAgIGxldCBjdXIgPSBuZXcgTGF5ZXJDdXJzb3IodGhpcywgbnVsbCwgLTEpLmdvdG8oMCksIGkgPSAwLCBzcGlsbCA9IFtdO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgd2hpbGUgKGN1ci52YWx1ZSB8fCBpIDwgYWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgPCBhZGQubGVuZ3RoICYmIChjdXIuZnJvbSAtIGFkZFtpXS5mcm9tIHx8IGN1ci5zdGFydFNpZGUgLSBhZGRbaV0udmFsdWUuc3RhcnRTaWRlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gYWRkW2krK107XG4gICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyLnJhbmdlSW5kZXggPT0gMSAmJiBjdXIuY2h1bmtJbmRleCA8IHRoaXMuY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKGkgPT0gYWRkLmxlbmd0aCB8fCB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSA8IGFkZFtpXS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSB8fCBmaWx0ZXJUbyA8IHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdKSAmJlxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2h1bmsodGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0sIHRoaXMuY2h1bmtbY3VyLmNodW5rSW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGN1ci5uZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiBjdXIudG8gfHwgZmlsdGVyVG8gPCBjdXIuZnJvbSB8fCBmaWx0ZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2goUmFuZ2UuY3JlYXRlKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaElubmVyKHRoaXMubmV4dExheWVyLmlzRW1wdHkgJiYgIXNwaWxsLmxlbmd0aCA/IFJhbmdlU2V0LmVtcHR5XG4gICAgICAgICAgICA6IHRoaXMubmV4dExheWVyLnVwZGF0ZSh7IGFkZDogc3BpbGwsIGZpbHRlciwgZmlsdGVyRnJvbSwgZmlsdGVyVG8gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSBzZXQgdGhyb3VnaCBhIHNldCBvZiBjaGFuZ2VzLCByZXR1cm4gdGhlIG5ldyBzZXQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5lbXB0eSB8fCB0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNodW5rcyA9IFtdLCBjaHVua1BvcyA9IFtdLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGxldCB0b3VjaCA9IGNoYW5nZXMudG91Y2hlc1JhbmdlKHN0YXJ0LCBzdGFydCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodG91Y2ggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKGNoYW5nZXMubWFwUG9zKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3VjaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hcHBlZCwgcG9zIH0gPSBjaHVuay5tYXAoc3RhcnQsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbWFwcGVkLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dExheWVyLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIGNodW5rcy5sZW5ndGggPT0gMCA/IG5leHQgOiBuZXcgUmFuZ2VTZXQoY2h1bmtQb3MsIGNodW5rcywgbmV4dCB8fCBSYW5nZVNldC5lbXB0eSwgbWF4UG9pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyB0aGF0IHRvdWNoIHRoZSByZWdpb24gYGZyb21gIHRvIGB0b2AsXG4gICAgY2FsbGluZyBgZmAgZm9yIGVhY2guIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZXMgd2lsbFxuICAgIGJlIHJlcG9ydGVkIGluIGFueSBzcGVjaWZpYyBvcmRlci4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGBmYWxzZWAsIGl0ZXJhdGlvbiBzdG9wcy5cbiAgICAqL1xuICAgIGJldHdlZW4oZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBpZiAodG8gPj0gc3RhcnQgJiYgZnJvbSA8PSBzdGFydCArIGNodW5rLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNodW5rLmJldHdlZW4oc3RhcnQsIGZyb20gLSBzdGFydCwgdG8gLSBzdGFydCwgZikgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRMYXllci5iZXR3ZWVuKGZyb20sIHRvLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gdGhpcyBzZXQsIGluIG9yZGVyLCBpbmNsdWRpbmcgYWxsXG4gICAgcmFuZ2VzIHRoYXQgZW5kIGF0IG9yIGFmdGVyIGBmcm9tYC5cbiAgICAqL1xuICAgIGl0ZXIoZnJvbSA9IDApIHtcbiAgICAgICAgcmV0dXJuIEhlYXBDdXJzb3IuZnJvbShbdGhpc10pLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlzRW1wdHkoKSB7IHJldHVybiB0aGlzLm5leHRMYXllciA9PSB0aGlzOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gYSBjb2xsZWN0aW9uIG9mIHNldHMsIGluIG9yZGVyLFxuICAgIHN0YXJ0aW5nIGZyb20gYGZyb21gLlxuICAgICovXG4gICAgc3RhdGljIGl0ZXIoc2V0cywgZnJvbSA9IDApIHtcbiAgICAgICAgcmV0dXJuIEhlYXBDdXJzb3IuZnJvbShzZXRzKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdHdvIGdyb3VwcyBvZiBzZXRzLCBjYWxsaW5nIG1ldGhvZHMgb24gYGNvbXBhcmF0b3JgXG4gICAgdG8gbm90aWZ5IGl0IG9mIHBvc3NpYmxlIGRpZmZlcmVuY2VzLlxuICAgICovXG4gICAgc3RhdGljIGNvbXBhcmUob2xkU2V0cywgbmV3U2V0cywgXG4gICAgLyoqXG4gICAgVGhpcyBpbmRpY2F0ZXMgaG93IHRoZSB1bmRlcmx5aW5nIGRhdGEgY2hhbmdlZCBiZXR3ZWVuIHRoZXNlXG4gICAgcmFuZ2VzLCBhbmQgaXMgbmVlZGVkIHRvIHN5bmNocm9uaXplIHRoZSBpdGVyYXRpb24uXG4gICAgKi9cbiAgICB0ZXh0RGlmZiwgY29tcGFyYXRvciwgXG4gICAgLyoqXG4gICAgQ2FuIGJlIHVzZWQgdG8gaWdub3JlIGFsbCBub24tcG9pbnQgcmFuZ2VzLCBhbmQgcG9pbnRzIGJlbG93XG4gICAgdGhlIGdpdmVuIHNpemUuIFdoZW4gLTEsIGFsbCByYW5nZXMgYXJlIGNvbXBhcmVkLlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+IDAgfHwgIXNldC5pc0VtcHR5ICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiLCB0ZXh0RGlmZik7XG4gICAgICAgIGxldCBzaWRlQSA9IG5ldyBTcGFuQ3Vyc29yKGEsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICB0ZXh0RGlmZi5pdGVyR2FwcygoZnJvbUEsIGZyb21CLCBsZW5ndGgpID0+IGNvbXBhcmUoc2lkZUEsIGZyb21BLCBzaWRlQiwgZnJvbUIsIGxlbmd0aCwgY29tcGFyYXRvcikpO1xuICAgICAgICBpZiAodGV4dERpZmYuZW1wdHkgJiYgdGV4dERpZmYubGVuZ3RoID09IDApXG4gICAgICAgICAgICBjb21wYXJlKHNpZGVBLCAwLCBzaWRlQiwgMCwgMCwgY29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIGNvbnRlbnRzIG9mIHR3byBncm91cHMgb2YgcmFuZ2Ugc2V0cywgcmV0dXJuaW5nIHRydWVcbiAgICBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyBlcShvbGRTZXRzLCBuZXdTZXRzLCBmcm9tID0gMCwgdG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi8gLSAxO1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgbmV3U2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG9sZFNldHMuaW5kZXhPZihzZXQpIDwgMCk7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFhLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pLCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHNpZGVBLnRvICE9IHNpZGVCLnRvIHx8XG4gICAgICAgICAgICAgICAgIXNhbWVWYWx1ZXMoc2lkZUEuYWN0aXZlLCBzaWRlQi5hY3RpdmUpIHx8XG4gICAgICAgICAgICAgICAgc2lkZUEucG9pbnQgJiYgKCFzaWRlQi5wb2ludCB8fCAhY21wVmFsKHNpZGVBLnBvaW50LCBzaWRlQi5wb2ludCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc2lkZUEubmV4dCgpO1xuICAgICAgICAgICAgc2lkZUIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciBhIGdyb3VwIG9mIHJhbmdlIHNldHMgYXQgdGhlIHNhbWUgdGltZSwgbm90aWZ5aW5nXG4gICAgdGhlIGl0ZXJhdG9yIGFib3V0IHRoZSByYW5nZXMgY292ZXJpbmcgZXZlcnkgZ2l2ZW4gcGllY2Ugb2ZcbiAgICBjb250ZW50LiBSZXR1cm5zIHRoZSBvcGVuIGNvdW50IChzZWVcbiAgICBbYFNwYW5JdGVyYXRvci5zcGFuYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TcGFuSXRlcmF0b3Iuc3BhbikpIGF0IHRoZSBlbmRcbiAgICBvZiB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHNwYW5zKHNldHMsIGZyb20sIHRvLCBpdGVyYXRvciwgXG4gICAgLyoqXG4gICAgV2hlbiBnaXZlbiBhbmQgZ3JlYXRlciB0aGFuIC0xLCBvbmx5IHBvaW50cyBvZiBhdCBsZWFzdCB0aGlzXG4gICAgc2l6ZSBhcmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTcGFuQ3Vyc29yKHNldHMsIG51bGwsIG1pblBvaW50U2l6ZSkuZ290byhmcm9tKSwgcG9zID0gZnJvbTtcbiAgICAgICAgbGV0IG9wZW5SYW5nZXMgPSBjdXJzb3Iub3BlblN0YXJ0O1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgY3VyVG8gPSBNYXRoLm1pbihjdXJzb3IudG8sIHRvKTtcbiAgICAgICAgICAgIGlmIChjdXJzb3IucG9pbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gY3Vyc29yLmFjdGl2ZUZvclBvaW50KGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgbGV0IG9wZW5Db3VudCA9IGN1cnNvci5wb2ludEZyb20gPCBmcm9tID8gYWN0aXZlLmxlbmd0aCArIDFcbiAgICAgICAgICAgICAgICAgICAgOiBjdXJzb3IucG9pbnQuc3RhcnRTaWRlIDwgMCA/IGFjdGl2ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4oYWN0aXZlLmxlbmd0aCwgb3BlblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IucG9pbnQocG9zLCBjdXJUbywgY3Vyc29yLnBvaW50LCBhY3RpdmUsIG9wZW5Db3VudCwgY3Vyc29yLnBvaW50UmFuayk7XG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IE1hdGgubWluKGN1cnNvci5vcGVuRW5kKGN1clRvKSwgYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJUbyA+IHBvcykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNwYW4ocG9zLCBjdXJUbywgY3Vyc29yLmFjdGl2ZSwgb3BlblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IGN1cnNvci5vcGVuRW5kKGN1clRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlblJhbmdlcyArIChjdXJzb3IucG9pbnQgJiYgY3Vyc29yLnRvID4gdG8gPyAxIDogMCk7XG4gICAgICAgICAgICBwb3MgPSBjdXJzb3IudG87XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlIHNldCBmb3IgdGhlIGdpdmVuIHJhbmdlIG9yIGFycmF5IG9mIHJhbmdlcy4gQnlcbiAgICBkZWZhdWx0LCB0aGlzIGV4cGVjdHMgdGhlIHJhbmdlcyB0byBiZSBfc29ydGVkXyAoYnkgc3RhcnRcbiAgICBwb3NpdGlvbiBhbmQsIGlmIHR3byBzdGFydCBhdCB0aGUgc2FtZSBwb3NpdGlvbixcbiAgICBgdmFsdWUuc3RhcnRTaWRlYCkuIFlvdSBjYW4gcGFzcyBgdHJ1ZWAgYXMgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgY2F1c2UgdGhlIG1ldGhvZCB0byBzb3J0IHRoZW0uXG4gICAgKi9cbiAgICBzdGF0aWMgb2YocmFuZ2VzLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiByYW5nZXMgaW5zdGFuY2VvZiBSYW5nZSA/IFtyYW5nZXNdIDogc29ydCA/IGxhenlTb3J0KHJhbmdlcykgOiByYW5nZXMpXG4gICAgICAgICAgICBidWlsZC5hZGQocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBKb2luIGFuIGFycmF5IG9mIHJhbmdlIHNldHMgaW50byBhIHNpbmdsZSBzZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgam9pbihzZXRzKSB7XG4gICAgICAgIGlmICghc2V0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gUmFuZ2VTZXQuZW1wdHk7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXRzW3NldHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAobGV0IGkgPSBzZXRzLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBsYXllciA9IHNldHNbaV07IGxheWVyICE9IFJhbmdlU2V0LmVtcHR5OyBsYXllciA9IGxheWVyLm5leHRMYXllcilcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgUmFuZ2VTZXQobGF5ZXIuY2h1bmtQb3MsIGxheWVyLmNodW5rLCByZXN1bHQsIE1hdGgubWF4KGxheWVyLm1heFBvaW50LCByZXN1bHQubWF4UG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiByYW5nZXMuXG4qL1xuUmFuZ2VTZXQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFJhbmdlU2V0KFtdLCBbXSwgbnVsbCwgLTEpO1xuZnVuY3Rpb24gbGF6eVNvcnQocmFuZ2VzKSB7XG4gICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBmb3IgKGxldCBwcmV2ID0gcmFuZ2VzWzBdLCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChjbXBSYW5nZShwcmV2LCBjdXIpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cblJhbmdlU2V0LmVtcHR5Lm5leHRMYXllciA9IFJhbmdlU2V0LmVtcHR5O1xuLyoqXG5BIHJhbmdlIHNldCBidWlsZGVyIGlzIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBoZWxwcyBidWlsZCB1cCBhXG5bcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBkaXJlY3RseSwgd2l0aG91dCBmaXJzdCBhbGxvY2F0aW5nXG5hbiBhcnJheSBvZiBbYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgb2JqZWN0cy5cbiovXG5jbGFzcyBSYW5nZVNldEJ1aWxkZXIge1xuICAgIGZpbmlzaENodW5rKG5ld0FycmF5cykge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBDaHVuayh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMudmFsdWUsIHRoaXMubWF4UG9pbnQpKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgdGhpcy5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgaWYgKG5ld0FycmF5cykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGJ1aWxkZXIuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIHJhbmdlLiBSYW5nZXMgc2hvdWxkIGJlIGFkZGVkIGluIHNvcnRlZCAoYnkgYGZyb21gIGFuZFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKSBvcmRlci5cbiAgICAqL1xuICAgIGFkZChmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkpXG4gICAgICAgICAgICAodGhpcy5uZXh0TGF5ZXIgfHwgKHRoaXMubmV4dExheWVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcikpLmFkZChmcm9tLCB0bywgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZGlmZiA9IGZyb20gLSB0aGlzLmxhc3RUbyB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZTtcbiAgICAgICAgaWYgKGRpZmYgPD0gMCAmJiAoZnJvbSAtIHRoaXMubGFzdEZyb20gfHwgdmFsdWUuc3RhcnRTaWRlIC0gdGhpcy5sYXN0LnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2VzIG11c3QgYmUgYWRkZWQgc29ydGVkIGJ5IGBmcm9tYCBwb3NpdGlvbiBhbmQgYHN0YXJ0U2lkZWBcIik7XG4gICAgICAgIGlmIChkaWZmIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGggPT0gMjUwIC8qIEMuQ2h1bmtTaXplICovKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmZyb20ucHVzaChmcm9tIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy50by5wdXNoKHRvIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5sYXN0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUucG9pbnQpXG4gICAgICAgICAgICB0aGlzLm1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5tYXhQb2ludCwgdG8gLSBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkQ2h1bmsoZnJvbSwgY2h1bmspIHtcbiAgICAgICAgaWYgKChmcm9tIC0gdGhpcy5sYXN0VG8gfHwgY2h1bmsudmFsdWVbMF0uc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGUpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKGZyb20pO1xuICAgICAgICBsZXQgbGFzdCA9IGNodW5rLnZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMubGFzdCA9IGNodW5rLnZhbHVlW2xhc3RdO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gY2h1bmsuZnJvbVtsYXN0XSArIGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gY2h1bmsudG9bbGFzdF0gKyBmcm9tO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluaXNoIHRoZSByYW5nZSBzZXQuIFJldHVybnMgdGhlIG5ldyBzZXQuIFRoZSBidWlsZGVyIGNhbid0IGJlXG4gICAgdXNlZCBhbnltb3JlIGFmdGVyIHRoaXMgaGFzIGJlZW4gY2FsbGVkLlxuICAgICovXG4gICAgZmluaXNoKCkgeyByZXR1cm4gdGhpcy5maW5pc2hJbm5lcihSYW5nZVNldC5lbXB0eSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmlzaElubmVyKG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBSYW5nZVNldC5jcmVhdGUodGhpcy5jaHVua1BvcywgdGhpcy5jaHVua3MsIHRoaXMubmV4dExheWVyID8gdGhpcy5uZXh0TGF5ZXIuZmluaXNoSW5uZXIobmV4dCkgOiBuZXh0LCB0aGlzLnNldE1heFBvaW50KTtcbiAgICAgICAgdGhpcy5mcm9tID0gbnVsbDsgLy8gTWFrZSBzdXJlIGZ1cnRoZXIgYGFkZGAgY2FsbHMgcHJvZHVjZSBlcnJvcnNcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKSB7XG4gICAgbGV0IGluQSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0LmNodW5rW2ldLm1heFBvaW50IDw9IDApXG4gICAgICAgICAgICAgICAgaW5BLnNldChzZXQuY2h1bmtbaV0sIHNldC5jaHVua1Bvc1tpXSk7XG4gICAgbGV0IHNoYXJlZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYilcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBrbm93biA9IGluQS5nZXQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgICAgIGlmIChrbm93biAhPSBudWxsICYmICh0ZXh0RGlmZiA/IHRleHREaWZmLm1hcFBvcyhrbm93bikgOiBrbm93bikgPT0gc2V0LmNodW5rUG9zW2ldICYmXG4gICAgICAgICAgICAgICAgISh0ZXh0RGlmZiA9PT0gbnVsbCB8fCB0ZXh0RGlmZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dERpZmYudG91Y2hlc1JhbmdlKGtub3duLCBrbm93biArIHNldC5jaHVua1tpXS5sZW5ndGgpKSlcbiAgICAgICAgICAgICAgICBzaGFyZWQuYWRkKHNldC5jaHVua1tpXSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gc2hhcmVkO1xufVxuY2xhc3MgTGF5ZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxheWVyLCBza2lwLCBtaW5Qb2ludCwgcmFuayA9IDApIHtcbiAgICAgICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgfVxuICAgIGdldCBzdGFydFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwOyB9XG4gICAgZ2V0IGVuZFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5lbmRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgdGhpcy5jaHVua0luZGV4ID0gdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5nb3RvSW5uZXIocG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnb3RvSW5uZXIocG9zLCBzaWRlLCBmb3J3YXJkKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICBpZiAoISh0aGlzLnNraXAgJiYgdGhpcy5za2lwLmhhcyhuZXh0KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXIuY2h1bmtFbmQodGhpcy5jaHVua0luZGV4KSA8IHBvcyB8fFxuICAgICAgICAgICAgICAgIG5leHQubWF4UG9pbnQgPCB0aGlzLm1pblBvaW50KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgZm9yd2FyZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlSW5kZXggPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0uZmluZEluZGV4KHBvcyAtIHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgc2lkZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIWZvcndhcmQgfHwgdGhpcy5yYW5nZUluZGV4IDwgcmFuZ2VJbmRleClcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5kZXgocmFuZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4ID09IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2h1bmtQb3MgPSB0aGlzLmxheWVyLmNodW5rUG9zW3RoaXMuY2h1bmtJbmRleF0sIGNodW5rID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY2h1bmtQb3MgKyBjaHVuay5mcm9tW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gY2h1bmtQb3MgKyBjaHVuay50b1t0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjaHVuay52YWx1ZVt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleCh0aGlzLnJhbmdlSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5Qb2ludCA8IDAgfHwgdGhpcy52YWx1ZS5wb2ludCAmJiB0aGlzLnRvIC0gdGhpcy5mcm9tID49IHRoaXMubWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldFJhbmdlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCAmJiB0aGlzLnNraXAuaGFzKHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRDaHVuaygpIHtcbiAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20gLSBvdGhlci5mcm9tIHx8IHRoaXMuc3RhcnRTaWRlIC0gb3RoZXIuc3RhcnRTaWRlIHx8IHRoaXMucmFuayAtIG90aGVyLnJhbmsgfHxcbiAgICAgICAgICAgIHRoaXMudG8gLSBvdGhlci50byB8fCB0aGlzLmVuZFNpZGUgLSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbn1cbmNsYXNzIEhlYXBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYXApIHtcbiAgICAgICAgdGhpcy5oZWFwID0gaGVhcDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oc2V0cywgc2tpcCA9IG51bGwsIG1pblBvaW50ID0gLTEpIHtcbiAgICAgICAgbGV0IGhlYXAgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjdXIgPSBzZXRzW2ldOyAhY3VyLmlzRW1wdHk7IGN1ciA9IGN1ci5uZXh0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLm1heFBvaW50ID49IG1pblBvaW50KVxuICAgICAgICAgICAgICAgICAgICBoZWFwLnB1c2gobmV3IExheWVyQ3Vyc29yKGN1ciwgc2tpcCwgbWluUG9pbnQsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhcC5sZW5ndGggPT0gMSA/IGhlYXBbMF0gOiBuZXcgSGVhcEN1cnNvcihoZWFwKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxuICAgICAgICAgICAgY3VyLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLnZhbHVlLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuaGVhcFswXTtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRvcC5mcm9tO1xuICAgICAgICAgICAgdGhpcy50byA9IHRvcC50bztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0b3AudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJhbmsgPSB0b3AucmFuaztcbiAgICAgICAgICAgIGlmICh0b3AudmFsdWUpXG4gICAgICAgICAgICAgICAgdG9wLm5leHQoKTtcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGhlYXBCdWJibGUoaGVhcCwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBoZWFwW2luZGV4XTs7KSB7XG4gICAgICAgIGxldCBjaGlsZEluZGV4ID0gKGluZGV4IDw8IDEpICsgMTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggPj0gaGVhcC5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGNoaWxkID0gaGVhcFtjaGlsZEluZGV4XTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggKyAxIDwgaGVhcC5sZW5ndGggJiYgY2hpbGQuY29tcGFyZShoZWFwW2NoaWxkSW5kZXggKyAxXSkgPj0gMCkge1xuICAgICAgICAgICAgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLmNvbXBhcmUoY2hpbGQpIDwgMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBoZWFwW2NoaWxkSW5kZXhdID0gY3VyO1xuICAgICAgICBoZWFwW2luZGV4XSA9IGNoaWxkO1xuICAgICAgICBpbmRleCA9IGNoaWxkSW5kZXg7XG4gICAgfVxufVxuY2xhc3MgU3BhbkN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc2V0cywgc2tpcCwgbWluUG9pbnQpIHtcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVRvID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlUmFuayA9IFtdO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IC0xO1xuICAgICAgICAvLyBBIGN1cnJlbnRseSBhY3RpdmUgcG9pbnQgcmFuZ2UsIGlmIGFueVxuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2ludEZyb20gPSAwO1xuICAgICAgICB0aGlzLnBvaW50UmFuayA9IDA7XG4gICAgICAgIHRoaXMudG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gMDtcbiAgICAgICAgLy8gVGhlIGFtb3VudCBvZiBvcGVuIGFjdGl2ZSByYW5nZXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgLy8gTm90IGluY2x1ZGluZyBwb2ludHMuXG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gSGVhcEN1cnNvci5mcm9tKHNldHMsIHNraXAsIG1pblBvaW50KTtcbiAgICB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmN1cnNvci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIHRoaXMuYWN0aXZlLmxlbmd0aCA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoID0gdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIHRoaXMudG8gPSBwb3M7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IHNpZGU7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubWluQWN0aXZlID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bdGhpcy5taW5BY3RpdmVdIC0gcG9zIHx8IHRoaXMuYWN0aXZlW3RoaXMubWluQWN0aXZlXS5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUodGhpcy5taW5BY3RpdmUpO1xuICAgICAgICB0aGlzLmN1cnNvci5mb3J3YXJkKHBvcywgc2lkZSk7XG4gICAgfVxuICAgIHJlbW92ZUFjdGl2ZShpbmRleCkge1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmUsIGluZGV4KTtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlVG8sIGluZGV4KTtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlUmFuaywgaW5kZXgpO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IGZpbmRNaW5JbmRleCh0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gICAgfVxuICAgIGFkZEFjdGl2ZSh0cmFja09wZW4pIHtcbiAgICAgICAgbGV0IGkgPSAwLCB7IHZhbHVlLCB0bywgcmFuayB9ID0gdGhpcy5jdXJzb3I7XG4gICAgICAgIC8vIE9yZ2FuaXplIGFjdGl2ZSBtYXJrcyBieSByYW5rIGZpcnN0LCB0aGVuIGJ5IHNpemVcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoICYmIChyYW5rIC0gdGhpcy5hY3RpdmVSYW5rW2ldIHx8IHRvIC0gdGhpcy5hY3RpdmVUb1tpXSkgPiAwKVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmUsIGksIHZhbHVlKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlVG8sIGksIHRvKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlUmFuaywgaSwgcmFuayk7XG4gICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICBpbnNlcnQodHJhY2tPcGVuLCBpLCB0aGlzLmN1cnNvci5mcm9tKTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICAgIH1cbiAgICAvLyBBZnRlciBjYWxsaW5nIHRoaXMsIGlmIGB0aGlzLnBvaW50YCAhPSBudWxsLCB0aGUgbmV4dCByYW5nZSBpcyBhXG4gICAgLy8gcG9pbnQuIE90aGVyd2lzZSwgaXQncyBhIHJlZ3VsYXIgcmFuZ2UsIGNvdmVyZWQgYnkgYHRoaXMuYWN0aXZlYC5cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG8sIHdhc1BvaW50ID0gdGhpcy5wb2ludDtcbiAgICAgICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgICAgIGxldCB0cmFja09wZW4gPSB0aGlzLm9wZW5TdGFydCA8IDAgPyBbXSA6IG51bGw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5taW5BY3RpdmU7XG4gICAgICAgICAgICBpZiAoYSA+IC0xICYmICh0aGlzLmFjdGl2ZVRvW2FdIC0gdGhpcy5jdXJzb3IuZnJvbSB8fCB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlIC0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1thXSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuYWN0aXZlVG9bYV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZShhKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgICAgICAgICByZW1vdmUodHJhY2tPcGVuLCBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmN1cnNvci52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmVuZFNpZGUgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJzb3IuZnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmN1cnNvci5zdGFydFNpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFZhbCA9IHRoaXMuY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFZhbC5wb2ludCkgeyAvLyBPcGVuaW5nIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBY3RpdmUodHJhY2tPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNQb2ludCAmJiB0aGlzLmN1cnNvci50byA9PSB0aGlzLnRvICYmIHRoaXMuY3Vyc29yLmZyb20gPCB0aGlzLmN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW55IG5vbi1lbXB0eSBwb2ludHMgdGhhdCBlbmQgcHJlY2lzZWx5IGF0IHRoZSBlbmQgb2YgdGhlIHByZXYgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gTmV3IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQgPSBuZXh0VmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50RnJvbSA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRSYW5rID0gdGhpcy5jdXJzb3IucmFuaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLnRvO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSBuZXh0VmFsLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkKHRoaXMudG8sIHRoaXMuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2tPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdHJhY2tPcGVuLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0cmFja09wZW5baV0gPCBmcm9tOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhY3RpdmVGb3JQb2ludCh0bykge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVJhbmtbaV0gPCB0aGlzLnBvaW50UmFuaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRvW2ldID4gdG8gfHwgdGhpcy5hY3RpdmVUb1tpXSA9PSB0byAmJiB0aGlzLmFjdGl2ZVtpXS5lbmRTaWRlID49IHRoaXMucG9pbnQuZW5kU2lkZSlcbiAgICAgICAgICAgICAgICBhY3RpdmUucHVzaCh0aGlzLmFjdGl2ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIG9wZW5FbmQodG8pIHtcbiAgICAgICAgbGV0IG9wZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hY3RpdmVUby5sZW5ndGggLSAxOyBpID49IDAgJiYgdGhpcy5hY3RpdmVUb1tpXSA+IHRvOyBpLS0pXG4gICAgICAgICAgICBvcGVuKys7XG4gICAgICAgIHJldHVybiBvcGVuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgc3RhcnRBLCBiLCBzdGFydEIsIGxlbmd0aCwgY29tcGFyYXRvcikge1xuICAgIGEuZ290byhzdGFydEEpO1xuICAgIGIuZ290byhzdGFydEIpO1xuICAgIGxldCBlbmRCID0gc3RhcnRCICsgbGVuZ3RoO1xuICAgIGxldCBwb3MgPSBzdGFydEIsIGRQb3MgPSBzdGFydEIgLSBzdGFydEE7XG4gICAgbGV0IGJvdW5kcyA9ICEhY29tcGFyYXRvci5ib3VuZENoYW5nZTtcbiAgICBmb3IgKGxldCBib3VuZENoYW5nZSA9IGZhbHNlOzspIHtcbiAgICAgICAgbGV0IGRFbmQgPSAoYS50byArIGRQb3MpIC0gYi50bywgZGlmZiA9IGRFbmQgfHwgYS5lbmRTaWRlIC0gYi5lbmRTaWRlO1xuICAgICAgICBsZXQgZW5kID0gZGlmZiA8IDAgPyBhLnRvICsgZFBvcyA6IGIudG8sIGNsaXBFbmQgPSBNYXRoLm1pbihlbmQsIGVuZEIpO1xuICAgICAgICBsZXQgcG9pbnQgPSBhLnBvaW50IHx8IGIucG9pbnQ7XG4gICAgICAgIGlmIChwb2ludCkge1xuICAgICAgICAgICAgaWYgKCEoYS5wb2ludCAmJiBiLnBvaW50ICYmIGNtcFZhbChhLnBvaW50LCBiLnBvaW50KSAmJlxuICAgICAgICAgICAgICAgIHNhbWVWYWx1ZXMoYS5hY3RpdmVGb3JQb2ludChhLnRvKSwgYi5hY3RpdmVGb3JQb2ludChiLnRvKSkpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVBvaW50KHBvcywgY2xpcEVuZCwgYS5wb2ludCwgYi5wb2ludCk7XG4gICAgICAgICAgICBib3VuZENoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGJvdW5kQ2hhbmdlKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuYm91bmRDaGFuZ2UocG9zKTtcbiAgICAgICAgICAgIGlmIChjbGlwRW5kID4gcG9zICYmICFzYW1lVmFsdWVzKGEuYWN0aXZlLCBiLmFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUmFuZ2UocG9zLCBjbGlwRW5kLCBhLmFjdGl2ZSwgYi5hY3RpdmUpO1xuICAgICAgICAgICAgaWYgKGJvdW5kcyAmJiBjbGlwRW5kIDwgZW5kQiAmJiAoZEVuZCB8fCBhLm9wZW5FbmQoZW5kKSAhPSBiLm9wZW5FbmQoZW5kKSkpXG4gICAgICAgICAgICAgICAgYm91bmRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiBlbmRCKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgaWYgKGRpZmYgPD0gMClcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZVZhbHVlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldICYmICFjbXBWYWwoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4LCBlID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA8IGU7IGkrKylcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XG4gICAgYXJyYXkucG9wKCk7XG59XG5mdW5jdGlvbiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IGluZGV4OyBpLS0pXG4gICAgICAgIGFycmF5W2kgKyAxXSA9IGFycmF5W2ldO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gZmluZE1pbkluZGV4KHZhbHVlLCBhcnJheSkge1xuICAgIGxldCBmb3VuZCA9IC0xLCBmb3VuZFBvcyA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKChhcnJheVtpXSAtIGZvdW5kUG9zIHx8IHZhbHVlW2ldLmVuZFNpZGUgLSB2YWx1ZVtmb3VuZF0uZW5kU2lkZSkgPCAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICBmb3VuZFBvcyA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG4vKipcbkNvdW50IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgdGhlIGdpdmVuIG9mZnNldCBpbnRvIHRoZSBzdHJpbmcsXG50YWtpbmcgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgYW5kIHRhYiBzaXplIGludG8gYWNjb3VudC5cbiovXG5mdW5jdGlvbiBjb3VudENvbHVtbihzdHJpbmcsIHRhYlNpemUsIHRvID0gc3RyaW5nLmxlbmd0aCkge1xuICAgIGxldCBuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvICYmIGkgPCBzdHJpbmcubGVuZ3RoOykge1xuICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSkge1xuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG4vKipcbkZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBjb2x1bW4gcG9zaXRpb24gaW4gYVxuc3RyaW5nLCB0YWtpbmcgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgYW5kIHRhYiBzaXplIGludG8gYWNjb3VudC4gQnlcbmRlZmF1bHQsIHRoZSBzdHJpbmcgbGVuZ3RoIGlzIHJldHVybmVkIHdoZW4gaXQgaXMgdG9vIHNob3J0IHRvXG5yZWFjaCB0aGUgY29sdW1uLiBQYXNzIGBzdHJpY3RgIHRydWUgdG8gbWFrZSBpdCByZXR1cm4gLTEgaW4gdGhhdFxuc2l0dWF0aW9uLlxuKi9cbmZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBjb2wsIHRhYlNpemUsIHN0cmljdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gMDs7KSB7XG4gICAgICAgIGlmIChuID49IGNvbClcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICBpZiAoaSA9PSBzdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG4gKz0gc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSA/IHRhYlNpemUgLSAobiAlIHRhYlNpemUpIDogMTtcbiAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmljdCA9PT0gdHJ1ZSA/IC0xIDogc3RyaW5nLmxlbmd0aDtcbn1cblxuZXhwb3J0IHsgQW5ub3RhdGlvbiwgQW5ub3RhdGlvblR5cGUsIENoYW5nZURlc2MsIENoYW5nZVNldCwgQ2hhckNhdGVnb3J5LCBDb21wYXJ0bWVudCwgRWRpdG9yU2VsZWN0aW9uLCBFZGl0b3JTdGF0ZSwgRmFjZXQsIExpbmUsIE1hcE1vZGUsIFByZWMsIFJhbmdlLCBSYW5nZVNldCwgUmFuZ2VTZXRCdWlsZGVyLCBSYW5nZVZhbHVlLCBTZWxlY3Rpb25SYW5nZSwgU3RhdGVFZmZlY3QsIFN0YXRlRWZmZWN0VHlwZSwgU3RhdGVGaWVsZCwgVGV4dCwgVHJhbnNhY3Rpb24sIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBjb21iaW5lQ29uZmlnLCBjb3VudENvbHVtbiwgZmluZENsdXN0ZXJCcmVhaywgZmluZENvbHVtbiwgZnJvbUNvZGVQb2ludCB9O1xuIiwgImNvbnN0IEMgPSBcIlxcdTAzN2NcIlxuY29uc3QgQ09VTlQgPSB0eXBlb2YgU3ltYm9sID09IFwidW5kZWZpbmVkXCIgPyBcIl9fXCIgKyBDIDogU3ltYm9sLmZvcihDKVxuY29uc3QgU0VUID0gdHlwZW9mIFN5bWJvbCA9PSBcInVuZGVmaW5lZFwiID8gXCJfX3N0eWxlU2V0XCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTgpIDogU3ltYm9sKFwic3R5bGVTZXRcIilcbmNvbnN0IHRvcCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge31cblxuLy8gOjogLSBTdHlsZSBtb2R1bGVzIGVuY2Fwc3VsYXRlIGEgc2V0IG9mIENTUyBydWxlcyBkZWZpbmVkIGZyb21cbi8vIEphdmFTY3JpcHQuIFRoZWlyIGRlZmluaXRpb25zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBhIGdpdmVuIERPTVxuLy8gcm9vdCBhZnRlciBpdCBoYXMgYmVlbiBfbW91bnRlZF8gdGhlcmUgd2l0aCBgU3R5bGVNb2R1bGUubW91bnRgLlxuLy9cbi8vIFN0eWxlIG1vZHVsZXMgc2hvdWxkIGJlIGNyZWF0ZWQgb25jZSBhbmQgc3RvcmVkIHNvbWV3aGVyZSwgYXNcbi8vIG9wcG9zZWQgdG8gcmUtY3JlYXRpbmcgdGhlbSBldmVyeSB0aW1lIHlvdSBuZWVkIHRoZW0uIFRoZSBhbW91bnQgb2Zcbi8vIENTUyBydWxlcyBnZW5lcmF0ZWQgZm9yIGEgZ2l2ZW4gRE9NIHJvb3QgaXMgYm91bmRlZCBieSB0aGUgYW1vdW50XG4vLyBvZiBzdHlsZSBtb2R1bGVzIHRoYXQgd2VyZSB1c2VkLiBTbyB0byBhdm9pZCBsZWFraW5nIHJ1bGVzLCBkb24ndFxuLy8gY3JlYXRlIHRoZXNlIGR5bmFtaWNhbGx5LCBidXQgdHJlYXQgdGhlbSBhcyBvbmUtdGltZSBhbGxvY2F0aW9ucy5cbmV4cG9ydCBjbGFzcyBTdHlsZU1vZHVsZSB7XG4gIC8vIDo6IChPYmplY3Q8U3R5bGU+LCA/e2ZpbmlzaDogPyhzdHJpbmcpIFx1MjE5MiBzdHJpbmd9KVxuICAvLyBDcmVhdGUgYSBzdHlsZSBtb2R1bGUgZnJvbSB0aGUgZ2l2ZW4gc3BlYy5cbiAgLy9cbiAgLy8gV2hlbiBgZmluaXNoYCBpcyBnaXZlbiwgaXQgaXMgY2FsbGVkIG9uIHJlZ3VsYXIgKG5vbi1gQGApXG4gIC8vIHNlbGVjdG9ycyAoYWZ0ZXIgYCZgIGV4cGFuc2lvbikgdG8gY29tcHV0ZSB0aGUgZmluYWwgc2VsZWN0b3IuXG4gIGNvbnN0cnVjdG9yKHNwZWMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnJ1bGVzID0gW11cbiAgICBsZXQge2ZpbmlzaH0gPSBvcHRpb25zIHx8IHt9XG5cbiAgICBmdW5jdGlvbiBzcGxpdFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gL15ALy50ZXN0KHNlbGVjdG9yKSA/IFtzZWxlY3Rvcl0gOiBzZWxlY3Rvci5zcGxpdCgvLFxccyovKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlcihzZWxlY3RvcnMsIHNwZWMsIHRhcmdldCwgaXNLZXlmcmFtZXMpIHtcbiAgICAgIGxldCBsb2NhbCA9IFtdLCBpc0F0ID0gL15AKFxcdyspXFxiLy5leGVjKHNlbGVjdG9yc1swXSksIGtleWZyYW1lcyA9IGlzQXQgJiYgaXNBdFsxXSA9PSBcImtleWZyYW1lc1wiXG4gICAgICBpZiAoaXNBdCAmJiBzcGVjID09IG51bGwpIHJldHVybiB0YXJnZXQucHVzaChzZWxlY3RvcnNbMF0gKyBcIjtcIilcbiAgICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdmFsdWUgPSBzcGVjW3Byb3BdXG4gICAgICAgIGlmICgvJi8udGVzdChwcm9wKSkge1xuICAgICAgICAgIHJlbmRlcihwcm9wLnNwbGl0KC8sXFxzKi8pLm1hcChwYXJ0ID0+IHNlbGVjdG9ycy5tYXAoc2VsID0+IHBhcnQucmVwbGFjZSgvJi8sIHNlbCkpKS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKSxcbiAgICAgICAgICAgICAgICAgdmFsdWUsIHRhcmdldClcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmICghaXNBdCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSAoXCIgKyBwcm9wICsgXCIpIHNob3VsZCBiZSBhIHByaW1pdGl2ZSB2YWx1ZS5cIilcbiAgICAgICAgICByZW5kZXIoc3BsaXRTZWxlY3Rvcihwcm9wKSwgdmFsdWUsIGxvY2FsLCBrZXlmcmFtZXMpXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGxvY2FsLnB1c2gocHJvcC5yZXBsYWNlKC9fLiovLCBcIlwiKS5yZXBsYWNlKC9bQS1aXS9nLCBsID0+IFwiLVwiICsgbC50b0xvd2VyQ2FzZSgpKSArIFwiOiBcIiArIHZhbHVlICsgXCI7XCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb2NhbC5sZW5ndGggfHwga2V5ZnJhbWVzKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKChmaW5pc2ggJiYgIWlzQXQgJiYgIWlzS2V5ZnJhbWVzID8gc2VsZWN0b3JzLm1hcChmaW5pc2gpIDogc2VsZWN0b3JzKS5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIiB7XCIgKyBsb2NhbC5qb2luKFwiIFwiKSArIFwifVwiKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykgcmVuZGVyKHNwbGl0U2VsZWN0b3IocHJvcCksIHNwZWNbcHJvcF0sIHRoaXMucnVsZXMpXG4gIH1cblxuICAvLyA6OiAoKSBcdTIxOTIgc3RyaW5nXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbW9kdWxlJ3MgQ1NTIHJ1bGVzLlxuICBnZXRSdWxlcygpIHsgcmV0dXJuIHRoaXMucnVsZXMuam9pbihcIlxcblwiKSB9XG5cbiAgLy8gOjogKCkgXHUyMTkyIHN0cmluZ1xuICAvLyBHZW5lcmF0ZSBhIG5ldyB1bmlxdWUgQ1NTIGNsYXNzIG5hbWUuXG4gIHN0YXRpYyBuZXdOYW1lKCkge1xuICAgIGxldCBpZCA9IHRvcFtDT1VOVF0gfHwgMVxuICAgIHRvcFtDT1VOVF0gPSBpZCArIDFcbiAgICByZXR1cm4gQyArIGlkLnRvU3RyaW5nKDM2KVxuICB9XG5cbiAgLy8gOjogKHVuaW9uPERvY3VtZW50LCBTaGFkb3dSb290PiwgdW5pb248W1N0eWxlTW9kdWxlXSwgU3R5bGVNb2R1bGU+LCA/e25vbmNlOiA/c3RyaW5nfSlcbiAgLy9cbiAgLy8gTW91bnQgdGhlIGdpdmVuIHNldCBvZiBtb2R1bGVzIGluIHRoZSBnaXZlbiBET00gcm9vdCwgd2hpY2ggZW5zdXJlc1xuICAvLyB0aGF0IHRoZSBDU1MgcnVsZXMgZGVmaW5lZCBieSB0aGUgbW9kdWxlIGFyZSBhdmFpbGFibGUgaW4gdGhhdFxuICAvLyBjb250ZXh0LlxuICAvL1xuICAvLyBSdWxlcyBhcmUgb25seSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgb25jZSBwZXIgcm9vdC5cbiAgLy9cbiAgLy8gUnVsZSBvcmRlciB3aWxsIGZvbGxvdyB0aGUgb3JkZXIgb2YgdGhlIG1vZHVsZXMsIHNvIHRoYXQgcnVsZXMgZnJvbVxuICAvLyBtb2R1bGVzIGxhdGVyIGluIHRoZSBhcnJheSB0YWtlIHByZWNlZGVuY2Ugb2YgdGhvc2UgZnJvbSBlYXJsaWVyXG4gIC8vIG1vZHVsZXMuIElmIHlvdSBjYWxsIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIHJvb3RcbiAgLy8gaW4gYSB3YXkgdGhhdCBjaGFuZ2VzIHRoZSBvcmRlciBvZiBhbHJlYWR5IG1vdW50ZWQgbW9kdWxlcywgdGhlIG9sZFxuICAvLyBvcmRlciB3aWxsIGJlIGNoYW5nZWQuXG4gIC8vXG4gIC8vIElmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgbm9uY2UgaXMgcHJvdmlkZWQsIGl0IGlzIGFkZGVkIHRvXG4gIC8vIHRoZSBgPHN0eWxlPmAgdGFnIGdlbmVyYXRlZCBieSB0aGUgbGlicmFyeS5cbiAgc3RhdGljIG1vdW50KHJvb3QsIG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgc2V0ID0gcm9vdFtTRVRdLCBub25jZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZVxuICAgIGlmICghc2V0KSBzZXQgPSBuZXcgU3R5bGVTZXQocm9vdCwgbm9uY2UpXG4gICAgZWxzZSBpZiAobm9uY2UpIHNldC5zZXROb25jZShub25jZSlcbiAgICBzZXQubW91bnQoQXJyYXkuaXNBcnJheShtb2R1bGVzKSA/IG1vZHVsZXMgOiBbbW9kdWxlc10sIHJvb3QpXG4gIH1cbn1cblxubGV0IGFkb3B0ZWRTZXQgPSBuZXcgTWFwIC8vPERvY3VtZW50LCBTdHlsZVNldD5cblxuY2xhc3MgU3R5bGVTZXQge1xuICBjb25zdHJ1Y3Rvcihyb290LCBub25jZSkge1xuICAgIGxldCBkb2MgPSByb290Lm93bmVyRG9jdW1lbnQgfHwgcm9vdCwgd2luID0gZG9jLmRlZmF1bHRWaWV3XG4gICAgaWYgKCFyb290LmhlYWQgJiYgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgJiYgd2luLkNTU1N0eWxlU2hlZXQpIHtcbiAgICAgIGxldCBhZG9wdGVkID0gYWRvcHRlZFNldC5nZXQoZG9jKVxuICAgICAgaWYgKGFkb3B0ZWQpIHJldHVybiByb290W1NFVF0gPSBhZG9wdGVkXG4gICAgICB0aGlzLnNoZWV0ID0gbmV3IHdpbi5DU1NTdHlsZVNoZWV0XG4gICAgICBhZG9wdGVkU2V0LnNldChkb2MsIHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGVUYWcgPSBkb2MuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpXG4gICAgICBpZiAobm9uY2UpIHRoaXMuc3R5bGVUYWcuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpXG4gICAgfVxuICAgIHRoaXMubW9kdWxlcyA9IFtdXG4gICAgcm9vdFtTRVRdID0gdGhpc1xuICB9XG5cbiAgbW91bnQobW9kdWxlcywgcm9vdCkge1xuICAgIGxldCBzaGVldCA9IHRoaXMuc2hlZXRcbiAgICBsZXQgcG9zID0gMCAvKiBDdXJyZW50IHJ1bGUgb2Zmc2V0ICovLCBqID0gMCAvKiBJbmRleCBpbnRvIHRoaXMubW9kdWxlcyAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG1vZCA9IG1vZHVsZXNbaV0sIGluZGV4ID0gdGhpcy5tb2R1bGVzLmluZGV4T2YobW9kKVxuICAgICAgaWYgKGluZGV4IDwgaiAmJiBpbmRleCA+IC0xKSB7IC8vIE9yZGVyaW5nIGNvbmZsaWN0XG4gICAgICAgIHRoaXMubW9kdWxlcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIGotLVxuICAgICAgICBpbmRleCA9IC0xXG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzLnNwbGljZShqKyssIDAsIG1vZClcbiAgICAgICAgaWYgKHNoZWV0KSBmb3IgKGxldCBrID0gMDsgayA8IG1vZC5ydWxlcy5sZW5ndGg7IGsrKylcbiAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKG1vZC5ydWxlc1trXSwgcG9zKyspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoaiA8IGluZGV4KSBwb3MgKz0gdGhpcy5tb2R1bGVzW2orK10ucnVsZXMubGVuZ3RoXG4gICAgICAgIHBvcyArPSBtb2QucnVsZXMubGVuZ3RoXG4gICAgICAgIGorK1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaGVldCkge1xuICAgICAgaWYgKHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLmluZGV4T2YodGhpcy5zaGVldCkgPCAwKVxuICAgICAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFt0aGlzLnNoZWV0LCAuLi5yb290LmFkb3B0ZWRTdHlsZVNoZWV0c11cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRleHQgPSBcIlwiXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9kdWxlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgdGV4dCArPSB0aGlzLm1vZHVsZXNbaV0uZ2V0UnVsZXMoKSArIFwiXFxuXCJcbiAgICAgIHRoaXMuc3R5bGVUYWcudGV4dENvbnRlbnQgPSB0ZXh0XG4gICAgICBsZXQgdGFyZ2V0ID0gcm9vdC5oZWFkIHx8IHJvb3RcbiAgICAgIGlmICh0aGlzLnN0eWxlVGFnLnBhcmVudE5vZGUgIT0gdGFyZ2V0KVxuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuc3R5bGVUYWcsIHRhcmdldC5maXJzdENoaWxkKVxuICAgIH1cbiAgfVxuXG4gIHNldE5vbmNlKG5vbmNlKSB7XG4gICAgaWYgKHRoaXMuc3R5bGVUYWcgJiYgdGhpcy5zdHlsZVRhZy5nZXRBdHRyaWJ1dGUoXCJub25jZVwiKSAhPSBub25jZSlcbiAgICAgIHRoaXMuc3R5bGVUYWcuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpXG4gIH1cbn1cblxuLy8gU3R5bGU6Ok9iamVjdDx1bmlvbjxTdHlsZSxzdHJpbmc+PlxuLy9cbi8vIEEgc3R5bGUgaXMgYW4gb2JqZWN0IHRoYXQsIGluIHRoZSBzaW1wbGUgY2FzZSwgbWFwcyBDU1MgcHJvcGVydHlcbi8vIG5hbWVzIHRvIHN0cmluZ3MgaG9sZGluZyB0aGVpciB2YWx1ZXMsIGFzIGluIGB7Y29sb3I6IFwicmVkXCIsXG4vLyBmb250V2VpZ2h0OiBcImJvbGRcIn1gLiBUaGUgcHJvcGVydHkgbmFtZXMgY2FuIGJlIGdpdmVuIGluXG4vLyBjYW1lbC1jYXNlXHUyMDE0dGhlIGxpYnJhcnkgd2lsbCBpbnNlcnQgYSBkYXNoIGJlZm9yZSBjYXBpdGFsIGxldHRlcnNcbi8vIHdoZW4gY29udmVydGluZyB0aGVtIHRvIENTUy5cbi8vXG4vLyBJZiB5b3UgaW5jbHVkZSBhbiB1bmRlcnNjb3JlIGluIGEgcHJvcGVydHkgbmFtZSwgaXQgYW5kIGV2ZXJ5dGhpbmdcbi8vIGFmdGVyIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBvdXRwdXQsIHdoaWNoIGNhbiBiZSB1c2VmdWwgd2hlblxuLy8gcHJvdmlkaW5nIGEgcHJvcGVydHkgbXVsdGlwbGUgdGltZXMsIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHlcbi8vIHJlYXNvbnMuXG4vL1xuLy8gQSBwcm9wZXJ0eSBpbiBhIHN0eWxlIG9iamVjdCBjYW4gYWxzbyBiZSBhIHN1Yi1zZWxlY3Rvciwgd2hpY2hcbi8vIGV4dGVuZHMgdGhlIGN1cnJlbnQgY29udGV4dCB0byBhZGQgYSBwc2V1ZG8tc2VsZWN0b3Igb3IgYSBjaGlsZFxuLy8gc2VsZWN0b3IuIFN1Y2ggYSBwcm9wZXJ0eSBzaG91bGQgY29udGFpbiBhIGAmYCBjaGFyYWN0ZXIsIHdoaWNoXG4vLyB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjdXJyZW50IHNlbGVjdG9yLiBGb3IgZXhhbXBsZSBge1wiJjpiZWZvcmVcIjpcbi8vIHtjb250ZW50OiAnXCJoaVwiJ319YC4gU3ViLXNlbGVjdG9ycyBhbmQgcmVndWxhciBwcm9wZXJ0aWVzIGNhblxuLy8gZnJlZWx5IGJlIG1peGVkIGluIGEgZ2l2ZW4gb2JqZWN0LiBBbnkgcHJvcGVydHkgY29udGFpbmluZyBhIGAmYCBpc1xuLy8gYXNzdW1lZCB0byBiZSBhIHN1Yi1zZWxlY3Rvci5cbi8vXG4vLyBGaW5hbGx5LCBhIHByb3BlcnR5IGNhbiBzcGVjaWZ5IGFuIEAtYmxvY2sgdG8gYmUgd3JhcHBlZCBhcm91bmQgdGhlXG4vLyBzdHlsZXMgZGVmaW5lZCBpbnNpZGUgdGhlIG9iamVjdCB0aGF0J3MgdGhlIHByb3BlcnR5J3MgdmFsdWUuIEZvclxuLy8gZXhhbXBsZSB0byBjcmVhdGUgYSBtZWRpYSBxdWVyeSB5b3UgY2FuIGRvIGB7XCJAbWVkaWEgc2NyZWVuIGFuZFxuLy8gKG1pbi13aWR0aDogNDAwcHgpXCI6IHsuLi59fWAuXG4iLCAiZXhwb3J0IHZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufVxuXG5leHBvcnQgdmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiXG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpXG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpXG5cbi8vIEFuZCB0aGUgYWxwaGFiZXRpYyBrZXlzXG5mb3IgKHZhciBpID0gNjU7IGkgPD0gOTA7IGkrKykge1xuICBiYXNlW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpXG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXVxuXG5leHBvcnQgZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICAvLyBPbiBtYWNPUywga2V5cyBoZWxkIHdpdGggU2hpZnQgYW5kIENtZCBkb24ndCByZWZsZWN0IHRoZSBlZmZlY3Qgb2YgU2hpZnQgaW4gYC5rZXlgLlxuICAvLyBPbiBJRSwgc2hpZnQgZWZmZWN0IGlzIG5ldmVyIGluY2x1ZGVkIGluIGAua2V5YC5cbiAgdmFyIGlnbm9yZUtleSA9IG1hYyAmJiBldmVudC5tZXRhS2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHxcbiAgICAgIGllICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09IDEgfHxcbiAgICAgIGV2ZW50LmtleSA9PSBcIlVuaWRlbnRpZmllZFwiXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVsdCgpIHtcbiAgdmFyIGVsdCA9IGFyZ3VtZW50c1swXVxuICBpZiAodHlwZW9mIGVsdCA9PSBcInN0cmluZ1wiKSBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsdClcbiAgdmFyIGkgPSAxLCBuZXh0ID0gYXJndW1lbnRzWzFdXG4gIGlmIChuZXh0ICYmIHR5cGVvZiBuZXh0ID09IFwib2JqZWN0XCIgJiYgbmV4dC5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0KSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHQsIG5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXh0W25hbWVdXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIGVsdC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSBlbHRbbmFtZV0gPSB2YWx1ZVxuICAgIH1cbiAgICBpKytcbiAgfVxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYWRkKGVsdCwgYXJndW1lbnRzW2ldKVxuICByZXR1cm4gZWx0XG59XG5cbmZ1bmN0aW9uIGFkZChlbHQsIGNoaWxkKSB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT0gXCJzdHJpbmdcIikge1xuICAgIGVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkpXG4gIH0gZWxzZSBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlICE9IG51bGwpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoY2hpbGQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBjaGlsZFtpXSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoaWxkIG5vZGU6IFwiICsgY2hpbGQpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBSYW5nZVNldCwgTWFwTW9kZSwgUmFuZ2VWYWx1ZSwgZmluZENsdXN0ZXJCcmVhaywgRWRpdG9yU2VsZWN0aW9uLCBGYWNldCwgU3RhdGVFZmZlY3QsIENoYW5nZVNldCwgVGV4dCwgZmluZENvbHVtbiwgQ2hhckNhdGVnb3J5LCBFZGl0b3JTdGF0ZSwgQW5ub3RhdGlvbiwgVHJhbnNhY3Rpb24sIFByZWMsIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBSYW5nZVNldEJ1aWxkZXIsIGNvdW50Q29sdW1uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuaW1wb3J0IHsga2V5TmFtZSwgYmFzZSwgc2hpZnQgfSBmcm9tICd3M2Mta2V5bmFtZSc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcblxubGV0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IHsgdXNlckFnZW50OiBcIlwiLCB2ZW5kb3I6IFwiXCIsIHBsYXRmb3JtOiBcIlwiIH07XG5sZXQgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHsgZG9jdW1lbnRFbGVtZW50OiB7IHN0eWxlOiB7fSB9IH07XG5jb25zdCBpZV9lZGdlID0gLypAX19QVVJFX18qLy9FZGdlXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gLypAX19QVVJFX18qLy9NU0lFIFxcZC8udGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvKkBfX1BVUkVfXyovL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGdlY2tvID0gIWllICYmIC8qQF9fUFVSRV9fKi8vZ2Vja29cXC8oXFxkKykvaS50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgY2hyb21lID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuY29uc3QgaW9zID0gc2FmYXJpICYmICgvKkBfX1BVUkVfXyovL01vYmlsZVxcL1xcdysvLnRlc3QobmF2LnVzZXJBZ2VudCkgfHwgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG52YXIgYnJvd3NlciA9IHtcbiAgICBtYWM6IGlvcyB8fCAvKkBfX1BVUkVfXyovL01hYy8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIHdpbmRvd3M6IC8qQF9fUFVSRV9fKi8vV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgbGludXg6IC8qQF9fUFVSRV9fKi8vTGludXh8WDExLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgaWUsXG4gICAgaWVfdmVyc2lvbjogaWVfdXB0bzEwID8gZG9jLmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMCxcbiAgICBnZWNrbyxcbiAgICBnZWNrb192ZXJzaW9uOiBnZWNrbyA/ICsoLypAX19QVVJFX18qLy9GaXJlZm94XFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIGNocm9tZTogISFjaHJvbWUsXG4gICAgY2hyb21lX3ZlcnNpb246IGNocm9tZSA/ICtjaHJvbWVbMV0gOiAwLFxuICAgIGlvcyxcbiAgICBhbmRyb2lkOiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2LnVzZXJBZ2VudCksXG4gICAgd2Via2l0LFxuICAgIHdlYmtpdF92ZXJzaW9uOiB3ZWJraXQgPyArKC8qQF9fUFVSRV9fKi8vXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgc2FmYXJpLFxuICAgIHNhZmFyaV92ZXJzaW9uOiBzYWZhcmkgPyArKC8qQF9fUFVSRV9fKi8vXFxiVmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvLmV4ZWMobmF2LnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgdGFiU2l6ZTogZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS50YWJTaXplICE9IG51bGwgPyBcInRhYi1zaXplXCIgOiBcIi1tb3otdGFiLXNpemVcIlxufTtcblxuZnVuY3Rpb24gY29tYmluZUF0dHJzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJjbGFzc1wiICYmIHRhcmdldC5jbGFzcylcbiAgICAgICAgICAgIHRhcmdldC5jbGFzcyArPSBcIiBcIiArIHNvdXJjZS5jbGFzcztcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcInN0eWxlXCIgJiYgdGFyZ2V0LnN0eWxlKVxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlICs9IFwiO1wiICsgc291cmNlLnN0eWxlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBub0F0dHJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBhdHRyc0VxKGEsIGIsIGlnbm9yZSkge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghYSlcbiAgICAgICAgYSA9IG5vQXR0cnM7XG4gICAgaWYgKCFiKVxuICAgICAgICBiID0gbm9BdHRycztcbiAgICBsZXQga2V5c0EgPSBPYmplY3Qua2V5cyhhKSwga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoa2V5c0EubGVuZ3RoIC0gKGlnbm9yZSAmJiBrZXlzQS5pbmRleE9mKGlnbm9yZSkgPiAtMSA/IDEgOiAwKSAhPVxuICAgICAgICBrZXlzQi5sZW5ndGggLSAoaWdub3JlICYmIGtleXNCLmluZGV4T2YoaWdub3JlKSA+IC0xID8gMSA6IDApKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXNBKSB7XG4gICAgICAgIGlmIChrZXkgIT0gaWdub3JlICYmIChrZXlzQi5pbmRleE9mKGtleSkgPT0gLTEgfHwgYVtrZXldICE9PSBiW2tleV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNldEF0dHJzKGRvbSwgYXR0cnMpIHtcbiAgICBmb3IgKGxldCBpID0gZG9tLmF0dHJpYnV0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5hbWUgPSBkb20uYXR0cmlidXRlc1tpXS5uYW1lO1xuICAgICAgICBpZiAoYXR0cnNbbmFtZV0gPT0gbnVsbClcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXR0cnNbbmFtZV07XG4gICAgICAgIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG4gICAgICAgIGVsc2UgaWYgKGRvbS5nZXRBdHRyaWJ1dGUobmFtZSkgIT0gdmFsdWUpXG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVBdHRycyhkb20sIHByZXYsIGF0dHJzKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAocHJldilcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcmV2KVxuICAgICAgICAgICAgaWYgKCEoYXR0cnMgJiYgbmFtZSBpbiBhdHRycykpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcInN0eWxlXCIpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgaWYgKCEocHJldiAmJiBwcmV2W25hbWVdID09IGF0dHJzW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QXR0cnMoZG9tKSB7XG4gICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBhdHRyID0gZG9tLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG59XG5cbi8qKlxuV2lkZ2V0cyBhZGRlZCB0byB0aGUgY29udGVudCBhcmUgZGVzY3JpYmVkIGJ5IHN1YmNsYXNzZXMgb2YgdGhpc1xuY2xhc3MuIFVzaW5nIGEgZGVzY3JpcHRpb24gb2JqZWN0IGxpa2UgdGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0b1xuZGVsYXkgY3JlYXRpbmcgb2YgdGhlIERPTSBzdHJ1Y3R1cmUgZm9yIGEgd2lkZ2V0IHVudGlsIGl0IGlzXG5uZWVkZWQsIGFuZCB0byBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyBldmVuIGlmIHRoZSBkZWNvcmF0aW9uc1xudGhhdCBkZWZpbmUgdGhlbSBhcmUgcmVjcmVhdGVkLlxuKi9cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBpbnN0YW5jZSB0byBhbm90aGVyIGluc3RhbmNlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgKFR5cGVTY3JpcHQgY2FuJ3QgZXhwcmVzcyB0aGlzLCBidXQgb25seSBpbnN0YW5jZXMgb2YgdGhlIHNhbWVcbiAgICBzcGVjaWZpYyBjbGFzcyB3aWxsIGJlIHBhc3NlZCB0byB0aGlzIG1ldGhvZC4pIFRoaXMgaXMgdXNlZCB0b1xuICAgIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIHdoZW4gdGhleSBhcmUgcmVwbGFjZWQgYnkgYSBuZXdcbiAgICBkZWNvcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3RcbiAgICByZXR1cm5zIGBmYWxzZWAsIHdoaWNoIHdpbGwgY2F1c2UgbmV3IGluc3RhbmNlcyBvZiB0aGUgd2lkZ2V0IHRvXG4gICAgYWx3YXlzIGJlIHJlZHJhd24uXG4gICAgKi9cbiAgICBlcSh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgVXBkYXRlIGEgRE9NIGVsZW1lbnQgY3JlYXRlZCBieSBhIHdpZGdldCBvZiB0aGUgc2FtZSB0eXBlIChidXRcbiAgICBkaWZmZXJlbnQsIG5vbi1gZXFgIGNvbnRlbnQpIHRvIHJlZmxlY3QgdGhpcyB3aWRnZXQuIE1heSByZXR1cm5cbiAgICB0cnVlIHRvIGluZGljYXRlIHRoYXQgaXQgY291bGQgdXBkYXRlLCBmYWxzZSB0byBpbmRpY2F0ZSBpdFxuICAgIGNvdWxkbid0IChpbiB3aGljaCBjYXNlIHRoZSB3aWRnZXQgd2lsbCBiZSByZWRyYXduKS4gVGhlIGRlZmF1bHRcbiAgICBpbXBsZW1lbnRhdGlvbiBqdXN0IHJldHVybnMgZmFsc2UuXG4gICAgKi9cbiAgICB1cGRhdGVET00oZG9tLCB2aWV3KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnN0cnVjdG9yID09IG90aGVyLmNvbnN0cnVjdG9yICYmIHRoaXMuZXEob3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZXN0aW1hdGVkIGhlaWdodCB0aGlzIHdpZGdldCB3aWxsIGhhdmUsIHRvIGJlIHVzZWQgd2hlblxuICAgIGVzdGltYXRpbmcgdGhlIGhlaWdodCBvZiBjb250ZW50IHRoYXQgaGFzbid0IGJlZW4gZHJhd24uIE1heVxuICAgIHJldHVybiAtMSB0byBpbmRpY2F0ZSB5b3UgZG9uJ3Qga25vdy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICByZXR1cm5zIC0xLlxuICAgICovXG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIC0xOyB9XG4gICAgLyoqXG4gICAgRm9yIGlubGluZSB3aWRnZXRzIHRoYXQgYXJlIGRpc3BsYXllZCBpbmxpbmUgKGFzIG9wcG9zZWQgdG9cbiAgICBgaW5saW5lLWJsb2NrYCkgYW5kIGludHJvZHVjZSBsaW5lIGJyZWFrcyAodGhyb3VnaCBgPGJyPmAgdGFnc1xuICAgIG9yIHRleHR1YWwgbmV3bGluZXMpLCB0aGlzIG11c3QgaW5kaWNhdGUgdGhlIGFtb3VudCBvZiBsaW5lXG4gICAgYnJlYWtzIHRoZXkgaW50cm9kdWNlLiBEZWZhdWx0cyB0byAwLlxuICAgICovXG4gICAgZ2V0IGxpbmVCcmVha3MoKSB7IHJldHVybiAwOyB9XG4gICAgLyoqXG4gICAgQ2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHdoaWNoIGtpbmRzIG9mIGV2ZW50cyBpbnNpZGUgdGhlIHdpZGdldFxuICAgIHNob3VsZCBiZSBpZ25vcmVkIGJ5IHRoZSBlZGl0b3IuIFRoZSBkZWZhdWx0IGlzIHRvIGlnbm9yZSBhbGxcbiAgICBldmVudHMuXG4gICAgKi9cbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIC8qKlxuICAgIE92ZXJyaWRlIHRoZSB3YXkgc2NyZWVuIGNvb3JkaW5hdGVzIGZvciBwb3NpdGlvbnMgYXQvaW4gdGhlXG4gICAgd2lkZ2V0IGFyZSBmb3VuZC4gYHBvc2Agd2lsbCBiZSB0aGUgb2Zmc2V0IGludG8gdGhlIHdpZGdldCwgYW5kXG4gICAgYHNpZGVgIHRoZSBzaWRlIG9mIHRoZSBwb3NpdGlvbiB0aGF0IGlzIGJlaW5nIHF1ZXJpZWRcdTIwMTRsZXNzIHRoYW5cbiAgICB6ZXJvIGZvciBiZWZvcmUsIGdyZWF0ZXIgdGhhbiB6ZXJvIGZvciBhZnRlciwgYW5kIHplcm8gZm9yXG4gICAgZGlyZWN0bHkgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGNvb3Jkc0F0KGRvbSwgcG9zLCBzaWRlKSB7IHJldHVybiBudWxsOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVkaXRhYmxlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgd2lkZ2V0IGlzIHJlbW92ZWRcbiAgICBmcm9tIHRoZSBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIGRlc3Ryb3koZG9tKSB7IH1cbn1cbi8qKlxuVGhlIGRpZmZlcmVudCB0eXBlcyBvZiBibG9ja3MgdGhhdCBjYW4gb2NjdXIgaW4gYW4gZWRpdG9yIHZpZXcuXG4qL1xudmFyIEJsb2NrVHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJsb2NrVHlwZSkge1xuICAgIC8qKlxuICAgIEEgbGluZSBvZiB0ZXh0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIlRleHRcIl0gPSAwXSA9IFwiVGV4dFwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYWZ0ZXIgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QmVmb3JlXCJdID0gMV0gPSBcIldpZGdldEJlZm9yZVwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYmVmb3JlIGl0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldEFmdGVyXCJdID0gMl0gPSBcIldpZGdldEFmdGVyXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgW3JlcGxhY2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmVwbGFjZSkgYSByYW5nZSBvZiBjb250ZW50LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldFJhbmdlXCJdID0gM10gPSBcIldpZGdldFJhbmdlXCI7XG5yZXR1cm4gQmxvY2tUeXBlfSkoQmxvY2tUeXBlIHx8IChCbG9ja1R5cGUgPSB7fSkpO1xuLyoqXG5BIGRlY29yYXRpb24gcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGRyYXcgb3Igc3R5bGUgYSBwaWVjZVxub2YgY29udGVudC4gWW91J2xsIHVzdWFsbHkgdXNlIGl0IHdyYXBwZWQgaW4gYVxuW2BSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpLCB3aGljaCBhZGRzIGEgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbi5cbkBub25hYnN0cmFjdFxuKi9cbmNsYXNzIERlY29yYXRpb24gZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXJ0U2lkZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbmRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdpZGdldCwgXG4gICAgLyoqXG4gICAgVGhlIGNvbmZpZyBvYmplY3QgdXNlZCB0byBjcmVhdGUgdGhpcyBkZWNvcmF0aW9uLiBZb3UgY2FuXG4gICAgaW5jbHVkZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW4gdGhlcmUgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXRcbiAgICB5b3VyIGRlY29yYXRpb24uXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRTaWRlID0gc3RhcnRTaWRlO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSBlbmRTaWRlO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgZGVjb3JhdGlvbiwgd2hpY2ggaW5mbHVlbmNlcyB0aGUgc3R5bGluZyBvZiB0aGVcbiAgICBjb250ZW50IGluIGl0cyByYW5nZS4gTmVzdGVkIG1hcmsgZGVjb3JhdGlvbnMgd2lsbCBjYXVzZSBuZXN0ZWRcbiAgICBET00gZWxlbWVudHMgdG8gYmUgY3JlYXRlZC4gTmVzdGluZyBvcmRlciBpcyBkZXRlcm1pbmVkIGJ5XG4gICAgcHJlY2VkZW5jZSBvZiB0aGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIHdpdGhcbiAgICB0aGUgaGlnaGVyLXByZWNlZGVuY2UgZGVjb3JhdGlvbnMgY3JlYXRpbmcgdGhlIGlubmVyIERPTSBub2Rlcy5cbiAgICBTdWNoIGVsZW1lbnRzIGFyZSBzcGxpdCBvbiBsaW5lIGJvdW5kYXJpZXMgYW5kIG9uIHRoZSBib3VuZGFyaWVzXG4gICAgb2YgbG93ZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGRpc3BsYXlzIGEgRE9NIGVsZW1lbnQgYXQgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgd2lkZ2V0KHNwZWMpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBNYXRoLm1heCgtMTAwMDAsIE1hdGgubWluKDEwMDAwLCBzcGVjLnNpZGUgfHwgMCkpLCBibG9jayA9ICEhc3BlYy5ibG9jaztcbiAgICAgICAgc2lkZSArPSAoYmxvY2sgJiYgIXNwZWMuaW5saW5lT3JkZXIpXG4gICAgICAgICAgICA/IChzaWRlID4gMCA/IDMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQWZ0ZXIgKi8gOiAtNDAwMDAwMDAwIC8qIFNpZGUuQmxvY2tCZWZvcmUgKi8pXG4gICAgICAgICAgICA6IChzaWRlID4gMCA/IDEwMDAwMDAwMCAvKiBTaWRlLklubGluZUFmdGVyICovIDogLTEwMDAwMDAwMCAvKiBTaWRlLklubGluZUJlZm9yZSAqLyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHNpZGUsIHNpZGUsIGJsb2NrLCBzcGVjLndpZGdldCB8fCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UgZGVjb3JhdGlvbiB3aGljaCByZXBsYWNlcyB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aFxuICAgIGEgd2lkZ2V0LCBvciBzaW1wbHkgaGlkZXMgaXQuXG4gICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZShzcGVjKSB7XG4gICAgICAgIGxldCBibG9jayA9ICEhc3BlYy5ibG9jaywgc3RhcnRTaWRlLCBlbmRTaWRlO1xuICAgICAgICBpZiAoc3BlYy5pc0Jsb2NrR2FwKSB7XG4gICAgICAgICAgICBzdGFydFNpZGUgPSAtNTAwMDAwMDAwIC8qIFNpZGUuR2FwU3RhcnQgKi87XG4gICAgICAgICAgICBlbmRTaWRlID0gNDAwMDAwMDAwIC8qIFNpZGUuR2FwRW5kICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrKTtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IChzdGFydCA/IChibG9jayA/IC0zMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY1N0YXJ0ICovIDogLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLykgOiA1MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNTdGFydCAqLykgLSAxO1xuICAgICAgICAgICAgZW5kU2lkZSA9IChlbmQgPyAoYmxvY2sgPyAyMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY0VuZCAqLyA6IDEgLyogU2lkZS5JbmxpbmVJbmNFbmQgKi8pIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLykgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsaW5lIGRlY29yYXRpb24sIHdoaWNoIGNhbiBhZGQgRE9NIGF0dHJpYnV0ZXMgdG8gdGhlXG4gICAgbGluZSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgbGluZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZURlY29yYXRpb24oc3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgW2BEZWNvcmF0aW9uU2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpIGZyb20gdGhlIGdpdmVuXG4gICAgZGVjb3JhdGVkIHJhbmdlIG9yIHJhbmdlcy4gSWYgdGhlIHJhbmdlcyBhcmVuJ3QgYWxyZWFkeSBzb3J0ZWQsXG4gICAgcGFzcyBgdHJ1ZWAgZm9yIGBzb3J0YCB0byBtYWtlIHRoZSBsaWJyYXJ5IHNvcnQgdGhlbSBmb3IgeW91LlxuICAgICovXG4gICAgc3RhdGljIHNldChvZiwgc29ydCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZVNldC5vZihvZiwgc29ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaGFzSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy53aWRnZXQgPyB0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPiAtMSA6IGZhbHNlOyB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgZGVjb3JhdGlvbnMuXG4qL1xuRGVjb3JhdGlvbi5ub25lID0gUmFuZ2VTZXQuZW1wdHk7XG5jbGFzcyBNYXJrRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMpO1xuICAgICAgICBzdXBlcihzdGFydCA/IC0xIC8qIFNpZGUuSW5saW5lSW5jU3RhcnQgKi8gOiA1MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNTdGFydCAqLywgZW5kID8gMSAvKiBTaWRlLklubGluZUluY0VuZCAqLyA6IC02MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNFbmQgKi8sIG51bGwsIHNwZWMpO1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSBzcGVjLnRhZ05hbWUgfHwgXCJzcGFuXCI7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBzcGVjLmNsYXNzICYmIHNwZWMuYXR0cmlidXRlcyA/IGNvbWJpbmVBdHRycyhzcGVjLmF0dHJpYnV0ZXMsIHsgY2xhc3M6IHNwZWMuY2xhc3MgfSlcbiAgICAgICAgICAgIDogc3BlYy5jbGFzcyA/IHsgY2xhc3M6IHNwZWMuY2xhc3MgfSA6IHNwZWMuYXR0cmlidXRlcyB8fCBub0F0dHJzO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCBvdGhlciBpbnN0YW5jZW9mIE1hcmtEZWNvcmF0aW9uICYmIHRoaXMudGFnTmFtZSA9PSBvdGhlci50YWdOYW1lICYmIGF0dHJzRXEodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hcmsgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5NYXJrRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcbmNsYXNzIExpbmVEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIG51bGwsIHNwZWMpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBMaW5lRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5zcGVjLmNsYXNzID09IG90aGVyLnNwZWMuY2xhc3MgJiZcbiAgICAgICAgICAgIGF0dHJzRXEodGhpcy5zcGVjLmF0dHJpYnV0ZXMsIG90aGVyLnNwZWMuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGluZSBkZWNvcmF0aW9uIHJhbmdlcyBtdXN0IGJlIHplcm8tbGVuZ3RoXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5jbGFzcyBQb2ludERlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjLCBzdGFydFNpZGUsIGVuZFNpZGUsIGJsb2NrLCB3aWRnZXQsIGlzUmVwbGFjZSkge1xuICAgICAgICBzdXBlcihzdGFydFNpZGUsIGVuZFNpZGUsIHdpZGdldCwgc3BlYyk7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgdGhpcy5pc1JlcGxhY2UgPSBpc1JlcGxhY2U7XG4gICAgICAgIHRoaXMubWFwTW9kZSA9ICFibG9jayA/IE1hcE1vZGUuVHJhY2tEZWwgOiBzdGFydFNpZGUgPD0gMCA/IE1hcE1vZGUuVHJhY2tCZWZvcmUgOiBNYXBNb2RlLlRyYWNrQWZ0ZXI7XG4gICAgfVxuICAgIC8vIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGlzLmJsb2NrID09IHRydWVcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTaWRlICE9IHRoaXMuZW5kU2lkZSA/IEJsb2NrVHlwZS5XaWRnZXRSYW5nZVxuICAgICAgICAgICAgOiB0aGlzLnN0YXJ0U2lkZSA8PSAwID8gQmxvY2tUeXBlLldpZGdldEJlZm9yZSA6IEJsb2NrVHlwZS5XaWRnZXRBZnRlcjtcbiAgICB9XG4gICAgZ2V0IGhlaWdodFJlbGV2YW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayB8fCAhIXRoaXMud2lkZ2V0ICYmICh0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPj0gNSB8fCB0aGlzLndpZGdldC5saW5lQnJlYWtzID4gMCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgd2lkZ2V0c0VxKHRoaXMud2lkZ2V0LCBvdGhlci53aWRnZXQpICYmXG4gICAgICAgICAgICB0aGlzLmJsb2NrID09IG90aGVyLmJsb2NrICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9PSBvdGhlci5zdGFydFNpZGUgJiYgdGhpcy5lbmRTaWRlID09IG90aGVyLmVuZFNpZGU7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlcGxhY2UgJiYgKGZyb20gPiB0byB8fCAoZnJvbSA9PSB0byAmJiB0aGlzLnN0YXJ0U2lkZSA+IDAgJiYgdGhpcy5lbmRTaWRlIDw9IDApKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBmb3IgcmVwbGFjZW1lbnQgZGVjb3JhdGlvblwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVwbGFjZSAmJiB0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaWRnZXQgZGVjb3JhdGlvbnMgY2FuIG9ubHkgaGF2ZSB6ZXJvLWxlbmd0aCByYW5nZXNcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuUG9pbnREZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5mdW5jdGlvbiBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2sgPSBmYWxzZSkge1xuICAgIGxldCB7IGluY2x1c2l2ZVN0YXJ0OiBzdGFydCwgaW5jbHVzaXZlRW5kOiBlbmQgfSA9IHNwZWM7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHN0YXJ0ID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICBlbmQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogYmxvY2ssIGVuZDogZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogYmxvY2sgfTtcbn1cbmZ1bmN0aW9uIHdpZGdldHNFcShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCAhIShhICYmIGIgJiYgYS5jb21wYXJlKGIpKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKGZyb20sIHRvLCByYW5nZXMsIG1hcmdpbiA9IDApIHtcbiAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdICsgbWFyZ2luID49IGZyb20pXG4gICAgICAgIHJhbmdlc1tsYXN0XSA9IE1hdGgubWF4KHJhbmdlc1tsYXN0XSwgdG8pO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2VzLnB1c2goZnJvbSwgdG8pO1xufVxuLyoqXG5BIGJsb2NrIHdyYXBwZXIgZGVmaW5lcyBhIERPTSBub2RlIHRoYXQgd3JhcHMgbGluZXMgb3Igb3RoZXIgYmxvY2tcbndyYXBwZXJzIGF0IHRoZSB0b3Agb2YgdGhlIGRvY3VtZW50LiBJdCBhZmZlY3RzIGFueSBsaW5lIG9yIGJsb2NrXG53aWRnZXQgdGhhdCBzdGFydHMgaW5zaWRlIGl0cyByYW5nZSwgaW5jbHVkaW5nIGJsb2NrcyBzdGFydGluZ1xuZGlyZWN0bHkgYXQgYGZyb21gIGJ1dCBub3QgaW5jbHVkaW5nIGB0b2AuXG4qL1xuY2xhc3MgQmxvY2tXcmFwcGVyIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodGFnTmFtZSwgYXR0cmlidXRlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgPT0gdGhpcyB8fFxuICAgICAgICAgICAgb3RoZXIgaW5zdGFuY2VvZiBCbG9ja1dyYXBwZXIgJiYgdGhpcy50YWdOYW1lID09IG90aGVyLnRhZ05hbWUgJiYgYXR0cnNFcSh0aGlzLmF0dHJpYnV0ZXMsIG90aGVyLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBibG9jayB3cmFwcGVyIG9iamVjdCB3aXRoIHRoZSBnaXZlbiB0YWcgbmFtZSBhbmRcbiAgICBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tXcmFwcGVyKHNwZWMudGFnTmFtZSwgc3BlYy5hdHRyaWJ1dGVzIHx8IG5vQXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSByYW5nZSBzZXQgZnJvbSB0aGUgZ2l2ZW4gYmxvY2sgd3JhcHBlciByYW5nZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0KG9mLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG9mLCBzb3J0KTtcbiAgICB9XG59XG5CbG9ja1dyYXBwZXIucHJvdG90eXBlLnN0YXJ0U2lkZSA9IEJsb2NrV3JhcHBlci5wcm90b3R5cGUuZW5kU2lkZSA9IC0xO1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24ocm9vdCkge1xuICAgIGxldCB0YXJnZXQ7XG4gICAgLy8gQnJvd3NlcnMgZGlmZmVyIG9uIHdoZXRoZXIgc2hhZG93IHJvb3RzIGhhdmUgYSBnZXRTZWxlY3Rpb25cbiAgICAvLyBtZXRob2QuIElmIGl0IGV4aXN0cywgdXNlIHRoYXQsIG90aGVyd2lzZSwgY2FsbCBpdCBvbiB0aGVcbiAgICAvLyBkb2N1bWVudC5cbiAgICBpZiAocm9vdC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICB0YXJnZXQgPSByb290LmdldFNlbGVjdGlvbiA/IHJvb3QgOiByb290Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSByb290O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LmdldFNlbGVjdGlvbigpO1xufVxuZnVuY3Rpb24gY29udGFpbnMoZG9tLCBub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgPyBkb20gPT0gbm9kZSB8fCBkb20uY29udGFpbnMobm9kZS5ub2RlVHlwZSAhPSAxID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbihkb20sIHNlbGVjdGlvbikge1xuICAgIGlmICghc2VsZWN0aW9uLmFuY2hvck5vZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGRvbSwgc2VsZWN0aW9uLmFuY2hvck5vZGUpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xpZW50UmVjdHNGb3IoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gdGV4dFJhbmdlKGRvbSwgMCwgZG9tLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgIHJldHVybiBkb20uZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBbXTtcbn1cbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmZ1bmN0aW9uIGlzRXF1aXZhbGVudFBvc2l0aW9uKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgPyAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8XG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZG9tSW5kZXgobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNCbG9ja0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDEgJiYgL14oRElWfFB8TEl8VUx8T0x8QkxPQ0tRVU9URXxERHxEVHxIXFxkfFNFQ1RJT058UFJFKSQvLnRlc3Qobm9kZS5ub2RlTmFtZSk7XG59XG5mdW5jdGlvbiBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCBkaXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG1heE9mZnNldChub2RlKSkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG1heE9mZnNldChub2RlKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXhPZmZzZXQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gZmxhdHRlblJlY3QocmVjdCwgbGVmdCkge1xuICAgIGxldCB4ID0gbGVmdCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gICAgcmV0dXJuIHsgbGVmdDogeCwgcmlnaHQ6IHgsIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC5ib3R0b20gfTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1JlY3Qod2luKSB7XG4gICAgbGV0IHZwID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICAgIGlmICh2cClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IDAsIHJpZ2h0OiB2cC53aWR0aCxcbiAgICAgICAgICAgIHRvcDogMCwgYm90dG9tOiB2cC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogd2luLmlubmVyV2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIGdldFNjYWxlKGVsdCwgcmVjdCkge1xuICAgIGxldCBzY2FsZVggPSByZWN0LndpZHRoIC8gZWx0Lm9mZnNldFdpZHRoO1xuICAgIGxldCBzY2FsZVkgPSByZWN0LmhlaWdodCAvIGVsdC5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKHNjYWxlWCA+IDAuOTk1ICYmIHNjYWxlWCA8IDEuMDA1IHx8ICFpc0Zpbml0ZShzY2FsZVgpIHx8IE1hdGguYWJzKHJlY3Qud2lkdGggLSBlbHQub2Zmc2V0V2lkdGgpIDwgMSlcbiAgICAgICAgc2NhbGVYID0gMTtcbiAgICBpZiAoc2NhbGVZID4gMC45OTUgJiYgc2NhbGVZIDwgMS4wMDUgfHwgIWlzRmluaXRlKHNjYWxlWSkgfHwgTWF0aC5hYnMocmVjdC5oZWlnaHQgLSBlbHQub2Zmc2V0SGVpZ2h0KSA8IDEpXG4gICAgICAgIHNjYWxlWSA9IDE7XG4gICAgcmV0dXJuIHsgc2NhbGVYLCBzY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyhkb20sIHJlY3QsIHNpZGUsIHgsIHksIHhNYXJnaW4sIHlNYXJnaW4sIGx0cikge1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudCwgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICBmb3IgKGxldCBjdXIgPSBkb20sIHN0b3AgPSBmYWxzZTsgY3VyICYmICFzdG9wOykge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHsgLy8gRWxlbWVudFxuICAgICAgICAgICAgbGV0IGJvdW5kaW5nLCB0b3AgPSBjdXIgPT0gZG9jLmJvZHk7XG4gICAgICAgICAgICBsZXQgc2NhbGVYID0gMSwgc2NhbGVZID0gMTtcbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHdpbmRvd1JlY3Qod2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgvXihmaXhlZHxzdGlja3kpJC8udGVzdChnZXRDb21wdXRlZFN0eWxlKGN1cikucG9zaXRpb24pKVxuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnNjcm9sbEhlaWdodCA8PSBjdXIuY2xpZW50SGVpZ2h0ICYmIGN1ci5zY3JvbGxXaWR0aCA8PSBjdXIuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gY3VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICh7IHNjYWxlWCwgc2NhbGVZIH0gPSBnZXRTY2FsZShjdXIsIHJlY3QpKTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0ICsgY3VyLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgY3VyLmNsaWVudEhlaWdodCAqIHNjYWxlWSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vdmVYID0gMCwgbW92ZVkgPSAwO1xuICAgICAgICAgICAgaWYgKHkgPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LnRvcCAtIChib3VuZGluZy50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tICsgbW92ZVkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCAmJiAocmVjdC50b3AgLSBtb3ZlWSkgPCBib3VuZGluZy50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QudG9wIC0gKGJvdW5kaW5nLnRvcCArIHlNYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCByZWN0SGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCwgYm91bmRpbmdIZWlnaHQgPSBib3VuZGluZy5ib3R0b20gLSBib3VuZGluZy50b3A7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFRvcCA9IHkgPT0gXCJjZW50ZXJcIiAmJiByZWN0SGVpZ2h0IDw9IGJvdW5kaW5nSGVpZ2h0ID8gcmVjdC50b3AgKyByZWN0SGVpZ2h0IC8gMiAtIGJvdW5kaW5nSGVpZ2h0IC8gMiA6XG4gICAgICAgICAgICAgICAgICAgIHkgPT0gXCJzdGFydFwiIHx8IHkgPT0gXCJjZW50ZXJcIiAmJiBzaWRlIDwgMCA/IHJlY3QudG9wIC0geU1hcmdpbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LmJvdHRvbSAtIGJvdW5kaW5nSGVpZ2h0ICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWSA9IHRhcmdldFRvcCAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID09IFwibmVhcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LmxlZnQgLSAoYm91bmRpbmcubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0ICsgbW92ZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCAmJiByZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgbW92ZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QubGVmdCAtIChib3VuZGluZy5sZWZ0ICsgeE1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldExlZnQgPSB4ID09IFwiY2VudGVyXCIgPyByZWN0LmxlZnQgKyAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgLyAyIC0gKGJvdW5kaW5nLnJpZ2h0IC0gYm91bmRpbmcubGVmdCkgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHggPT0gXCJzdGFydFwiKSA9PSBsdHIgPyByZWN0LmxlZnQgLSB4TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QucmlnaHQgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgbW92ZVggPSB0YXJnZXRMZWZ0IC0gYm91bmRpbmcubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luLnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW92ZWRYID0gMCwgbW92ZWRZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbFRvcCArPSBtb3ZlWSAvIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkWSA9IChjdXIuc2Nyb2xsVG9wIC0gc3RhcnQpICogc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY3VyLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsTGVmdCArPSBtb3ZlWCAvIHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkWCA9IChjdXIuc2Nyb2xsTGVmdCAtIHN0YXJ0KSAqIHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBtb3ZlZFgsIHRvcDogcmVjdC50b3AgLSBtb3ZlZFksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCAtIG1vdmVkWCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIG1vdmVkWSB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRYICYmIE1hdGguYWJzKG1vdmVkWCAtIG1vdmVYKSA8IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gXCJuZWFyZXN0XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFkgJiYgTWF0aC5hYnMobW92ZWRZIC0gbW92ZVkpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wIHx8IHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tIHx8XG4gICAgICAgICAgICAgICAgcmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCB8fCByZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQpXG4gICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogTWF0aC5tYXgocmVjdC5sZWZ0LCBib3VuZGluZy5sZWZ0KSwgcmlnaHQ6IE1hdGgubWluKHJlY3QucmlnaHQsIGJvdW5kaW5nLnJpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBNYXRoLm1heChyZWN0LnRvcCwgYm91bmRpbmcudG9wKSwgYm90dG9tOiBNYXRoLm1pbihyZWN0LmJvdHRvbSwgYm91bmRpbmcuYm90dG9tKSB9O1xuICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMTEpIHsgLy8gQSBzaGFkb3cgcm9vdFxuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNjcm9sbGFibGVQYXJlbnRzKGRvbSkge1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudCwgeCwgeTtcbiAgICBmb3IgKGxldCBjdXIgPSBkb20ucGFyZW50Tm9kZTsgY3VyOykge1xuICAgICAgICBpZiAoY3VyID09IGRvYy5ib2R5IHx8ICh4ICYmIHkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgaWYgKCF5ICYmIGN1ci5zY3JvbGxIZWlnaHQgPiBjdXIuY2xpZW50SGVpZ2h0KVxuICAgICAgICAgICAgICAgIHkgPSBjdXI7XG4gICAgICAgICAgICBpZiAoIXggJiYgY3VyLnNjcm9sbFdpZHRoID4gY3VyLmNsaWVudFdpZHRoKVxuICAgICAgICAgICAgICAgIHggPSBjdXI7XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkge1xuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB4LCB5IH07XG59XG5jbGFzcyBET01TZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZXEoZG9tU2VsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuY2hvck5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgdGhpcy5hbmNob3JPZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCAmJlxuICAgICAgICAgICAgdGhpcy5mb2N1c05vZGUgPT0gZG9tU2VsLmZvY3VzTm9kZSAmJiB0aGlzLmZvY3VzT2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldDtcbiAgICB9XG4gICAgc2V0UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgYW5jaG9yTm9kZSwgZm9jdXNOb2RlIH0gPSByYW5nZTtcbiAgICAgICAgLy8gQ2xpcCBvZmZzZXRzIHRvIG5vZGUgc2l6ZSB0byBhdm9pZCBjcmFzaGVzIHdoZW4gU2FmYXJpIHJlcG9ydHMgYm9ndXMgb2Zmc2V0cyAoIzExNTIpXG4gICAgICAgIHRoaXMuc2V0KGFuY2hvck5vZGUsIE1hdGgubWluKHJhbmdlLmFuY2hvck9mZnNldCwgYW5jaG9yTm9kZSA/IG1heE9mZnNldChhbmNob3JOb2RlKSA6IDApLCBmb2N1c05vZGUsIE1hdGgubWluKHJhbmdlLmZvY3VzT2Zmc2V0LCBmb2N1c05vZGUgPyBtYXhPZmZzZXQoZm9jdXNOb2RlKSA6IDApKTtcbiAgICB9XG4gICAgc2V0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBhbmNob3JOb2RlO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IGFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBmb2N1c05vZGU7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICB9XG59XG5sZXQgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG4vLyBTYWZhcmkgMjYgYnJlYWtzIHByZXZlbnRTY3JvbGwgc3VwcG9ydFxuaWYgKGJyb3dzZXIuc2FmYXJpICYmIGJyb3dzZXIuc2FmYXJpX3ZlcnNpb24gPj0gMjYpXG4gICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICAgIGlmIChkb20uc2V0QWN0aXZlKVxuICAgICAgICByZXR1cm4gZG9tLnNldEFjdGl2ZSgpOyAvLyBpbiBJRVxuICAgIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICAgIGxldCBzdGFjayA9IFtdO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBzdGFjay5wdXNoKGN1ciwgY3VyLnNjcm9sbFRvcCwgY3VyLnNjcm9sbExlZnQpO1xuICAgICAgICBpZiAoY3VyID09IGN1ci5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBzdGFja1tpKytdLCB0b3AgPSBzdGFja1tpKytdLCBsZWZ0ID0gc3RhY2tbaSsrXTtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsVG9wICE9IHRvcClcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgICAgICAgaWYgKGVsdC5zY3JvbGxMZWZ0ICE9IGxlZnQpXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IHNjcmF0Y2hSYW5nZTtcbmZ1bmN0aW9uIHRleHRSYW5nZShub2RlLCBmcm9tLCB0byA9IGZyb20pIHtcbiAgICBsZXQgcmFuZ2UgPSBzY3JhdGNoUmFuZ2UgfHwgKHNjcmF0Y2hSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgZnJvbSk7XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hLZXkoZWx0LCBuYW1lLCBjb2RlLCBtb2RzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IGtleTogbmFtZSwgY29kZTogbmFtZSwga2V5Q29kZTogY29kZSwgd2hpY2g6IGNvZGUsIGNhbmNlbGFibGU6IHRydWUgfTtcbiAgICBpZiAobW9kcylcbiAgICAgICAgKHsgYWx0S2V5OiBvcHRpb25zLmFsdEtleSwgY3RybEtleTogb3B0aW9ucy5jdHJsS2V5LCBzaGlmdEtleTogb3B0aW9ucy5zaGlmdEtleSwgbWV0YUtleTogb3B0aW9ucy5tZXRhS2V5IH0gPSBtb2RzKTtcbiAgICBsZXQgZG93biA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCBvcHRpb25zKTtcbiAgICBkb3duLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgZWx0LmRpc3BhdGNoRXZlbnQoZG93bik7XG4gICAgbGV0IHVwID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCBvcHRpb25zKTtcbiAgICB1cC5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KHVwKTtcbiAgICByZXR1cm4gZG93bi5kZWZhdWx0UHJldmVudGVkIHx8IHVwLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PSA5IHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgJiYgbm9kZS5ob3N0KSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0RWxlbWVudFN0YXJ0KGRvYywgc2VsZWN0aW9uKSB7XG4gICAgbGV0IG5vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlIHx8IHNlbGVjdGlvbi5hbmNob3JOb2RlICE9IG5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBTYWZhcmkgY2FuIHJlcG9ydCBib2d1cyBvZmZzZXRzICgjMTE1MilcbiAgICBvZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQsIG1heE9mZnNldChub2RlKSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlID09IGRvYykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1Njcm9sbGVkVG9Cb3R0b20oZWx0KSB7XG4gICAgcmV0dXJuIGVsdC5zY3JvbGxUb3AgPiBNYXRoLm1heCgxLCBlbHQuc2Nyb2xsSGVpZ2h0IC0gZWx0LmNsaWVudEhlaWdodCAtIDQpO1xufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUoc3RhcnROb2RlLCBzdGFydE9mZnNldCkge1xuICAgIGZvciAobGV0IG5vZGUgPSBzdGFydE5vZGUsIG9mZnNldCA9IHN0YXJ0T2Zmc2V0OzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBvZmZzZXQ6IG9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIWlzQmxvY2tFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQWZ0ZXIoc3RhcnROb2RlLCBzdGFydE9mZnNldCkge1xuICAgIGZvciAobGV0IG5vZGUgPSBzdGFydE5vZGUsIG9mZnNldCA9IHN0YXJ0T2Zmc2V0OzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhaXNCbG9ja0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIERPTVBvcyB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0LCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wcmVjaXNlID0gcHJlY2lzZTtcbiAgICB9XG4gICAgc3RhdGljIGJlZm9yZShkb20sIHByZWNpc2UpIHsgcmV0dXJuIG5ldyBET01Qb3MoZG9tLnBhcmVudE5vZGUsIGRvbUluZGV4KGRvbSksIHByZWNpc2UpOyB9XG4gICAgc3RhdGljIGFmdGVyKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSArIDEsIHByZWNpc2UpOyB9XG59XG5cbi8qKlxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuKi9cbnZhciBEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXG4gICAgLy8gdGVybXMsIG9mIHNwYW5zIGluIHRoYXQgZGlyZWN0aW9uLilcbiAgICAvKipcbiAgICBMZWZ0LXRvLXJpZ2h0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICBSaWdodC10by1sZWZ0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbnJldHVybiBEaXJlY3Rpb259KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBMVFIgPSBEaXJlY3Rpb24uTFRSLCBSVEwgPSBEaXJlY3Rpb24uUlRMO1xuLy8gRGVjb2RlIGEgc3RyaW5nIHdpdGggZWFjaCB0eXBlIGVuY29kZWQgYXMgbG9nMih0eXBlKVxuZnVuY3Rpb24gZGVjKHN0cikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMSA8PCArc3RyW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmOFxuY29uc3QgTG93VHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg2NjY4ODg4ODg3ODc4MzMzMzMzMzMzMzc4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODc4NjY2Njg4ODgwODg4ODg2NjMzODA4ODgzMDg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDhcIik7XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbmNvbnN0IEFyYWJpY1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjQ0NDQ0NDg4MjY2MjcyODg5OTk5OTk5OTk5OTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk5OTk5OTk5OTk5OTk5OTQ0NDQ0NDQ0NDQ2NDQyMjI4MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5NDk5OTk5OTkyMjk5ODk5OTkyMjMzMzMzMzMzMzNcIik7XG5jb25zdCBCcmFja2V0cyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpLCBCcmFja2V0U3RhY2sgPSBbXTtcbi8vIFRoZXJlJ3MgYSBsb3QgbW9yZSBpblxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL0JpZGlCcmFja2V0cy50eHQsXG4vLyB3aGljaCBhcmUgbGVmdCBvdXQgdG8ga2VlcCBjb2RlIHNpemUgZG93bi5cbmZvciAobGV0IHAgb2YgW1wiKClcIiwgXCJbXVwiLCBcInt9XCJdKSB7XG4gICAgbGV0IGwgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDApLCByID0gLypAX19QVVJFX18qL3AuY2hhckNvZGVBdCgxKTtcbiAgICBCcmFja2V0c1tsXSA9IHI7XG4gICAgQnJhY2tldHNbcl0gPSAtbDtcbn1cbmZ1bmN0aW9uIGNoYXJUeXBlKGNoKSB7XG4gICAgcmV0dXJuIGNoIDw9IDB4ZjcgPyBMb3dUeXBlc1tjaF0gOlxuICAgICAgICAweDU5MCA8PSBjaCAmJiBjaCA8PSAweDVmNCA/IDIgLyogVC5SICovIDpcbiAgICAgICAgICAgIDB4NjAwIDw9IGNoICYmIGNoIDw9IDB4NmY5ID8gQXJhYmljVHlwZXNbY2ggLSAweDYwMF0gOlxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBULkFMICovIDpcbiAgICAgICAgICAgICAgICAgICAgMHgyMDAwIDw9IGNoICYmIGNoIDw9IDB4MjAwYyA/IDI1NiAvKiBULk5JICovIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmI1MCA8PSBjaCAmJiBjaCA8PSAweGZkZmYgPyA0IC8qIFQuQUwgKi8gOiAxIC8qIFQuTCAqLztcbn1cbmNvbnN0IEJpZGlSRSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXFx1ZmI1MC1cXHVmZGZmXS87XG4vKipcblJlcHJlc2VudHMgYSBjb250aWd1b3VzIHJhbmdlIG9mIHRleHQgdGhhdCBoYXMgYSBzaW5nbGUgZGlyZWN0aW9uXG4oYXMgaW4gbGVmdC10by1yaWdodCBvciByaWdodC10by1sZWZ0KS5cbiovXG5jbGFzcyBCaWRpU3BhbiB7XG4gICAgLyoqXG4gICAgVGhlIGRpcmVjdGlvbiBvZiB0aGlzIHNwYW4uXG4gICAgKi9cbiAgICBnZXQgZGlyKCkgeyByZXR1cm4gdGhpcy5sZXZlbCAlIDIgPyBSVEwgOiBMVFI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgc3BhbiAocmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHNwYW4uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIFtcImJpZGlcbiAgICBsZXZlbFwiXShodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5LyNCYXNpY19EaXNwbGF5X0FsZ29yaXRobSlcbiAgICBvZiB0aGUgc3BhbiAoaW4gdGhpcyBjb250ZXh0LCAwIG1lYW5zXG4gICAgbGVmdC10by1yaWdodCwgMSBtZWFucyByaWdodC10by1sZWZ0LCAyIG1lYW5zIGxlZnQtdG8tcmlnaHRcbiAgICBudW1iZXIgaW5zaWRlIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4gICAgKi9cbiAgICBsZXZlbCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaWRlKGVuZCwgZGlyKSB7IHJldHVybiAodGhpcy5kaXIgPT0gZGlyKSA9PSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3J3YXJkKGZvcndhcmQsIGRpcikgeyByZXR1cm4gZm9yd2FyZCA9PSAodGhpcy5kaXIgPT0gZGlyKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZpbmQob3JkZXIsIGluZGV4LCBsZXZlbCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IG1heWJlID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gb3JkZXJbaV07XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGluZGV4ICYmIHNwYW4udG8gPj0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbi5sZXZlbCA9PSBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBtdWx0aXBsZSBzcGFucyBtYXRjaCwgaWYgYXNzb2MgIT0gMCwgdGFrZSB0aGUgb25lIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBjb3ZlcnMgdGhhdCBzaWRlLCBvdGhlcndpc2UgdGFrZSB0aGUgb25lIHdpdGggdGhlIG1pbmltdW1cbiAgICAgICAgICAgICAgICAvLyBsZXZlbC5cbiAgICAgICAgICAgICAgICBpZiAobWF5YmUgPCAwIHx8IChhc3NvYyAhPSAwID8gKGFzc29jIDwgMCA/IHNwYW4uZnJvbSA8IGluZGV4IDogc3Bhbi50byA+IGluZGV4KSA6IG9yZGVyW21heWJlXS5sZXZlbCA+IHNwYW4ubGV2ZWwpKVxuICAgICAgICAgICAgICAgICAgICBtYXliZSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gbWF5YmU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNvbGF0ZXNFcShhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpQSA9IGFbaV0sIGlCID0gYltpXTtcbiAgICAgICAgaWYgKGlBLmZyb20gIT0gaUIuZnJvbSB8fCBpQS50byAhPSBpQi50byB8fCBpQS5kaXJlY3Rpb24gIT0gaUIuZGlyZWN0aW9uIHx8ICFpc29sYXRlc0VxKGlBLmlubmVyLCBpQi5pbm5lcikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmV1c2VkIGFycmF5IG9mIGNoYXJhY3RlciB0eXBlc1xuY29uc3QgdHlwZXMgPSBbXTtcbi8vIEZpbGwgaW4gdGhlIGNoYXJhY3RlciB0eXBlcyAoaW4gYHR5cGVzYCkgZnJvbSBgZnJvbWAgdG8gYHRvYCBhbmRcbi8vIGFwcGx5IFcgbm9ybWFsaXphdGlvbiBydWxlcy5cbmZ1bmN0aW9uIGNvbXB1dGVDaGFyVHlwZXMobGluZSwgckZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGZvciAobGV0IGlJID0gMDsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgbGV0IHByZXZUeXBlID0gaUkgPyAyNTYgLyogVC5OSSAqLyA6IG91dGVyVHlwZTtcbiAgICAgICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuICAgICAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG4gICAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIEFMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhblxuICAgICAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgICAgIC8vIG51bWJlci5cbiAgICAgICAgLy8gVzMuIENoYW5nZSBhbGwgQUxzIHRvIFIuXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOLCBBTiwgRVQsIENTLCBOSSlcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIHByZXYgPSBwcmV2VHlwZSwgcHJldlN0cm9uZyA9IHByZXZUeXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBjaGFyVHlwZShsaW5lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gNTEyIC8qIFQuTlNNICovKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBwcmV2O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSA0IC8qIFQuQUwgKi8pXG4gICAgICAgICAgICAgICAgdHlwZSA9IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICB0eXBlc1tpXSA9IHR5cGUgPT0gNCAvKiBULkFMICovID8gMiAvKiBULlIgKi8gOiB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW5cbiAgICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAgICAgLy8gTmV1dHJhbC5cbiAgICAgICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xuICAgICAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTiwgTkkpXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBwcmV2ID0gcHJldlR5cGUsIHByZXZTdHJvbmcgPSBwcmV2VHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAxMjggLyogVC5DUyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdG8gLSAxICYmIHByZXYgPT0gdHlwZXNbaSArIDFdICYmIChwcmV2ICYgMjQgLyogVC5OdW0gKi8pKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZXNbaV0gPSBwcmV2O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gNjQgLyogVC5FVCAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW5kIDwgdG8gJiYgdHlwZXNbZW5kXSA9PSA2NCAvKiBULkVUICovKVxuICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICBsZXQgcmVwbGFjZSA9IChpICYmIHByZXYgPT0gOCAvKiBULkVOICovKSB8fCAoZW5kIDwgclRvICYmIHR5cGVzW2VuZF0gPT0gOCAvKiBULkVOICovKSA/IChwcmV2U3Ryb25nID09IDEgLyogVC5MICovID8gMSAvKiBULkwgKi8gOiA4IC8qIFQuRU4gKi8pIDogMjU2IC8qIFQuTkkgKi87XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlICYgNyAvKiBULlN0cm9uZyAqLylcbiAgICAgICAgICAgICAgICBwcmV2U3Ryb25nID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFByb2Nlc3MgYnJhY2tldHMgdGhyb3VnaG91dCBhIHJ1biBzZXF1ZW5jZS5cbmZ1bmN0aW9uIHByb2Nlc3NCcmFja2V0UGFpcnMobGluZSwgckZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGxldCBvcHBvc2l0ZVR5cGUgPSBvdXRlclR5cGUgPT0gMSAvKiBULkwgKi8gPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovO1xuICAgIGZvciAobGV0IGlJID0gMCwgc0kgPSAwLCBjb250ZXh0ID0gMDsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgLy8gTjAuIFByb2Nlc3MgYnJhY2tldCBwYWlycyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlXG4gICAgICAgIC8vIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dCBwb3NpdGlvbnMgb2YgdGhlXG4gICAgICAgIC8vIG9wZW5pbmcgcGFpcmVkIGJyYWNrZXRzIHVzaW5nIHRoZSBsb2dpYyBnaXZlbiBiZWxvdy4gV2l0aGluIHRoaXNcbiAgICAgICAgLy8gc2NvcGUsIGJpZGlyZWN0aW9uYWwgdHlwZXMgRU4gYW5kIEFOIGFyZSB0cmVhdGVkIGFzIFIuXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBjaCwgYnIsIHR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBLZWVwcyBbc3RhcnRJbmRleCwgdHlwZSwgc3Ryb25nU2Vlbl0gdHJpcGxlcyBmb3IgZWFjaCBvcGVuXG4gICAgICAgICAgICAvLyBicmFja2V0IG9uIEJyYWNrZXRTdGFjay5cbiAgICAgICAgICAgIGlmIChiciA9IEJyYWNrZXRzW2NoID0gbGluZS5jaGFyQ29kZUF0KGkpXSkge1xuICAgICAgICAgICAgICAgIGlmIChiciA8IDApIHsgLy8gQ2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnJhY2tldFN0YWNrW3NKICsgMV0gPT0gLWJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAoZmxhZ3MgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLykgPyBvdXRlclR5cGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZsYWdzICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLykgPyBvcHBvc2l0ZVR5cGUgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZXNbQnJhY2tldFN0YWNrW3NKXV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNJID0gc0o7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQnJhY2tldFN0YWNrLmxlbmd0aCA9PSAxODkgLyogQnJhY2tldGVkLk1heERlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY2g7XG4gICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGUgPSB0eXBlc1tpXSkgPT0gMiAvKiBULlIgKi8gfHwgdHlwZSA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbWJlZCA9IHR5cGUgPT0gb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBlbWJlZCA/IDAgOiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzSiA9IHNJIC0gMzsgc0ogPj0gMDsgc0ogLT0gMykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW1iZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSiArIDJdIHw9IDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzTmV1dHJhbHMockZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGZvciAobGV0IGlJID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbiAgICAgICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXG4gICAgICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXG4gICAgICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuICAgICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTilcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAyNTYgLyogVC5OSSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpSSA9PSBpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpc29sYXRlc1tpSSsrXS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1tlbmRdID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiZWZvcmVMID0gcHJldiA9PSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXJMID0gKGVuZCA8IHJUbyA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlID0gYmVmb3JlTCA9PSBhZnRlckwgPyAoYmVmb3JlTCA/IDEgLyogVC5MICovIDogMiAvKiBULlIgKi8pIDogb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBlbmQsIGpJID0gaUksIGZyb21KID0gakkgPyBpc29sYXRlc1tqSSAtIDFdLnRvIDogckZyb207IGogPiBpOykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBmcm9tSikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGlzb2xhdGVzWy0takldLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tSiA9IGpJID8gaXNvbGF0ZXNbakkgLSAxXS50byA6IHJGcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzWy0tal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gRmluZCB0aGUgY29udGlndW91cyByYW5nZXMgb2YgY2hhcmFjdGVyIHR5cGVzIGluIGEgZ2l2ZW4gcmFuZ2UsIGFuZFxuLy8gZW1pdCBzcGFucyBmb3IgdGhlbS4gRmxpcCB0aGUgb3JkZXIgb2YgdGhlIHNwYW5zIGFzIGFwcHJvcHJpYXRlXG4vLyBiYXNlZCBvbiB0aGUgbGV2ZWwsIGFuZCBjYWxsIHRocm91Z2ggdG8gY29tcHV0ZSB0aGUgc3BhbnMgZm9yXG4vLyBpc29sYXRlcyBhdCB0aGUgcHJvcGVyIHBvaW50LlxuZnVuY3Rpb24gZW1pdFNwYW5zKGxpbmUsIGZyb20sIHRvLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgb3JkZXIpIHtcbiAgICBsZXQgb3VyVHlwZSA9IGxldmVsICUgMiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgaWYgKChsZXZlbCAlIDIpID09IChiYXNlTGV2ZWwgJSAyKSkgeyAvLyBTYW1lIGRpciBhcyBiYXNlIGRpcmVjdGlvbiwgZG9uJ3QgZmxpcFxuICAgICAgICBmb3IgKGxldCBpQ2ggPSBmcm9tLCBpSSA9IDA7IGlDaCA8IHRvOykge1xuICAgICAgICAgICAgLy8gU2NhbiBhIHNlY3Rpb24gb2YgY2hhcmFjdGVycyBpbiBkaXJlY3Rpb24gb3VyVHlwZSwgdW5sZXNzXG4gICAgICAgICAgICAvLyB0aGVyZSdzIGFub3RoZXIgdHlwZSBvZiBjaGFyIHJpZ2h0IGFmdGVyIGlDaCwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgLy8gd2Ugc2NhbiBhIHNlY3Rpb24gb2Ygb3RoZXIgY2hhcmFjdGVycyAod2hpY2gsIGlmIG91clR5cGUgPT1cbiAgICAgICAgICAgIC8vIFQuTCwgbWF5IGNvbnRhaW4gYm90aCBULlIgYW5kIFQuQU4gY2hhcnMpLlxuICAgICAgICAgICAgbGV0IHNhbWVEaXIgPSB0cnVlLCBpc051bSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlJID09IGlzb2xhdGVzLmxlbmd0aCB8fCBpQ2ggPCBpc29sYXRlc1tpSV0uZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdHlwZXNbaUNoXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBvdXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVEaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSBuZXh0ID09IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSG9sZHMgYW4gYXJyYXkgb2YgaXNvbGF0ZXMgdG8gcGFzcyB0byBhIHJlY3Vyc2l2ZSBjYWxsIGlmIHdlXG4gICAgICAgICAgICAvLyBtdXN0IHJlY3Vyc2UgKHRvIGRpc3Rpbmd1aXNoIFQuQU4gaW5zaWRlIGFuIFJUTCBzZWN0aW9uIGluXG4gICAgICAgICAgICAvLyBMVFIgdGV4dCksIG51bGwgaWYgd2UgY2FuIGVtaXQgZGlyZWN0bHlcbiAgICAgICAgICAgIGxldCByZWN1cnNlID0gIXNhbWVEaXIgJiYgb3VyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBsb2NhbExldmVsID0gc2FtZURpciA/IGxldmVsIDogbGV2ZWwgKyAxO1xuICAgICAgICAgICAgbGV0IGlTY2FuID0gaUNoO1xuICAgICAgICAgICAgcnVuOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlJIDwgaXNvbGF0ZXMubGVuZ3RoICYmIGlTY2FuID09IGlzb2xhdGVzW2lJXS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzbyA9IGlzb2xhdGVzW2lJXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBhaGVhZCB0byB2ZXJpZnkgdGhhdCB0aGVyZSBpcyBhbm90aGVyIGNoYXIgaW4gdGhpcyBkaXIgYWZ0ZXIgdGhlIGlzb2xhdGUocylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdXB0byA9IGlzby50bywgakkgPSBpSSArIDE7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHRvID09IHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpJIDwgaXNvbGF0ZXMubGVuZ3RoICYmIGlzb2xhdGVzW2pJXS5mcm9tID09IHVwdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwdG8gPSBpc29sYXRlc1tqSSsrXS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1t1cHRvXSA9PSBvdXJUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaUkrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UucHVzaChpc28pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzby5mcm9tID4gaUNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlDaCwgaXNvLmZyb20sIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXJTd2FwID0gKGlzby5kaXJlY3Rpb24gPT0gTFRSKSAhPSAhKGxvY2FsTGV2ZWwgJSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgZGlyU3dhcCA/IGxldmVsICsgMSA6IGxldmVsLCBiYXNlTGV2ZWwsIGlzby5pbm5lciwgaXNvLmZyb20sIGlzby50bywgb3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaUNoID0gaXNvLnRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuID0gaXNvLnRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpU2NhbiA9PSB0byB8fCAoc2FtZURpciA/IHR5cGVzW2lTY2FuXSAhPSBvdXJUeXBlIDogdHlwZXNbaVNjYW5dID09IG91clR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaVNjYW4rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdXJzZSlcbiAgICAgICAgICAgICAgICBlbWl0U3BhbnMobGluZSwgaUNoLCBpU2NhbiwgbGV2ZWwgKyAxLCBiYXNlTGV2ZWwsIHJlY3Vyc2UsIG9yZGVyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlDaCA8IGlTY2FuKVxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlDaCwgaVNjYW4sIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgIGlDaCA9IGlTY2FuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJdGVyYXRlIGluIHJldmVyc2UgdG8gZmxpcCB0aGUgc3BhbiBvcmRlci4gU2FtZSBjb2RlIGFnYWluLCBidXRcbiAgICAgICAgLy8gZ29pbmcgZnJvbSB0aGUgYmFjayBvZiB0aGUgc2VjdGlvbiB0byB0aGUgZnJvbnRcbiAgICAgICAgZm9yIChsZXQgaUNoID0gdG8sIGlJID0gaXNvbGF0ZXMubGVuZ3RoOyBpQ2ggPiBmcm9tOykge1xuICAgICAgICAgICAgbGV0IHNhbWVEaXIgPSB0cnVlLCBpc051bSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpSSB8fCBpQ2ggPiBpc29sYXRlc1tpSSAtIDFdLnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlc1tpQ2ggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBvdXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVEaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSBuZXh0ID09IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlY3Vyc2UgPSAhc2FtZURpciAmJiBvdXJUeXBlID09IDEgLyogVC5MICovID8gW10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGxvY2FsTGV2ZWwgPSBzYW1lRGlyID8gbGV2ZWwgOiBsZXZlbCArIDE7XG4gICAgICAgICAgICBsZXQgaVNjYW4gPSBpQ2g7XG4gICAgICAgICAgICBydW46IGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaUkgJiYgaVNjYW4gPT0gaXNvbGF0ZXNbaUkgLSAxXS50bykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc28gPSBpc29sYXRlc1stLWlJXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBhaGVhZCB0byB2ZXJpZnkgdGhhdCB0aGVyZSBpcyBhbm90aGVyIGNoYXIgaW4gdGhpcyBkaXIgYWZ0ZXIgdGhlIGlzb2xhdGUocylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdXB0byA9IGlzby5mcm9tLCBqSSA9IGlJOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXB0byA9PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpJICYmIGlzb2xhdGVzW2pJIC0gMV0udG8gPT0gdXB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0byA9IGlzb2xhdGVzWy0takldLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNbdXB0byAtIDFdID09IG91clR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZS5wdXNoKGlzbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvLnRvIDwgaUNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlzby50bywgaUNoLCBsb2NhbExldmVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlyU3dhcCA9IChpc28uZGlyZWN0aW9uID09IExUUikgIT0gIShsb2NhbExldmVsICUgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGRpclN3YXAgPyBsZXZlbCArIDEgOiBsZXZlbCwgYmFzZUxldmVsLCBpc28uaW5uZXIsIGlzby5mcm9tLCBpc28udG8sIG9yZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlDaCA9IGlzby5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuID0gaXNvLmZyb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuID09IGZyb20gfHwgKHNhbWVEaXIgPyB0eXBlc1tpU2NhbiAtIDFdICE9IG91clR5cGUgOiB0eXBlc1tpU2NhbiAtIDFdID09IG91clR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaVNjYW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdXJzZSlcbiAgICAgICAgICAgICAgICBlbWl0U3BhbnMobGluZSwgaVNjYW4sIGlDaCwgbGV2ZWwgKyAxLCBiYXNlTGV2ZWwsIHJlY3Vyc2UsIG9yZGVyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuIDwgaUNoKVxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlTY2FuLCBpQ2gsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgIGlDaCA9IGlTY2FuO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgZnJvbSwgdG8sIG9yZGVyKSB7XG4gICAgbGV0IG91dGVyVHlwZSA9IChsZXZlbCAlIDIgPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovKTtcbiAgICBjb21wdXRlQ2hhclR5cGVzKGxpbmUsIGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBwcm9jZXNzQnJhY2tldFBhaXJzKGxpbmUsIGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBwcm9jZXNzTmV1dHJhbHMoZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIGVtaXRTcGFucyhsaW5lLCBmcm9tLCB0bywgbGV2ZWwsIGJhc2VMZXZlbCwgaXNvbGF0ZXMsIG9yZGVyKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVPcmRlcihsaW5lLCBkaXJlY3Rpb24sIGlzb2xhdGVzKSB7XG4gICAgaWYgKCFsaW5lKVxuICAgICAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCAwLCBkaXJlY3Rpb24gPT0gUlRMID8gMSA6IDApXTtcbiAgICBpZiAoZGlyZWN0aW9uID09IExUUiAmJiAhaXNvbGF0ZXMubGVuZ3RoICYmICFCaWRpUkUudGVzdChsaW5lKSlcbiAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgaWYgKGlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgd2hpbGUgKGxpbmUubGVuZ3RoID4gdHlwZXMubGVuZ3RoKVxuICAgICAgICAgICAgdHlwZXNbdHlwZXMubGVuZ3RoXSA9IDI1NiAvKiBULk5JICovOyAvLyBNYWtlIHN1cmUgdHlwZXMgYXJyYXkgaGFzIG5vIGdhcHNcbiAgICBsZXQgb3JkZXIgPSBbXSwgbGV2ZWwgPSBkaXJlY3Rpb24gPT0gTFRSID8gMCA6IDE7XG4gICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBsZXZlbCwgbGV2ZWwsIGlzb2xhdGVzLCAwLCBsaW5lLmxlbmd0aCwgb3JkZXIpO1xuICAgIHJldHVybiBvcmRlcjtcbn1cbmZ1bmN0aW9uIHRyaXZpYWxPcmRlcihsZW5ndGgpIHtcbiAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCBsZW5ndGgsIDApXTtcbn1cbmxldCBtb3ZlZE92ZXIgPSBcIlwiO1xuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBtb3ZlcyBzdHJpY3RseSB2aXN1YWxseSwgd2l0aG91dCBjb25jZXJuIGZvciBhXG4vLyB0cmF2ZXJzYWwgdmlzaXRpbmcgZXZlcnkgbG9naWNhbCBwb3NpdGlvbiBpbiB0aGUgc3RyaW5nLiBJdCB3aWxsXG4vLyBzdGlsbCBkbyBzbyBmb3Igc2ltcGxlIGlucHV0LCBidXQgc2l0dWF0aW9ucyBsaWtlIG11bHRpcGxlIGlzb2xhdGVzXG4vLyB3aXRoIHRoZSBzYW1lIGxldmVsIG5leHQgdG8gZWFjaCBvdGhlciwgb3IgdGV4dCBnb2luZyBhZ2FpbnN0IHRoZVxuLy8gbWFpbiBkaXIgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSwgd2lsbCBtYWtlIHNvbWUgcG9zaXRpb25zXG4vLyB1bnJlYWNoYWJsZSB3aXRoIHRoaXMgbW90aW9uLiBFYWNoIHZpc2libGUgY3Vyc29yIHBvc2l0aW9uIHdpbGxcbi8vIGNvcnJlc3BvbmQgdG8gdGhlIGxvd2VyLWxldmVsIGJpZGkgc3BhbiB0aGF0IHRvdWNoZXMgaXQuXG4vL1xuLy8gVGhlIGFsdGVybmF0aXZlIHdvdWxkIGJlIHRvIHNvbHZlIGFuIG9yZGVyIGdsb2JhbGx5IGZvciBhIGdpdmVuXG4vLyBsaW5lLCBtYWtpbmcgc3VyZSB0aGF0IGl0IGluY2x1ZGVzIGV2ZXJ5IHBvc2l0aW9uLCBidXQgdGhhdCB3b3VsZFxuLy8gcmVxdWlyZSBhc3NvY2lhdGluZyBub24tY2Fub25pY2FsIChoaWdoZXIgYmlkaSBzcGFuIGxldmVsKVxuLy8gcG9zaXRpb25zIHdpdGggYSBnaXZlbiB2aXN1YWwgcG9zaXRpb24sIHdoaWNoIGlzIGxpa2VseSB0byBjb25mdXNlXG4vLyBwZW9wbGUuIChBbmQgd291bGQgZ2VuZXJhbGx5IGJlIGEgbG90IG1vcmUgY29tcGxpY2F0ZWQuKVxuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIG9yZGVyLCBkaXIsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaGVhZCAtIGxpbmUuZnJvbTtcbiAgICBsZXQgc3BhbkkgPSBCaWRpU3Bhbi5maW5kKG9yZGVyLCBzdGFydEluZGV4LCAoX2EgPSBzdGFydC5iaWRpTGV2ZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IHNwYW4gPSBvcmRlcltzcGFuSV0sIHNwYW5FbmQgPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKTtcbiAgICAvLyBFbmQgb2Ygc3BhblxuICAgIGlmIChzdGFydEluZGV4ID09IHNwYW5FbmQpIHtcbiAgICAgICAgbGV0IG5leHRJID0gc3BhbkkgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgaWYgKG5leHRJIDwgMCB8fCBuZXh0SSA+PSBvcmRlci5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgc3BhbiA9IG9yZGVyW3NwYW5JID0gbmV4dEldO1xuICAgICAgICBzdGFydEluZGV4ID0gc3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpO1xuICAgICAgICBzcGFuRW5kID0gc3Bhbi5zaWRlKGZvcndhcmQsIGRpcik7XG4gICAgfVxuICAgIGxldCBuZXh0SW5kZXggPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgc3RhcnRJbmRleCwgc3Bhbi5mb3J3YXJkKGZvcndhcmQsIGRpcikpO1xuICAgIGlmIChuZXh0SW5kZXggPCBzcGFuLmZyb20gfHwgbmV4dEluZGV4ID4gc3Bhbi50bylcbiAgICAgICAgbmV4dEluZGV4ID0gc3BhbkVuZDtcbiAgICBtb3ZlZE92ZXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4oc3RhcnRJbmRleCwgbmV4dEluZGV4KSwgTWF0aC5tYXgoc3RhcnRJbmRleCwgbmV4dEluZGV4KSk7XG4gICAgbGV0IG5leHRTcGFuID0gc3BhbkkgPT0gKGZvcndhcmQgPyBvcmRlci5sZW5ndGggLSAxIDogMCkgPyBudWxsIDogb3JkZXJbc3BhbkkgKyAoZm9yd2FyZCA/IDEgOiAtMSldO1xuICAgIGlmIChuZXh0U3BhbiAmJiBuZXh0SW5kZXggPT0gc3BhbkVuZCAmJiBuZXh0U3Bhbi5sZXZlbCArIChmb3J3YXJkID8gMCA6IDEpIDwgc3Bhbi5sZXZlbClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dFNwYW4uc2lkZSghZm9yd2FyZCwgZGlyKSArIGxpbmUuZnJvbSwgbmV4dFNwYW4uZm9yd2FyZChmb3J3YXJkLCBkaXIpID8gMSA6IC0xLCBuZXh0U3Bhbi5sZXZlbCk7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBzcGFuLmZvcndhcmQoZm9yd2FyZCwgZGlyKSA/IC0xIDogMSwgc3Bhbi5sZXZlbCk7XG59XG5mdW5jdGlvbiBhdXRvRGlyZWN0aW9uKHRleHQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgIGxldCB0eXBlID0gY2hhclR5cGUodGV4dC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gMSAvKiBULkwgKi8pXG4gICAgICAgICAgICByZXR1cm4gTFRSO1xuICAgICAgICBpZiAodHlwZSA9PSAyIC8qIFQuUiAqLyB8fCB0eXBlID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgIHJldHVybiBSVEw7XG4gICAgfVxuICAgIHJldHVybiBMVFI7XG59XG5cbmNvbnN0IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZHJhZ01vdmVzU2VsZWN0aW9uJDEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBtb3VzZVNlbGVjdGlvblN0eWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZXhjZXB0aW9uU2luayA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHVwZGF0ZUxpc3RlbmVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaW5wdXRIYW5kbGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZm9jdXNDaGFuZ2VFZmZlY3QgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjbGlwYm9hcmRJbnB1dEZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNsaXBib2FyZE91dHB1dEZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHBlckxpbmVUZXh0RGlyZWN0aW9uID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY29uc3QgbmF0aXZlU2VsZWN0aW9uSGlkZGVuID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY29uc3Qgc2Nyb2xsSGFuZGxlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIFNjcm9sbFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2UsIHkgPSBcIm5lYXJlc3RcIiwgeCA9IFwibmVhcmVzdFwiLCB5TWFyZ2luID0gNSwgeE1hcmdpbiA9IDUsIFxuICAgIC8vIFRoaXMgZGF0YSBzdHJ1Y3R1cmUgaXMgYWJ1c2VkIHRvIGFsc28gc3RvcmUgcHJlY2lzZSBzY3JvbGxcbiAgICAvLyBzbmFwc2hvdHMsIGluc3RlYWQgb2YgYSBgc2Nyb2xsSW50b1ZpZXdgIHJlcXVlc3QuIFdoZW4gdGhpc1xuICAgIC8vIGZsYWcgaXMgYHRydWVgLCBgcmFuZ2VgIHBvaW50cyBhdCBhIHBvc2l0aW9uIGluIHRoZSByZWZlcmVuY2VcbiAgICAvLyBsaW5lLCBgeU1hcmdpbmAgaG9sZHMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdG9wIG9mIHRoYXRcbiAgICAvLyBsaW5lIGFuZCB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIGFuZCBgeE1hcmdpbmAgaG9sZHMgdGhlXG4gICAgLy8gZWRpdG9yJ3MgYHNjcm9sbExlZnRgLlxuICAgIGlzU25hcHNob3QgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueU1hcmdpbiA9IHlNYXJnaW47XG4gICAgICAgIHRoaXMueE1hcmdpbiA9IHhNYXJnaW47XG4gICAgICAgIHRoaXMuaXNTbmFwc2hvdCA9IGlzU25hcHNob3Q7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5ID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgU2Nyb2xsVGFyZ2V0KHRoaXMucmFuZ2UubWFwKGNoYW5nZXMpLCB0aGlzLnksIHRoaXMueCwgdGhpcy55TWFyZ2luLCB0aGlzLnhNYXJnaW4sIHRoaXMuaXNTbmFwc2hvdCk7XG4gICAgfVxuICAgIGNsaXAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2UudG8gPD0gc3RhdGUuZG9jLmxlbmd0aCA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IFNjcm9sbFRhcmdldChFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXRlLmRvYy5sZW5ndGgpLCB0aGlzLnksIHRoaXMueCwgdGhpcy55TWFyZ2luLCB0aGlzLnhNYXJnaW4sIHRoaXMuaXNTbmFwc2hvdCk7XG4gICAgfVxufVxuY29uc3Qgc2Nyb2xsSW50b1ZpZXcgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiAodCwgY2gpID0+IHQubWFwKGNoKSB9KTtcbmNvbnN0IHNldEVkaXRDb250ZXh0Rm9ybWF0dGluZyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuTG9nIG9yIHJlcG9ydCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGluIGNsaWVudCBjb2RlLiBTaG91bGRcbnByb2JhYmx5IG9ubHkgYmUgdXNlZCBieSBleHRlbnNpb24gY29kZSB0aGF0IGFsbG93cyBjbGllbnQgY29kZSB0b1xucHJvdmlkZSBmdW5jdGlvbnMsIGFuZCBjYWxscyB0aG9zZSBmdW5jdGlvbnMgaW4gYSBjb250ZXh0IHdoZXJlIGFuXG5leGNlcHRpb24gY2FuJ3QgYmUgcHJvcGFnYXRlZCB0byBjYWxsaW5nIGNvZGUgaW4gYSByZWFzb25hYmxlIHdheVxuKGZvciBleGFtcGxlIHdoZW4gaW4gYW4gZXZlbnQgaGFuZGxlcikuXG5cbkVpdGhlciBjYWxscyBhIGhhbmRsZXIgcmVnaXN0ZXJlZCB3aXRoXG5bYEVkaXRvclZpZXcuZXhjZXB0aW9uU2lua2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmV4Y2VwdGlvblNpbmspLFxuYHdpbmRvdy5vbmVycm9yYCwgaWYgZGVmaW5lZCwgb3IgYGNvbnNvbGUuZXJyb3JgIChpbiB3aGljaCBjYXNlXG5pdCdsbCBwYXNzIGBjb250ZXh0YCwgd2hlbiBnaXZlbiwgYXMgZmlyc3QgYXJndW1lbnQpLlxuKi9cbmZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbihzdGF0ZSwgZXhjZXB0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IGhhbmRsZXIgPSBzdGF0ZS5mYWNldChleGNlcHRpb25TaW5rKTtcbiAgICBpZiAoaGFuZGxlci5sZW5ndGgpXG4gICAgICAgIGhhbmRsZXJbMF0oZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmICh3aW5kb3cub25lcnJvciAmJiB3aW5kb3cub25lcnJvcihTdHJpbmcoZXhjZXB0aW9uKSwgY29udGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4Y2VwdGlvbikpIDtcbiAgICBlbHNlIGlmIChjb250ZXh0KVxuICAgICAgICBjb25zb2xlLmVycm9yKGNvbnRleHQgKyBcIjpcIiwgZXhjZXB0aW9uKTtcbiAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXhjZXB0aW9uKTtcbn1cbmNvbnN0IGVkaXRhYmxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdHJ1ZSB9KTtcbmxldCBuZXh0UGx1Z2luSUQgPSAwO1xuY29uc3Qgdmlld1BsdWdpbiA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUocGx1Z2lucykge1xuICAgICAgICByZXR1cm4gcGx1Z2lucy5maWx0ZXIoKHAsIGkpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5zW2pdLnBsdWdpbiA9PSBwLnBsdWdpbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5WaWV3IHBsdWdpbnMgYXNzb2NpYXRlIHN0YXRlZnVsIHZhbHVlcyB3aXRoIGEgdmlldy4gVGhleSBjYW5cbmluZmx1ZW5jZSB0aGUgd2F5IHRoZSBjb250ZW50IGlzIGRyYXduLCBhbmQgYXJlIG5vdGlmaWVkIG9mIHRoaW5nc1xudGhhdCBoYXBwZW4gaW4gdGhlIHZpZXcuIFRoZXkgb3B0aW9uYWxseSB0YWtlIGFuIGFyZ3VtZW50LCBpblxud2hpY2ggY2FzZSB5b3UgbmVlZCB0byBjYWxsIFtgb2ZgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbi5vZikgdG8gY3JlYXRlXG5hbiBleHRlbnNpb24gZm9yIHRoZSBwbHVnaW4uIFdoZW4gdGhlIGFyZ3VtZW50IHR5cGUgaXMgdW5kZWZpbmVkLFxueW91IGNhbiB1c2UgdGhlIHBsdWdpbiBpbnN0YW5jZSBhcyBhbiBleHRlbnNpb24gZGlyZWN0bHkuXG4qL1xuY2xhc3MgVmlld1BsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpZCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjcmVhdGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tRXZlbnRIYW5kbGVycywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21FdmVudE9ic2VydmVycywgYnVpbGRFeHRlbnNpb25zKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRIYW5kbGVycyA9IGRvbUV2ZW50SGFuZGxlcnM7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRPYnNlcnZlcnMgPSBkb21FdmVudE9ic2VydmVycztcbiAgICAgICAgdGhpcy5iYXNlRXh0ZW5zaW9ucyA9IGJ1aWxkRXh0ZW5zaW9ucyh0aGlzKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSB0aGlzLmJhc2VFeHRlbnNpb25zLmNvbmNhdCh2aWV3UGx1Z2luLm9mKHsgcGx1Z2luOiB0aGlzLCBhcmc6IHVuZGVmaW5lZCB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIHRoaXMgcGx1Z2luIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50LlxuICAgICovXG4gICAgb2YoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VFeHRlbnNpb25zLmNvbmNhdCh2aWV3UGx1Z2luLm9mKHsgcGx1Z2luOiB0aGlzLCBhcmcgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBwbHVnaW4gZnJvbSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGVcbiAgICBwbHVnaW4ncyB2YWx1ZSwgZ2l2ZW4gYW4gZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNyZWF0ZSwgc3BlYykge1xuICAgICAgICBjb25zdCB7IGV2ZW50SGFuZGxlcnMsIGV2ZW50T2JzZXJ2ZXJzLCBwcm92aWRlLCBkZWNvcmF0aW9uczogZGVjbyB9ID0gc3BlYyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3UGx1Z2luKG5leHRQbHVnaW5JRCsrLCBjcmVhdGUsIGV2ZW50SGFuZGxlcnMsIGV2ZW50T2JzZXJ2ZXJzLCBwbHVnaW4gPT4ge1xuICAgICAgICAgICAgbGV0IGV4dCA9IFtdO1xuICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgZXh0LnB1c2goZGVjb3JhdGlvbnMub2YodmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW5JbnN0ID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkluc3QgPyBkZWNvKHBsdWdpbkluc3QpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKHByb3ZpZGUocGx1Z2luKSk7XG4gICAgICAgICAgICByZXR1cm4gZXh0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGZvciBhIGNsYXNzIHdob3NlIGNvbnN0cnVjdG9yIHRha2VzIGEgc2luZ2xlXG4gICAgZWRpdG9yIHZpZXcgYXMgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUNsYXNzKGNscywgc3BlYykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKHZpZXcsIGFyZykgPT4gbmV3IGNscyh2aWV3LCBhcmcpLCBzcGVjKTtcbiAgICB9XG59XG5jbGFzcyBQbHVnaW5JbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvLyBXaGVuIHN0YXJ0aW5nIGFuIHVwZGF0ZSwgYWxsIHBsdWdpbnMgaGF2ZSB0aGlzIGZpZWxkIHNldCB0byB0aGVcbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCwgaW5kaWNhdGluZyB0aGV5IG5lZWQgdG8gYmUgdXBkYXRlZC4gV2hlbiBmaW5pc2hlZFxuICAgICAgICAvLyB1cGRhdGluZywgaXQgaXMgc2V0IHRvIGBudWxsYC4gUmV0cmlldmluZyBhIHBsdWdpbiB0aGF0IG5lZWRzIHRvXG4gICAgICAgIC8vIGJlIHVwZGF0ZWQgd2l0aCBgdmlldy5wbHVnaW5gIGZvcmNlcyBhbiBlYWdlciB1cGRhdGUuXG4gICAgICAgIHRoaXMubXVzdFVwZGF0ZSA9IG51bGw7XG4gICAgICAgIC8vIFRoaXMgaXMgbnVsbCB3aGVuIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIGJ1dFxuICAgICAgICAvLyBpbml0aWFsaXplZCBvbiB0aGUgZmlyc3QgdXBkYXRlLlxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBsdWdpbigpIHsgcmV0dXJuIHRoaXMuc3BlYyAmJiB0aGlzLnNwZWMucGx1Z2luOyB9XG4gICAgdXBkYXRlKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcGVjKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3BlYy5wbHVnaW4uY3JlYXRlKHZpZXcsIHRoaXMuc3BlYy5hcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tdXN0VXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gdGhpcy5tdXN0VXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih1cGRhdGUuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSh2aWV3KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGVkaXRvckF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjb250ZW50QXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8vIFByb3ZpZGUgZGVjb3JhdGlvbnNcbmNvbnN0IGRlY29yYXRpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYmxvY2tXcmFwcGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IG91dGVyRGVjb3JhdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhdG9taWNSYW5nZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBiaWRpSXNvbGF0ZWRSYW5nZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5mdW5jdGlvbiBnZXRJc29sYXRlZFJhbmdlcyh2aWV3LCBsaW5lKSB7XG4gICAgbGV0IGlzb2xhdGVzID0gdmlldy5zdGF0ZS5mYWNldChiaWRpSXNvbGF0ZWRSYW5nZXMpO1xuICAgIGlmICghaXNvbGF0ZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gaXNvbGF0ZXM7XG4gICAgbGV0IHNldHMgPSBpc29sYXRlcy5tYXAoaSA9PiBpIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBpKHZpZXcpIDogaSk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIFJhbmdlU2V0LnNwYW5zKHNldHMsIGxpbmUuZnJvbSwgbGluZS50bywge1xuICAgICAgICBwb2ludCgpIHsgfSxcbiAgICAgICAgc3Bhbihmcm9tRG9jLCB0b0RvYywgYWN0aXZlLCBvcGVuKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGZyb21Eb2MgLSBsaW5lLmZyb20sIHRvID0gdG9Eb2MgLSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSByZXN1bHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tLCBvcGVuLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gYWN0aXZlW2ldLnNwZWMuYmlkaUlzb2xhdGUsIHVwZGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IGF1dG9EaXJlY3Rpb24obGluZS50ZXh0LCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW4gPiAwICYmIGxldmVsLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAodXBkYXRlID0gbGV2ZWxbbGV2ZWwubGVuZ3RoIC0gMV0pLnRvID09IGZyb20gJiYgdXBkYXRlLmRpcmVjdGlvbiA9PSBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlLnRvID0gdG87XG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gdXBkYXRlLmlubmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZCA9IHsgZnJvbSwgdG8sIGRpcmVjdGlvbiwgaW5uZXI6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgIGxldmVsLnB1c2goYWRkKTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSBhZGQuaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHNjcm9sbE1hcmdpbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5mdW5jdGlvbiBnZXRTY3JvbGxNYXJnaW5zKHZpZXcpIHtcbiAgICBsZXQgbGVmdCA9IDAsIHJpZ2h0ID0gMCwgdG9wID0gMCwgYm90dG9tID0gMDtcbiAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygdmlldy5zdGF0ZS5mYWNldChzY3JvbGxNYXJnaW5zKSkge1xuICAgICAgICBsZXQgbSA9IHNvdXJjZSh2aWV3KTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGlmIChtLmxlZnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgbS5sZWZ0KTtcbiAgICAgICAgICAgIGlmIChtLnJpZ2h0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgbS5yaWdodCk7XG4gICAgICAgICAgICBpZiAobS50b3AgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIG0udG9wKTtcbiAgICAgICAgICAgIGlmIChtLmJvdHRvbSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGJvdHRvbSwgbS5ib3R0b20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9O1xufVxuY29uc3Qgc3R5bGVNb2R1bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jbGFzcyBDaGFuZ2VkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpIHtcbiAgICAgICAgdGhpcy5mcm9tQSA9IGZyb21BO1xuICAgICAgICB0aGlzLnRvQSA9IHRvQTtcbiAgICAgICAgdGhpcy5mcm9tQiA9IGZyb21CO1xuICAgICAgICB0aGlzLnRvQiA9IHRvQjtcbiAgICB9XG4gICAgam9pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZWRSYW5nZShNYXRoLm1pbih0aGlzLmZyb21BLCBvdGhlci5mcm9tQSksIE1hdGgubWF4KHRoaXMudG9BLCBvdGhlci50b0EpLCBNYXRoLm1pbih0aGlzLmZyb21CLCBvdGhlci5mcm9tQiksIE1hdGgubWF4KHRoaXMudG9CLCBvdGhlci50b0IpKTtcbiAgICB9XG4gICAgYWRkVG9TZXQoc2V0KSB7XG4gICAgICAgIGxldCBpID0gc2V0Lmxlbmd0aCwgbWUgPSB0aGlzO1xuICAgICAgICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2V0W2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tQSA+IG1lLnRvQSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50b0EgPCBtZS5mcm9tQSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG1lID0gbWUuam9pbihyYW5nZSk7XG4gICAgICAgICAgICBzZXQuc3BsaWNlKGkgLSAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuc3BsaWNlKGksIDAsIG1lKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLy8gRXh0ZW5kIGEgc2V0IHRvIGNvdmVyIGFsbCB0aGUgY29udGVudCBpbiBgcmFuZ2VzYCwgd2hpY2ggaXMgYVxuICAgIC8vIGZsYXQgYXJyYXkgd2l0aCBlYWNoIHBhaXIgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgZnJvbUIvdG9CXG4gICAgLy8gcG9zaXRpb25zLiBUaGVzZSBwYWlycyBhcmUgZ2VuZXJhdGVkIGluIHVuY2hhbmdlZCByYW5nZXMsIHNvIHRoZVxuICAgIC8vIG9mZnNldCBiZXR3ZWVuIGRvYyBBIGFuZCBkb2MgQiBpcyB0aGUgc2FtZSBmb3IgdGhlaXIgc3RhcnQgYW5kXG4gICAgLy8gZW5kIHBvaW50cy5cbiAgICBzdGF0aWMgZXh0ZW5kV2l0aFJhbmdlcyhkaWZmLCByYW5nZXMpIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGRJID0gMCwgckkgPSAwLCBvZmYgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0RCA9IGRJIDwgZGlmZi5sZW5ndGggPyBkaWZmW2RJXS5mcm9tQiA6IDFlOTtcbiAgICAgICAgICAgIGxldCBuZXh0UiA9IHJJIDwgcmFuZ2VzLmxlbmd0aCA/IHJhbmdlc1tySV0gOiAxZTk7XG4gICAgICAgICAgICBsZXQgZnJvbUIgPSBNYXRoLm1pbihuZXh0RCwgbmV4dFIpO1xuICAgICAgICAgICAgaWYgKGZyb21CID09IDFlOSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBmcm9tQSA9IGZyb21CICsgb2ZmLCB0b0IgPSBmcm9tQiwgdG9BID0gZnJvbUE7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJJIDwgcmFuZ2VzLmxlbmd0aCAmJiByYW5nZXNbckldIDw9IHRvQikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gcmFuZ2VzW3JJICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHJJICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHRvQiA9IE1hdGgubWF4KHRvQiwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGRJOyBpIDwgZGlmZi5sZW5ndGggJiYgZGlmZltpXS5mcm9tQiA8PSB0b0I7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IGRpZmZbaV0udG9BIC0gZGlmZltpXS50b0I7XG4gICAgICAgICAgICAgICAgICAgIHRvQSA9IE1hdGgubWF4KHRvQSwgZW5kICsgb2ZmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZEkgPCBkaWZmLmxlbmd0aCAmJiBkaWZmW2RJXS5mcm9tQiA8PSB0b0IpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBkaWZmW2RJKytdO1xuICAgICAgICAgICAgICAgICAgICB0b0IgPSBNYXRoLm1heCh0b0IsIG5leHQudG9CKTtcbiAgICAgICAgICAgICAgICAgICAgdG9BID0gTWF0aC5tYXgodG9BLCBuZXh0LnRvQSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZiA9IG5leHQudG9BIC0gbmV4dC50b0I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgQ2hhbmdlZFJhbmdlKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVmlldyBbcGx1Z2luc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlZpZXdQbHVnaW4pIGFyZSBnaXZlbiBpbnN0YW5jZXMgb2YgdGhpc1xuY2xhc3MsIHdoaWNoIGRlc2NyaWJlIHdoYXQgaGFwcGVuZWQsIHdoZW5ldmVyIHRoZSB2aWV3IGlzIHVwZGF0ZWQuXG4qL1xuY2xhc3MgVmlld1VwZGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciB2aWV3IHRoYXQgdGhlIHVwZGF0ZSBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgKi9cbiAgICB2aWV3LCBcbiAgICAvKipcbiAgICBUaGUgbmV3IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgdHJhbnNhY3Rpb25zIGludm9sdmVkIGluIHRoZSB1cGRhdGUuIE1heSBiZSBlbXB0eS5cbiAgICAqL1xuICAgIHRyYW5zYWN0aW9ucykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBDaGFuZ2VTZXQuZW1wdHkodGhpcy5zdGFydFN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLmNoYW5nZXMuY29tcG9zZSh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiBjaGFuZ2VkUmFuZ2VzLnB1c2gobmV3IENoYW5nZWRSYW5nZShmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSkpO1xuICAgICAgICB0aGlzLmNoYW5nZWRSYW5nZXMgPSBjaGFuZ2VkUmFuZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUodmlldywgc3RhdGUsIHRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdVcGRhdGUodmlldywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSBbdmlld3BvcnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpZXdwb3J0KSBvclxuICAgIFt2aXNpYmxlIHJhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlzaWJsZVJhbmdlcykgY2hhbmdlZCBpbiB0aGlzXG4gICAgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuXG4gICAgW2B2aWV3cG9ydENoYW5nZWRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1VwZGF0ZS52aWV3cG9ydENoYW5nZWQpIGlzIHRydWVcbiAgICBhbmQgdGhlIHZpZXdwb3J0IGNoYW5nZSBpcyBub3QganVzdCB0aGUgcmVzdWx0IG9mIG1hcHBpbmcgaXQgaW5cbiAgICByZXNwb25zZSB0byBkb2N1bWVudCBjaGFuZ2VzLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0TW92ZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDggLyogVXBkYXRlRmxhZy5WaWV3cG9ydE1vdmVkICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBoZWlnaHQgb2YgYSBibG9jayBlbGVtZW50IGluIHRoZSBlZGl0b3JcbiAgICBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGhlaWdodENoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGRvY3VtZW50IHdhcyBtb2RpZmllZCBvciB0aGUgc2l6ZSBvZiB0aGVcbiAgICBlZGl0b3IsIG9yIGVsZW1lbnRzIHdpdGhpbiB0aGUgZWRpdG9yLCBjaGFuZ2VkLlxuICAgICovXG4gICAgZ2V0IGdlb21ldHJ5Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jQ2hhbmdlZCB8fCAodGhpcy5mbGFncyAmICgxNiAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgdXBkYXRlIGluZGljYXRlcyBhIGZvY3VzIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBmb2N1c0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBkb2N1bWVudCBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgc2V0IGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZsYWdzID09IDAgJiYgdGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoID09IDA7IH1cbn1cblxuY29uc3Qgbm9DaGlsZHJlbiA9IFtdO1xuY2xhc3MgVGlsZSB7XG4gICAgY29uc3RydWN0b3IoZG9tLCBsZW5ndGgsIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICBkb20uY21UaWxlID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IGJyZWFrQWZ0ZXIoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVGlsZUZsYWcuQnJlYWtBZnRlciAqLyk7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBub0NoaWxkcmVuOyB9XG4gICAgaXNXaWRnZXQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaXNDb21wb3NpdGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlzTGluZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaXNUZXh0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpc0Jsb2NrKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgZG9tQXR0cnMoKSB7IHJldHVybiBudWxsOyB9XG4gICAgc3luYyh0cmFjaykge1xuICAgICAgICB0aGlzLmZsYWdzIHw9IDIgLyogVGlsZUZsYWcuU3luY2VkICovO1xuICAgICAgICBpZiAodGhpcy5mbGFncyAmIDQgLyogVGlsZUZsYWcuQXR0cnNEaXJ0eSAqLykge1xuICAgICAgICAgICAgdGhpcy5mbGFncyAmPSB+NCAvKiBUaWxlRmxhZy5BdHRyc0RpcnR5ICovO1xuICAgICAgICAgICAgbGV0IGF0dHJzID0gdGhpcy5kb21BdHRycztcbiAgICAgICAgICAgIGlmIChhdHRycylcbiAgICAgICAgICAgICAgICBzZXRBdHRycyh0aGlzLmRvbSwgYXR0cnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gYCgke3RoaXMuY2hpbGRyZW59KWAgOiBcIlwiKSArICh0aGlzLmJyZWFrQWZ0ZXIgPyBcIiNcIiA6IFwiXCIpO1xuICAgIH1cbiAgICBkZXN0cm95KCkgeyB0aGlzLnBhcmVudCA9IG51bGw7IH1cbiAgICBzZXRET00oZG9tKSB7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICBkb20uY21UaWxlID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZSh0aGlzKSA6IDA7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3NCZWZvcmUodGlsZSwgc3RhcnQgPSB0aGlzLnBvc0F0U3RhcnQpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gdGlsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNoaWxkIGluIHBvc0JlZm9yZVwiKTtcbiAgICB9XG4gICAgcG9zQWZ0ZXIodGlsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUodGlsZSkgKyB0aWxlLmxlbmd0aDtcbiAgICB9XG4gICAgY292ZXJzKHNpZGUpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjb29yZHNJbihwb3MsIHNpZGUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBkb21Qb3NGb3Iob2ZmLCBzaWRlKSB7XG4gICAgICAgIGxldCBpbmRleCA9IGRvbUluZGV4KHRoaXMuZG9tKTtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5sZW5ndGggPyBvZmYgPiAwIDogc2lkZSA+IDA7XG4gICAgICAgIHJldHVybiBuZXcgRE9NUG9zKHRoaXMucGFyZW50LmRvbSwgaW5kZXggKyAoYWZ0ZXIgPyAxIDogMCksIG9mZiA9PSAwIHx8IG9mZiA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIG1hcmtEaXJ0eShhdHRycykge1xuICAgICAgICB0aGlzLmZsYWdzICY9IH4yIC8qIFRpbGVGbGFnLlN5bmNlZCAqLztcbiAgICAgICAgaWYgKGF0dHJzKVxuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0IC8qIFRpbGVGbGFnLkF0dHJzRGlydHkgKi87XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAodGhpcy5wYXJlbnQuZmxhZ3MgJiAyIC8qIFRpbGVGbGFnLlN5bmNlZCAqLykpXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5tYXJrRGlydHkoZmFsc2UpO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGdldCByb290KCkge1xuICAgICAgICBmb3IgKGxldCB0ID0gdGhpczsgdDsgdCA9IHQucGFyZW50KVxuICAgICAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBEb2NUaWxlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGdldChkb20pIHtcbiAgICAgICAgcmV0dXJuIGRvbS5jbVRpbGU7XG4gICAgfVxufVxuY2xhc3MgQ29tcG9zaXRlVGlsZSBleHRlbmRzIFRpbGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbSkge1xuICAgICAgICBzdXBlcihkb20sIDApO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgIH1cbiAgICBpc0NvbXBvc2l0ZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiB0aGlzLl9jaGlsZHJlbjsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA/IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA6IG51bGw7IH1cbiAgICBhcHBlbmQoY2hpbGQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB9XG4gICAgc3luYyh0cmFjaykge1xuICAgICAgICBpZiAodGhpcy5mbGFncyAmIDIgLyogVGlsZUZsYWcuU3luY2VkICovKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdXBlci5zeW5jKHRyYWNrKTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZG9tLCBwcmV2ID0gbnVsbCwgbmV4dDtcbiAgICAgICAgbGV0IHRyYWNraW5nID0gKHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5ub2RlKSA9PSBwYXJlbnQgPyB0cmFjayA6IG51bGw7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZC5zeW5jKHRyYWNrKTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAodHJhY2tpbmcgJiYgbmV4dCAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgdHJhY2tpbmcud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBybSQxKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZC5kb20sIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IGNoaWxkLmRvbTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRyYWNraW5nICYmIG5leHQpXG4gICAgICAgICAgICB0cmFja2luZy53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKG5leHQpXG4gICAgICAgICAgICBuZXh0ID0gcm0kMShuZXh0KTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxufVxuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0kMShkb20pIHtcbiAgICBsZXQgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICAgIHJldHVybiBuZXh0O1xufVxuLy8gVGhlIHRvcC1sZXZlbCB0aWxlLiBJdHMgZG9tIHByb3BlcnR5IGVxdWFscyB2aWV3LmNvbnRlbnRET00uXG5jbGFzcyBEb2NUaWxlIGV4dGVuZHMgQ29tcG9zaXRlVGlsZSB7XG4gICAgY29uc3RydWN0b3IodmlldywgZG9tKSB7XG4gICAgICAgIHN1cGVyKGRvbSk7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgfVxuICAgIG93bnModGlsZSkge1xuICAgICAgICBmb3IgKDsgdGlsZTsgdGlsZSA9IHRpbGUucGFyZW50KVxuICAgICAgICAgICAgaWYgKHRpbGUgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc0Jsb2NrKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIG5lYXJlc3QoZG9tKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICghZG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHRpbGUgPSBUaWxlLmdldChkb20pO1xuICAgICAgICAgICAgaWYgKHRpbGUgJiYgdGhpcy5vd25zKHRpbGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmxvY2tUaWxlcyhmKSB7XG4gICAgICAgIGZvciAobGV0IHN0YWNrID0gW10sIGN1ciA9IHRoaXMsIGkgPSAwLCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgIGlmIChpID09IGN1ci5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5icmVha0FmdGVyKVxuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGN1ci5jaGlsZHJlbltpKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgQmxvY2tXcmFwcGVyVGlsZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBwb3MgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGYobmV4dCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZW5kICsgbmV4dC5icmVha0FmdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBibG9jayBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIElmIHNpZGUgPCAtMSwgbWFrZSBzdXJlIHRvXG4gICAgLy8gc3RheSBiZWZvcmUgYmxvY2sgd2lkZ2V0cyBhdCB0aGF0IHBvc2l0aW9uLCBpZiBzaWRlID4gMSwgYWZ0ZXJcbiAgICAvLyBzdWNoIHdpZGdldHMgKHVzZWQgZm9yIHNlbGVjdGlvbiBkcmF3aW5nLCB3aGljaCBuZWVkcyB0byBiZSBhYmxlXG4gICAgLy8gdG8gZ2V0IGNvb3JkaW5hdGVzIGZvciBwb3NpdGlvbnMgdGhhdCBhcmVuJ3QgdmFsaWQgY3Vyc29yIHBvc2l0aW9ucykuXG4gICAgcmVzb2x2ZUJsb2NrKHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgYmVmb3JlLCBiZWZvcmVPZmYgPSAtMSwgYWZ0ZXIsIGFmdGVyT2ZmID0gLTE7XG4gICAgICAgIHRoaXMuYmxvY2tUaWxlcygodGlsZSwgb2ZmKSA9PiB7XG4gICAgICAgICAgICBsZXQgZW5kID0gb2ZmICsgdGlsZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID49IG9mZiAmJiBwb3MgPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbGUuaXNXaWRnZXQoKSAmJiBzaWRlID49IC0xICYmIHNpZGUgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZS5mbGFncyAmIDMyIC8qIFRpbGVGbGFnLkFmdGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWxlLmZsYWdzICYgMTYgLyogVGlsZUZsYWcuQmVmb3JlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKG9mZiA8IHBvcyB8fCBwb3MgPT0gZW5kICYmIChzaWRlIDwgLTEgPyB0aWxlLmxlbmd0aCA6IHRpbGUuY292ZXJzKDEpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZWZvcmUgfHwgIXRpbGUuaXNXaWRnZXQoKSAmJiBiZWZvcmUuaXNXaWRnZXQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gdGlsZTtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlT2ZmID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGVuZCA+IHBvcyB8fCBwb3MgPT0gb2ZmICYmIChzaWRlID4gMSA/IHRpbGUubGVuZ3RoIDogdGlsZS5jb3ZlcnMoLTEpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFhZnRlciB8fCAhdGlsZS5pc1dpZGdldCgpICYmIGFmdGVyLmlzV2lkZ2V0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gdGlsZTtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJPZmYgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFiZWZvcmUgJiYgIWFmdGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGlsZSBhdCBwb3NpdGlvbiBcIiArIHBvcyk7XG4gICAgICAgIHJldHVybiBiZWZvcmUgJiYgc2lkZSA8IDAgfHwgIWFmdGVyID8geyB0aWxlOiBiZWZvcmUsIG9mZnNldDogYmVmb3JlT2ZmIH0gOiB7IHRpbGU6IGFmdGVyLCBvZmZzZXQ6IGFmdGVyT2ZmIH07XG4gICAgfVxufVxuY2xhc3MgQmxvY2tXcmFwcGVyVGlsZSBleHRlbmRzIENvbXBvc2l0ZVRpbGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbSwgd3JhcHBlcikge1xuICAgICAgICBzdXBlcihkb20pO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSB3cmFwcGVyO1xuICAgIH1cbiAgICBpc0Jsb2NrKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGNvdmVycyhzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBzaWRlIDwgMCA/IHRoaXMuY2hpbGRyZW5bMF0uY292ZXJzKC0xKSA6IHRoaXMubGFzdENoaWxkLmNvdmVycygxKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0dHJzKCkgeyByZXR1cm4gdGhpcy53cmFwcGVyLmF0dHJpYnV0ZXM7IH1cbiAgICBzdGF0aWMgb2Yod3JhcHBlciwgZG9tKSB7XG4gICAgICAgIGxldCB0aWxlID0gbmV3IEJsb2NrV3JhcHBlclRpbGUoZG9tIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQod3JhcHBlci50YWdOYW1lKSwgd3JhcHBlcik7XG4gICAgICAgIGlmICghZG9tKVxuICAgICAgICAgICAgdGlsZS5mbGFncyB8PSA0IC8qIFRpbGVGbGFnLkF0dHJzRGlydHkgKi87XG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgIH1cbn1cbmNsYXNzIExpbmVUaWxlIGV4dGVuZHMgQ29tcG9zaXRlVGlsZSB7XG4gICAgY29uc3RydWN0b3IoZG9tLCBhdHRycykge1xuICAgICAgICBzdXBlcihkb20pO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgfVxuICAgIGlzTGluZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBzdGF0aWMgc3RhcnQoYXR0cnMsIGRvbSwga2VlcEF0dHJzKSB7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IExpbmVUaWxlKGRvbSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBhdHRycyk7XG4gICAgICAgIGlmICghZG9tIHx8ICFrZWVwQXR0cnMpXG4gICAgICAgICAgICBsaW5lLmZsYWdzIHw9IDQgLyogVGlsZUZsYWcuQXR0cnNEaXJ0eSAqLztcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIGdldCBkb21BdHRycygpIHsgcmV0dXJuIHRoaXMuYXR0cnM7IH1cbiAgICAvLyBGaW5kIHRoZSB0aWxlIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHBvc2l0aW9uIGluIHRoaXMgbGluZS5cbiAgICByZXNvbHZlSW5saW5lKHBvcywgc2lkZSwgZm9yQ29vcmRzKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSBudWxsLCBiZWZvcmVPZmYgPSAtMSwgYWZ0ZXIgPSBudWxsLCBhZnRlck9mZiA9IC0xO1xuICAgICAgICBmdW5jdGlvbiBzY2FuKHRpbGUsIHBvcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCB0aWxlLmNoaWxkcmVuLmxlbmd0aCAmJiBvZmYgPD0gcG9zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aWxlLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzQ29tcG9zaXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW4oY2hpbGQsIHBvcyAtIG9mZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKCFhZnRlciB8fCBhZnRlci5pc0hpZGRlbiAmJiAoc2lkZSA+IDAgfHwgZm9yQ29vcmRzICYmIG9uU2FtZUxpbmUoYWZ0ZXIsIGNoaWxkKSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZW5kID4gcG9zIHx8IChjaGlsZC5mbGFncyAmIDMyIC8qIFRpbGVGbGFnLkFmdGVyICovKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlck9mZiA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmYgPCBwb3MgfHwgKGNoaWxkLmZsYWdzICYgMTYgLyogVGlsZUZsYWcuQmVmb3JlICovKSAmJiAhY2hpbGQuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlT2ZmID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2FuKHRoaXMsIHBvcyk7XG4gICAgICAgIGxldCB0YXJnZXQgPSAoKHNpZGUgPCAwID8gYmVmb3JlIDogYWZ0ZXIpIHx8IGJlZm9yZSB8fCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0YXJnZXQgPyB7IHRpbGU6IHRhcmdldCwgb2Zmc2V0OiB0YXJnZXQgPT0gYmVmb3JlID8gYmVmb3JlT2ZmIDogYWZ0ZXJPZmYgfSA6IG51bGw7XG4gICAgfVxuICAgIGNvb3Jkc0luKHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLnJlc29sdmVJbmxpbmUocG9zLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFja1JlY3QodGhpcyk7XG4gICAgICAgIHJldHVybiBmb3VuZC50aWxlLmNvb3Jkc0luKE1hdGgubWF4KDAsIGZvdW5kLm9mZnNldCksIHNpZGUpO1xuICAgIH1cbiAgICBkb21Jbihwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5yZXNvbHZlSW5saW5lKHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgbGV0IHsgdGlsZSwgb2Zmc2V0IH0gPSBmb3VuZDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbS5jb250YWlucyh0aWxlLmRvbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5pc1RleHQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBET01Qb3ModGlsZS5kb20sIE1hdGgubWluKHRpbGUuZG9tLm5vZGVWYWx1ZS5sZW5ndGgsIG9mZnNldCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlLmRvbVBvc0ZvcihvZmZzZXQsIHRpbGUuZmxhZ3MgJiAxNiAvKiBUaWxlRmxhZy5CZWZvcmUgKi8gPyAxIDogdGlsZS5mbGFncyAmIDMyIC8qIFRpbGVGbGFnLkFmdGVyICovID8gLTEgOiBzaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBmb3VuZC50aWxlLnBhcmVudCwgc2F3ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiBwYXJlbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2F3KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERPTVBvcyhjaC5kb20sIDApO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSBmb3VuZC50aWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRE9NUG9zKHRoaXMuZG9tLCAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmYWxsYmFja1JlY3QodGlsZSkge1xuICAgIGxldCBsYXN0ID0gdGlsZS5kb20ubGFzdENoaWxkO1xuICAgIGlmICghbGFzdClcbiAgICAgICAgcmV0dXJuIHRpbGUuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGxhc3QpO1xuICAgIHJldHVybiByZWN0c1tyZWN0cy5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxuZnVuY3Rpb24gb25TYW1lTGluZShhLCBiKSB7XG4gICAgbGV0IHBvc0EgPSBhLmNvb3Jkc0luKDAsIDEpLCBwb3NCID0gYi5jb29yZHNJbigwLCAxKTtcbiAgICByZXR1cm4gcG9zQSAmJiBwb3NCICYmIHBvc0IudG9wIDwgcG9zQS5ib3R0b207XG59XG5jbGFzcyBNYXJrVGlsZSBleHRlbmRzIENvbXBvc2l0ZVRpbGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbSwgbWFyaykge1xuICAgICAgICBzdXBlcihkb20pO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBnZXQgZG9tQXR0cnMoKSB7IHJldHVybiB0aGlzLm1hcmsuYXR0cnM7IH1cbiAgICBzdGF0aWMgb2YobWFyaywgZG9tKSB7XG4gICAgICAgIGxldCB0aWxlID0gbmV3IE1hcmtUaWxlKGRvbSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG1hcmsudGFnTmFtZSksIG1hcmspO1xuICAgICAgICBpZiAoIWRvbSlcbiAgICAgICAgICAgIHRpbGUuZmxhZ3MgfD0gNCAvKiBUaWxlRmxhZy5BdHRyc0RpcnR5ICovO1xuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9XG59XG5jbGFzcyBUZXh0VGlsZSBleHRlbmRzIFRpbGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbSwgdGV4dCkge1xuICAgICAgICBzdXBlcihkb20sIHRleHQubGVuZ3RoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgc3luYyh0cmFjaykge1xuICAgICAgICBpZiAodGhpcy5mbGFncyAmIDIgLyogVGlsZUZsYWcuU3luY2VkICovKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdXBlci5zeW5jKHRyYWNrKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tLm5vZGVWYWx1ZSAhPSB0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5ub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20ubm9kZVZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzVGV4dCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudGV4dCk7IH1cbiAgICBjb29yZHNJbihwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMuZG9tLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChwb3MgPiBsZW5ndGgpXG4gICAgICAgICAgICBwb3MgPSBsZW5ndGg7XG4gICAgICAgIGxldCBmcm9tID0gcG9zLCB0byA9IHBvcywgZmxhdHRlbiA9IDA7XG4gICAgICAgIGlmIChwb3MgPT0gMCAmJiBzaWRlIDwgMCB8fCBwb3MgPT0gbGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICAgICAgaWYgKCEoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykpIHsgLy8gVGhlc2UgYnJvd3NlcnMgcmVsaWFibHkgcmV0dXJuIHZhbGlkIHJlY3RhbmdsZXMgZm9yIGVtcHR5IHJhbmdlc1xuICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuID0gMTtcbiAgICAgICAgICAgICAgICB9IC8vIEZJWE1FIHRoaXMgaXMgd3JvbmcgaW4gUlRMIHRleHRcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0byA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNpZGUgPCAwKVxuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKHRoaXMuZG9tLCBmcm9tLCB0bykuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHJlY3QgPSByZWN0c1soZmxhdHRlbiA/IGZsYXR0ZW4gPCAwIDogc2lkZSA+PSAwKSA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFmbGF0dGVuICYmIHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgICAgIHJlY3QgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCByID0+IHIud2lkdGgpIHx8IHJlY3Q7XG4gICAgICAgIHJldHVybiBmbGF0dGVuID8gZmxhdHRlblJlY3QocmVjdCwgZmxhdHRlbiA8IDApIDogcmVjdCB8fCBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgb2YodGV4dCwgZG9tKSB7XG4gICAgICAgIGxldCB0aWxlID0gbmV3IFRleHRUaWxlKGRvbSB8fCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSwgdGV4dCk7XG4gICAgICAgIGlmICghZG9tKVxuICAgICAgICAgICAgdGlsZS5mbGFncyB8PSAyIC8qIFRpbGVGbGFnLlN5bmNlZCAqLztcbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfVxufVxuY2xhc3MgV2lkZ2V0VGlsZSBleHRlbmRzIFRpbGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbSwgbGVuZ3RoLCB3aWRnZXQsIGZsYWdzKSB7XG4gICAgICAgIHN1cGVyKGRvbSwgbGVuZ3RoLCBmbGFncyk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgIH1cbiAgICBpc1dpZGdldCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0aGlzLndpZGdldC5pc0hpZGRlbjsgfVxuICAgIGNvdmVycyhzaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzICYgNDggLyogVGlsZUZsYWcuUG9pbnRXaWRnZXQgKi8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIChzaWRlIDwgMCA/IDY0IC8qIFRpbGVGbGFnLkluY1N0YXJ0ICovIDogMTI4IC8qIFRpbGVGbGFnLkluY0VuZCAqLykpID4gMDtcbiAgICB9XG4gICAgY29vcmRzSW4ocG9zLCBzaWRlKSB7IHJldHVybiB0aGlzLmNvb3Jkc0luV2lkZ2V0KHBvcywgc2lkZSwgZmFsc2UpOyB9XG4gICAgY29vcmRzSW5XaWRnZXQocG9zLCBzaWRlLCBibG9jaykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy53aWRnZXQuY29vcmRzQXQodGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuUmVjdCh0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdGhpcy5sZW5ndGggPyBwb3MgPT0gMCA6IHNpZGUgPD0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSB0aGlzLmRvbS5nZXRDbGllbnRSZWN0cygpLCByZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IGZyb21CYWNrID0gKHRoaXMuZmxhZ3MgJiAxNiAvKiBUaWxlRmxhZy5CZWZvcmUgKi8pID8gdHJ1ZSA6ICh0aGlzLmZsYWdzICYgMzIgLyogVGlsZUZsYWcuQWZ0ZXIgKi8pID8gZmFsc2UgOiBwb3MgPiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21CYWNrID8gcmVjdHMubGVuZ3RoIC0gMSA6IDA7OyBpICs9IChmcm9tQmFjayA/IC0xIDogMSkpIHtcbiAgICAgICAgICAgICAgICByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IDAgPyBpID09IDAgOiBpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblJlY3QocmVjdCwgIWZyb21CYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIGxldCB7IHJvb3QgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcm9vdClcbiAgICAgICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIHJldHVybiByb290LnZpZXcuc3RhdGUuZG9jLnNsaWNlKHN0YXJ0LCBzdGFydCArIHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG4gICAgc3RhdGljIG9mKHdpZGdldCwgdmlldywgbGVuZ3RoLCBmbGFncywgZG9tKSB7XG4gICAgICAgIGlmICghZG9tKSB7XG4gICAgICAgICAgICBkb20gPSB3aWRnZXQudG9ET00odmlldyk7XG4gICAgICAgICAgICBpZiAoIXdpZGdldC5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2lkZ2V0VGlsZShkb20sIGxlbmd0aCwgd2lkZ2V0LCBmbGFncyk7XG4gICAgfVxufVxuLy8gVGhlc2UgYXJlIGRyYXduIGFyb3VuZCB1bmVkaXRhYmxlIHdpZGdldHMgdG8gYXZvaWQgYSBudW1iZXIgb2Zcbi8vIGJyb3dzZXIgYnVncyB0aGF0IHNob3cgdXAgd2hlbiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IG5leHQgdG9cbi8vIHVuZWRpdGFibGUgaW5saW5lIGNvbnRlbnQuXG5jbGFzcyBXaWRnZXRCdWZmZXJUaWxlIGV4dGVuZHMgVGlsZSB7XG4gICAgY29uc3RydWN0b3IoZmxhZ3MpIHtcbiAgICAgICAgbGV0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIGltZy5jbGFzc05hbWUgPSBcImNtLXdpZGdldEJ1ZmZlclwiO1xuICAgICAgICBpbWcuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICBzdXBlcihpbWcsIDAsIGZsYWdzKTtcbiAgICB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBUZXh0LmVtcHR5OyB9XG4gICAgY29vcmRzSW4ocG9zKSB7IHJldHVybiB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfVxufVxuLy8gUmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSB0aWxlIHRyZWUuXG5jbGFzcyBUaWxlUG9pbnRlciB7XG4gICAgY29uc3RydWN0b3IodG9wKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJlZm9yZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnRpbGUgPSB0b3A7XG4gICAgfVxuICAgIC8vIEFkdmFuY2UgYnkgdGhlIGdpdmVuIGRpc3RhbmNlLiBJZiBzaWRlIGlzIC0xLCBzdG9wIGxlYXZpbmcgb3JcbiAgICAvLyBlbnRlcmluZyB0aWxlcywgb3Igc2tpcHBpbmcgemVyby1sZW5ndGggdGlsZXMsIG9uY2UgdGhlIGRpc3RhbmNlXG4gICAgLy8gaGFzIGJlZW4gdHJhdmVyc2VkLiBXaGVuIHNpZGUgaXMgMSwgbGVhdmUsIGVudGVyLCBvciBza2lwXG4gICAgLy8gZXZlcnl0aGluZyBhdCB0aGUgZW5kIHBvc2l0aW9uLlxuICAgIGFkdmFuY2UoZGlzdCwgc2lkZSwgd2Fsa2VyKSB7XG4gICAgICAgIGxldCB7IHRpbGUsIGluZGV4LCBiZWZvcmVCcmVhaywgcGFyZW50cyB9ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGRpc3QgfHwgc2lkZSA+IDApIHtcbiAgICAgICAgICAgIGlmICghdGlsZS5pc0NvbXBvc2l0ZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRpbGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUJyZWFrID0gISF0aWxlLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgICh7IHRpbGUsIGluZGV4IH0gPSBwYXJlbnRzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFrZSA9IE1hdGgubWluKGRpc3QsIHRpbGUubGVuZ3RoIC0gaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Fsa2VyKVxuICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLnNraXAodGlsZSwgaW5kZXgsIGluZGV4ICsgdGFrZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgLT0gdGFrZTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gdGFrZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWZvcmVCcmVhaykge1xuICAgICAgICAgICAgICAgIGlmICghZGlzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHdhbGtlcilcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgZGlzdC0tO1xuICAgICAgICAgICAgICAgIGJlZm9yZUJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PSB0aWxlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghZGlzdCAmJiAhcGFyZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICh3YWxrZXIpXG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5sZWF2ZSh0aWxlKTtcbiAgICAgICAgICAgICAgICBiZWZvcmVCcmVhayA9ICEhdGlsZS5icmVha0FmdGVyO1xuICAgICAgICAgICAgICAgICh7IHRpbGUsIGluZGV4IH0gPSBwYXJlbnRzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aWxlLmNoaWxkcmVuW2luZGV4XSwgYnJrID0gbmV4dC5icmVha0FmdGVyO1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBuZXh0Lmxlbmd0aCA8PSBkaXN0IDogbmV4dC5sZW5ndGggPCBkaXN0KSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXdhbGtlciB8fCB3YWxrZXIuc2tpcChuZXh0LCAwLCBuZXh0Lmxlbmd0aCkgIT09IGZhbHNlIHx8ICFuZXh0LmlzQ29tcG9zaXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVCcmVhayA9ICEhYnJrO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBkaXN0IC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHsgdGlsZSwgaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxrZXIgJiYgbmV4dC5pc0NvbXBvc2l0ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmVudGVyKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbGUgPSB0aWxlO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYmVmb3JlQnJlYWsgPSBiZWZvcmVCcmVhaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCByb290KCkgeyByZXR1cm4gKHRoaXMucGFyZW50cy5sZW5ndGggPyB0aGlzLnBhcmVudHNbMF0udGlsZSA6IHRoaXMudGlsZSk7IH1cbn1cblxuLy8gVXNlZCB0byB0cmFjayBvcGVuIGJsb2NrIHdyYXBwZXJzXG5jbGFzcyBPcGVuV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHdyYXBwZXIsIHJhbmspIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSB3cmFwcGVyO1xuICAgICAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgIH1cbn1cbi8vIFRoaXMgY2xhc3MgYnVpbGRzIHVwIGEgbmV3IGRvY3VtZW50IHRpbGUgdXNpbmcgaW5wdXQgZnJvbSBlaXRoZXJcbi8vIGl0ZXJhdGlvbiBvdmVyIHRoZSBvbGQgdHJlZSBvciBpdGVyYXRpb24gb3ZlciB0aGUgZG9jdW1lbnQgK1xuLy8gZGVjb3JhdGlvbnMuIFRoZSBhZGQqIG1ldGhvZHMgZW1pdCBlbGVtZW50cyBpbnRvIHRoZSB0aWxlXG4vLyBzdHJ1Y3R1cmUuIFRvIGF2b2lkIGF3a3dhcmQgc3luY2hyb25pemF0aW9uIGlzc3VlcywgbWFya3MgYW5kIGJsb2NrXG4vLyB3cmFwcGVycyBhcmUgdHJlYXRlZCBhcyBiZWxvbmdpbmcgdG8gdG8gdGhlaXIgY29udGVudCwgcmF0aGVyIHRoYW5cbi8vIG9wZW5lZC9jbG9zZWQgaW5kZXBlbmRlbnRseS5cbi8vXG4vLyBBbGwgY29tcG9zaXRlIHRpbGVzIHRoYXQgYXJlIHRvdWNoZWQgYnkgY2hhbmdlcyBhcmUgcmVidWlsdCxcbi8vIHJldXNpbmcgYXMgbXVjaCBvZiB0aGUgb2xkIHRyZWUgKGVpdGhlciB3aG9sZSBub2RlcyBvciBqdXN0IERPTVxuLy8gZWxlbWVudHMpIGFzIHBvc3NpYmxlLiBUaGUgbmV3IHRyZWUgaXMgYnVpbHQgd2l0aG91dCB0aGUgU3luY2VkXG4vLyBmbGFnLCBhbmQgdGhlbiBzeW5jZWQgKGR1cmluZyB3aGljaCBET00gcGFyZW50L2NoaWxkIHJlbGF0aW9ucyBhcmVcbi8vIGZpeGVkIHVwLCB0ZXh0IG5vZGVzIGZpbGxlZCBpbiwgYW5kIGF0dHJpYnV0ZXMgYWRkZWQpIGluIGEgc2Vjb25kXG4vLyBwaGFzZS5cbmNsYXNzIFRpbGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWNoZSwgcm9vdCwgYmxvY2tXcmFwcGVycykge1xuICAgICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuYmxvY2tXcmFwcGVycyA9IGJsb2NrV3JhcHBlcnM7XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEJsb2NrID0gbnVsbDtcbiAgICAgICAgdGhpcy5hZnRlcldpZGdldCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy53cmFwcGVycyA9IFtdO1xuICAgICAgICB0aGlzLndyYXBwZXJQb3MgPSAwO1xuICAgIH1cbiAgICBhZGRUZXh0KHRleHQsIG1hcmtzLCBvcGVuU3RhcnQsIHRpbGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmVuc3VyZU1hcmtzKG1hcmtzLCBvcGVuU3RhcnQpO1xuICAgICAgICBsZXQgcHJldiA9IHBhcmVudC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmIChwcmV2ICYmIHByZXYuaXNUZXh0KCkgJiYgIShwcmV2LmZsYWdzICYgOCAvKiBUaWxlRmxhZy5Db21wb3NpdGlvbiAqLykgJiYgcHJldi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCA8IDUxMiAvKiBDLkNodW5rICovKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnJldXNlZC5zZXQocHJldiwgMiAvKiBSZXVzZWQuRE9NICovKTtcbiAgICAgICAgICAgIGxldCB0aWxlID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IG5ldyBUZXh0VGlsZShwcmV2LmRvbSwgcHJldi50ZXh0ICsgdGV4dCk7XG4gICAgICAgICAgICB0aWxlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmQodGlsZSB8fCBUZXh0VGlsZS5vZih0ZXh0LCAoX2EgPSB0aGlzLmNhY2hlLmZpbmQoVGV4dFRpbGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZG9tKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuYWZ0ZXJXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBhZGRDb21wb3NpdGlvbihjb21wb3NpdGlvbiwgY29udGV4dCkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuY3VyTGluZTtcbiAgICAgICAgaWYgKGxpbmUuZG9tICE9IGNvbnRleHQubGluZS5kb20pIHtcbiAgICAgICAgICAgIGxpbmUuc2V0RE9NKHRoaXMuY2FjaGUucmV1c2VkLmhhcyhjb250ZXh0LmxpbmUpID8gZnJlZU5vZGUoY29udGV4dC5saW5lLmRvbSkgOiBjb250ZXh0LmxpbmUuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUucmV1c2VkLnNldChjb250ZXh0LmxpbmUsIDIgLyogUmV1c2VkLkRPTSAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhlYWQgPSBsaW5lO1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5tYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IG1hcmsgPSBjb250ZXh0Lm1hcmtzW2ldO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBoZWFkLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgTWFya1RpbGUgJiYgbGFzdC5tYXJrLmVxKG1hcmsubWFyaykpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdC5kb20gIT0gbWFyay5kb20pXG4gICAgICAgICAgICAgICAgICAgIGxhc3Quc2V0RE9NKGZyZWVOb2RlKG1hcmsuZG9tKSk7XG4gICAgICAgICAgICAgICAgaGVhZCA9IGxhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWNoZS5yZXVzZWQuZ2V0KG1hcmspKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0aWxlID0gVGlsZS5nZXQobWFyay5kb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUuc2V0RE9NKGZyZWVOb2RlKG1hcmsuZG9tKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBudyA9IE1hcmtUaWxlLm9mKG1hcmsubWFyaywgbWFyay5kb20pO1xuICAgICAgICAgICAgICAgIGhlYWQuYXBwZW5kKG53KTtcbiAgICAgICAgICAgICAgICBoZWFkID0gbnc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnJldXNlZC5zZXQobWFyaywgMiAvKiBSZXVzZWQuRE9NICovKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2xkVGlsZSA9IFRpbGUuZ2V0KGNvbXBvc2l0aW9uLnRleHQpO1xuICAgICAgICBpZiAob2xkVGlsZSlcbiAgICAgICAgICAgIHRoaXMuY2FjaGUucmV1c2VkLnNldChvbGRUaWxlLCAyIC8qIFJldXNlZC5ET00gKi8pO1xuICAgICAgICBsZXQgdGV4dCA9IG5ldyBUZXh0VGlsZShjb21wb3NpdGlvbi50ZXh0LCBjb21wb3NpdGlvbi50ZXh0Lm5vZGVWYWx1ZSk7XG4gICAgICAgIHRleHQuZmxhZ3MgfD0gOCAvKiBUaWxlRmxhZy5Db21wb3NpdGlvbiAqLztcbiAgICAgICAgaGVhZC5hcHBlbmQodGV4dCk7XG4gICAgfVxuICAgIGFkZElubGluZVdpZGdldCh3aWRnZXQsIG1hcmtzLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgLy8gQWRqYWNlbnQgc2FtZS1zaWRlLWZhY2luZyBub24tcmVwbGFjaW5nIHdpZGdldHMgZG9uJ3QgbmVlZCBidWZmZXJzIGJldHdlZW4gdGhlbVxuICAgICAgICBsZXQgbm9TcGFjZSA9IHRoaXMuYWZ0ZXJXaWRnZXQgJiYgKHdpZGdldC5mbGFncyAmIDQ4IC8qIFRpbGVGbGFnLlBvaW50V2lkZ2V0ICovKSAmJlxuICAgICAgICAgICAgKHRoaXMuYWZ0ZXJXaWRnZXQuZmxhZ3MgJiA0OCAvKiBUaWxlRmxhZy5Qb2ludFdpZGdldCAqLykgPT0gKHdpZGdldC5mbGFncyAmIDQ4IC8qIFRpbGVGbGFnLlBvaW50V2lkZ2V0ICovKTtcbiAgICAgICAgaWYgKCFub1NwYWNlKVxuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5lbnN1cmVNYXJrcyhtYXJrcywgb3BlblN0YXJ0KTtcbiAgICAgICAgaWYgKCFub1NwYWNlICYmICEod2lkZ2V0LmZsYWdzICYgMTYgLyogVGlsZUZsYWcuQmVmb3JlICovKSlcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmQodGhpcy5nZXRCdWZmZXIoMSkpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kKHdpZGdldCk7XG4gICAgICAgIHRoaXMucG9zICs9IHdpZGdldC5sZW5ndGg7XG4gICAgICAgIHRoaXMuYWZ0ZXJXaWRnZXQgPSB3aWRnZXQ7XG4gICAgfVxuICAgIGFkZE1hcmsodGlsZSwgbWFya3MsIG9wZW5TdGFydCkge1xuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmVuc3VyZU1hcmtzKG1hcmtzLCBvcGVuU3RhcnQpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kKHRpbGUpO1xuICAgICAgICB0aGlzLnBvcyArPSB0aWxlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5hZnRlcldpZGdldCA9IG51bGw7XG4gICAgfVxuICAgIGFkZEJsb2NrV2lkZ2V0KHdpZGdldCkge1xuICAgICAgICB0aGlzLmdldEJsb2NrUG9zKCkuYXBwZW5kKHdpZGdldCk7XG4gICAgICAgIHRoaXMucG9zICs9IHdpZGdldC5sZW5ndGg7XG4gICAgICAgIHRoaXMubGFzdEJsb2NrID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmVuZExpbmUoKTtcbiAgICB9XG4gICAgY29udGludWVXaWRnZXQobGVuZ3RoKSB7XG4gICAgICAgIGxldCB3aWRnZXQgPSB0aGlzLmFmdGVyV2lkZ2V0IHx8IHRoaXMubGFzdEJsb2NrO1xuICAgICAgICB3aWRnZXQubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIH1cbiAgICBhZGRMaW5lU3RhcnQoYXR0cnMsIGRvbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghYXR0cnMpXG4gICAgICAgICAgICBhdHRycyA9IGxpbmVCYXNlQXR0cnM7XG4gICAgICAgIGxldCB0aWxlID0gTGluZVRpbGUuc3RhcnQoYXR0cnMsIGRvbSB8fCAoKF9hID0gdGhpcy5jYWNoZS5maW5kKExpbmVUaWxlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvbSksICEhZG9tKTtcbiAgICAgICAgdGhpcy5nZXRCbG9ja1BvcygpLmFwcGVuZCh0aGlzLmxhc3RCbG9jayA9IHRoaXMuY3VyTGluZSA9IHRpbGUpO1xuICAgIH1cbiAgICBhZGRMaW5lKHRpbGUpIHtcbiAgICAgICAgdGhpcy5nZXRCbG9ja1BvcygpLmFwcGVuZCh0aWxlKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gdGlsZS5sZW5ndGg7XG4gICAgICAgIHRoaXMubGFzdEJsb2NrID0gdGlsZTtcbiAgICAgICAgdGhpcy5lbmRMaW5lKCk7XG4gICAgfVxuICAgIGFkZEJyZWFrKCkge1xuICAgICAgICB0aGlzLmxhc3RCbG9jay5mbGFncyB8PSAxIC8qIFRpbGVGbGFnLkJyZWFrQWZ0ZXIgKi87XG4gICAgICAgIHRoaXMuZW5kTGluZSgpO1xuICAgICAgICB0aGlzLnBvcysrO1xuICAgIH1cbiAgICBhZGRMaW5lU3RhcnRJZk5vdENvdmVyZWQoYXR0cnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJsb2NrUG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgdGhpcy5hZGRMaW5lU3RhcnQoYXR0cnMpO1xuICAgIH1cbiAgICBlbnN1cmVMaW5lKGF0dHJzKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJMaW5lKVxuICAgICAgICAgICAgdGhpcy5hZGRMaW5lU3RhcnQoYXR0cnMpO1xuICAgIH1cbiAgICBlbnN1cmVNYXJrcyhtYXJrcywgb3BlblN0YXJ0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuY3VyTGluZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbWFyayA9IG1hcmtzW2ldLCBsYXN0O1xuICAgICAgICAgICAgaWYgKG9wZW5TdGFydCA+IDAgJiYgKGxhc3QgPSBwYXJlbnQubGFzdENoaWxkKSAmJiBsYXN0IGluc3RhbmNlb2YgTWFya1RpbGUgJiYgbGFzdC5tYXJrLmVxKG1hcmspKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbGFzdDtcbiAgICAgICAgICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0aWxlID0gTWFya1RpbGUub2YobWFyaywgKF9hID0gdGhpcy5jYWNoZS5maW5kKE1hcmtUaWxlLCBtID0+IG0ubWFyay5lcShtYXJrKSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kb20pO1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmQodGlsZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGlsZTtcbiAgICAgICAgICAgICAgICBvcGVuU3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIGVuZExpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5jdXJMaW5lLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghbGFzdCB8fCAhaGFzQ29udGVudCh0aGlzLmN1ckxpbmUsIGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgIGxhc3QuZG9tLm5vZGVOYW1lICE9IFwiQlJcIiAmJiBsYXN0LmlzV2lkZ2V0KCkgJiYgIShicm93c2VyLmlvcyAmJiBoYXNDb250ZW50KHRoaXMuY3VyTGluZSwgdHJ1ZSkpKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZS5hcHBlbmQodGhpcy5jYWNoZS5maW5kV2lkZ2V0KEJyZWFrV2lkZ2V0LCAwLCAzMiAvKiBUaWxlRmxhZy5BZnRlciAqLykgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFdpZGdldFRpbGUoQnJlYWtXaWRnZXQudG9ET00oKSwgMCwgQnJlYWtXaWRnZXQsIDMyIC8qIFRpbGVGbGFnLkFmdGVyICovKSk7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmFmdGVyV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVCbG9ja1dyYXBwZXJzKCkge1xuICAgICAgICBpZiAodGhpcy53cmFwcGVyUG9zID4gdGhpcy5wb3MgKyAxMDAwMCAvKiBDLldyYXBwZXJSZXNldCAqLykge1xuICAgICAgICAgICAgdGhpcy5ibG9ja1dyYXBwZXJzLmdvdG8odGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy53cmFwcGVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLndyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaWYgKHRoaXMud3JhcHBlcnNbaV0udG8gPCB0aGlzLnBvcylcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gdGhpcy5ibG9ja1dyYXBwZXJzOyBjdXIudmFsdWUgJiYgY3VyLmZyb20gPD0gdGhpcy5wb3M7IGN1ci5uZXh0KCkpXG4gICAgICAgICAgICBpZiAoY3VyLnRvID49IHRoaXMucG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXAgPSBuZXcgT3BlbldyYXBwZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlLCBjdXIucmFuayksIGkgPSB0aGlzLndyYXBwZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgKHRoaXMud3JhcHBlcnNbaSAtIDFdLnJhbmsgLSB3cmFwLnJhbmsgfHwgdGhpcy53cmFwcGVyc1tpIC0gMV0udG8gLSB3cmFwLnRvKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXJzLnNwbGljZShpLCAwLCB3cmFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy53cmFwcGVyUG9zID0gdGhpcy5wb3M7XG4gICAgfVxuICAgIGdldEJsb2NrUG9zKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudXBkYXRlQmxvY2tXcmFwcGVycygpO1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5yb290O1xuICAgICAgICBmb3IgKGxldCB3cmFwIG9mIHRoaXMud3JhcHBlcnMpIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gcGFyZW50Lmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICh3cmFwLmZyb20gPCB0aGlzLnBvcyAmJiBsYXN0IGluc3RhbmNlb2YgQmxvY2tXcmFwcGVyVGlsZSAmJiBsYXN0LndyYXBwZXIuZXEod3JhcC53cmFwcGVyKSkge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGxhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGlsZSA9IEJsb2NrV3JhcHBlclRpbGUub2Yod3JhcC53cmFwcGVyLCAoX2EgPSB0aGlzLmNhY2hlLmZpbmQoQmxvY2tXcmFwcGVyVGlsZSwgdCA9PiB0LndyYXBwZXIuZXEod3JhcC53cmFwcGVyKSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kb20pO1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmQodGlsZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBibG9ja1Bvc0NvdmVyZWQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5sYXN0QmxvY2s7XG4gICAgICAgIHJldHVybiBsYXN0ICE9IG51bGwgJiYgIWxhc3QuYnJlYWtBZnRlciAmJiAoIWxhc3QuaXNXaWRnZXQoKSB8fCAobGFzdC5mbGFncyAmICgzMiAvKiBUaWxlRmxhZy5BZnRlciAqLyB8IDEyOCAvKiBUaWxlRmxhZy5JbmNFbmQgKi8pKSA+IDApO1xuICAgIH1cbiAgICBnZXRCdWZmZXIoc2lkZSkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAyIC8qIFRpbGVGbGFnLlN5bmNlZCAqLyB8IChzaWRlIDwgMCA/IDE2IC8qIFRpbGVGbGFnLkJlZm9yZSAqLyA6IDMyIC8qIFRpbGVGbGFnLkFmdGVyICovKTtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5jYWNoZS5maW5kKFdpZGdldEJ1ZmZlclRpbGUsIHVuZGVmaW5lZCwgMSAvKiBSZXVzZWQuRnVsbCAqLyk7XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgIGZvdW5kLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHJldHVybiBmb3VuZCB8fCBuZXcgV2lkZ2V0QnVmZmVyVGlsZShmbGFncyk7XG4gICAgfVxuICAgIGZsdXNoQnVmZmVyKCkge1xuICAgICAgICBpZiAodGhpcy5hZnRlcldpZGdldCAmJiAhKHRoaXMuYWZ0ZXJXaWRnZXQuZmxhZ3MgJiAzMiAvKiBUaWxlRmxhZy5BZnRlciAqLykpIHtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJXaWRnZXQucGFyZW50LmFwcGVuZCh0aGlzLmdldEJ1ZmZlcigtMSkpO1xuICAgICAgICAgICAgdGhpcy5hZnRlcldpZGdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBIZWxwcyBnZXR0aW5nIGVmZmljaWVudCBhY2Nlc3MgdG8gdGhlIGRvY3VtZW50IHRleHQuXG5jbGFzcyBUZXh0U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgdGhpcy5za2lwQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgfVxuICAgIHNraXAobGVuKSB7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIGl0ZXJhdG9yIHBhc3QgdGhlIHJlcGxhY2VkIGNvbnRlbnRcbiAgICAgICAgaWYgKHRoaXMudGV4dE9mZiArIGxlbiA8PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5za2lwQ291bnQgKz0gbGVuIC0gKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYpO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dChtYXhMZW4pIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dE9mZiA9PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyB2YWx1ZSwgbGluZUJyZWFrLCBkb25lIH0gPSB0aGlzLmN1cnNvci5uZXh0KHRoaXMuc2tpcENvdW50KTtcbiAgICAgICAgICAgIHRoaXMuc2tpcENvdW50ID0gMDtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbiBvdXQgb2YgdGV4dCBjb250ZW50IHdoZW4gZHJhd2luZyBpbmxpbmUgdmlld3NcIik7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnRleHRPZmYgPSBNYXRoLm1pbihtYXhMZW4sIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gbGluZUJyZWFrID8gbnVsbCA6IHZhbHVlLnNsaWNlKDAsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHRoaXMudGV4dC5sZW5ndGgsIHRoaXMudGV4dE9mZiArIG1heExlbik7XG4gICAgICAgIGxldCBjaGFycyA9IHRoaXMudGV4dC5zbGljZSh0aGlzLnRleHRPZmYsIGVuZCk7XG4gICAgICAgIHRoaXMudGV4dE9mZiA9IGVuZDtcbiAgICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbn1cbi8vIEFzc2lnbiB0aGUgdGlsZSBjbGFzc2VzIGJ1Y2tldCBudW1iZXJzIGZvciBjYWNoaW5nLlxuY29uc3QgYnVja2V0cyA9IFtXaWRnZXRUaWxlLCBMaW5lVGlsZSwgVGV4dFRpbGUsIE1hcmtUaWxlLCBXaWRnZXRCdWZmZXJUaWxlLCBCbG9ja1dyYXBwZXJUaWxlLCBEb2NUaWxlXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgYnVja2V0cy5sZW5ndGg7IGkrKylcbiAgICBidWNrZXRzW2ldLmJ1Y2tldCA9IGk7XG4vLyBMZWFmIHRpbGVzIGFuZCBsaW5lIHRpbGVzIG1heSBiZSByZXVzZWQgaW4gdGhlaXIgZW50aXJldHkuIEFsbFxuLy8gb3RoZXJzIHdpbGwgZ2V0IG5ldyB0aWxlcyBhbGxvY2F0ZWQsIHVzaW5nIHRoZSBvbGQgRE9NIHdoZW5cbi8vIHBvc3NpYmxlLlxuY2xhc3MgVGlsZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIC8vIEJ1Y2tldHMgYXJlIGNpcmN1bGFyIGJ1ZmZlcnMsIHVzaW5nIGBpbmRleGAgYXMgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gcG9zaXRpb24uXG4gICAgICAgIHRoaXMuYnVja2V0cyA9IGJ1Y2tldHMubWFwKCgpID0+IFtdKTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGJ1Y2tldHMubWFwKCgpID0+IDApO1xuICAgICAgICB0aGlzLnJldXNlZCA9IG5ldyBNYXA7XG4gICAgfVxuICAgIC8vIFB1dCBhIHRpbGUgaW4gdGhlIGNhY2hlLlxuICAgIGFkZCh0aWxlKSB7XG4gICAgICAgIGxldCBpID0gdGlsZS5jb25zdHJ1Y3Rvci5idWNrZXQsIGJ1Y2tldCA9IHRoaXMuYnVja2V0c1tpXTtcbiAgICAgICAgaWYgKGJ1Y2tldC5sZW5ndGggPCA2IC8qIEMuQnVja2V0ICovKVxuICAgICAgICAgICAgYnVja2V0LnB1c2godGlsZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJ1Y2tldFt0aGlzLmluZGV4W2ldID0gKHRoaXMuaW5kZXhbaV0gKyAxKSAlIDYgLyogQy5CdWNrZXQgKi9dID0gdGlsZTtcbiAgICB9XG4gICAgZmluZChjbHMsIHRlc3QsIHR5cGUgPSAyIC8qIFJldXNlZC5ET00gKi8pIHtcbiAgICAgICAgbGV0IGkgPSBjbHMuYnVja2V0O1xuICAgICAgICBsZXQgYnVja2V0ID0gdGhpcy5idWNrZXRzW2ldLCBvZmYgPSB0aGlzLmluZGV4W2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gYnVja2V0Lmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAvLyBMb29rIGF0IHRoZSBtb3N0IHJlY2VudGx5IGFkZGVkIGl0ZW1zIGZpcnN0IChsYXN0LWluLCBmaXJzdC1vdXQpXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAoaiArIG9mZikgJSBidWNrZXQubGVuZ3RoLCB0aWxlID0gYnVja2V0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICgoIXRlc3QgfHwgdGVzdCh0aWxlKSkgJiYgIXRoaXMucmV1c2VkLmhhcyh0aWxlKSkge1xuICAgICAgICAgICAgICAgIGJ1Y2tldC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IG9mZilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleFtpXS0tO1xuICAgICAgICAgICAgICAgIHRoaXMucmV1c2VkLnNldCh0aWxlLCB0eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZmluZFdpZGdldCh3aWRnZXQsIGxlbmd0aCwgZmxhZ3MpIHtcbiAgICAgICAgbGV0IHdpZGdldHMgPSB0aGlzLmJ1Y2tldHNbMF07XG4gICAgICAgIGlmICh3aWRnZXRzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwYXNzID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID09IHdpZGdldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBhc3MgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRpbGUgPSB3aWRnZXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXVzZWQuaGFzKHRpbGUpICYmXG4gICAgICAgICAgICAgICAgICAgIChwYXNzID09IDAgPyB0aWxlLndpZGdldC5jb21wYXJlKHdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGlsZS53aWRnZXQuY29uc3RydWN0b3IgPT0gd2lkZ2V0LmNvbnN0cnVjdG9yICYmIHdpZGdldC51cGRhdGVET00odGlsZS5kb20sIHRoaXMudmlldykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMuaW5kZXhbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4WzBdLS07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWxlLndpZGdldCA9PSB3aWRnZXQgJiYgdGlsZS5sZW5ndGggPT0gbGVuZ3RoICYmICh0aWxlLmZsYWdzICYgKDQ5NiAvKiBUaWxlRmxhZy5XaWRnZXQgKi8gfCAxIC8qIFRpbGVGbGFnLkJyZWFrQWZ0ZXIgKi8pKSA9PSBmbGFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXVzZWQuc2V0KHRpbGUsIDEgLyogUmV1c2VkLkZ1bGwgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJldXNlZC5zZXQodGlsZSwgMiAvKiBSZXVzZWQuRE9NICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2lkZ2V0VGlsZSh0aWxlLmRvbSwgbGVuZ3RoLCB3aWRnZXQsICh0aWxlLmZsYWdzICYgfig0OTYgLyogVGlsZUZsYWcuV2lkZ2V0ICovIHwgMSAvKiBUaWxlRmxhZy5CcmVha0FmdGVyICovKSkgfCBmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldXNlKHRpbGUpIHtcbiAgICAgICAgdGhpcy5yZXVzZWQuc2V0KHRpbGUsIDEgLyogUmV1c2VkLkZ1bGwgKi8pO1xuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9XG4gICAgbWF5YmVSZXVzZSh0aWxlLCB0eXBlID0gMiAvKiBSZXVzZWQuRE9NICovKSB7XG4gICAgICAgIGlmICh0aGlzLnJldXNlZC5oYXModGlsZSkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJldXNlZC5zZXQodGlsZSwgdHlwZSk7XG4gICAgICAgIHJldHVybiB0aWxlLmRvbTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5idWNrZXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5idWNrZXRzW2ldLmxlbmd0aCA9IHRoaXMuaW5kZXhbaV0gPSAwO1xuICAgIH1cbn1cbi8vIFRoaXMgY2xhc3Mgb3JnYW5pemVzIGEgcGFzcyBvdmVyIHRoZSBkb2N1bWVudCwgZ3VpZGVkIGJ5IHRoZSBhcnJheVxuLy8gb2YgcmVwbGFjZWQgcmFuZ2VzLiBGb3IgcmFuZ2VzIHRoYXQgaGF2ZW4ndCBjaGFuZ2VkLCBpdCBpdGVyYXRlc1xuLy8gdGhlIG9sZCB0cmVlIGFuZCBjb3BpZXMgaXRzIGNvbnRlbnQgaW50byB0aGUgbmV3IGRvY3VtZW50LiBGb3Jcbi8vIGNoYW5nZWQgcmFuZ2VzLCBpdCBydW5zIGEgZGVjb3JhdGlvbiBpdGVyYXRvciB0byBndWlkZSBnZW5lcmF0aW9uXG4vLyBvZiBjb250ZW50LlxuY2xhc3MgVGlsZVVwZGF0ZSB7XG4gICAgY29uc3RydWN0b3Iodmlldywgb2xkLCBibG9ja1dyYXBwZXJzLCBkZWNvcmF0aW9ucywgZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuICAgICAgICB0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yID0gZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3I7XG4gICAgICAgIHRoaXMub3BlbldpZGdldCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wZW5NYXJrcyA9IDA7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgVGlsZUNhY2hlKHZpZXcpO1xuICAgICAgICB0aGlzLnRleHQgPSBuZXcgVGV4dFN0cmVhbSh2aWV3LnN0YXRlLmRvYyk7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IG5ldyBUaWxlQnVpbGRlcih0aGlzLmNhY2hlLCBuZXcgRG9jVGlsZSh2aWV3LCB2aWV3LmNvbnRlbnRET00pLCBSYW5nZVNldC5pdGVyKGJsb2NrV3JhcHBlcnMpKTtcbiAgICAgICAgdGhpcy5jYWNoZS5yZXVzZWQuc2V0KG9sZCwgMiAvKiBSZXVzZWQuRE9NICovKTtcbiAgICAgICAgdGhpcy5vbGQgPSBuZXcgVGlsZVBvaW50ZXIob2xkKTtcbiAgICAgICAgdGhpcy5yZXVzZVdhbGtlciA9IHtcbiAgICAgICAgICAgIHNraXA6ICh0aWxlLCBmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuYWRkKHRpbGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLmlzQ29tcG9zaXRlKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnRlcjogdGlsZSA9PiB0aGlzLmNhY2hlLmFkZCh0aWxlKSxcbiAgICAgICAgICAgIGxlYXZlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBicmVhazogKCkgPT4geyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bihjaGFuZ2VzLCBjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgY29tcG9zaXRpb25Db250ZXh0ID0gY29tcG9zaXRpb24gJiYgdGhpcy5nZXRDb21wb3NpdGlvbkNvbnRleHQoY29tcG9zaXRpb24udGV4dCk7XG4gICAgICAgIGZvciAobGV0IHBvc0EgPSAwLCBwb3NCID0gMCwgaSA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2krK10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IHNraXBBID0gbmV4dCA/IG5leHQuZnJvbUEgOiB0aGlzLm9sZC5yb290Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChza2lwQSA+IHBvc0EpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gc2tpcEEgLSBwb3NBO1xuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VydmUobGVuLCAhaSwgIW5leHQpO1xuICAgICAgICAgICAgICAgIHBvc0EgPSBza2lwQTtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIENvbXBvc2l0aW9ucyBuZWVkIHRvIGJlIGhhbmRsZWQgc3BlY2lhbGx5LCBmb3JjaW5nIHRoZVxuICAgICAgICAgICAgLy8gZm9jdXNlZCB0ZXh0IG5vZGUgYW5kIGl0cyBwYXJlbnQgbm9kZXMgdG8gcmVtYWluIHN0YWJsZSBhdFxuICAgICAgICAgICAgLy8gdGhhdCBwb2ludCBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb24gJiYgbmV4dC5mcm9tQSA8PSBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQSAmJiBuZXh0LnRvQSA+PSBjb21wb3NpdGlvbi5yYW5nZS50b0EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmQobmV4dC5mcm9tQSwgY29tcG9zaXRpb24ucmFuZ2UuZnJvbUEsIGNvbXBvc2l0aW9uLnJhbmdlLmZyb21BIDwgY29tcG9zaXRpb24ucmFuZ2UudG9BID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQocG9zQiwgY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTsgLy8gTXVzdCBub3QgcmV1c2UgRE9NIGFjcm9zcyBjb21wb3NpdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5hZGRDb21wb3NpdGlvbihjb21wb3NpdGlvbiwgY29tcG9zaXRpb25Db250ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQuc2tpcChjb21wb3NpdGlvbi5yYW5nZS50b0IgLSBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQik7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkKGNvbXBvc2l0aW9uLnJhbmdlLmZyb21BLCBuZXh0LnRvQSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGNvbXBvc2l0aW9uLnJhbmdlLnRvQiwgbmV4dC50b0IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkKG5leHQuZnJvbUEsIG5leHQudG9BKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQocG9zQiwgbmV4dC50b0IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQiA9IG5leHQudG9CO1xuICAgICAgICAgICAgcG9zQSA9IG5leHQudG9BO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJ1aWxkZXIuY3VyTGluZSlcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlci5lbmRMaW5lKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkZXIucm9vdDtcbiAgICB9XG4gICAgcHJlc2VydmUobGVuZ3RoLCBpbmNTdGFydCwgaW5jRW5kKSB7XG4gICAgICAgIGxldCBhY3RpdmVNYXJrcyA9IGdldE1hcmtzKHRoaXMub2xkKSwgb3Blbk1hcmtzID0gdGhpcy5vcGVuTWFya3M7XG4gICAgICAgIHRoaXMub2xkLmFkdmFuY2UobGVuZ3RoLCBpbmNFbmQgPyAxIDogLTEsIHtcbiAgICAgICAgICAgIHNraXA6ICh0aWxlLCBmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLmlzV2lkZ2V0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3BlbldpZGdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmNvbnRpbnVlV2lkZ2V0KHRvIC0gZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lkZ2V0ID0gdG8gPiAwIHx8IGZyb20gPCB0aWxlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gV2lkZ2V0VGlsZS5vZih0aWxlLndpZGdldCwgdGhpcy52aWV3LCB0byAtIGZyb20sIHRpbGUuZmxhZ3MgJiA0OTYgLyogVGlsZUZsYWcuV2lkZ2V0ICovLCB0aGlzLmNhY2hlLm1heWJlUmV1c2UodGlsZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmNhY2hlLnJldXNlKHRpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZGdldC5mbGFncyAmIDI1NiAvKiBUaWxlRmxhZy5CbG9jayAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldC5mbGFncyAmPSB+MSAvKiBUaWxlRmxhZy5CcmVha0FmdGVyICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5hZGRCbG9ja1dpZGdldCh3aWRnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmVuc3VyZUxpbmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmFkZElubGluZVdpZGdldCh3aWRnZXQsIGFjdGl2ZU1hcmtzLCBvcGVuTWFya3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5NYXJrcyA9IGFjdGl2ZU1hcmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aWxlLmlzVGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5lbnN1cmVMaW5lKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZyb20gJiYgdG8gPT0gdGlsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5hZGRUZXh0KHRpbGUudGV4dCwgYWN0aXZlTWFya3MsIG9wZW5NYXJrcywgdGhpcy5jYWNoZS5yZXVzZSh0aWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmFkZCh0aWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5hZGRUZXh0KHRpbGUudGV4dC5zbGljZShmcm9tLCB0byksIGFjdGl2ZU1hcmtzLCBvcGVuTWFya3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wZW5NYXJrcyA9IGFjdGl2ZU1hcmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGlsZS5pc0xpbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aWxlLmZsYWdzICY9IH4xIC8qIFRpbGVGbGFnLkJyZWFrQWZ0ZXIgKi87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUucmV1c2VkLnNldCh0aWxlLCAxIC8qIFJldXNlZC5GdWxsICovKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmFkZExpbmUodGlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbGUgaW5zdGFuY2VvZiBXaWRnZXRCdWZmZXJUaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuYWRkKHRpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aWxlIGluc3RhbmNlb2YgTWFya1RpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmVuc3VyZUxpbmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5hZGRNYXJrKHRpbGUsIGFjdGl2ZU1hcmtzLCBvcGVuTWFya3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLnJldXNlZC5zZXQodGlsZSwgMSAvKiBSZXVzZWQuRnVsbCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5NYXJrcyA9IGFjdGl2ZU1hcmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuV2lkZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW50ZXI6ICh0aWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbGUuaXNMaW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZGVyLmFkZExpbmVTdGFydCh0aWxlLmF0dHJzLCB0aGlzLmNhY2hlLm1heWJlUmV1c2UodGlsZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5hZGQodGlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWxlIGluc3RhbmNlb2YgTWFya1RpbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXJrcy51bnNoaWZ0KHRpbGUubWFyayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbldpZGdldCA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlYXZlOiAodGlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLmlzTGluZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVNYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXJrcy5sZW5ndGggPSBvcGVuTWFya3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aWxlIGluc3RhbmNlb2YgTWFya1RpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlTWFya3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgb3Blbk1hcmtzID0gTWF0aC5taW4ob3Blbk1hcmtzLCBhY3RpdmVNYXJrcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBicmVhazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5hZGRCcmVhaygpO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbldpZGdldCA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGV4dC5za2lwKGxlbmd0aCk7XG4gICAgfVxuICAgIGVtaXQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHBlbmRpbmdMaW5lQXR0cnMgPSBudWxsO1xuICAgICAgICBsZXQgYiA9IHRoaXMuYnVpbGRlciwgbWFya0NvdW50ID0gMDtcbiAgICAgICAgbGV0IG9wZW5FbmQgPSBSYW5nZVNldC5zcGFucyh0aGlzLmRlY29yYXRpb25zLCBmcm9tLCB0bywge1xuICAgICAgICAgICAgcG9pbnQ6IChmcm9tLCB0bywgZGVjbywgYWN0aXZlLCBvcGVuU3RhcnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3JbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVjby5ibG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJsb2NrIGRlY29yYXRpb25zIG1heSBub3QgYmUgc3BlY2lmaWVkIHZpYSBwbHVnaW5zXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvID4gdGhpcy52aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSkudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWNvcmF0aW9ucyB0aGF0IHJlcGxhY2UgbGluZSBicmVha3MgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFya0NvdW50ID0gYWN0aXZlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5TdGFydCA+IGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuY29udGludWVXaWRnZXQodG8gLSBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aWRnZXQgPSBkZWNvLndpZGdldCB8fCAoZGVjby5ibG9jayA/IE51bGxXaWRnZXQuYmxvY2sgOiBOdWxsV2lkZ2V0LmlubGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSB3aWRnZXRGbGFncyhkZWNvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy5jYWNoZS5maW5kV2lkZ2V0KHdpZGdldCwgdG8gLSBmcm9tLCBmbGFncykgfHwgV2lkZ2V0VGlsZS5vZih3aWRnZXQsIHRoaXMudmlldywgdG8gLSBmcm9tLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNvLnN0YXJ0U2lkZSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYWRkTGluZVN0YXJ0SWZOb3RDb3ZlcmVkKHBlbmRpbmdMaW5lQXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYWRkQmxvY2tXaWRnZXQodGlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmVuc3VyZUxpbmUocGVuZGluZ0xpbmVBdHRycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5hZGRJbmxpbmVXaWRnZXQodGlsZSwgYWN0aXZlLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdMaW5lQXR0cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0xpbmVBdHRycyA9IGFkZExpbmVEZWNvKHBlbmRpbmdMaW5lQXR0cnMsIGRlY28pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQuc2tpcCh0byAtIGZyb20pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNwYW46IChmcm9tLCB0bywgYWN0aXZlLCBvcGVuU3RhcnQpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPCB0bzspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYXJzID0gdGhpcy50ZXh0Lm5leHQoTWF0aC5taW4oNTEyIC8qIEMuQ2h1bmsgKi8sIHRvIC0gcG9zKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFycyA9PSBudWxsKSB7IC8vIExpbmUgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuYWRkTGluZVN0YXJ0SWZOb3RDb3ZlcmVkKHBlbmRpbmdMaW5lQXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5hZGRCcmVhaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLmVuc3VyZUxpbmUocGVuZGluZ0xpbmVBdHRycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLmFkZFRleHQoY2hhcnMsIGFjdGl2ZSwgcG9zID09IGZyb20gPyBvcGVuU3RhcnQgOiBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBjaGFycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0xpbmVBdHRycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYi5hZGRMaW5lU3RhcnRJZk5vdENvdmVyZWQocGVuZGluZ0xpbmVBdHRycyk7XG4gICAgICAgIHRoaXMub3BlbldpZGdldCA9IG9wZW5FbmQgPiBtYXJrQ291bnQ7XG4gICAgICAgIHRoaXMub3Blbk1hcmtzID0gb3BlbkVuZDtcbiAgICB9XG4gICAgZm9yd2FyZChmcm9tLCB0bywgc2lkZSA9IDEpIHtcbiAgICAgICAgaWYgKHRvIC0gZnJvbSA8PSAxMCkge1xuICAgICAgICAgICAgdGhpcy5vbGQuYWR2YW5jZSh0byAtIGZyb20sIHNpZGUsIHRoaXMucmV1c2VXYWxrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbGQuYWR2YW5jZSg1LCAtMSwgdGhpcy5yZXVzZVdhbGtlcik7XG4gICAgICAgICAgICB0aGlzLm9sZC5hZHZhbmNlKHRvIC0gZnJvbSAtIDEwLCAtMSk7XG4gICAgICAgICAgICB0aGlzLm9sZC5hZHZhbmNlKDUsIHNpZGUsIHRoaXMucmV1c2VXYWxrZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbXBvc2l0aW9uQ29udGV4dCh0ZXh0KSB7XG4gICAgICAgIGxldCBtYXJrcyA9IFtdLCBsaW5lID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGV4dC5wYXJlbnROb2RlOzsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCB0aWxlID0gVGlsZS5nZXQocGFyZW50KTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy52aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGlsZSBpbnN0YW5jZW9mIE1hcmtUaWxlKVxuICAgICAgICAgICAgICAgIG1hcmtzLnB1c2godGlsZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0aWxlID09PSBudWxsIHx8IHRpbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbGUuaXNMaW5lKCkpXG4gICAgICAgICAgICAgICAgbGluZSA9IHRpbGU7XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQubm9kZU5hbWUgPT0gXCJESVZcIiAmJiAhbGluZSAmJiBwYXJlbnQgIT0gdGhpcy52aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgbGluZSA9IG5ldyBMaW5lVGlsZShwYXJlbnQsIGxpbmVCYXNlQXR0cnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1hcmtzLnB1c2goTWFya1RpbGUub2YobmV3IE1hcmtEZWNvcmF0aW9uKHsgdGFnTmFtZTogcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJpYnV0ZXM6IGdldEF0dHJzKHBhcmVudCkgfSksIHBhcmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIG1hcmtzIH07XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ29udGVudCh0aWxlLCByZXF1aXJlVGV4dCkge1xuICAgIGxldCBzY2FuID0gKHRpbGUpID0+IHtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGlsZS5jaGlsZHJlbilcbiAgICAgICAgICAgIGlmICgocmVxdWlyZVRleHQgPyBjaC5pc1RleHQoKSA6IGNoLmxlbmd0aCkgfHwgc2NhbihjaCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBzY2FuKHRpbGUpO1xufVxuZnVuY3Rpb24gd2lkZ2V0RmxhZ3MoZGVjbykge1xuICAgIGxldCBmbGFncyA9IGRlY28uaXNSZXBsYWNlID8gKGRlY28uc3RhcnRTaWRlIDwgMCA/IDY0IC8qIFRpbGVGbGFnLkluY1N0YXJ0ICovIDogMCkgfCAoZGVjby5lbmRTaWRlID4gMCA/IDEyOCAvKiBUaWxlRmxhZy5JbmNFbmQgKi8gOiAwKVxuICAgICAgICA6IChkZWNvLnN0YXJ0U2lkZSA+IDAgPyAzMiAvKiBUaWxlRmxhZy5BZnRlciAqLyA6IDE2IC8qIFRpbGVGbGFnLkJlZm9yZSAqLyk7XG4gICAgaWYgKGRlY28uYmxvY2spXG4gICAgICAgIGZsYWdzIHw9IDI1NiAvKiBUaWxlRmxhZy5CbG9jayAqLztcbiAgICByZXR1cm4gZmxhZ3M7XG59XG5jb25zdCBsaW5lQmFzZUF0dHJzID0geyBjbGFzczogXCJjbS1saW5lXCIgfTtcbmZ1bmN0aW9uIGFkZExpbmVEZWNvKHZhbHVlLCBkZWNvKSB7XG4gICAgbGV0IGF0dHJzID0gZGVjby5zcGVjLmF0dHJpYnV0ZXMsIGNscyA9IGRlY28uc3BlYy5jbGFzcztcbiAgICBpZiAoIWF0dHJzICYmICFjbHMpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICB2YWx1ZSA9IHsgY2xhc3M6IFwiY20tbGluZVwiIH07XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBjb21iaW5lQXR0cnMoYXR0cnMsIHZhbHVlKTtcbiAgICBpZiAoY2xzKVxuICAgICAgICB2YWx1ZS5jbGFzcyArPSBcIiBcIiArIGNscztcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRNYXJrcyhwdHIpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gcHRyLnBhcmVudHMubGVuZ3RoOyBpID4gMTsgaS0tKSB7XG4gICAgICAgIGxldCB0aWxlID0gaSA9PSBwdHIucGFyZW50cy5sZW5ndGggPyBwdHIudGlsZSA6IHB0ci5wYXJlbnRzW2ldLnRpbGU7XG4gICAgICAgIGlmICh0aWxlIGluc3RhbmNlb2YgTWFya1RpbGUpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHRpbGUubWFyayk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGZyZWVOb2RlKG5vZGUpIHtcbiAgICBsZXQgdGlsZSA9IFRpbGUuZ2V0KG5vZGUpO1xuICAgIGlmICh0aWxlKVxuICAgICAgICB0aWxlLnNldERPTShub2RlLmNsb25lTm9kZSgpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbmNsYXNzIE51bGxXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci50YWcgPT0gdGhpcy50YWc7IH1cbiAgICB0b0RPTSgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWcpOyB9XG4gICAgdXBkYXRlRE9NKGVsdCkgeyByZXR1cm4gZWx0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gdGhpcy50YWc7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0cnVlOyB9XG59XG5OdWxsV2lkZ2V0LmlubGluZSA9IC8qQF9fUFVSRV9fKi9uZXcgTnVsbFdpZGdldChcInNwYW5cIik7XG5OdWxsV2lkZ2V0LmJsb2NrID0gLypAX19QVVJFX18qL25ldyBOdWxsV2lkZ2V0KFwiZGl2XCIpO1xuY29uc3QgQnJlYWtXaWRnZXQgPSAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGVkaXRhYmxlKCkgeyByZXR1cm4gdHJ1ZTsgfVxufTtcblxuY2xhc3MgRG9jVmlldyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuYmxvY2tXcmFwcGVycyA9IFtdO1xuICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwID0gW2ZhbHNlXTtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZWRpdENvbnRleHRGb3JtYXR0aW5nID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB0aGlzLmxhc3RDb21wb3NpdGlvbkFmdGVyQ3Vyc29yID0gZmFsc2U7XG4gICAgICAgIC8vIFRyYWNrIGEgbWluaW11bSB3aWR0aCBmb3IgdGhlIGVkaXRvci4gV2hlbiBtZWFzdXJpbmcgc2l6ZXMgaW5cbiAgICAgICAgLy8gbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cywgdGhpcyBpcyB1cGRhdGVkIHRvIHBvaW50IGF0IHRoZSB3aWR0aFxuICAgICAgICAvLyBvZiBhIGdpdmVuIGVsZW1lbnQgYW5kIGl0cyBleHRlbnQgaW4gdGhlIGRvY3VtZW50LiBXaGVuIGEgY2hhbmdlXG4gICAgICAgIC8vIGhhcHBlbnMgaW4gdGhhdCByYW5nZSwgdGhlc2UgYXJlIHJlc2V0LiBUaGF0IHdheSwgb25jZSB3ZSd2ZSBzZWVuXG4gICAgICAgIC8vIGEgbGluZS9lbGVtZW50IG9mIGEgZ2l2ZW4gbGVuZ3RoLCB3ZSBrZWVwIHRoZSBlZGl0b3Igd2lkZSBlbm91Z2hcbiAgICAgICAgLy8gdG8gZml0IGF0IGxlYXN0IHRoYXQgZWxlbWVudCwgdW50aWwgaXQgaXMgY2hhbmdlZCwgYXQgd2hpY2ggcG9pbnRcbiAgICAgICAgLy8gd2UgZm9yZ2V0IGl0IGFnYWluLlxuICAgICAgICB0aGlzLm1pbldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAvLyBUcmFjayB3aGV0aGVyIHRoZSBET00gc2VsZWN0aW9uIHdhcyBzZXQgaW4gYSBsb3NzeSB3YXksIHNvIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgbWVzcyBpdCB1cCB3aGVuIHJlYWRpbmcgaXQgYmFjayBpdFxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgcmVzaXplIG9ic2VydmVyIHRvIGlnbm9yZSByZXNpemVzIHRoYXQgd2UgY2F1c2VkXG4gICAgICAgIC8vIG91cnNlbHZlc1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgdGhpcy50aWxlID0gbmV3IERvY1RpbGUodmlldywgdmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSwgbnVsbCk7XG4gICAgfVxuICAgIC8vIFVwZGF0ZSB0aGUgZG9jdW1lbnQgdmlldyB0byBhIGdpdmVuIHN0YXRlLlxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBpZiAodGhpcy5taW5XaWR0aCA+IDAgJiYgY2hhbmdlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghY2hhbmdlZFJhbmdlcy5ldmVyeSgoeyBmcm9tQSwgdG9BIH0pID0+IHRvQSA8IHRoaXMubWluV2lkdGhGcm9tIHx8IGZyb21BID4gdGhpcy5taW5XaWR0aFRvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSB0aGlzLm1pbldpZHRoRnJvbSA9IHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoRnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhUbywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVFZGl0Q29udGV4dEZvcm1hdHRpbmcodXBkYXRlKTtcbiAgICAgICAgbGV0IHJlYWRDb21wb3NpdGlvbkF0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJiAhdGhpcy52aWV3Lm9ic2VydmVyLmVkaXRDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5kb21DaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV3U2VsKVxuICAgICAgICAgICAgICAgIHJlYWRDb21wb3NpdGlvbkF0ID0gdGhpcy5kb21DaGFuZ2VkLm5ld1NlbC5oZWFkO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXRvdWNoZXNDb21wb3NpdGlvbih1cGRhdGUuY2hhbmdlcywgdGhpcy5oYXNDb21wb3NpdGlvbikgJiYgIXVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICAgICAgcmVhZENvbXBvc2l0aW9uQXQgPSB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSByZWFkQ29tcG9zaXRpb25BdCA+IC0xID8gZmluZENvbXBvc2l0aW9uUmFuZ2UodGhpcy52aWV3LCB1cGRhdGUuY2hhbmdlcywgcmVhZENvbXBvc2l0aW9uQXQpIDogbnVsbDtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLmhhc0NvbXBvc2l0aW9uO1xuICAgICAgICAgICAgY2hhbmdlZFJhbmdlcyA9IG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbSwgdG8sIHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyhmcm9tLCAtMSksIHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0bywgMSkpXG4gICAgICAgICAgICAgICAgLmFkZFRvU2V0KGNoYW5nZWRSYW5nZXMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNDb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uID8geyBmcm9tOiBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiwgdG86IGNvbXBvc2l0aW9uLnJhbmdlLnRvQiB9IDogbnVsbDtcbiAgICAgICAgLy8gV2hlbiB0aGUgRE9NIG5vZGVzIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGFyZSBtb3ZlZCB0byBhbm90aGVyXG4gICAgICAgIC8vIHBhcmVudCwgQ2hyb21lIHNvbWV0aW1lcyByZXBvcnRzIGEgZGlmZmVyZW50IHNlbGVjdGlvbiB0aHJvdWdoXG4gICAgICAgIC8vIGdldFNlbGVjdGlvbiB0aGFuIHRoZSBvbmUgdGhhdCBpdCBhY3R1YWxseSBzaG93cyB0byB0aGUgdXNlci5cbiAgICAgICAgLy8gVGhpcyBmb3JjZXMgYSBzZWxlY3Rpb24gdXBkYXRlIHdoZW4gbGluZXMgYXJlIGpvaW5lZCB0byB3b3JrXG4gICAgICAgIC8vIGFyb3VuZCB0aGF0LiBJc3N1ZSAjNTRcbiAgICAgICAgaWYgKChicm93c2VyLmllIHx8IGJyb3dzZXIuY2hyb21lKSAmJiAhY29tcG9zaXRpb24gJiYgdXBkYXRlICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuZG9jLmxpbmVzICE9IHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lcylcbiAgICAgICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLmRlY29yYXRpb25zLCBwcmV2V3JhcHBlcnMgPSB0aGlzLmJsb2NrV3JhcHBlcnM7XG4gICAgICAgIHRoaXMudXBkYXRlRGVjbygpO1xuICAgICAgICBsZXQgZGVjb0RpZmYgPSBmaW5kQ2hhbmdlZERlY28ocHJldkRlY28sIHRoaXMuZGVjb3JhdGlvbnMsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKGRlY29EaWZmLmxlbmd0aClcbiAgICAgICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBkZWNvRGlmZik7XG4gICAgICAgIGxldCBibG9ja0RpZmYgPSBmaW5kQ2hhbmdlZFdyYXBwZXJzKHByZXZXcmFwcGVycywgdGhpcy5ibG9ja1dyYXBwZXJzLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGlmIChibG9ja0RpZmYubGVuZ3RoKVxuICAgICAgICAgICAgY2hhbmdlZFJhbmdlcyA9IENoYW5nZWRSYW5nZS5leHRlbmRXaXRoUmFuZ2VzKGNoYW5nZWRSYW5nZXMsIGJsb2NrRGlmZik7XG4gICAgICAgIGlmIChjb21wb3NpdGlvbiAmJiAhY2hhbmdlZFJhbmdlcy5zb21lKHIgPT4gci5mcm9tQSA8PSBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQSAmJiByLnRvQSA+PSBjb21wb3NpdGlvbi5yYW5nZS50b0EpKVxuICAgICAgICAgICAgY2hhbmdlZFJhbmdlcyA9IGNvbXBvc2l0aW9uLnJhbmdlLmFkZFRvU2V0KGNoYW5nZWRSYW5nZXMuc2xpY2UoKSk7XG4gICAgICAgIGlmICgodGhpcy50aWxlLmZsYWdzICYgMiAvKiBUaWxlRmxhZy5TeW5jZWQgKi8pICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIoY2hhbmdlZFJhbmdlcywgY29tcG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2VkIGJ5IHVwZGF0ZSBhbmQgdGhlIGNvbnN0cnVjdG9yIGRvIHBlcmZvcm0gdGhlIGFjdHVhbCBET01cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVJbm5lcihjaGFuZ2VzLCBjb21wb3NpdGlvbikge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIGxldCB7IG9ic2VydmVyIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIG9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb24gfHwgY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2xkVGlsZSA9IHRoaXMudGlsZTtcbiAgICAgICAgICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBUaWxlVXBkYXRlKHRoaXMudmlldywgb2xkVGlsZSwgdGhpcy5ibG9ja1dyYXBwZXJzLCB0aGlzLmRlY29yYXRpb25zLCB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGUgPSBidWlsZGVyLnJ1bihjaGFuZ2VzLCBjb21wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgZGVzdHJveURyb3BwZWQob2xkVGlsZSwgYnVpbGRlci5jYWNoZS5yZXVzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9jayB0aGUgaGVpZ2h0IGR1cmluZyByZWRyYXdpbmcsIHNpbmNlIENocm9tZSBzb21ldGltZXNcbiAgICAgICAgICAgIC8vIG1lc3NlcyB3aXRoIHRoZSBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIERPTSBtdXRhdGlvbiAodGhvdWdoXG4gICAgICAgICAgICAvLyBubyByZWxheW91dCBpcyB0cmlnZ2VyZWQgYW5kIEkgY2Fubm90IGltYWdpbmUgaG93IGl0IGNhblxuICAgICAgICAgICAgLy8gcmVjb21wdXRlIHRoZSBzY3JvbGwgcG9zaXRpb24gd2l0aG91dCBhIGxheW91dClcbiAgICAgICAgICAgIHRoaXMudGlsZS5kb20uc3R5bGUuaGVpZ2h0ID0gdGhpcy52aWV3LnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMudGlsZS5kb20uc3R5bGUuZmxleEJhc2lzID0gdGhpcy5taW5XaWR0aCA/IHRoaXMubWluV2lkdGggKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzLCB3aGVuIERPTSBtdXRhdGlvbnMgb2NjdXIgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGFyb3VuZCB0aGUgc2VsZWN0aW9uLCBnZXQgY29uZnVzZWQgYW5kIHJlcG9ydCBhIGRpZmZlcmVudFxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGZyb20gdGhlIG9uZSBpdCBkaXNwbGF5cyAoaXNzdWUgIzIxOCkuIFRoaXMgdHJpZXNcbiAgICAgICAgICAgIC8vIHRvIGRldGVjdCB0aGF0IHNpdHVhdGlvbi5cbiAgICAgICAgICAgIGxldCB0cmFjayA9IGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuaW9zID8geyBub2RlOiBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUsIHdyaXR0ZW46IGZhbHNlIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRpbGUuc3luYyh0cmFjayk7XG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgKHRyYWNrLndyaXR0ZW4gfHwgb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlICE9IHRyYWNrLm5vZGUgfHwgIXRoaXMudGlsZS5kb20uY29udGFpbnModHJhY2subm9kZSkpKVxuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50aWxlLmRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMudmlldy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA8IHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy50aWxlLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pc1dpZGdldCgpICYmIGNoaWxkLndpZGdldCBpbnN0YW5jZW9mIEJsb2NrR2FwV2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICBnYXBzLnB1c2goY2hpbGQuZG9tKTtcbiAgICAgICAgb2JzZXJ2ZXIudXBkYXRlR2FwcyhnYXBzKTtcbiAgICB9XG4gICAgdXBkYXRlRWRpdENvbnRleHRGb3JtYXR0aW5nKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZyA9IHRoaXMuZWRpdENvbnRleHRGb3JtYXR0aW5nLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHVwZGF0ZS50cmFuc2FjdGlvbnMpXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEVkaXRDb250ZXh0Rm9ybWF0dGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dEZvcm1hdHRpbmcgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBET00gc2VsZWN0aW9uIHRvIHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgdXBkYXRlU2VsZWN0aW9uKG11c3RSZWFkID0gZmFsc2UsIGZyb21Qb2ludGVyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG11c3RSZWFkIHx8ICF0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgeyBkb20gfSA9IHRoaXMudGlsZTtcbiAgICAgICAgbGV0IGFjdGl2ZUVsdCA9IHRoaXMudmlldy5yb290LmFjdGl2ZUVsZW1lbnQsIGZvY3VzZWQgPSBhY3RpdmVFbHQgPT0gZG9tO1xuICAgICAgICBsZXQgc2VsZWN0aW9uTm90Rm9jdXMgPSAhZm9jdXNlZCAmJiAhKHRoaXMudmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgfHwgZG9tLnRhYkluZGV4ID4gLTEpICYmXG4gICAgICAgICAgICBoYXNTZWxlY3Rpb24oZG9tLCB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UpICYmICEoYWN0aXZlRWx0ICYmIGRvbS5jb250YWlucyhhY3RpdmVFbHQpKTtcbiAgICAgICAgaWYgKCEoZm9jdXNlZCB8fCBmcm9tUG9pbnRlciB8fCBzZWxlY3Rpb25Ob3RGb2N1cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBmb3JjZSA9IHRoaXMuZm9yY2VTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIGFuY2hvciwgaGVhZDtcbiAgICAgICAgaWYgKG1haW4uZW1wdHkpIHtcbiAgICAgICAgICAgIGhlYWQgPSBhbmNob3IgPSB0aGlzLmlubGluZURPTU5lYXJQb3MobWFpbi5hbmNob3IsIG1haW4uYXNzb2MgfHwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkID0gdGhpcy5pbmxpbmVET01OZWFyUG9zKG1haW4uaGVhZCwgbWFpbi5oZWFkID09IG1haW4uZnJvbSA/IDEgOiAtMSk7XG4gICAgICAgICAgICBhbmNob3IgPSB0aGlzLmlubGluZURPTU5lYXJQb3MobWFpbi5hbmNob3IsIG1haW4uYW5jaG9yID09IG1haW4uZnJvbSA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWx3YXlzIHJlc2V0IG9uIEZpcmVmb3ggd2hlbiBuZXh0IHRvIGFuIHVuZWRpdGFibGUgbm9kZSB0b1xuICAgICAgICAvLyBhdm9pZCBpbnZpc2libGUgY3Vyc29yIGJ1Z3MgKCMxMTEpXG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvICYmIG1haW4uZW1wdHkgJiYgIXRoaXMuaGFzQ29tcG9zaXRpb24gJiYgYmV0d2VlblVuZWRpdGFibGUoYW5jaG9yKSkge1xuICAgICAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IGFuY2hvci5ub2RlLmluc2VydEJlZm9yZShkdW1teSwgYW5jaG9yLm5vZGUuY2hpbGROb2Rlc1thbmNob3Iub2Zmc2V0XSB8fCBudWxsKSk7XG4gICAgICAgICAgICBhbmNob3IgPSBoZWFkID0gbmV3IERPTVBvcyhkdW1teSwgMCk7XG4gICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvbVNlbCA9IHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGhlcmUsIG9yIGluIGFuIGVxdWl2YWxlbnQgcG9zaXRpb24sIGRvbid0IHRvdWNoIGl0XG4gICAgICAgIGlmIChmb3JjZSB8fCAhZG9tU2VsLmZvY3VzTm9kZSB8fCAoIWlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgfHxcbiAgICAgICAgICAgICFpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkLm5vZGUsIGhlYWQub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKSAmJiAhdGhpcy5zdXBwcmVzc1dpZGdldEN1cnNvckNoYW5nZShkb21TZWwsIG1haW4pKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIGhpZGUgdGhlIHZpcnR1YWwga2V5Ym9hcmQgd2hlbiB0YXBwaW5nXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIHVuZWRpdGFibGUgbm9kZSwgYW5kIG5vdCBicmluZyBpdCBiYWNrIHdoZW4gd2VcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgdG8gaXRzIHByb3BlciBwb3NpdGlvbi4gVGhpcyB0cmllcyB0b1xuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGtleWJvYXJkIGJ5IGN5Y2xpbmcgZm9jdXMuXG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiBkb20uY29udGFpbnMoZG9tU2VsLmZvY3VzTm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5VbmVkaXRhYmxlKGRvbVNlbC5mb2N1c05vZGUsIGRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhd1NlbCA9IGdldFNlbGVjdGlvbih0aGlzLnZpZXcucm9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYXdTZWwpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWluLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MTIwNzZcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0VG8gPSBuZXh0VG9VbmVkaXRhYmxlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VG8gJiYgbmV4dFRvICE9ICgxIC8qIE5leHRUby5CZWZvcmUgKi8gfCAyIC8qIE5leHRUby5BZnRlciAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IChuZXh0VG8gPT0gMSAvKiBOZXh0VG8uQmVmb3JlICovID8gdGV4dE5vZGVCZWZvcmUgOiB0ZXh0Tm9kZUFmdGVyKShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5ldyBET01Qb3ModGV4dC5ub2RlLCB0ZXh0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYmlkaUxldmVsICE9IG51bGwgJiYgcmF3U2VsLmNhcmV0QmlkaUxldmVsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdTZWwuY2FyZXRCaWRpTGV2ZWwgPSBtYWluLmJpZGlMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmF3U2VsLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgd2lsbCBpZ25vcmUgdGhlIGNhbGwgYWJvdmUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZGRlbiwgYW5kIHRoZW4gcmFpc2UgYW4gZXJyb3Igb24gdGhlIGNhbGwgdG8gZXh0ZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vICgjOTQwKS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5leHRlbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIChJRSkgd2F5XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmFuY2hvciA+IG1haW4uaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gW2hlYWQsIGFuY2hvcl07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Ob3RGb2N1cyAmJiB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50ID09IGRvbSkge1xuICAgICAgICAgICAgICAgICAgICBkb20uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRWx0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IGFuY2hvci5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBoZWFkLnByZWNpc2UgPyBudWxsIDogbmV3IERPTVBvcyhkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICAvLyBJZiBhIHplcm8tbGVuZ3RoIHdpZGdldCBpcyBpbnNlcnRlZCBuZXh0IHRvIHRoZSBjdXJzb3IgZHVyaW5nXG4gICAgLy8gY29tcG9zaXRpb24sIGF2b2lkIG1vdmluZyBpdCBhY3Jvc3MgaXQgYW5kIGRpc3J1cHRpbmcgdGhlXG4gICAgLy8gY29tcG9zaXRpb24uXG4gICAgc3VwcHJlc3NXaWRnZXRDdXJzb3JDaGFuZ2Uoc2VsLCBjdXJzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ29tcG9zaXRpb24gJiYgY3Vyc29yLmVtcHR5ICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSAmJlxuICAgICAgICAgICAgdGhpcy5wb3NGcm9tRE9NKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCkgPT0gY3Vyc29yLmhlYWQ7XG4gICAgfVxuICAgIGVuZm9yY2VDdXJzb3JBc3NvYygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIGN1cnNvciA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgbGV0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAoIXNlbCB8fCAhY3Vyc29yLmVtcHR5IHx8ICFjdXJzb3IuYXNzb2MgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5saW5lQXQoY3Vyc29yLmhlYWQsIGN1cnNvci5hc3NvYyk7XG4gICAgICAgIGlmICghbGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGxpbmUucG9zQXRTdGFydDtcbiAgICAgICAgaWYgKGN1cnNvci5oZWFkID09IGxpbmVTdGFydCB8fCBjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29vcmRzQXQoY3Vyc29yLmhlYWQsIC0xKSwgYWZ0ZXIgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAxKTtcbiAgICAgICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8IGJlZm9yZS5ib3R0b20gPiBhZnRlci50b3ApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb20gPSB0aGlzLmRvbUF0UG9zKGN1cnNvci5oZWFkICsgY3Vyc29yLmFzc29jLCBjdXJzb3IuYXNzb2MpO1xuICAgICAgICBzZWwuY29sbGFwc2UoZG9tLm5vZGUsIGRvbS5vZmZzZXQpO1xuICAgICAgICBzZWwubW9kaWZ5KFwibW92ZVwiLCBjdXJzb3IuYXNzb2MgPCAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIsIFwibGluZWJvdW5kYXJ5XCIpO1xuICAgICAgICAvLyBUaGlzIGNhbiBnbyB3cm9uZyBpbiBjb3JuZXIgY2FzZXMgbGlrZSBzaW5nbGUtY2hhcmFjdGVyIGxpbmVzLFxuICAgICAgICAvLyBzbyBjaGVjayBhbmQgcmVzZXQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICB2aWV3Lm9ic2VydmVyLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgbmV3UmFuZ2UgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAodmlldy5kb2NWaWV3LnBvc0Zyb21ET00obmV3UmFuZ2UuYW5jaG9yTm9kZSwgbmV3UmFuZ2UuYW5jaG9yT2Zmc2V0KSAhPSBjdXJzb3IuZnJvbSlcbiAgICAgICAgICAgIHNlbC5jb2xsYXBzZShhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgdGlsZSA9IHRoaXMudGlsZS5uZWFyZXN0KG5vZGUpO1xuICAgICAgICBpZiAoIXRpbGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aWxlLmRvbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIDIgLyogUFJFQ0VESU5HICovID8gMCA6IHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aWxlLnBvc0F0U3RhcnQ7XG4gICAgICAgIGlmICh0aWxlLmlzQ29tcG9zaXRlKCkpIHtcbiAgICAgICAgICAgIGxldCBhZnRlcjtcbiAgICAgICAgICAgIGlmIChub2RlID09IHRpbGUuZG9tKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSB0aWxlLmRvbS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmlhcyA9IG1heE9mZnNldChub2RlKSA9PSAwID8gMCA6IG9mZnNldCA9PSAwID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PSB0aWxlLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmlhcyA9PSAwICYmIHBhcmVudC5maXJzdENoaWxkICE9IHBhcmVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09IHBhcmVudC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZnRlciA9PSB0aWxlLmRvbS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIHdoaWxlIChhZnRlciAmJiAhVGlsZS5nZXQoYWZ0ZXIpKVxuICAgICAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydCArIHRpbGUubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGlsZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZG9tID09IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRpbGUuaXNUZXh0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlID09IHRpbGUuZG9tID8gc3RhcnQgKyBvZmZzZXQgOiBzdGFydCArIChvZmZzZXQgPyB0aWxlLmxlbmd0aCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyB0aWxlLCBvZmZzZXQgfSA9IHRoaXMudGlsZS5yZXNvbHZlQmxvY2socG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKHRpbGUuaXNXaWRnZXQoKSlcbiAgICAgICAgICAgIHJldHVybiB0aWxlLmRvbVBvc0Zvcihwb3MsIHNpZGUpO1xuICAgICAgICByZXR1cm4gdGlsZS5kb21JbihvZmZzZXQsIHNpZGUpO1xuICAgIH1cbiAgICBpbmxpbmVET01OZWFyUG9zKHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgYmVmb3JlLCBiZWZvcmVPZmYgPSAtMSwgYmVmb3JlQmFkID0gZmFsc2U7XG4gICAgICAgIGxldCBhZnRlciwgYWZ0ZXJPZmYgPSAtMSwgYWZ0ZXJCYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aWxlLmJsb2NrVGlsZXMoKHRpbGUsIG9mZikgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbGUuaXNXaWRnZXQoKSkge1xuICAgICAgICAgICAgICAgIGlmICgodGlsZS5mbGFncyAmIDMyIC8qIFRpbGVGbGFnLkFmdGVyICovKSAmJiBvZmYgPj0gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5mbGFncyAmIDE2IC8qIFRpbGVGbGFnLkJlZm9yZSAqLylcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlQmFkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBvZmYgKyB0aWxlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAob2ZmIDw9IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSB0aWxlO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVPZmYgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUJhZCA9IGVuZCA8IHBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MgJiYgIWFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gdGlsZTtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJPZmYgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyQmFkID0gb2ZmID4gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2ZmID4gcG9zICYmIGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghYmVmb3JlICYmICFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbUF0UG9zKHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChiZWZvcmVCYWQgJiYgYWZ0ZXIpXG4gICAgICAgICAgICBiZWZvcmUgPSBudWxsO1xuICAgICAgICBlbHNlIGlmIChhZnRlckJhZCAmJiBiZWZvcmUpXG4gICAgICAgICAgICBhZnRlciA9IG51bGw7XG4gICAgICAgIHJldHVybiBiZWZvcmUgJiYgc2lkZSA8IDAgfHwgIWFmdGVyID8gYmVmb3JlLmRvbUluKGJlZm9yZU9mZiwgc2lkZSkgOiBhZnRlci5kb21JbihhZnRlck9mZiwgc2lkZSk7XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyB0aWxlLCBvZmZzZXQgfSA9IHRoaXMudGlsZS5yZXNvbHZlQmxvY2socG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKHRpbGUuaXNXaWRnZXQoKSkge1xuICAgICAgICAgICAgaWYgKHRpbGUud2lkZ2V0IGluc3RhbmNlb2YgQmxvY2tHYXBXaWRnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGlsZS5jb29yZHNJbldpZGdldChvZmZzZXQsIHNpZGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWxlLmNvb3Jkc0luKG9mZnNldCwgc2lkZSk7XG4gICAgfVxuICAgIGxpbmVBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgdGlsZSB9ID0gdGhpcy50aWxlLnJlc29sdmVCbG9jayhwb3MsIHNpZGUpO1xuICAgICAgICByZXR1cm4gdGlsZS5pc0xpbmUoKSA/IHRpbGUgOiBudWxsO1xuICAgIH1cbiAgICBjb29yZHNGb3JDaGFyKHBvcykge1xuICAgICAgICBsZXQgeyB0aWxlLCBvZmZzZXQgfSA9IHRoaXMudGlsZS5yZXNvbHZlQmxvY2socG9zLCAxKTtcbiAgICAgICAgaWYgKCF0aWxlLmlzTGluZSgpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIHNjYW4odGlsZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAodGlsZS5pc0NvbXBvc2l0ZSgpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2ggb2YgdGlsZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2gubGVuZ3RoID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gc2NhbihjaCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IGNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aWxlLmlzVGV4dCgpICYmIG9mZnNldCA8IHRpbGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGZpbmRDbHVzdGVyQnJlYWsodGlsZS50ZXh0LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UodGlsZS5kb20sIG9mZnNldCwgZW5kKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gcmVjdHMubGVuZ3RoIC0gMSB8fCByZWN0LnRvcCA8IHJlY3QuYm90dG9tICYmIHJlY3QubGVmdCA8IHJlY3QucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Nhbih0aWxlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZpZXdwb3J0KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgeyBmcm9tLCB0byB9ID0gdmlld3BvcnQ7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSB0aGlzLnZpZXcuY29udGVudERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgbGV0IGlzV2lkZXIgPSBjb250ZW50V2lkdGggPiBNYXRoLm1heCh0aGlzLnZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB0aGlzLm1pbldpZHRoKSArIDE7XG4gICAgICAgIGxldCB3aWRlc3QgPSAtMSwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgbGV0IHNwYWNlQWJvdmUgPSAwO1xuICAgICAgICBsZXQgc2NhbiA9ICh0aWxlLCBwb3MsIG1lYXN1cmVCb3VuZHMpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlsZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGlsZS5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZFJlY3QgPSBjaGlsZC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHsgaGVpZ2h0IH0gPSBjaGlsZFJlY3Q7XG4gICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVCb3VuZHMgJiYgIWkpXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlQWJvdmUgKz0gY2hpbGRSZWN0LnRvcCAtIG1lYXN1cmVCb3VuZHMudG9wO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJsb2NrV3JhcHBlclRpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FuKGNoaWxkLCBwb3MsIGNoaWxkUmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvcyA+PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFjZUFib3ZlID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC1zcGFjZUFib3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaGVpZ2h0ICsgc3BhY2VBYm92ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlQWJvdmUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBjaGlsZC5kb20ubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RzID0gbGFzdCA/IGNsaWVudFJlY3RzRm9yKGxhc3QpIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSBsdHIgPyByZWN0LnJpZ2h0IC0gY2hpbGRSZWN0LmxlZnQgOiBjaGlsZFJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoID4gd2lkZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVhc3VyZUJvdW5kcyAmJiBpID09IHRpbGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VBYm92ZSArPSBtZWFzdXJlQm91bmRzLmJvdHRvbSAtIGNoaWxkUmVjdC5ib3R0b207XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2Nhbih0aGlzLnRpbGUsIDAsIG51bGwpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCB7IHRpbGUgfSA9IHRoaXMudGlsZS5yZXNvbHZlQmxvY2socG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUodGlsZS5kb20pLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgbGV0IGxpbmVNZWFzdXJlID0gdGhpcy50aWxlLmJsb2NrVGlsZXModGlsZSA9PiB7XG4gICAgICAgICAgICBpZiAodGlsZS5pc0xpbmUoKSAmJiB0aWxlLmNoaWxkcmVuLmxlbmd0aCAmJiB0aWxlLmxlbmd0aCA8PSAyMCkge1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoID0gMCwgdGV4dEhlaWdodDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aWxlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQuaXNUZXh0KCkgfHwgL1teIC1+XS8udGVzdChjaGlsZC50ZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkLmRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGggIT0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gcmVjdHNbMF0ud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRleHRIZWlnaHQgPSByZWN0c1swXS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogdGlsZS5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcldpZHRoOiB0b3RhbFdpZHRoIC8gdGlsZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGluZU1lYXN1cmUpXG4gICAgICAgICAgICByZXR1cm4gbGluZU1lYXN1cmU7XG4gICAgICAgIC8vIElmIG5vIHdvcmthYmxlIGxpbmUgZXhpc3RzLCBmb3JjZSBhIGxheW91dCBvZiBhIG1lYXN1cmFibGUgZWxlbWVudFxuICAgICAgICBsZXQgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQ7XG4gICAgICAgIGR1bW15LmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICBkdW1teS5zdHlsZS53aWR0aCA9IFwiOTk5OTlweFwiO1xuICAgICAgICBkdW1teS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgZHVtbXkudGV4dENvbnRlbnQgPSBcImFiYyBkZWYgZ2hpIGprbCBtbm8gcHFyIHN0dVwiO1xuICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGlsZS5kb20uYXBwZW5kQ2hpbGQoZHVtbXkpO1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBjbGllbnRSZWN0c0ZvcihkdW1teS5maXJzdENoaWxkKVswXTtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBkdW1teS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICBjaGFyV2lkdGggPSByZWN0ICYmIHJlY3Qud2lkdGggPyByZWN0LndpZHRoIC8gMjcgOiA3O1xuICAgICAgICAgICAgdGV4dEhlaWdodCA9IHJlY3QgJiYgcmVjdC5oZWlnaHQgPyByZWN0LmhlaWdodCA6IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBkdW1teS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCB9O1xuICAgIH1cbiAgICBjb21wdXRlQmxvY2tHYXBEZWNvKCkge1xuICAgICAgICBsZXQgZGVjbyA9IFtdLCB2cyA9IHRoaXMudmlldy52aWV3U3RhdGU7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gdnMudmlld3BvcnRzLmxlbmd0aCA/IG51bGwgOiB2cy52aWV3cG9ydHNbaV07XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbSAtIDEgOiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gKHZzLmxpbmVCbG9ja0F0KGVuZCkuYm90dG9tIC0gdnMubGluZUJsb2NrQXQocG9zKS50b3ApIC8gdGhpcy52aWV3LnNjYWxlWTtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2goRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgQmxvY2tHYXBXaWRnZXQoaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9ja0dhcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShwb3MsIGVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dC50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbiAgICB1cGRhdGVEZWNvKCkge1xuICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgIGxldCBhbGxEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5tYXAoZCA9PiB7XG4gICAgICAgICAgICBsZXQgZHluYW1pYyA9IHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljID8gZCh0aGlzLnZpZXcpIDogZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkeW5hbWljT3V0ZXIgPSBmYWxzZSwgb3V0ZXJEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KG91dGVyRGVjb3JhdGlvbnMpLm1hcCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGR5bmFtaWMgPSB0eXBlb2YgZCA9PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICBpZiAoZHluYW1pYylcbiAgICAgICAgICAgICAgICBkeW5hbWljT3V0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWMgPyBkKHRoaXMudmlldykgOiBkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dGVyRGVjby5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IGR5bmFtaWNPdXRlcjtcbiAgICAgICAgICAgIGFsbERlY28ucHVzaChSYW5nZVNldC5qb2luKG91dGVyRGVjbykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBbXG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZyxcbiAgICAgICAgICAgIC4uLmFsbERlY28sXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCbG9ja0dhcERlY28oKSxcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubGluZUdhcERlY29cbiAgICAgICAgXTtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrV3JhcHBlcnMgPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoYmxvY2tXcmFwcGVycykubWFwKHYgPT4gdHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiID8gdih0aGlzLnZpZXcpIDogdik7XG4gICAgfVxuICAgIHNjcm9sbEludG9WaWV3KHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0LmlzU25hcHNob3QpIHtcbiAgICAgICAgICAgIGxldCByZWYgPSB0aGlzLnZpZXcudmlld1N0YXRlLmxpbmVCbG9ja0F0KHRhcmdldC5yYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsVG9wID0gcmVmLnRvcCAtIHRhcmdldC55TWFyZ2luO1xuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ID0gdGFyZ2V0LnhNYXJnaW47XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoc2Nyb2xsSGFuZGxlcikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIodGhpcy52aWV3LCB0YXJnZXQucmFuZ2UsIHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlLCBcInNjcm9sbCBoYW5kbGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB7IHJhbmdlIH0gPSB0YXJnZXQ7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5jb29yZHNBdChyYW5nZS5oZWFkLCByYW5nZS5lbXB0eSA/IHJhbmdlLmFzc29jIDogcmFuZ2UuaGVhZCA+IHJhbmdlLmFuY2hvciA/IC0xIDogMSksIG90aGVyO1xuICAgICAgICBpZiAoIXJlY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgJiYgKG90aGVyID0gdGhpcy5jb29yZHNBdChyYW5nZS5hbmNob3IsIHJhbmdlLmFuY2hvciA+IHJhbmdlLmhlYWQgPyAtMSA6IDEpKSlcbiAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IE1hdGgubWluKHJlY3QubGVmdCwgb3RoZXIubGVmdCksIHRvcDogTWF0aC5taW4ocmVjdC50b3AsIG90aGVyLnRvcCksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IE1hdGgubWF4KHJlY3QucmlnaHQsIG90aGVyLnJpZ2h0KSwgYm90dG9tOiBNYXRoLm1heChyZWN0LmJvdHRvbSwgb3RoZXIuYm90dG9tKSB9O1xuICAgICAgICBsZXQgbWFyZ2lucyA9IGdldFNjcm9sbE1hcmdpbnModGhpcy52aWV3KTtcbiAgICAgICAgbGV0IHRhcmdldFJlY3QgPSB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBtYXJnaW5zLmxlZnQsIHRvcDogcmVjdC50b3AgLSBtYXJnaW5zLnRvcCxcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgbWFyZ2lucy5yaWdodCwgYm90dG9tOiByZWN0LmJvdHRvbSArIG1hcmdpbnMuYm90dG9tXG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IHRoaXMudmlldy5zY3JvbGxET007XG4gICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLnZpZXcuc2Nyb2xsRE9NLCB0YXJnZXRSZWN0LCByYW5nZS5oZWFkIDwgcmFuZ2UuYW5jaG9yID8gLTEgOiAxLCB0YXJnZXQueCwgdGFyZ2V0LnksIE1hdGgubWF4KE1hdGgubWluKHRhcmdldC54TWFyZ2luLCBvZmZzZXRXaWR0aCksIC1vZmZzZXRXaWR0aCksIE1hdGgubWF4KE1hdGgubWluKHRhcmdldC55TWFyZ2luLCBvZmZzZXRIZWlnaHQpLCAtb2Zmc2V0SGVpZ2h0KSwgdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUik7XG4gICAgfVxuICAgIGxpbmVIYXNXaWRnZXQocG9zKSB7XG4gICAgICAgIGxldCBzY2FuID0gKGNoaWxkKSA9PiBjaGlsZC5pc1dpZGdldCgpIHx8IGNoaWxkLmNoaWxkcmVuLnNvbWUoc2Nhbik7XG4gICAgICAgIHJldHVybiBzY2FuKHRoaXMudGlsZS5yZXNvbHZlQmxvY2socG9zLCAxKS50aWxlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZGVzdHJveURyb3BwZWQodGhpcy50aWxlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXN0cm95RHJvcHBlZCh0aWxlLCByZXVzZWQpIHtcbiAgICBsZXQgciA9IHJldXNlZCA9PT0gbnVsbCB8fCByZXVzZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJldXNlZC5nZXQodGlsZSk7XG4gICAgaWYgKHIgIT0gMSAvKiBSZXVzZWQuRnVsbCAqLykge1xuICAgICAgICBpZiAociA9PSBudWxsKVxuICAgICAgICAgICAgdGlsZS5kZXN0cm95KCk7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRpbGUuY2hpbGRyZW4pXG4gICAgICAgICAgICBkZXN0cm95RHJvcHBlZChjaCwgcmV1c2VkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiZXR3ZWVuVW5lZGl0YWJsZShwb3MpIHtcbiAgICByZXR1cm4gcG9zLm5vZGUubm9kZVR5cGUgPT0gMSAmJiBwb3Mubm9kZS5maXJzdENoaWxkICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IDAgfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgJiZcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gcG9zLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbn1cbmZ1bmN0aW9uIGZpbmRDb21wb3NpdGlvbk5vZGUodmlldywgaGVhZFBvcykge1xuICAgIGxldCBzZWwgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmICghc2VsLmZvY3VzTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHRleHRCZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGxldCB0ZXh0QWZ0ZXIgPSB0ZXh0Tm9kZUFmdGVyKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgbGV0IHRleHROb2RlID0gdGV4dEJlZm9yZSB8fCB0ZXh0QWZ0ZXI7XG4gICAgaWYgKHRleHRBZnRlciAmJiB0ZXh0QmVmb3JlICYmIHRleHRBZnRlci5ub2RlICE9IHRleHRCZWZvcmUubm9kZSkge1xuICAgICAgICBsZXQgdGlsZUFmdGVyID0gVGlsZS5nZXQodGV4dEFmdGVyLm5vZGUpO1xuICAgICAgICBpZiAoIXRpbGVBZnRlciB8fCB0aWxlQWZ0ZXIuaXNUZXh0KCkgJiYgdGlsZUFmdGVyLnRleHQgIT0gdGV4dEFmdGVyLm5vZGUubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICB0ZXh0Tm9kZSA9IHRleHRBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3LmRvY1ZpZXcubGFzdENvbXBvc2l0aW9uQWZ0ZXJDdXJzb3IpIHtcbiAgICAgICAgICAgIGxldCB0aWxlQmVmb3JlID0gVGlsZS5nZXQodGV4dEJlZm9yZS5ub2RlKTtcbiAgICAgICAgICAgIGlmICghKCF0aWxlQmVmb3JlIHx8IHRpbGVCZWZvcmUuaXNUZXh0KCkgJiYgdGlsZUJlZm9yZS50ZXh0ICE9IHRleHRCZWZvcmUubm9kZS5ub2RlVmFsdWUpKVxuICAgICAgICAgICAgICAgIHRleHROb2RlID0gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9jVmlldy5sYXN0Q29tcG9zaXRpb25BZnRlckN1cnNvciA9IHRleHROb2RlICE9IHRleHRCZWZvcmU7XG4gICAgaWYgKCF0ZXh0Tm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZyb20gPSBoZWFkUG9zIC0gdGV4dE5vZGUub2Zmc2V0O1xuICAgIHJldHVybiB7IGZyb20sIHRvOiBmcm9tICsgdGV4dE5vZGUubm9kZS5ub2RlVmFsdWUubGVuZ3RoLCBub2RlOiB0ZXh0Tm9kZS5ub2RlIH07XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25SYW5nZSh2aWV3LCBjaGFuZ2VzLCBoZWFkUG9zKSB7XG4gICAgbGV0IGZvdW5kID0gZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBoZWFkUG9zKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBub2RlOiB0ZXh0Tm9kZSwgZnJvbSwgdG8gfSA9IGZvdW5kLCB0ZXh0ID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgIC8vIERvbid0IHRyeSB0byBwcmVzZXJ2ZSBtdWx0aS1saW5lIGNvbXBvc2l0aW9uc1xuICAgIGlmICgvW1xcblxccl0vLnRlc3QodGV4dCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhmb3VuZC5mcm9tLCBmb3VuZC50bykgIT0gdGV4dClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGludiA9IGNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgIHJldHVybiB7IHJhbmdlOiBuZXcgQ2hhbmdlZFJhbmdlKGludi5tYXBQb3MoZnJvbSksIGludi5tYXBQb3ModG8pLCBmcm9tLCB0byksIHRleHQ6IHRleHROb2RlIH07XG59XG5mdW5jdGlvbiBuZXh0VG9VbmVkaXRhYmxlKG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAob2Zmc2V0ICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMSAvKiBOZXh0VG8uQmVmb3JlICovIDogMCkgfFxuICAgICAgICAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMiAvKiBOZXh0VG8uQWZ0ZXIgKi8gOiAwKTtcbn1cbmxldCBEZWNvcmF0aW9uQ29tcGFyYXRvciQxID0gY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XG4gICAgYm91bmRDaGFuZ2UocG9zKSB7IGFkZFJhbmdlKHBvcywgcG9zLCB0aGlzLmNoYW5nZXMpOyB9XG59O1xuZnVuY3Rpb24gZmluZENoYW5nZWREZWNvKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvciQxO1xuICAgIFJhbmdlU2V0LmNvbXBhcmUoYSwgYiwgZGlmZiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcbn1cbmNsYXNzIFdyYXBwZXJDb21wYXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG4gICAgfVxuICAgIGNvbXBhcmVSYW5nZShmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxuICAgIGNvbXBhcmVQb2ludCgpIHsgfVxuICAgIGJvdW5kQ2hhbmdlKHBvcykgeyBhZGRSYW5nZShwb3MsIHBvcywgdGhpcy5jaGFuZ2VzKTsgfVxufVxuZnVuY3Rpb24gZmluZENoYW5nZWRXcmFwcGVycyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgV3JhcHBlckNvbXBhcmF0b3I7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuZnVuY3Rpb24gaW5VbmVkaXRhYmxlKG5vZGUsIGluc2lkZSkge1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1ciAmJiBjdXIgIT0gaW5zaWRlOyBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSAmJiBjdXIuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvdWNoZXNDb21wb3NpdGlvbihjaGFuZ2VzLCBjb21wb3NpdGlvbikge1xuICAgIGxldCB0b3VjaGVkID0gZmFsc2U7XG4gICAgaWYgKGNvbXBvc2l0aW9uKVxuICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPCBjb21wb3NpdGlvbi50byAmJiB0byA+IGNvbXBvc2l0aW9uLmZyb20pXG4gICAgICAgICAgICAgICAgdG91Y2hlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIHJldHVybiB0b3VjaGVkO1xufVxuY2xhc3MgQmxvY2tHYXBXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IFwiY20tZ2FwXCI7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5oZWlnaHQgPT0gdGhpcy5oZWlnaHQ7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBlZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5oZWlnaHQ7IH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmZ1bmN0aW9uIGdyb3VwQXQoc3RhdGUsIHBvcywgYmlhcyA9IDEpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBsaW5lUG9zID0gcG9zIC0gbGluZS5mcm9tO1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIGlmIChsaW5lUG9zID09IDApXG4gICAgICAgIGJpYXMgPSAxO1xuICAgIGVsc2UgaWYgKGxpbmVQb3MgPT0gbGluZS5sZW5ndGgpXG4gICAgICAgIGJpYXMgPSAtMTtcbiAgICBsZXQgZnJvbSA9IGxpbmVQb3MsIHRvID0gbGluZVBvcztcbiAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgIGZyb20gPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcywgZmFsc2UpO1xuICAgIGVsc2VcbiAgICAgICAgdG8gPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcyk7XG4gICAgbGV0IGNhdCA9IGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgd2hpbGUgKGZyb20gPiAwKSB7XG4gICAgICAgIGxldCBwcmV2ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKHByZXYsIGZyb20pKSAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZnJvbSA9IHByZXY7XG4gICAgfVxuICAgIHdoaWxlICh0byA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHRvKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKHRvLCBuZXh0KSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHRvID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tICsgbGluZS5mcm9tLCB0byArIGxpbmUuZnJvbSk7XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50UmVjdCwgYmxvY2ssIHgsIHkpIHtcbiAgICBsZXQgaW50byA9IE1hdGgucm91bmQoKHggLSBjb250ZW50UmVjdC5sZWZ0KSAqIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKTtcbiAgICBpZiAodmlldy5saW5lV3JhcHBpbmcgJiYgYmxvY2suaGVpZ2h0ID4gdmlldy5kZWZhdWx0TGluZUhlaWdodCAqIDEuNSkge1xuICAgICAgICBsZXQgdGV4dEhlaWdodCA9IHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0O1xuICAgICAgICBsZXQgbGluZSA9IE1hdGguZmxvb3IoKHkgLSBibG9jay50b3AgLSAodmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHRleHRIZWlnaHQpICogMC41KSAvIHRleHRIZWlnaHQpO1xuICAgICAgICBpbnRvICs9IGxpbmUgKiB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUxlbmd0aDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGJsb2NrLmZyb20sIGJsb2NrLnRvKTtcbiAgICByZXR1cm4gYmxvY2suZnJvbSArIGZpbmRDb2x1bW4oY29udGVudCwgaW50bywgdmlldy5zdGF0ZS50YWJTaXplKTtcbn1cbmZ1bmN0aW9uIGJsb2NrQXQodmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSkge1xuICAgICAgICBsZXQgYmVzdDtcbiAgICAgICAgZm9yIChsZXQgbCBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChsLmZyb20gPiBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobC50byA8IHBvcylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChsLmZyb20gPCBwb3MgJiYgbC50byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgICAgIGlmICghYmVzdCB8fCAobC50eXBlID09IEJsb2NrVHlwZS5UZXh0ICYmIChiZXN0LnR5cGUgIT0gbC50eXBlIHx8IChzaWRlIDwgMCA/IGwuZnJvbSA8IHBvcyA6IGwudG8gPiBwb3MpKSkpXG4gICAgICAgICAgICAgICAgYmVzdCA9IGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3QgfHwgbGluZTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59XG5mdW5jdGlvbiBtb3ZlVG9MaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKSB7XG4gICAgbGV0IGxpbmUgPSBibG9ja0F0KHZpZXcsIHN0YXJ0LmhlYWQsIHN0YXJ0LmFzc29jIHx8IC0xKTtcbiAgICBsZXQgY29vcmRzID0gIWluY2x1ZGVXcmFwIHx8IGxpbmUudHlwZSAhPSBCbG9ja1R5cGUuVGV4dCB8fCAhKHZpZXcubGluZVdyYXBwaW5nIHx8IGxpbmUud2lkZ2V0TGluZUJyZWFrcykgPyBudWxsXG4gICAgICAgIDogdmlldy5jb29yZHNBdFBvcyhzdGFydC5hc3NvYyA8IDAgJiYgc3RhcnQuaGVhZCA+IGxpbmUuZnJvbSA/IHN0YXJ0LmhlYWQgLSAxIDogc3RhcnQuaGVhZCk7XG4gICAgaWYgKGNvb3Jkcykge1xuICAgICAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBmb3J3YXJkID09IChkaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUikgPyBlZGl0b3JSZWN0LnJpZ2h0IC0gMSA6IGVkaXRvclJlY3QubGVmdCArIDEsXG4gICAgICAgICAgICB5OiAoY29vcmRzLnRvcCArIGNvb3Jkcy5ib3R0b20pIC8gMiB9KTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gbW92ZUJ5Q2hhcih2aWV3LCBzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKSwgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFydCwgY2hlY2sgPSBudWxsOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlVmlzdWFsbHkobGluZSwgc3BhbnMsIGRpcmVjdGlvbiwgY3VyLCBmb3J3YXJkKSwgY2hhciA9IG1vdmVkT3ZlcjtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjaGFyID0gXCJcXG5cIjtcbiAgICAgICAgICAgIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lKGxpbmUubnVtYmVyICsgKGZvcndhcmQgPyAxIDogLTEpKTtcbiAgICAgICAgICAgIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgICAgICBuZXh0ID0gdmlldy52aXN1YWxMaW5lU2lkZShsaW5lLCAhZm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgaWYgKCFieSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIGNoZWNrID0gYnkoY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrKGNoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYnlHcm91cCh2aWV3LCBwb3MsIHN0YXJ0KSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKHN0YXJ0KTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHJldHVybiBjYXQgPT0gbmV4dENhdDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZVZlcnRpY2FsbHkodmlldywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQuaGVhZCwgZGlyID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICBpZiAoc3RhcnRQb3MgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiAwKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnRQb3MsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgZ29hbCA9IHN0YXJ0LmdvYWxDb2x1bW4sIHN0YXJ0WTtcbiAgICBsZXQgcmVjdCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc3RhcnRDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0UG9zLCAoc3RhcnQuZW1wdHkgPyBzdGFydC5hc3NvYyA6IDApIHx8IChmb3J3YXJkID8gMSA6IC0xKSksIGRvY1RvcCA9IHZpZXcuZG9jdW1lbnRUb3A7XG4gICAgaWYgKHN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gc3RhcnRDb29yZHMubGVmdCAtIHJlY3QubGVmdDtcbiAgICAgICAgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQoc3RhcnRQb3MpO1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoICogKHN0YXJ0UG9zIC0gbGluZS5mcm9tKSk7XG4gICAgICAgIHN0YXJ0WSA9IChkaXIgPCAwID8gbGluZS50b3AgOiBsaW5lLmJvdHRvbSkgKyBkb2NUb3A7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZEdvYWwgPSByZWN0LmxlZnQgKyBnb2FsO1xuICAgIGxldCBkaXN0ID0gZGlzdGFuY2UgIT09IG51bGwgJiYgZGlzdGFuY2UgIT09IHZvaWQgMCA/IGRpc3RhbmNlIDogKHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0ID4+IDEpO1xuICAgIGxldCBwb3MgPSBwb3NBdENvb3Jkcyh2aWV3LCB7IHg6IHJlc29sdmVkR29hbCwgeTogc3RhcnRZICsgZGlzdCAqIGRpciB9LCBmYWxzZSwgZGlyKTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MucG9zLCBwb3MuYXNzb2MsIHVuZGVmaW5lZCwgZ29hbCk7XG59XG5mdW5jdGlvbiBza2lwQXRvbWljUmFuZ2VzKGF0b21zLCBwb3MsIGJpYXMpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBtb3ZlZCA9IDA7XG4gICAgICAgIGZvciAobGV0IHNldCBvZiBhdG9tcykge1xuICAgICAgICAgICAgc2V0LmJldHdlZW4ocG9zIC0gMSwgcG9zICsgMSwgKGZyb20sIHRvLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIHBvcyA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaWRlID0gbW92ZWQgfHwgYmlhcyB8fCAocG9zIC0gZnJvbSA8IHRvIC0gcG9zID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gc2lkZSA8IDAgPyBmcm9tIDogdG87XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkID0gc2lkZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vdmVkKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG59XG5mdW5jdGlvbiBza2lwQXRvbXNGb3JTZWxlY3Rpb24oYXRvbXMsIHNlbCkge1xuICAgIGxldCByYW5nZXMgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldLCB1cGRhdGVkID0gbnVsbDtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gc2tpcEF0b21pY1JhbmdlcyhhdG9tcywgcmFuZ2UuZnJvbSwgMCk7XG4gICAgICAgICAgICBpZiAocG9zICE9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgdXBkYXRlZCA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHNraXBBdG9taWNSYW5nZXMoYXRvbXMsIHJhbmdlLmZyb20sIC0xKTtcbiAgICAgICAgICAgIGxldCB0byA9IHNraXBBdG9taWNSYW5nZXMoYXRvbXMsIHJhbmdlLnRvLCAxKTtcbiAgICAgICAgICAgIGlmIChmcm9tICE9IHJhbmdlLmZyb20gfHwgdG8gIT0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgdXBkYXRlZCA9IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5mcm9tID09IHJhbmdlLmFuY2hvciA/IGZyb20gOiB0bywgcmFuZ2UuZnJvbSA9PSByYW5nZS5oZWFkID8gZnJvbSA6IHRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgaWYgKCFyYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzID0gc2VsLnJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgcmFuZ2VzW2ldID0gdXBkYXRlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzID8gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHNlbC5tYWluSW5kZXgpIDogc2VsO1xufVxuZnVuY3Rpb24gc2tpcEF0b21zKHZpZXcsIG9sZFBvcywgcG9zKSB7XG4gICAgbGV0IG5ld1BvcyA9IHNraXBBdG9taWNSYW5nZXModmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpLCBwb3MuZnJvbSwgb2xkUG9zLmhlYWQgPiBwb3MuZnJvbSA/IC0xIDogMSk7XG4gICAgcmV0dXJuIG5ld1BvcyA9PSBwb3MuZnJvbSA/IHBvcyA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV3UG9zLCBuZXdQb3MgPCBwb3MuZnJvbSA/IDEgOiAtMSk7XG59XG5jbGFzcyBQb3NBc3NvYyB7XG4gICAgY29uc3RydWN0b3IocG9zLCBhc3NvYykge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5hc3NvYyA9IGFzc29jO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzKHZpZXcsIGNvb3JkcywgcHJlY2lzZSwgc2NhblkpIHtcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9jVG9wID0gY29udGVudC50b3AgKyB2aWV3LnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICAgIGxldCB7IHgsIHkgfSA9IGNvb3JkcywgeU9mZnNldCA9IHkgLSBkb2NUb3AsIGJsb2NrO1xuICAgIC8vIEZpcnN0IGZpbmQgdGhlIGJsb2NrIGF0IHRoZSBnaXZlbiBZIHBvc2l0aW9uLCBpZiBhbnkuIElmIHNjYW5ZIGlzXG4gICAgLy8gZ2l2ZW4gKHVzZWQgZm9yIHZlcnRpY2FsIGN1cnNvciBtb3Rpb24pLCB0cnkgdG8gc2tpcCB3aWRnZXRzIGFuZFxuICAgIC8vIGxpbmUgcGFkZGluZy5cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICh5T2Zmc2V0IDwgMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zQXNzb2MoMCwgMSk7XG4gICAgICAgIGlmICh5T2Zmc2V0ID4gdmlldy52aWV3U3RhdGUuZG9jSGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3NBc3NvYyh2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIC0xKTtcbiAgICAgICAgYmxvY2sgPSB2aWV3LmVsZW1lbnRBdEhlaWdodCh5T2Zmc2V0KTtcbiAgICAgICAgaWYgKHNjYW5ZID09IG51bGwpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgIGlmIChzY2FuWSA8IDAgPyBibG9jay50byA8IHZpZXcudmlld3BvcnQuZnJvbSA6IGJsb2NrLmZyb20gPiB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB3ZSBhcmVuJ3QgbGFuZGluZyBvbiB0aGUgdG9wL2JvdHRvbSBwYWRkaW5nIG9mIHRoZSBsaW5lXG4gICAgICAgICAgICBsZXQgcmVjdCA9IHZpZXcuZG9jVmlldy5jb29yZHNBdChzY2FuWSA8IDAgPyBibG9jay5mcm9tIDogYmxvY2sudG8sIHNjYW5ZID4gMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBpZiAocmVjdCAmJiAoc2NhblkgPCAwID8gcmVjdC50b3AgPD0geU9mZnNldCArIGRvY1RvcCA6IHJlY3QuYm90dG9tID49IHlPZmZzZXQgKyBkb2NUb3ApKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYWxmTGluZSA9IHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0IC8gMjtcbiAgICAgICAgeU9mZnNldCA9IHNjYW5ZID4gMCA/IGJsb2NrLmJvdHRvbSArIGhhbGZMaW5lIDogYmxvY2sudG9wIC0gaGFsZkxpbmU7XG4gICAgfVxuICAgIC8vIElmIG91dHNpZGUgdGhlIHZpZXdwb3J0LCByZXR1cm4gbnVsbCBpZiBwcmVjaXNlPT10cnVlLCBhblxuICAgIC8vIGVzdGltYXRlIG90aGVyd2lzZS5cbiAgICBpZiAodmlldy52aWV3cG9ydC5mcm9tID49IGJsb2NrLnRvIHx8IHZpZXcudmlld3BvcnQudG8gPD0gYmxvY2suZnJvbSkge1xuICAgICAgICBpZiAocHJlY2lzZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoYmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnQsIGJsb2NrLCB4LCB5KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zQXNzb2MocG9zLCBwb3MgPT0gYmxvY2suZnJvbSA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJsb2NrLnR5cGUgIT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgIHJldHVybiB5T2Zmc2V0IDwgKGJsb2NrLnRvcCArIGJsb2NrLmJvdHRvbSkgLyAyID8gbmV3IFBvc0Fzc29jKGJsb2NrLmZyb20sIDEpIDogbmV3IFBvc0Fzc29jKGJsb2NrLnRvLCAtMSk7XG4gICAgLy8gSGVyZSB3ZSBrbm93IHdlJ3JlIGluIGEgbGluZSwgc28gcnVuIHRoZSBsb2dpYyBmb3IgaW5saW5lIGxheW91dFxuICAgIGxldCBsaW5lID0gdmlldy5kb2NWaWV3LmxpbmVBdChibG9jay5mcm9tLCAyKTtcbiAgICBpZiAoIWxpbmUgfHwgbGluZS5sZW5ndGggIT0gYmxvY2subGVuZ3RoKVxuICAgICAgICBsaW5lID0gdmlldy5kb2NWaWV3LmxpbmVBdChibG9jay5mcm9tLCAtMik7XG4gICAgcmV0dXJuIHBvc0F0Q29vcmRzSW5saW5lKHZpZXcsIGxpbmUsIGJsb2NrLmZyb20sIHgsIHkpO1xufVxuLy8gU2NhbiB0aHJvdWdoIHRoZSByZWN0YW5nbGVzIGZvciB0aGUgY29udGVudCBvZiBhIHRpbGUsIGZpbmRpbmcgdGhlXG4vLyBvbmUgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMsIHByZWZlcmluZyBjbG9zZW5lc3MgaW4gWSBvdmVyXG4vLyBjbG9zZW5lc3MgaW4gWC5cbi8vXG4vLyBJZiB0aGlzIGlzIGEgdGV4dCB0aWxlLCBnbyBjaGFyYWN0ZXItYnktY2hhcmFjdGVyLiBGb3IgbGluZSBvciBtYXJrXG4vLyB0aWxlcywgY2hlY2sgZWFjaCBub24tcG9pbnQtd2lkZ2V0IGNoaWxkLCBhbmQgZGVzY2VuZCB0ZXh0IG9yIG1hcmtcbi8vIHRpbGVzIHdpdGggYSByZWN1cnNpdmUgY2FsbC5cbi8vXG4vLyBGb3Igbm9uLXdyYXBwZWQsIHB1cmVseSBsZWZ0LXRvLXJpZ2h0IHRleHQsIHRoaXMgY291bGQgdXNlIGEgYmluYXJ5XG4vLyBzZWFyY2guIEJ1dCBiZWNhdXNlIHRoaXMgc2VlbXMgdG8gYmUgZmFzdCBlbm91Z2gsIGZvciBob3cgb2Z0ZW4gaXRcbi8vIGlzIGNhbGxlZCwgdGhlcmUncyBub3QgY3VycmVudGx5IGEgc3BlY2lhbGl6ZWQgaW1wbGVtZW50YXRpb24gZm9yXG4vLyB0aGF0LlxuZnVuY3Rpb24gcG9zQXRDb29yZHNJbmxpbmUodmlldywgdGlsZSwgb2Zmc2V0LCB4LCB5KSB7XG4gICAgbGV0IGNsb3Nlc3QgPSAtMSwgY2xvc2VzdFJlY3QgPSBudWxsO1xuICAgIGxldCBkeENsb3Nlc3QgPSAxZTksIGR5Q2xvc2VzdCA9IDFlOTtcbiAgICBsZXQgcm93VG9wID0geSwgcm93Qm90ID0geTtcbiAgICBsZXQgY2hlY2tSZWN0cyA9IChyZWN0cywgaW5kZXgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBkeCA9IHJlY3QubGVmdCA+IHggPyByZWN0LmxlZnQgLSB4IDogcmVjdC5yaWdodCA8IHggPyB4IC0gcmVjdC5yaWdodCA6IDA7XG4gICAgICAgICAgICBsZXQgZHkgPSByZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiByZWN0LmJvdHRvbSA8IHkgPyB5IC0gcmVjdC5ib3R0b20gOiAwO1xuICAgICAgICAgICAgaWYgKHJlY3QudG9wIDw9IHJvd0JvdCAmJiByZWN0LmJvdHRvbSA+PSByb3dUb3ApIHtcbiAgICAgICAgICAgICAgICAvLyBSZWN0YW5nbGUgaXMgaW4gdGhlIGN1cnJlbnQgcm93XG4gICAgICAgICAgICAgICAgcm93VG9wID0gTWF0aC5taW4ocmVjdC50b3AsIHJvd1RvcCk7XG4gICAgICAgICAgICAgICAgcm93Qm90ID0gTWF0aC5tYXgocmVjdC5ib3R0b20sIHJvd0JvdCk7XG4gICAgICAgICAgICAgICAgZHkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsb3Nlc3QgPCAwIHx8IChkeSAtIGR5Q2xvc2VzdCB8fCBkeCAtIGR4Q2xvc2VzdCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3QgPj0gMCAmJiBkeUNsb3Nlc3QgJiYgZHhDbG9zZXN0IDwgZHggJiZcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFJlY3QudG9wIDw9IHJvd0JvdCAtIDIgJiYgY2xvc2VzdFJlY3QuYm90dG9tID49IHJvd1RvcCArIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0cm9hY3RpdmVseSBzZXQgZHkgdG8gMCBpZiB0aGUgY3VycmVudCBtYXRjaCBpcyBpbiB0aGlzIHJvdy5cbiAgICAgICAgICAgICAgICAgICAgZHlDbG9zZXN0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgZHhDbG9zZXN0ID0gZHg7XG4gICAgICAgICAgICAgICAgICAgIGR5Q2xvc2VzdCA9IGR5O1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAodGlsZS5pc1RleHQoKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbGUubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKHRpbGUudGV4dCwgaSk7XG4gICAgICAgICAgICBjaGVja1JlY3RzKHRleHRSYW5nZSh0aWxlLmRvbSwgaSwgbmV4dCkuZ2V0Q2xpZW50UmVjdHMoKSwgaSk7XG4gICAgICAgICAgICBpZiAoIWR4Q2xvc2VzdCAmJiAhZHlDbG9zZXN0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFmdGVyID0gKHggPiAoY2xvc2VzdFJlY3QubGVmdCArIGNsb3Nlc3RSZWN0LnJpZ2h0KSAvIDIpID09IChkaXJBdCh2aWV3LCBjbG9zZXN0ICsgb2Zmc2V0KSA9PSBEaXJlY3Rpb24uTFRSKTtcbiAgICAgICAgcmV0dXJuIGFmdGVyID8gbmV3IFBvc0Fzc29jKG9mZnNldCArIGZpbmRDbHVzdGVyQnJlYWsodGlsZS50ZXh0LCBjbG9zZXN0KSwgLTEpIDogbmV3IFBvc0Fzc29jKG9mZnNldCArIGNsb3Nlc3QsIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCF0aWxlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zQXNzb2Mob2Zmc2V0LCAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWxlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aWxlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmZsYWdzICYgNDggLyogVGlsZUZsYWcuUG9pbnRXaWRnZXQgKi8pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSAoY2hpbGQuZG9tLm5vZGVUeXBlID09IDEgPyBjaGlsZC5kb20gOiB0ZXh0UmFuZ2UoY2hpbGQuZG9tLCAwLCBjaGlsZC5sZW5ndGgpKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgY2hlY2tSZWN0cyhyZWN0cywgaSk7XG4gICAgICAgICAgICBpZiAoIWR4Q2xvc2VzdCAmJiAhZHlDbG9zZXN0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbm5lciA9IHRpbGUuY2hpbGRyZW5bY2xvc2VzdF0sIGlubmVyT2ZmID0gdGlsZS5wb3NCZWZvcmUoaW5uZXIsIG9mZnNldCk7XG4gICAgICAgIGlmIChpbm5lci5pc0NvbXBvc2l0ZSgpIHx8IGlubmVyLmlzVGV4dCgpKVxuICAgICAgICAgICAgcmV0dXJuIHBvc0F0Q29vcmRzSW5saW5lKHZpZXcsIGlubmVyLCBpbm5lck9mZiwgTWF0aC5tYXgoY2xvc2VzdFJlY3QubGVmdCwgTWF0aC5taW4oY2xvc2VzdFJlY3QucmlnaHQsIHgpKSwgeSk7XG4gICAgICAgIGxldCBhZnRlciA9ICh4ID4gKGNsb3Nlc3RSZWN0LmxlZnQgKyBjbG9zZXN0UmVjdC5yaWdodCkgLyAyKSA9PSAoZGlyQXQodmlldywgY2xvc2VzdCArIG9mZnNldCkgPT0gRGlyZWN0aW9uLkxUUik7XG4gICAgICAgIHJldHVybiBhZnRlciA/IG5ldyBQb3NBc3NvYyhpbm5lck9mZiArIGlubmVyLmxlbmd0aCwgLTEpIDogbmV3IFBvc0Fzc29jKGlubmVyT2ZmLCAxKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaXJBdCh2aWV3LCBwb3MpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBzcGFucyA9IHZpZXcuYmlkaVNwYW5zKGxpbmUpO1xuICAgIHJldHVybiBzcGFuc1tCaWRpU3Bhbi5maW5kKHZpZXcuYmlkaVNwYW5zKGxpbmUpLCBwb3MgLSBsaW5lLmZyb20sIC0xLCAxKV0uZGlyO1xufVxuXG5jb25zdCBMaW5lQnJlYWtQbGFjZWhvbGRlciA9IFwiXFx1ZmZmZlwiO1xuY2xhc3MgRE9NUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2ludHMsIHZpZXcpIHtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMubGluZVNlcGFyYXRvciA9IHZpZXcuc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcik7XG4gICAgfVxuICAgIGFwcGVuZCh0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCArPSB0ZXh0O1xuICAgIH1cbiAgICBsaW5lQnJlYWsoKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSBMaW5lQnJlYWtQbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmVhZFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBjdXIpO1xuICAgICAgICAgICAgbGV0IG9sZExlbiA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlYWROb2RlKGN1cik7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IFRpbGUuZ2V0KGN1ciksIG5leHQgPSBjdXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHRpbGUgPT09IG51bGwgfHwgdGlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGlsZS5icmVha0FmdGVyKSAmJiAhbmV4dCAmJiBwYXJlbnQgIT0gdGhpcy52aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dFRpbGUgPSBUaWxlLmdldChuZXh0KTtcbiAgICAgICAgICAgIGlmICgodGlsZSAmJiBuZXh0VGlsZSA/IHRpbGUuYnJlYWtBZnRlciA6XG4gICAgICAgICAgICAgICAgKHRpbGUgPyB0aWxlLmJyZWFrQWZ0ZXIgOiBpc0Jsb2NrRWxlbWVudChjdXIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNCbG9ja0VsZW1lbnQobmV4dCkgJiYgKGN1ci5ub2RlTmFtZSAhPSBcIkJSXCIgfHwgKHRpbGUgPT09IG51bGwgfHwgdGlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGlsZS5pc1dpZGdldCgpKSkgJiYgdGhpcy50ZXh0Lmxlbmd0aCA+IG9sZExlbikpICYmXG4gICAgICAgICAgICAgICAgIWlzRW1wdHlUb0VuZChuZXh0LCBlbmQpKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlYWRUZXh0Tm9kZShub2RlKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgTWF0aC5taW4ocG9pbnQub2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IDAsIHJlID0gdGhpcy5saW5lU2VwYXJhdG9yID8gbnVsbCA6IC9cXHJcXG4/fFxcbi9nOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QnJlYWsgPSAtMSwgYnJlYWtTaXplID0gMSwgbTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YodGhpcy5saW5lU2VwYXJhdG9yLCBvZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtID0gcmUuZXhlYyh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIG5leHRCcmVhayA9IG0uaW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWtTaXplID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGVuZCh0ZXh0LnNsaWNlKG9mZiwgbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrKSk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICBpZiAoYnJlYWtTaXplID4gMSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBwb2ludC5wb3MgPiB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQucG9zIC09IGJyZWFrU2l6ZSAtIDE7XG4gICAgICAgICAgICBvZmYgPSBuZXh0QnJlYWsgKyBicmVha1NpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZE5vZGUobm9kZSkge1xuICAgICAgICBsZXQgdGlsZSA9IFRpbGUuZ2V0KG5vZGUpO1xuICAgICAgICBsZXQgZnJvbVZpZXcgPSB0aWxlICYmIHRpbGUub3ZlcnJpZGVET01UZXh0O1xuICAgICAgICBpZiAoZnJvbVZpZXcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRJbnNpZGUobm9kZSwgZnJvbVZpZXcubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tVmlldy5pdGVyKCk7ICFpLm5leHQoKS5kb25lOykge1xuICAgICAgICAgICAgICAgIGlmIChpLmxpbmVCcmVhaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgdGhpcy5yZWFkVGV4dE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYW5nZShub2RlLmZpcnN0Q2hpbGQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRQb2ludEJlZm9yZShub2RlLCBuZXh0KSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBub2RlLmNoaWxkTm9kZXNbcG9pbnQub2Zmc2V0XSA9PSBuZXh0KVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGZpbmRQb2ludEluc2lkZShub2RlLCBsZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzID8gcG9pbnQubm9kZSA9PSBub2RlIDogbm9kZS5jb250YWlucyhwb2ludC5ub2RlKSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgKGlzQXRFbmQobm9kZSwgcG9pbnQubm9kZSwgcG9pbnQub2Zmc2V0KSA/IGxlbmd0aCA6IDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQXRFbmQocGFyZW50LCBub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghbm9kZSB8fCBvZmZzZXQgPCBtYXhPZmZzZXQobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKSArIDE7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFbXB0eVRvRW5kKG5vZGUsIGVuZCkge1xuICAgIGxldCB3aWRnZXRzO1xuICAgIGZvciAoOzsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gZW5kIHx8ICFub2RlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCB2aWV3ID0gVGlsZS5nZXQobm9kZSk7XG4gICAgICAgIGlmICghKHZpZXcgPT09IG51bGwgfHwgdmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlldy5pc1dpZGdldCgpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHZpZXcpXG4gICAgICAgICAgICAod2lkZ2V0cyB8fCAod2lkZ2V0cyA9IFtdKSkucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgaWYgKHdpZGdldHMpXG4gICAgICAgIGZvciAobGV0IHcgb2Ygd2lkZ2V0cykge1xuICAgICAgICAgICAgbGV0IG92ZXJyaWRlID0gdy5vdmVycmlkZURPTVRleHQ7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUgPT09IG51bGwgfHwgb3ZlcnJpZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIERPTVBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucG9zID0gLTE7XG4gICAgfVxufVxuXG5jbGFzcyBET01DaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXJ0LCBlbmQsIHR5cGVPdmVyKSB7XG4gICAgICAgIHRoaXMudHlwZU92ZXIgPSB0eXBlT3ZlcjtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZWQgPSBzdGFydCA+IC0xO1xuICAgICAgICBsZXQgeyBpbXByZWNpc2VIZWFkOiBpSGVhZCwgaW1wcmVjaXNlQW5jaG9yOiBpQW5jaG9yIH0gPSB2aWV3LmRvY1ZpZXc7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5ICYmIHN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBjaGFuZ2VzIHdoZW4gdGhlIGVkaXRvciBpcyByZWFkLW9ubHlcbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydCA+IC0xICYmICh0aGlzLmJvdW5kcyA9IGRvbUJvdW5kc0Fyb3VuZCh2aWV3LmRvY1ZpZXcudGlsZSwgc3RhcnQsIGVuZCwgMCkpKSB7XG4gICAgICAgICAgICBsZXQgc2VsUG9pbnRzID0gaUhlYWQgfHwgaUFuY2hvciA/IFtdIDogc2VsZWN0aW9uUG9pbnRzKHZpZXcpO1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBET01SZWFkZXIoc2VsUG9pbnRzLCB2aWV3KTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkUmFuZ2UodGhpcy5ib3VuZHMuc3RhcnRET00sIHRoaXMuYm91bmRzLmVuZERPTSk7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSByZWFkZXIudGV4dDtcbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gc2VsZWN0aW9uRnJvbVBvaW50cyhzZWxQb2ludHMsIHRoaXMuYm91bmRzLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgICAgICBsZXQgaGVhZCA9IGlIZWFkICYmIGlIZWFkLm5vZGUgPT0gZG9tU2VsLmZvY3VzTm9kZSAmJiBpSGVhZC5vZmZzZXQgPT0gZG9tU2VsLmZvY3VzT2Zmc2V0IHx8XG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zKHZpZXcuY29udGVudERPTSwgZG9tU2VsLmZvY3VzTm9kZSlcbiAgICAgICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZFxuICAgICAgICAgICAgICAgIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCBhbmNob3IgPSBpQW5jaG9yICYmIGlBbmNob3Iubm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiBpQW5jaG9yLm9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0IHx8XG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zKHZpZXcuY29udGVudERPTSwgZG9tU2VsLmFuY2hvck5vZGUpXG4gICAgICAgICAgICAgICAgPyB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvclxuICAgICAgICAgICAgICAgIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgLy8gaU9TIHdpbGwgcmVmdXNlIHRvIHNlbGVjdCB0aGUgYmxvY2sgZ2FwcyB3aGVuIGRvaW5nXG4gICAgICAgICAgICAvLyBzZWxlY3QtYWxsLlxuICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgcHV0IHRoZSBzZWxlY3Rpb24gKmluc2lkZSogdGhlbSwgY29uZnVzaW5nXG4gICAgICAgICAgICAvLyBwb3NGcm9tRE9NXG4gICAgICAgICAgICBsZXQgdnAgPSB2aWV3LnZpZXdwb3J0O1xuICAgICAgICAgICAgaWYgKChicm93c2VyLmlvcyB8fCBicm93c2VyLmNocm9tZSkgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiBoZWFkICE9IGFuY2hvciAmJlxuICAgICAgICAgICAgICAgICh2cC5mcm9tID4gMCB8fCB2cC50byA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKGhlYWQsIGFuY2hvciksIHRvID0gTWF0aC5tYXgoaGVhZCwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2ZmRnJvbSA9IHZwLmZyb20gLSBmcm9tLCBvZmZUbyA9IHZwLnRvIC0gdG87XG4gICAgICAgICAgICAgICAgaWYgKChvZmZGcm9tID09IDAgfHwgb2ZmRnJvbSA9PSAxIHx8IGZyb20gPT0gMCkgJiYgKG9mZlRvID09IDAgfHwgb2ZmVG8gPT0gLTEgfHwgdG8gPT0gdmlldy5zdGF0ZS5kb2MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gdmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID4gLTEgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yZXBsYWNlUmFuZ2UoRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGFuY2hvciwgaGVhZCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShhbmNob3IsIGhlYWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZG9tQm91bmRzQXJvdW5kKHRpbGUsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICBpZiAodGlsZS5pc0NvbXBvc2l0ZSgpKSB7XG4gICAgICAgIGxldCBmcm9tSSA9IC0xLCBmcm9tU3RhcnQgPSAtMSwgdG9JID0gLTEsIHRvRW5kID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBvZmZzZXQsIHByZXZFbmQgPSBvZmZzZXQ7IGkgPCB0aWxlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aWxlLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSAmJiBlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQm91bmRzQXJvdW5kKGNoaWxkLCBmcm9tLCB0bywgcG9zKTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gZnJvbSAmJiBmcm9tSSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZyb21JID0gaTtcbiAgICAgICAgICAgICAgICBmcm9tU3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID4gdG8gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGlsZS5kb20pIHtcbiAgICAgICAgICAgICAgICB0b0kgPSBpO1xuICAgICAgICAgICAgICAgIHRvRW5kID0gcHJldkVuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZFbmQgPSBlbmQ7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb206IGZyb21TdGFydCwgdG86IHRvRW5kIDwgMCA/IG9mZnNldCArIHRpbGUubGVuZ3RoIDogdG9FbmQsXG4gICAgICAgICAgICBzdGFydERPTTogKGZyb21JID8gdGlsZS5jaGlsZHJlbltmcm9tSSAtIDFdLmRvbS5uZXh0U2libGluZyA6IG51bGwpIHx8IHRpbGUuZG9tLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBlbmRET006IHRvSSA8IHRpbGUuY2hpbGRyZW4ubGVuZ3RoICYmIHRvSSA+PSAwID8gdGlsZS5jaGlsZHJlblt0b0ldLmRvbSA6IG51bGwgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGlsZS5pc1RleHQoKSkge1xuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmZzZXQsIHRvOiBvZmZzZXQgKyB0aWxlLmxlbmd0aCwgc3RhcnRET006IHRpbGUuZG9tLCBlbmRET006IHRpbGUuZG9tLm5leHRTaWJsaW5nIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseURPTUNoYW5nZSh2aWV3LCBkb21DaGFuZ2UpIHtcbiAgICBsZXQgY2hhbmdlO1xuICAgIGxldCB7IG5ld1NlbCB9ID0gZG9tQ2hhbmdlLCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBsYXN0S2V5ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RLZXlUaW1lID4gRGF0ZS5ub3coKSAtIDEwMCA/IHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA6IC0xO1xuICAgIGlmIChkb21DaGFuZ2UuYm91bmRzKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBkb21DaGFuZ2UuYm91bmRzO1xuICAgICAgICBsZXQgcHJlZmVycmVkUG9zID0gc2VsLmZyb20sIHByZWZlcnJlZFNpZGUgPSBudWxsO1xuICAgICAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkIChvciwgb25cbiAgICAgICAgLy8gQW5kcm9pZCwgd2hlbiBzb21ldGhpbmcgd2FzIGRlbGV0ZWQpXG4gICAgICAgIGlmIChsYXN0S2V5ID09PSA4IHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBkb21DaGFuZ2UudGV4dC5sZW5ndGggPCB0byAtIGZyb20pIHtcbiAgICAgICAgICAgIHByZWZlcnJlZFBvcyA9IHNlbC50bztcbiAgICAgICAgICAgIHByZWZlcnJlZFNpZGUgPSBcImVuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWZmID0gZmluZERpZmYodmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIExpbmVCcmVha1BsYWNlaG9sZGVyKSwgZG9tQ2hhbmdlLnRleHQsIHByZWZlcnJlZFBvcyAtIGZyb20sIHByZWZlcnJlZFNpZGUpO1xuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGluc2VydHMgdHdvIG5ld2xpbmVzIHdoZW4gcHJlc3Npbmcgc2hpZnQtZW50ZXIgYXQgdGhlXG4gICAgICAgICAgICAvLyBlbmQgb2YgYSBsaW5lLiBEb21DaGFuZ2UgZHJvcHMgb25lIG9mIHRob3NlLlxuICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGxhc3RLZXkgPT0gMTMgJiZcbiAgICAgICAgICAgICAgICBkaWZmLnRvQiA9PSBkaWZmLmZyb20gKyAyICYmIGRvbUNoYW5nZS50ZXh0LnNsaWNlKGRpZmYuZnJvbSwgZGlmZi50b0IpID09IExpbmVCcmVha1BsYWNlaG9sZGVyICsgTGluZUJyZWFrUGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAgICAgZGlmZi50b0ItLTtcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgZnJvbTogZnJvbSArIGRpZmYuZnJvbSwgdG86IGZyb20gKyBkaWZmLnRvQSxcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IFRleHQub2YoZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikuc3BsaXQoTGluZUJyZWFrUGxhY2Vob2xkZXIpKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ld1NlbCAmJiAoIXZpZXcuaGFzRm9jdXMgJiYgdmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgfHwgc2FtZVNlbFBvcyhuZXdTZWwsIHNlbCkpKSB7XG4gICAgICAgIG5ld1NlbCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghY2hhbmdlICYmICFuZXdTZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWNoYW5nZSAmJiBkb21DaGFuZ2UudHlwZU92ZXIgJiYgIXNlbC5lbXB0eSAmJiBuZXdTZWwgJiYgbmV3U2VsLm1haW4uZW1wdHkpIHtcbiAgICAgICAgLy8gSGV1cmlzdGljIHRvIG5vdGljZSB0eXBpbmcgb3ZlciBhIHNlbGVjdGVkIGNoYXJhY3RlclxuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IHZpZXcuc3RhdGUuZG9jLnNsaWNlKHNlbC5mcm9tLCBzZWwudG8pIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKChicm93c2VyLm1hYyB8fCBicm93c2VyLmFuZHJvaWQpICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgY2hhbmdlLmZyb20gPT0gc2VsLmhlYWQgLSAxICYmXG4gICAgICAgIC9eXFwuID8kLy50ZXN0KGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSkgJiYgdmlldy5jb250ZW50RE9NLmdldEF0dHJpYnV0ZShcImF1dG9jb3JyZWN0XCIpID09IFwib2ZmXCIpIHtcbiAgICAgICAgLy8gRGV0ZWN0IGluc2VydC1wZXJpb2Qtb24tZG91YmxlLXNwYWNlIE1hYyBhbmQgQW5kcm9pZCBiZWhhdmlvcixcbiAgICAgICAgLy8gYW5kIHRyYW5zZm9ybSBpdCBpbnRvIGEgcmVndWxhciBzcGFjZSBpbnNlcnQuXG4gICAgICAgIGlmIChuZXdTZWwgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMilcbiAgICAgICAgICAgIG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV3U2VsLm1haW4uYW5jaG9yIC0gMSwgbmV3U2VsLm1haW4uaGVhZCAtIDEpO1xuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IGNoYW5nZS5mcm9tLCB0bzogY2hhbmdlLnRvLCBpbnNlcnQ6IFRleHQub2YoW2NoYW5nZS5pbnNlcnQudG9TdHJpbmcoKS5yZXBsYWNlKFwiLlwiLCBcIiBcIildKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJlxuICAgICAgICAoY2hhbmdlLmZyb20gIT0gc2VsLmZyb20gfHwgY2hhbmdlLnRvICE9IHNlbC50bykgJiZcbiAgICAgICAgKHNlbC50byAtIHNlbC5mcm9tKSAtIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSkgPD0gNCkge1xuICAgICAgICAvLyBJZiB0aGUgY2hhbmdlIGlzIGluc2lkZSB0aGUgc2VsZWN0aW9uIGFuZCBjb3ZlcnMgbW9zdCBvZiBpdCxcbiAgICAgICAgLy8gYXNzdW1lIGl0IGlzIGEgc2VsZWN0aW9uIHJlcGxhY2UgKHdpdGggaWRlbnRpY2FsIGNoYXJhY3RlcnMgYXRcbiAgICAgICAgLy8gdGhlIHN0YXJ0L2VuZCBub3QgaW5jbHVkZWQgaW4gdGhlIGRpZmYpXG4gICAgICAgIGNoYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLFxuICAgICAgICAgICAgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgY2hhbmdlLmZyb20pLmFwcGVuZChjaGFuZ2UuaW5zZXJ0KS5hcHBlbmQodmlldy5zdGF0ZS5kb2Muc2xpY2UoY2hhbmdlLnRvLCBzZWwudG8pKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LnN0YXRlLmRvYy5saW5lQXQoc2VsLmZyb20pLnRvIDwgc2VsLnRvICYmIHZpZXcuZG9jVmlldy5saW5lSGFzV2lkZ2V0KHNlbC50bykgJiZcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmluc2VydGluZ1RleHRBdCA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICAvLyBGb3IgYSBjcm9zcy1saW5lIGluc2VydGlvbiwgQ2hyb21lIGFuZCBTYWZhcmkgd2lsbCBjcnVkZWx5IHRha2VcbiAgICAgICAgLy8gdGhlIHRleHQgb2YgdGhlIGxpbmUgYWZ0ZXIgdGhlIHNlbGVjdGlvbiwgZmxhdHRlbmluZyBhbnlcbiAgICAgICAgLy8gd2lkZ2V0cywgYW5kIG1vdmUgaXQgaW50byB0aGUgam9pbmVkIGxpbmUuIFRoaXMgdHJpZXMgdG8gZGV0ZWN0XG4gICAgICAgIC8vIHN1Y2ggYSBzaXR1YXRpb24sIGFuZCByZXBsYWNlcyB0aGUgY2hhbmdlIHdpdGggYSBzZWxlY3Rpb25cbiAgICAgICAgLy8gcmVwbGFjZSBvZiB0aGUgdGV4dCBwcm92aWRlZCBieSB0aGUgYmVmb3JlaW5wdXQgZXZlbnQuXG4gICAgICAgIGNoYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLFxuICAgICAgICAgICAgaW5zZXJ0OiB2aWV3LnN0YXRlLnRvVGV4dCh2aWV3LmlucHV0U3RhdGUuaW5zZXJ0aW5nVGV4dClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAmJlxuICAgICAgICBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkgPT0gXCJcXG4gXCIgJiYgdmlldy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgLy8gSW4gQ2hyb21lLCBpZiB5b3UgaW5zZXJ0IGEgc3BhY2UgYXQgdGhlIHN0YXJ0IG9mIGEgd3JhcHBlZFxuICAgICAgICAvLyBsaW5lLCBpdCB3aWxsIGFjdHVhbGx5IGluc2VydCBhIG5ld2xpbmUgYW5kIGEgc3BhY2UsIGNhdXNpbmcgYVxuICAgICAgICAvLyBib2d1cyBuZXcgbGluZSB0byBiZSBjcmVhdGVkIGluIENvZGVNaXJyb3IgKCM5NjgpXG4gICAgICAgIGlmIChuZXdTZWwpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIiBcIl0pIH07XG4gICAgfVxuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5RE9NQ2hhbmdlSW5uZXIodmlldywgY2hhbmdlLCBuZXdTZWwsIGxhc3RLZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXdTZWwgJiYgIXNhbWVTZWxQb3MobmV3U2VsLCBzZWwpKSB7XG4gICAgICAgIGxldCBzY3JvbGxJbnRvVmlldyA9IGZhbHNlLCB1c2VyRXZlbnQgPSBcInNlbGVjdFwiO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwKSB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW4gPT0gXCJzZWxlY3RcIilcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldyA9IHRydWU7XG4gICAgICAgICAgICB1c2VyRXZlbnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbjtcbiAgICAgICAgICAgIGlmICh1c2VyRXZlbnQgPT0gXCJzZWxlY3QucG9pbnRlclwiKVxuICAgICAgICAgICAgICAgIG5ld1NlbCA9IHNraXBBdG9tc0ZvclNlbGVjdGlvbih2aWV3LnN0YXRlLmZhY2V0KGF0b21pY1JhbmdlcykubWFwKGYgPT4gZih2aWV3KSksIG5ld1NlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogbmV3U2VsLCBzY3JvbGxJbnRvVmlldywgdXNlckV2ZW50IH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseURPTUNoYW5nZUlubmVyKHZpZXcsIGNoYW5nZSwgbmV3U2VsLCBsYXN0S2V5ID0gLTEpIHtcbiAgICBpZiAoYnJvd3Nlci5pb3MgJiYgdmlldy5pbnB1dFN0YXRlLmZsdXNoSU9TS2V5KGNoYW5nZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIC8vIEFuZHJvaWQgYnJvd3NlcnMgZG9uJ3QgZmlyZSByZWFzb25hYmxlIGtleSBldmVudHMgZm9yIGVudGVyLFxuICAgIC8vIGJhY2tzcGFjZSwgb3IgZGVsZXRlLiBTbyB0aGlzIGRldGVjdHMgY2hhbmdlcyB0aGF0IGxvb2sgbGlrZVxuICAgIC8vIHRoZXkncmUgY2F1c2VkIGJ5IHRob3NlIGtleXMsIGFuZCByZWludGVycHJldHMgdGhlbSBhcyBrZXlcbiAgICAvLyBldmVudHMuIChTb21lIG9mIHRoZXNlIGtleXMgYXJlIGFsc28gaGFuZGxlZCBieSBiZWZvcmVpbnB1dFxuICAgIC8vIGV2ZW50cyBhbmQgdGhlIHBlbmRpbmdBbmRyb2lkS2V5IG1lY2hhbmlzbSwgYnV0IHRoYXQncyBub3RcbiAgICAvLyByZWxpYWJsZSBpbiBhbGwgc2l0dWF0aW9ucy4pXG4gICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJlxuICAgICAgICAoKGNoYW5nZS50byA9PSBzZWwudG8gJiZcbiAgICAgICAgICAgIC8vIEdCb2FyZCB3aWxsIHNvbWV0aW1lcyByZW1vdmUgYSBzcGFjZSBpdCBqdXN0IGluc2VydGVkXG4gICAgICAgICAgICAvLyBhZnRlciBhIGNvbXBsZXRpb24gd2hlbiB5b3UgcHJlc3MgZW50ZXJcbiAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSB8fCBjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAtIDEgJiYgdmlldy5zdGF0ZS5zbGljZURvYyhjaGFuZ2UuZnJvbSwgc2VsLmZyb20pID09IFwiIFwiKSAmJlxuICAgICAgICAgICAgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UuaW5zZXJ0LmxpbmVzID09IDIgJiZcbiAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJFbnRlclwiLCAxMykpIHx8XG4gICAgICAgICAgICAoKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tIC0gMSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDAgfHxcbiAgICAgICAgICAgICAgICBsYXN0S2V5ID09IDggJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPCBjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSAmJiBjaGFuZ2UudG8gPiBzZWwuaGVhZCkgJiZcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiQmFja3NwYWNlXCIsIDgpKSB8fFxuICAgICAgICAgICAgKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gKyAxICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiRGVsZXRlXCIsIDQ2KSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgdGV4dCA9IGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nKys7XG4gICAgbGV0IGRlZmF1bHRUcjtcbiAgICBsZXQgZGVmYXVsdEluc2VydCA9ICgpID0+IGRlZmF1bHRUciB8fCAoZGVmYXVsdFRyID0gYXBwbHlEZWZhdWx0SW5zZXJ0KHZpZXcsIGNoYW5nZSwgbmV3U2VsKSk7XG4gICAgaWYgKCF2aWV3LnN0YXRlLmZhY2V0KGlucHV0SGFuZGxlcikuc29tZShoID0+IGgodmlldywgY2hhbmdlLmZyb20sIGNoYW5nZS50bywgdGV4dCwgZGVmYXVsdEluc2VydCkpKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKGRlZmF1bHRJbnNlcnQoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhcHBseURlZmF1bHRJbnNlcnQodmlldywgY2hhbmdlLCBuZXdTZWwpIHtcbiAgICBsZXQgdHIsIHN0YXJ0U3RhdGUgPSB2aWV3LnN0YXRlLCBzZWwgPSBzdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLCBpbkF0b21pYyA9IC0xO1xuICAgIGlmIChjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgY2hhbmdlLmZyb20gPCBzZWwuZnJvbSB8fCBjaGFuZ2UuZnJvbSA+IHNlbC50bykge1xuICAgICAgICBsZXQgc2lkZSA9IGNoYW5nZS5mcm9tIDwgc2VsLmZyb20gPyAtMSA6IDEsIHBvcyA9IHNpZGUgPCAwID8gc2VsLmZyb20gOiBzZWwudG87XG4gICAgICAgIGxldCBtb3ZlZCA9IHNraXBBdG9taWNSYW5nZXMoc3RhcnRTdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpLCBwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoY2hhbmdlLmZyb20gPT0gbW92ZWQpXG4gICAgICAgICAgICBpbkF0b21pYyA9IG1vdmVkO1xuICAgIH1cbiAgICBpZiAoaW5BdG9taWMgPiAtMSkge1xuICAgICAgICB0ciA9IHtcbiAgICAgICAgICAgIGNoYW5nZXM6IGNoYW5nZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihjaGFuZ2UuZnJvbSArIGNoYW5nZS5pbnNlcnQubGVuZ3RoLCAtMSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSA+PSAoc2VsLnRvIC0gc2VsLmZyb20pIC8gMyAmJlxuICAgICAgICAoIW5ld1NlbCB8fCBuZXdTZWwubWFpbi5lbXB0eSAmJiBuZXdTZWwubWFpbi5mcm9tID09IGNoYW5nZS5mcm9tICsgY2hhbmdlLmluc2VydC5sZW5ndGgpICYmXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSBzZWwuZnJvbSA8IGNoYW5nZS5mcm9tID8gc3RhcnRTdGF0ZS5zbGljZURvYyhzZWwuZnJvbSwgY2hhbmdlLmZyb20pIDogXCJcIjtcbiAgICAgICAgbGV0IGFmdGVyID0gc2VsLnRvID4gY2hhbmdlLnRvID8gc3RhcnRTdGF0ZS5zbGljZURvYyhjaGFuZ2UudG8sIHNlbC50bykgOiBcIlwiO1xuICAgICAgICB0ciA9IHN0YXJ0U3RhdGUucmVwbGFjZVNlbGVjdGlvbih2aWV3LnN0YXRlLnRvVGV4dChiZWZvcmUgKyBjaGFuZ2UuaW5zZXJ0LnNsaWNlU3RyaW5nKDAsIHVuZGVmaW5lZCwgdmlldy5zdGF0ZS5saW5lQnJlYWspICsgYWZ0ZXIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKGNoYW5nZSk7XG4gICAgICAgIGxldCBtYWluU2VsID0gbmV3U2VsICYmIG5ld1NlbC5tYWluLnRvIDw9IGNoYW5nZXMubmV3TGVuZ3RoID8gbmV3U2VsLm1haW4gOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRyeSB0byBhcHBseSBhIGNvbXBvc2l0aW9uIGNoYW5nZSB0byBhbGwgY3Vyc29yc1xuICAgICAgICBpZiAoc3RhcnRTdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCA+IDEgJiYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCB8fCB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlKSAmJlxuICAgICAgICAgICAgY2hhbmdlLnRvIDw9IHNlbC50byArIDEwICYmIGNoYW5nZS50byA+PSBzZWwudG8gLSAxMCkge1xuICAgICAgICAgICAgbGV0IHJlcGxhY2VkID0gdmlldy5zdGF0ZS5zbGljZURvYyhjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcbiAgICAgICAgICAgIGxldCBjb21wb3NpdGlvblJhbmdlLCBjb21wb3NpdGlvbiA9IG5ld1NlbCAmJiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcsIG5ld1NlbC5tYWluLmhlYWQpO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRMZW4gPSBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCAtIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSk7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25SYW5nZSA9IHsgZnJvbTogY29tcG9zaXRpb24uZnJvbSwgdG86IGNvbXBvc2l0aW9uLnRvIC0gZExlbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25SYW5nZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzZWwuaGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gc2VsLnRvIC0gY2hhbmdlLnRvO1xuICAgICAgICAgICAgdHIgPSBzdGFydFN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIHJhbmdlLnRvID09IHNlbC50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlcywgcmFuZ2U6IG1haW5TZWwgfHwgcmFuZ2UubWFwKGNoYW5nZXMpIH07XG4gICAgICAgICAgICAgICAgbGV0IHRvID0gcmFuZ2UudG8gLSBvZmZzZXQsIGZyb20gPSB0byAtIHJlcGxhY2VkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0bykgIT0gcmVwbGFjZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUncyBubyB3YXkgdG8gbWFrZSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIGluIHRoZSBzYW1lIG5vZGUgd29yayB3aXRob3V0IGFib3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0aW9uLCBzbyBjdXJzb3JzIGluIHRoZSBjb21wb3NpdGlvbiByYW5nZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgdG8gPj0gY29tcG9zaXRpb25SYW5nZS5mcm9tICYmIGZyb20gPD0gY29tcG9zaXRpb25SYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VDaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKHsgZnJvbSwgdG8sIGluc2VydDogY2hhbmdlLmluc2VydCB9KSwgc2VsT2ZmID0gcmFuZ2UudG8gLSBzZWwudG87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VDaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogIW1haW5TZWwgPyByYW5nZS5tYXAocmFuZ2VDaGFuZ2VzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5tYXgoMCwgbWFpblNlbC5hbmNob3IgKyBzZWxPZmYpLCBNYXRoLm1heCgwLCBtYWluU2VsLmhlYWQgKyBzZWxPZmYpKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyID0ge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBtYWluU2VsICYmIHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJlcGxhY2VSYW5nZShtYWluU2VsKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdXNlckV2ZW50ID0gXCJpbnB1dC50eXBlXCI7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nIHx8XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHVzZXJFdmVudCArPSBcIi5jb21wb3NlXCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdXNlckV2ZW50ICs9IFwiLnN0YXJ0XCI7XG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydFN0YXRlLnVwZGF0ZSh0ciwgeyB1c2VyRXZlbnQsIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IG1pbkxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgbGV0IGZyb20gPSAwO1xuICAgIHdoaWxlIChmcm9tIDwgbWluTGVuICYmIGEuY2hhckNvZGVBdChmcm9tKSA9PSBiLmNoYXJDb2RlQXQoZnJvbSkpXG4gICAgICAgIGZyb20rKztcbiAgICBpZiAoZnJvbSA9PSBtaW5MZW4gJiYgYS5sZW5ndGggPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0b0EgPSBhLmxlbmd0aCwgdG9CID0gYi5sZW5ndGg7XG4gICAgd2hpbGUgKHRvQSA+IDAgJiYgdG9CID4gMCAmJiBhLmNoYXJDb2RlQXQodG9BIC0gMSkgPT0gYi5jaGFyQ29kZUF0KHRvQiAtIDEpKSB7XG4gICAgICAgIHRvQS0tO1xuICAgICAgICB0b0ItLTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgZnJvbSAtIE1hdGgubWluKHRvQSwgdG9CKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSB0b0EgKyBhZGp1c3QgLSBmcm9tO1xuICAgIH1cbiAgICBpZiAodG9BIDwgZnJvbSAmJiBhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQSA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQiA9IGZyb20gKyAodG9CIC0gdG9BKTtcbiAgICAgICAgdG9BID0gZnJvbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9CIDwgZnJvbSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0IgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0EgPSBmcm9tICsgKHRvQSAtIHRvQik7XG4gICAgICAgIHRvQiA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIHRvQSwgdG9CIH07XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Qb2ludHModmlldykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSk7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT0gYW5jaG9yTm9kZSB8fCBmb2N1c09mZnNldCAhPSBhbmNob3JPZmZzZXQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbVBvaW50cyhwb2ludHMsIGJhc2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yID0gcG9pbnRzWzBdLnBvcywgaGVhZCA9IHBvaW50cy5sZW5ndGggPT0gMiA/IHBvaW50c1sxXS5wb3MgOiBhbmNob3I7XG4gICAgcmV0dXJuIGFuY2hvciA+IC0xICYmIGhlYWQgPiAtMSA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yICsgYmFzZSwgaGVhZCArIGJhc2UpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHNhbWVTZWxQb3Moc2VsZWN0aW9uLCByYW5nZSkge1xuICAgIHJldHVybiByYW5nZS5oZWFkID09IHNlbGVjdGlvbi5tYWluLmhlYWQgJiYgcmFuZ2UuYW5jaG9yID09IHNlbGVjdGlvbi5tYWluLmFuY2hvcjtcbn1cblxuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKG9yaWdpbikge1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLZXlUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIC8vIE9uIGlPUywgc29tZSBrZXlzIG5lZWQgdG8gaGF2ZSB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIGhhcHBlblxuICAgICAgICAvLyAoYWZ0ZXIgd2hpY2ggd2UgcmV0cm9hY3RpdmVseSBoYW5kbGUgdGhlbSBhbmQgcmVzZXQgdGhlIERPTSkgdG9cbiAgICAgICAgLy8gYXZvaWQgbWVzc2luZyB1cCB0aGUgdmlydHVhbCBrZXlib2FyZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgV2hlbiBlbmFibGVkICg+LTEpLCB0YWIgcHJlc3NlcyBhcmUgbm90IGdpdmVuIHRvIGtleSBoYW5kbGVycyxcbiAgICAgICAgbGVhdmluZyB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IuIElmID4wLCB0aGUgbW9kZSBleHBpcmVzXG4gICAgICAgIGF0IHRoYXQgdGltZXN0YW1wLCBhbmQgYW55IG90aGVyIGtleXByZXNzIGNsZWFycyBpdC5cbiAgICAgICAgRXNjIGVuYWJsZXMgdGVtcG9yYXJ5IHRhYiBmb2N1cyBtb2RlIGZvciB0d28gc2Vjb25kcyB3aGVuIG5vdFxuICAgICAgICBvdGhlcndpc2UgaGFuZGxlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJGb2N1c01vZGUgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbnRleHRNZW51ID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLy8gLTEgbWVhbnMgbm90IGluIGEgY29tcG9zaXRpb24uIE90aGVyd2lzZSwgdGhpcyBjb3VudHMgdGhlIG51bWJlclxuICAgICAgICAvLyBvZiBjaGFuZ2VzIG1hZGUgZHVyaW5nIHRoZSBjb21wb3NpdGlvbi4gVGhlIGNvdW50IGlzIHVzZWQgdG9cbiAgICAgICAgLy8gYXZvaWQgdHJlYXRpbmcgdGhlIHN0YXJ0IHN0YXRlIG9mIHRoZSBjb21wb3NpdGlvbiwgYmVmb3JlIGFueVxuICAgICAgICAvLyBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlLCBhcyBwYXJ0IG9mIHRoZSBjb21wb3NpdGlvbi5cbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAtMTtcbiAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIG5leHQgY2hhbmdlIHNob3VsZCBiZSBtYXJrZWQgYXMgc3RhcnRpbmcgdGhlXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIChudWxsIG1lYW5zIG5vIGNvbXBvc2l0aW9uLCB0cnVlIG1lYW5zIG5leHQgaXMgdGhlXG4gICAgICAgIC8vIGZpcnN0LCBmYWxzZSBtZWFucyBmaXJzdCBoYXMgYWxyZWFkeSBiZWVuIG1hcmtlZCBmb3IgdGhpc1xuICAgICAgICAvLyBjb21wb3NpdGlvbilcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgLy8gRW5kIHRpbWUgb2YgdGhlIHByZXZpb3VzIGNvbXBvc2l0aW9uXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gMDtcbiAgICAgICAgLy8gVXNlZCBpbiBhIGtsdWRnZSB0byBkZXRlY3Qgd2hlbiBhbiBFbnRlciBrZXlwcmVzcyBzaG91bGQgYmVcbiAgICAgICAgLy8gY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBjb21wb3NpdGlvbiBvbiBTYWZhcmksIHdoaWNoIGZpcmVzIGV2ZW50c1xuICAgICAgICAvLyBpbiB0aGUgd3Jvbmcgb3JkZXJcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSBmYWxzZTtcbiAgICAgICAgLy8gVXNlZCB0byBjYXRlZ29yaXplIGNoYW5nZXMgYXMgcGFydCBvZiBhIGNvbXBvc2l0aW9uLCBldmVuIHdoZW5cbiAgICAgICAgLy8gdGhlIG11dGF0aW9uIGV2ZW50cyBmaXJlIHNob3J0bHkgYWZ0ZXIgdGhlIGNvbXBvc2l0aW9uZW5kIGV2ZW50XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIC8vIFNldCBieSBiZWZvcmVpbnB1dCwgdXNlZCBpbiBET00gY2hhbmdlIHJlYWRlclxuICAgICAgICB0aGlzLmluc2VydGluZ1RleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmluc2VydGluZ1RleHRBdCA9IDA7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAvLyBXaGVuIGEgZHJhZyBmcm9tIHRoZSBlZGl0b3IgaXMgYWN0aXZlLCB0aGlzIHBvaW50cyBhdCB0aGUgcmFuZ2VcbiAgICAgICAgLy8gYmVpbmcgZHJhZ2dlZC5cbiAgICAgICAgdGhpcy5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubm90aWZpZWRGb2N1c2VkID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgLy8gT24gU2FmYXJpIGFkZGluZyBhbiBpbnB1dCBldmVudCBoYW5kbGVyIHNvbWVob3cgcHJldmVudHMgYW5cbiAgICAgICAgLy8gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW4geW91IHByZXNzIGVudGVyLlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkpXG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbylcbiAgICAgICAgICAgIGZpcmVmb3hDb3B5Q3V0SGFjayh2aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudCk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnRCZWxvbmdzVG9FZGl0b3IodGhpcy52aWV3LCBldmVudCkgfHwgdGhpcy5pZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChldmVudC50eXBlID09IFwia2V5ZG93blwiICYmIHRoaXMua2V5ZG93bihldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnZpZXcudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLnJ1bkhhbmRsZXJzKGV2ZW50LnR5cGUsIGV2ZW50KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucnVuSGFuZGxlcnMoZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIH1cbiAgICBydW5IYW5kbGVycyh0eXBlLCBldmVudCkge1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9ic2VydmVyIG9mIGhhbmRsZXJzLm9ic2VydmVycylcbiAgICAgICAgICAgICAgICBvYnNlcnZlcih0aGlzLnZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgaGFuZGxlcnMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIodGhpcy52aWV3LCBldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVuc3VyZUhhbmRsZXJzKHBsdWdpbnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gY29tcHV0ZUhhbmRsZXJzKHBsdWdpbnMpLCBwcmV2ID0gdGhpcy5oYW5kbGVycywgZG9tID0gdGhpcy52aWV3LmNvbnRlbnRET007XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgICAgICBpZiAodHlwZSAhPSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhc3NpdmUgPSAhaGFuZGxlcnNbdHlwZV0uaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBleGlzdHMgPSBwcmV2W3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHMgJiYgcGFzc2l2ZSAhPSAhZXhpc3RzLmhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuaGFuZGxlRXZlbnQsIHsgcGFzc2l2ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBwcmV2KVxuICAgICAgICAgICAgaWYgKHR5cGUgIT0gXCJzY3JvbGxcIiAmJiAhaGFuZGxlcnNbdHlwZV0pXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICB9XG4gICAga2V5ZG93bihldmVudCkge1xuICAgICAgICAvLyBNdXN0IGFsd2F5cyBydW4sIGV2ZW4gaWYgYSBjdXN0b20gaGFuZGxlciBoYW5kbGVkIHRoZSBldmVudFxuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDkgJiYgdGhpcy50YWJGb2N1c01vZGUgPiAtMSAmJiAoIXRoaXMudGFiRm9jdXNNb2RlIHx8IERhdGUubm93KCkgPD0gdGhpcy50YWJGb2N1c01vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLnRhYkZvY3VzTW9kZSA+IDAgJiYgZXZlbnQua2V5Q29kZSAhPSAyNyAmJiBtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy50YWJGb2N1c01vZGUgPSAtMTtcbiAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkIHVzdWFsbHkgZG9lc24ndCBmaXJlIHByb3BlciBrZXkgZXZlbnRzLCBidXRcbiAgICAgICAgLy8gb2NjYXNpb25hbGx5IGRvZXMsIHVzdWFsbHkgc3Vycm91bmRlZCBieSBhIGJ1bmNoIG9mIGNvbXBsaWNhdGVkXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIGNoYW5nZXMuIFdoZW4gYW4gZW50ZXIgb3IgYmFja3NwYWNlIGtleSBldmVudCBpc1xuICAgICAgICAvLyBzZWVuLCBob2xkIG9mZiBvbiBoYW5kbGluZyBET00gZXZlbnRzIGZvciBhIGJpdCwgYW5kIHRoZW5cbiAgICAgICAgLy8gZGlzcGF0Y2ggaXQuXG4gICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJlxuICAgICAgICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PSA4KSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShldmVudC5rZXksIGV2ZW50LmtleUNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudGluZyB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBFbnRlciBvbiBpT1MgbWFrZXMgdGhlXG4gICAgICAgIC8vIHZpcnR1YWwga2V5Ym9hcmQgZ2V0IHN0dWNrIGluIHRoZSB3cm9uZyAobG93ZXJjYXNlKVxuICAgICAgICAvLyBzdGF0ZS4gU28gd2UgbGV0IGl0IGdvIHRocm91Z2gsIGFuZCB0aGVuLCBpblxuICAgICAgICAvLyBhcHBseURPTUNoYW5nZSwgbm90aWZ5IGtleSBoYW5kbGVycyBvZiBpdCBhbmQgcmVzZXQgdG9cbiAgICAgICAgLy8gdGhlIHN0YXRlIHRoZXkgcHJvZHVjZS5cbiAgICAgICAgbGV0IHBlbmRpbmc7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiAhZXZlbnQuc3ludGhldGljICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgJiZcbiAgICAgICAgICAgICgocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5rZXlDb2RlID09IGV2ZW50LmtleUNvZGUpKSAmJiAhZXZlbnQuY3RybEtleSB8fFxuICAgICAgICAgICAgICAgIEVtYWNzeVBlbmRpbmdLZXlzLmluZGV4T2YoZXZlbnQua2V5KSA+IC0xICYmIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gcGVuZGluZyB8fCBldmVudDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaElPU0tleSgpLCAyNTApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjI5KVxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmbHVzaElPU0tleShjaGFuZ2UpIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMucGVuZGluZ0lPU0tleTtcbiAgICAgICAgaWYgKCFrZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSBhbiBhdXRvY29ycmVjdGlvbiBiZWZvcmUgRW50ZXJcbiAgICAgICAgaWYgKGtleS5rZXkgPT0gXCJFbnRlclwiICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA8IGNoYW5nZS50byAmJiAvXlxcUyskLy50ZXN0KGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KHRoaXMudmlldy5jb250ZW50RE9NLCBrZXkua2V5LCBrZXkua2V5Q29kZSwga2V5IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCA/IGtleSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghL15rZXkvLnRlc3QoZXZlbnQudHlwZSkgfHwgZXZlbnQuc3ludGhldGljKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAgICAgLy8gT24gc29tZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0b1xuICAgICAgICAvLyBjb25maXJtIGNoYXJhY3RlciBzZWxlY3Rpb24uIE9uIFNhZmFyaSwgd2hlbiBFbnRlciBpcyBwcmVzc2VkLFxuICAgICAgICAvLyBjb21wb3NpdGlvbmVuZCBhbmQga2V5ZG93biBldmVudHMgYXJlIHNvbWV0aW1lcyBlbWl0dGVkIGluIHRoZVxuICAgICAgICAvLyB3cm9uZyBvcmRlci4gVGhlIGtleSBldmVudCBzaG91bGQgc3RpbGwgYmUgaWdub3JlZCwgZXZlbiB3aGVuXG4gICAgICAgIC8vIGl0IGhhcHBlbnMgYWZ0ZXIgdGhlIGNvbXBvc2l0aW9uZW5kIGV2ZW50LlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWJyb3dzZXIuaW9zICYmIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ICYmIERhdGUubm93KCkgLSB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA8IDEwMCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRNb3VzZVNlbGVjdGlvbihtb3VzZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uID0gbW91c2VTZWxlY3Rpb247XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnZWRDb250ZW50ICYmIHVwZGF0ZS5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkQ29udGVudCA9IHRoaXMuZHJhZ2dlZENvbnRlbnQubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJpbmRIYW5kbGVyKHBsdWdpbiwgaGFuZGxlcikge1xuICAgIHJldHVybiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwocGx1Z2luLCBldmVudCwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSGFuZGxlcnMocGx1Z2lucykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZ1bmN0aW9uIHJlY29yZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbdHlwZV0gfHwgKHJlc3VsdFt0eXBlXSA9IHsgb2JzZXJ2ZXJzOiBbXSwgaGFuZGxlcnM6IFtdIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICBsZXQgc3BlYyA9IHBsdWdpbi5zcGVjLCBoYW5kbGVycyA9IHNwZWMgJiYgc3BlYy5wbHVnaW4uZG9tRXZlbnRIYW5kbGVycywgb2JzZXJ2ZXJzID0gc3BlYyAmJiBzcGVjLnBsdWdpbi5kb21FdmVudE9ic2VydmVycztcbiAgICAgICAgaWYgKGhhbmRsZXJzKVxuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGxldCBmID0gaGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCh0eXBlKS5oYW5kbGVycy5wdXNoKGJpbmRIYW5kbGVyKHBsdWdpbi52YWx1ZSwgZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAob2JzZXJ2ZXJzKVxuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBvYnNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZiA9IG9ic2VydmVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkKHR5cGUpLm9ic2VydmVycy5wdXNoKGJpbmRIYW5kbGVyKHBsdWdpbi52YWx1ZSwgZikpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB0eXBlIGluIGhhbmRsZXJzKVxuICAgICAgICByZWNvcmQodHlwZSkuaGFuZGxlcnMucHVzaChoYW5kbGVyc1t0eXBlXSk7XG4gICAgZm9yIChsZXQgdHlwZSBpbiBvYnNlcnZlcnMpXG4gICAgICAgIHJlY29yZCh0eXBlKS5vYnNlcnZlcnMucHVzaChvYnNlcnZlcnNbdHlwZV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBQZW5kaW5nS2V5cyA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwga2V5Q29kZTogOCwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRQYXJhZ3JhcGhcIiB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIGtleUNvZGU6IDEzLCBpbnB1dFR5cGU6IFwiaW5zZXJ0TGluZUJyZWFrXCIgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwga2V5Q29kZTogNDYsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiIH1cbl07XG5jb25zdCBFbWFjc3lQZW5kaW5nS2V5cyA9IFwiZHRoa29cIjtcbi8vIEtleSBjb2RlcyBmb3IgbW9kaWZpZXIga2V5c1xuY29uc3QgbW9kaWZpZXJDb2RlcyA9IFsxNiwgMTcsIDE4LCAyMCwgOTEsIDkyLCAyMjQsIDIyNV07XG5jb25zdCBkcmFnU2Nyb2xsTWFyZ2luID0gNjtcbmZ1bmN0aW9uIGRyYWdTY3JvbGxTcGVlZChkaXN0KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGRpc3QpICogMC43ICsgODtcbn1cbmZ1bmN0aW9uIGRpc3QoYSwgYikge1xuICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyhhLmNsaWVudFggLSBiLmNsaWVudFgpLCBNYXRoLmFicyhhLmNsaWVudFkgLSBiLmNsaWVudFkpKTtcbn1cbmNsYXNzIE1vdXNlU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydEV2ZW50LCBzdHlsZSwgbXVzdFNlbGVjdCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBzdGFydEV2ZW50O1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IG11c3RTZWxlY3Q7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBzdGFydEV2ZW50O1xuICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMgPSBzY3JvbGxhYmxlUGFyZW50cyh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmF0b21zID0gdmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpO1xuICAgICAgICBsZXQgZG9jID0gdmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV4dGVuZCA9IHN0YXJ0RXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMubXVsdGlwbGUgPSB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSAmJiBhZGRzU2VsZWN0aW9uUmFuZ2Uodmlldywgc3RhcnRFdmVudCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBzdGFydEV2ZW50KSAmJiBnZXRDbGlja1R5cGUoc3RhcnRFdmVudCkgPT0gMSA/IG51bGwgOiBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnQoZXZlbnQpIHtcbiAgICAgICAgLy8gV2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb24sIGltbWVkaWF0ZWx5IGFwcGx5IHRoZVxuICAgICAgICAvLyBlZmZlY3Qgb2Ygc3RhcnRpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdChldmVudCk7XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgfHwgdGhpcy5kcmFnZ2luZyA9PSBudWxsICYmIGRpc3QodGhpcy5zdGFydEV2ZW50LCBldmVudCkgPCAxMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQgPSBldmVudCk7XG4gICAgICAgIGxldCBzeCA9IDAsIHN5ID0gMDtcbiAgICAgICAgbGV0IGxlZnQgPSAwLCB0b3AgPSAwLCByaWdodCA9IHRoaXMudmlldy53aW4uaW5uZXJXaWR0aCwgYm90dG9tID0gdGhpcy52aWV3Lndpbi5pbm5lckhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50cy54KVxuICAgICAgICAgICAgKHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMuc2Nyb2xsUGFyZW50cy54LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50cy55KVxuICAgICAgICAgICAgKHsgdG9wLCBib3R0b20gfSA9IHRoaXMuc2Nyb2xsUGFyZW50cy55LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgbGV0IG1hcmdpbnMgPSBnZXRTY3JvbGxNYXJnaW5zKHRoaXMudmlldyk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYIC0gbWFyZ2lucy5sZWZ0IDw9IGxlZnQgKyBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3ggPSAtZHJhZ1Njcm9sbFNwZWVkKGxlZnQgLSBldmVudC5jbGllbnRYKTtcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCArIG1hcmdpbnMucmlnaHQgPj0gcmlnaHQgLSBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3ggPSBkcmFnU2Nyb2xsU3BlZWQoZXZlbnQuY2xpZW50WCAtIHJpZ2h0KTtcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFkgLSBtYXJnaW5zLnRvcCA8PSB0b3AgKyBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3kgPSAtZHJhZ1Njcm9sbFNwZWVkKHRvcCAtIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRZICsgbWFyZ2lucy5ib3R0b20gPj0gYm90dG9tIC0gZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN5ID0gZHJhZ1Njcm9sbFNwZWVkKGV2ZW50LmNsaWVudFkgLSBib3R0b20pO1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKHN4LCBzeSk7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKDAsIDApO1xuICAgICAgICBsZXQgZG9jID0gdGhpcy52aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbiA9IHRoaXMudmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsU3BlZWQoc3gsIHN5KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IHN4LCB5OiBzeSB9O1xuICAgICAgICBpZiAoc3ggfHwgc3kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbGluZyA8IDApXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNjcm9sbCgpLCA1MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY3JvbGxpbmcgPiAtMSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbGluZyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjcm9sbCgpIHtcbiAgICAgICAgbGV0IHsgeCwgeSB9ID0gdGhpcy5zY3JvbGxTcGVlZDtcbiAgICAgICAgaWYgKHggJiYgdGhpcy5zY3JvbGxQYXJlbnRzLngpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cy54LnNjcm9sbExlZnQgKz0geDtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ICYmIHRoaXMuc2Nyb2xsUGFyZW50cy55KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMueS5zY3JvbGxUb3AgKz0geTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IHx8IHkpXG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLnNjcm9sbEJ5KHgsIHkpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgfVxuICAgIHNlbGVjdChldmVudCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBzZWxlY3Rpb24gPSBza2lwQXRvbXNGb3JTZWxlY3Rpb24odGhpcy5hdG9tcywgdGhpcy5zdHlsZS5nZXQoZXZlbnQsIHRoaXMuZXh0ZW5kLCB0aGlzLm11bHRpcGxlKSk7XG4gICAgICAgIGlmICh0aGlzLm11c3RTZWxlY3QgfHwgIXNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbiwgdGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5wb2ludGVyXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSkpXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdHlsZS51cGRhdGUodXBkYXRlKSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpLCAyMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7XG59XG5mdW5jdGlvbiBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGRyYWdNb3Zlc1NlbGVjdGlvbiQxKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyAhZXZlbnQuYWx0S2V5IDogIWV2ZW50LmN0cmxLZXk7XG59XG5mdW5jdGlvbiBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCB7IG1haW4gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChtYWluLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gT24gYm91bmRhcnkgY2xpY2tzLCBjaGVjayB3aGV0aGVyIHRoZSBjb29yZGluYXRlcyBhcmUgaW5zaWRlIHRoZVxuICAgIC8vIHNlbGVjdGlvbidzIGNsaWVudCByZWN0YW5nbGVzXG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgIGlmICghc2VsIHx8IHNlbC5yYW5nZUNvdW50ID09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCByZWN0cyA9IHNlbC5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDw9IGV2ZW50LmNsaWVudFggJiYgcmVjdC5yaWdodCA+PSBldmVudC5jbGllbnRYICYmXG4gICAgICAgICAgICByZWN0LnRvcCA8PSBldmVudC5jbGllbnRZICYmIHJlY3QuYm90dG9tID49IGV2ZW50LmNsaWVudFkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldCwgdGlsZTsgbm9kZSAhPSB2aWV3LmNvbnRlbnRET007IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8XG4gICAgICAgICAgICAoKHRpbGUgPSBUaWxlLmdldChub2RlKSkgJiYgdGlsZS5pc1dpZGdldCgpICYmICF0aWxlLmlzSGlkZGVuICYmIHRpbGUud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBoYW5kbGVycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3Qgb2JzZXJ2ZXJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUElcdTIwMTRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPCAxNSkgfHxcbiAgICAoYnJvd3Nlci5pb3MgJiYgYnJvd3Nlci53ZWJraXRfdmVyc2lvbiA8IDYwNCk7XG5mdW5jdGlvbiBjYXB0dXJlUGFzdGUodmlldykge1xuICAgIGxldCBwYXJlbnQgPSB2aWV3LmRvbS5wYXJlbnROb2RlO1xuICAgIGlmICghcGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRhcmdldCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIikpO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlKTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiB0ZXh0RmlsdGVyKHN0YXRlLCBmYWNldCwgdGV4dCkge1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChmYWNldCkpXG4gICAgICAgIHRleHQgPSBmaWx0ZXIodGV4dCwgc3RhdGUpO1xuICAgIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gZG9QYXN0ZSh2aWV3LCBpbnB1dCkge1xuICAgIGlucHV0ID0gdGV4dEZpbHRlcih2aWV3LnN0YXRlLCBjbGlwYm9hcmRJbnB1dEZpbHRlciwgaW5wdXQpO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzLCBpID0gMSwgdGV4dCA9IHN0YXRlLnRvVGV4dChpbnB1dCk7XG4gICAgbGV0IGJ5TGluZSA9IHRleHQubGluZXMgPT0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7XG4gICAgbGV0IGxpbmV3aXNlID0gbGFzdExpbmV3aXNlQ29weSAhPSBudWxsICYmIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuZXZlcnkociA9PiByLmVtcHR5KSAmJiBsYXN0TGluZXdpc2VDb3B5ID09IHRleHQudG9TdHJpbmcoKTtcbiAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lID0gLTE7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdExpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgIGxhc3RMaW5lID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IHN0YXRlLnRvVGV4dCgoYnlMaW5lID8gdGV4dC5saW5lKGkrKykudGV4dCA6IGlucHV0KSArIHN0YXRlLmxpbmVCcmVhayk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGluc2VydC5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChieUxpbmUpIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0ZXh0LmxpbmUoaSsrKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IGxpbmUudGV4dCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBsaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUucmVwbGFjZVNlbGVjdGlvbih0ZXh0KTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaChjaGFuZ2VzLCB7XG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5wYXN0ZVwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgIH0pO1xufVxub2JzZXJ2ZXJzLnNjcm9sbCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wID0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQ7XG59O1xuaGFuZGxlcnMua2V5ZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3RcIik7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcgJiYgdmlldy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSAhPSAwKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUudGFiRm9jdXNNb2RlID0gRGF0ZS5ub3coKSArIDIwMDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbm9ic2VydmVycy50b3VjaHN0YXJ0ID0gKHZpZXcsIGUpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbm9ic2VydmVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA+IERhdGUubm93KCkgLSAyMDAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIElnbm9yZSB0b3VjaCBpbnRlcmFjdGlvblxuICAgIGxldCBzdHlsZSA9IG51bGw7XG4gICAgZm9yIChsZXQgbWFrZVN0eWxlIG9mIHZpZXcuc3RhdGUuZmFjZXQobW91c2VTZWxlY3Rpb25TdHlsZSkpIHtcbiAgICAgICAgc3R5bGUgPSBtYWtlU3R5bGUodmlldywgZXZlbnQpO1xuICAgICAgICBpZiAoc3R5bGUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFzdHlsZSAmJiBldmVudC5idXR0b24gPT0gMClcbiAgICAgICAgc3R5bGUgPSBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgbGV0IG11c3RGb2N1cyA9ICF2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuc3RhcnRNb3VzZVNlbGVjdGlvbihuZXcgTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQsIHN0eWxlLCBtdXN0Rm9jdXMpKTtcbiAgICAgICAgaWYgKG11c3RGb2N1cylcbiAgICAgICAgICAgIHZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSAmJiAhYWN0aXZlLmNvbnRhaW5zKHZpZXcuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5ibHVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbGV0IG1vdXNlU2VsID0gdmlldy5pbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uO1xuICAgICAgICBpZiAobW91c2VTZWwpIHtcbiAgICAgICAgICAgIG1vdXNlU2VsLnN0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBtb3VzZVNlbC5kcmFnZ2luZyA9PT0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIHJhbmdlRm9yQ2xpY2sodmlldywgcG9zLCBiaWFzLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gMSkgeyAvLyBTaW5nbGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7IC8vIERvdWJsZSBjbGlja1xuICAgICAgICByZXR1cm4gZ3JvdXBBdCh2aWV3LnN0YXRlLCBwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gVHJpcGxlIGNsaWNrXG4gICAgICAgIGxldCB2aXN1YWwgPSB2aWV3LmRvY1ZpZXcubGluZUF0KHBvcywgYmlhcyksIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogcG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRTdGFydCA6IGxpbmUuZnJvbSwgdG8gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBsaW5lLnRvO1xuICAgICAgICBpZiAodG8gPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGggJiYgdG8gPT0gbGluZS50bylcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbmNvbnN0IEJhZE1vdXNlRGV0YWlsID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5sZXQgbGFzdE1vdXNlRG93biA9IG51bGwsIGxhc3RNb3VzZURvd25Db3VudCA9IDAsIGxhc3RNb3VzZURvd25UaW1lID0gMDtcbmZ1bmN0aW9uIGdldENsaWNrVHlwZShldmVudCkge1xuICAgIGlmICghQmFkTW91c2VEZXRhaWwpXG4gICAgICAgIHJldHVybiBldmVudC5kZXRhaWw7XG4gICAgbGV0IGxhc3QgPSBsYXN0TW91c2VEb3duLCBsYXN0VGltZSA9IGxhc3RNb3VzZURvd25UaW1lO1xuICAgIGxhc3RNb3VzZURvd24gPSBldmVudDtcbiAgICBsYXN0TW91c2VEb3duVGltZSA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIGxhc3RNb3VzZURvd25Db3VudCA9ICFsYXN0IHx8IChsYXN0VGltZSA+IERhdGUubm93KCkgLSA0MDAgJiYgTWF0aC5hYnMobGFzdC5jbGllbnRYIC0gZXZlbnQuY2xpZW50WCkgPCAyICYmXG4gICAgICAgIE1hdGguYWJzKGxhc3QuY2xpZW50WSAtIGV2ZW50LmNsaWVudFkpIDwgMikgPyAobGFzdE1vdXNlRG93bkNvdW50ICsgMSkgJSAzIDogMTtcbn1cbmZ1bmN0aW9uIGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSB2aWV3LnBvc0FuZFNpZGVBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpLCB0eXBlID0gZ2V0Q2xpY2tUeXBlKGV2ZW50KTtcbiAgICBsZXQgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydC5wb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgZXh0ZW5kLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHZpZXcucG9zQW5kU2lkZUF0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSksIHJlbW92ZWQ7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZUZvckNsaWNrKHZpZXcsIGN1ci5wb3MsIGN1ci5hc3NvYywgdHlwZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQucG9zICE9IGN1ci5wb3MgJiYgIWV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBzdGFydC5wb3MsIHN0YXJ0LmFzc29jLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHN0YXJ0UmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSksIHRvID0gTWF0aC5tYXgoc3RhcnRSYW5nZS50bywgcmFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gZnJvbSA8IHJhbmdlLmZyb20gPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLnJlcGxhY2VSYW5nZShzdGFydFNlbC5tYWluLmV4dGVuZChyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUgJiYgdHlwZSA9PSAxICYmIHN0YXJ0U2VsLnJhbmdlcy5sZW5ndGggPiAxICYmIChyZW1vdmVkID0gcmVtb3ZlUmFuZ2VBcm91bmQoc3RhcnRTZWwsIGN1ci5wb3MpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUmFuZ2VBcm91bmQoc2VsLCBwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICAgIGlmIChmcm9tIDw9IHBvcyAmJiB0byA+PSBwb3MpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLnNsaWNlKDAsIGkpLmNvbmNhdChzZWwucmFuZ2VzLnNsaWNlKGkgKyAxKSksIHNlbC5tYWluSW5kZXggPT0gaSA/IDAgOiBzZWwubWFpbkluZGV4IC0gKHNlbC5tYWluSW5kZXggPiBpID8gMSA6IDApKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb246IHsgbWFpbjogcmFuZ2UgfSB9ID0gdmlldy5zdGF0ZTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICBsZXQgdGlsZSA9IHZpZXcuZG9jVmlldy50aWxlLm5lYXJlc3QoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS5pc1dpZGdldCgpKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHRpbGUucG9zQXRTdGFydCwgdG8gPSBmcm9tICsgdGlsZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA+PSByYW5nZS50byB8fCB0byA8PSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgeyBpbnB1dFN0YXRlIH0gPSB2aWV3O1xuICAgIGlmIChpbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICBpbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICBpbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gcmFuZ2U7XG4gICAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlcikge1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcIlRleHRcIiwgdGV4dEZpbHRlcih2aWV3LnN0YXRlLCBjbGlwYm9hcmRPdXRwdXRGaWx0ZXIsIHZpZXcuc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKSk7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuaGFuZGxlcnMuZHJhZ2VuZCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LCBkaXJlY3QpIHtcbiAgICB0ZXh0ID0gdGV4dEZpbHRlcih2aWV3LnN0YXRlLCBjbGlwYm9hcmRJbnB1dEZpbHRlciwgdGV4dCk7XG4gICAgaWYgKCF0ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRyb3BQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgbGV0IHsgZHJhZ2dlZENvbnRlbnQgfSA9IHZpZXcuaW5wdXRTdGF0ZTtcbiAgICBsZXQgZGVsID0gZGlyZWN0ICYmIGRyYWdnZWRDb250ZW50ICYmIGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBldmVudClcbiAgICAgICAgPyB7IGZyb206IGRyYWdnZWRDb250ZW50LmZyb20sIHRvOiBkcmFnZ2VkQ29udGVudC50byB9IDogbnVsbDtcbiAgICBsZXQgaW5zID0geyBmcm9tOiBkcm9wUG9zLCBpbnNlcnQ6IHRleHQgfTtcbiAgICBsZXQgY2hhbmdlcyA9IHZpZXcuc3RhdGUuY2hhbmdlcyhkZWwgPyBbZGVsLCBpbnNdIDogaW5zKTtcbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIC0xKSwgaGVhZDogY2hhbmdlcy5tYXBQb3MoZHJvcFBvcywgMSkgfSxcbiAgICAgICAgdXNlckV2ZW50OiBkZWwgPyBcIm1vdmUuZHJvcFwiIDogXCJpbnB1dC5kcm9wXCJcbiAgICB9KTtcbiAgICB2aWV3LmlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xufVxuaGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBmaWxlcyA9IGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoKSB7IC8vIEZvciBhIGZpbGUgZHJvcCwgcmVhZCB0aGUgZmlsZSdzIHRleHQuXG4gICAgICAgIGxldCB0ZXh0ID0gQXJyYXkoZmlsZXMubGVuZ3RoKSwgcmVhZCA9IDA7XG4gICAgICAgIGxldCBmaW5pc2hGaWxlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCsrcmVhZCA9PSBmaWxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQuZmlsdGVyKHMgPT4gcyAhPSBudWxsKS5qb2luKHZpZXcuc3RhdGUubGluZUJyZWFrKSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZpbmlzaEZpbGU7XG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghL1tcXHgwMC1cXHgwOFxceDBlLVxceDFmXXsyfS8udGVzdChyZWFkZXIucmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgdGV4dFtpXSA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgZmluaXNoRmlsZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRvUGFzdGUodmlldywgZGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSB8fCBkYXRhLmdldERhdGEoXCJ0ZXh0L3VyaS1saXN0XCIpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlUGFzdGUodmlldyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgdGV4dCkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LnZhbHVlID0gdGV4dDtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICB0YXJnZXQuc2VsZWN0aW9uRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgdGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gY29waWVkUmFuZ2Uoc3RhdGUpIHtcbiAgICBsZXQgY29udGVudCA9IFtdLCByYW5nZXMgPSBbXSwgbGluZXdpc2UgPSBmYWxzZTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKVxuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIGlmICghY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgLy8gTm90aGluZyBzZWxlY3RlZCwgZG8gYSBsaW5lLXdpc2UgY29weVxuICAgICAgICBsZXQgdXB0byA9IC0xO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20gfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPiB1cHRvKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGxpbmUudGV4dCk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBsaW5lLnRvICsgMSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cHRvID0gbGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXdpc2UgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4geyB0ZXh0OiB0ZXh0RmlsdGVyKHN0YXRlLCBjbGlwYm9hcmRPdXRwdXRGaWx0ZXIsIGNvbnRlbnQuam9pbihzdGF0ZS5saW5lQnJlYWspKSwgcmFuZ2VzLCBsaW5ld2lzZSB9O1xufVxubGV0IGxhc3RMaW5ld2lzZUNvcHkgPSBudWxsO1xuaGFuZGxlcnMuY29weSA9IGhhbmRsZXJzLmN1dCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIC8vIElmIHRoZSBET00gc2VsZWN0aW9uIGlzIG91dHNpZGUgdGhpcyBlZGl0b3IsIGRvbid0IGludGVyY2VwdC5cbiAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiBhIHBhcmVudCBlZGl0b3IgKGxpa2UgUHJvc2VNaXJyb3IpIHNlbGVjdHMgY29udGVudCB0aGF0XG4gICAgLy8gc3BhbnMgbXVsdGlwbGUgZWxlbWVudHMgaW5jbHVkaW5nIHRoaXMgQ29kZU1pcnJvci4gVGhlIGNvcHkgZXZlbnQgbWF5XG4gICAgLy8gYnViYmxlIHRocm91Z2ggQ29kZU1pcnJvciAoZS5nLiB3aGVuIENvZGVNaXJyb3IgaXMgdGhlIGZpcnN0IG9yIHRoZSBsYXN0XG4gICAgLy8gZWxlbWVudCBpbiB0aGUgc2VsZWN0aW9uKSwgYnV0IHdlIHNob3VsZCBsZXQgdGhlIHBhcmVudCBoYW5kbGUgaXQuXG4gICAgbGV0IGRvbVNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgIGlmIChkb21TZWwgJiYgIWhhc1NlbGVjdGlvbih2aWV3LmNvbnRlbnRET00sIGRvbVNlbCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyB0ZXh0LCByYW5nZXMsIGxpbmV3aXNlIH0gPSBjb3BpZWRSYW5nZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAoIXRleHQgJiYgIWxpbmV3aXNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGFzdExpbmV3aXNlQ29weSA9IGxpbmV3aXNlID8gdGV4dCA6IG51bGw7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJjdXRcIiAmJiAhdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBjaGFuZ2VzOiByYW5nZXMsXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIHVzZXJFdmVudDogXCJkZWxldGUuY3V0XCJcbiAgICAgICAgfSk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmNvbnN0IGlzRm9jdXNDaGFuZ2UgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24oc3RhdGUsIGZvY3VzKSB7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBnZXRFZmZlY3Qgb2Ygc3RhdGUuZmFjZXQoZm9jdXNDaGFuZ2VFZmZlY3QpKSB7XG4gICAgICAgIGxldCBlZmZlY3QgPSBnZXRFZmZlY3Qoc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgaWYgKGVmZmVjdClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGggPyBzdGF0ZS51cGRhdGUoeyBlZmZlY3RzLCBhbm5vdGF0aW9uczogaXNGb2N1c0NoYW5nZS5vZih0cnVlKSB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxldCBmb2N1cyA9IHZpZXcuaGFzRm9jdXM7XG4gICAgICAgIGlmIChmb2N1cyAhPSB2aWV3LmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSBmb2N1c0NoYW5nZVRyYW5zYWN0aW9uKHZpZXcuc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIH1cbiAgICB9LCAxMCk7XG59XG5vYnNlcnZlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gV2hlbiBmb2N1c2luZyByZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uLCBtb3ZlIGl0IGJhY2sgdG8gd2hlcmUgaXQgd2FzXG4gICAgaWYgKCF2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgJiYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wIHx8IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCkpIHtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3A7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQ7XG4gICAgfVxuICAgIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpO1xufTtcbm9ic2VydmVycy5ibHVyID0gdmlldyA9PiB7XG4gICAgdmlldy5vYnNlcnZlci5jbGVhclNlbGVjdGlvblJhbmdlKCk7XG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XG59O1xub2JzZXJ2ZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSBvYnNlcnZlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5vYnNlcnZlci5lZGl0Q29udGV4dClcbiAgICAgICAgcmV0dXJuOyAvLyBDb21wb3NpdGlvbiBoYW5kbGVkIGJ5IGVkaXQgY29udGV4dFxuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9PSBudWxsKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IHRydWU7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgIC8vIEZJWE1FIHBvc3NpYmx5IHNldCBhIHRpbWVvdXQgdG8gY2xlYXIgaXQgYWdhaW4gb24gQW5kcm9pZFxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gMDtcbiAgICB9XG59O1xub2JzZXJ2ZXJzLmNvbXBvc2l0aW9uZW5kID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcub2JzZXJ2ZXIuZWRpdENvbnRleHQpXG4gICAgICAgIHJldHVybjsgLy8gQ29tcG9zaXRpb24gaGFuZGxlZCBieSBlZGl0IGNvbnRleHRcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gLTE7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9IHRydWU7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSA9IHZpZXcub2JzZXJ2ZXIucGVuZGluZ1JlY29yZHMoKS5sZW5ndGggPiAwO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkKSB7XG4gICAgICAgIC8vIERlbGF5IGZsdXNoaW5nIGZvciBhIGJpdCBvbiBBbmRyb2lkIGJlY2F1c2UgaXQnbGwgb2Z0ZW4gZmlyZSBhXG4gICAgICAgIC8vIGJ1bmNoIG9mIGNvbnRyYWRpY3RvcnkgY2hhbmdlcyBpbiBhIHJvdyBhdCBlbmQgb2YgY29tcG9zaXRvblxuICAgICAgICB2aWV3Lm9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlKSB7XG4gICAgICAgIC8vIElmIHdlIGZvdW5kIHBlbmRpbmcgcmVjb3Jkcywgc2NoZWR1bGUgYSBmbHVzaC5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB2aWV3Lm9ic2VydmVyLmZsdXNoKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBtYWtlIHN1cmUgdGhhdCwgaWYgbm8gY2hhbmdlcyBjb21lIGluIHNvb24sIHRoZVxuICAgICAgICAvLyBjb21wb3NpdGlvbiB2aWV3IGlzIGNsZWFyZWQuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwICYmIHZpZXcuZG9jVmlldy5oYXNDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xub2JzZXJ2ZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RDb250ZXh0TWVudSA9IERhdGUubm93KCk7XG59O1xuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChldmVudC5pbnB1dFR5cGUgPT0gXCJpbnNlcnRUZXh0XCIgfHwgZXZlbnQuaW5wdXRUeXBlID09IFwiaW5zZXJ0Q29tcG9zaXRpb25UZXh0XCIpIHtcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmluc2VydGluZ1RleHQgPSBldmVudC5kYXRhO1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuaW5zZXJ0aW5nVGV4dEF0ID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgLy8gSW4gRWRpdENvbnRleHQgbW9kZSwgd2UgbXVzdCBoYW5kbGUgaW5zZXJ0UmVwbGFjZW1lbnRUZXh0IGV2ZW50c1xuICAgIC8vIGRpcmVjdGx5LCB0byBtYWtlIHNwZWxsIGNoZWNraW5nIGNvcnJlY3Rpb25zIHdvcmtcbiAgICBpZiAoZXZlbnQuaW5wdXRUeXBlID09IFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCIgJiYgdmlldy5vYnNlcnZlci5lZGl0Q29udGV4dCkge1xuICAgICAgICBsZXQgdGV4dCA9IChfYSA9IGV2ZW50LmRhdGFUcmFuc2ZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpLCByYW5nZXMgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcbiAgICAgICAgaWYgKHRleHQgJiYgcmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHIgPSByYW5nZXNbMF07XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZpZXcucG9zQXRET00oci5zdGFydENvbnRhaW5lciwgci5zdGFydE9mZnNldCksIHRvID0gdmlldy5wb3NBdERPTShyLmVuZENvbnRhaW5lciwgci5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgYXBwbHlET01DaGFuZ2VJbm5lcih2aWV3LCB7IGZyb20sIHRvLCBpbnNlcnQ6IHZpZXcuc3RhdGUudG9UZXh0KHRleHQpIH0sIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmVjYXVzZSBDaHJvbWUgQW5kcm9pZCBkb2Vzbid0IGZpcmUgdXNlZnVsIGtleSBldmVudHMsIHVzZVxuICAgIC8vIGJlZm9yZWlucHV0IHRvIGRldGVjdCBiYWNrc3BhY2UgKGFuZCBwb3NzaWJseSBlbnRlciBhbmQgZGVsZXRlLFxuICAgIC8vIGJ1dCB0aG9zZSB1c3VhbGx5IGRvbid0IGV2ZW4gc2VlbSB0byBmaXJlIGJlZm9yZWlucHV0IGV2ZW50cyBhdFxuICAgIC8vIHRoZSBtb21lbnQpIGFuZCBmYWtlIGEga2V5IGV2ZW50IGZvciBpdC5cbiAgICAvL1xuICAgIC8vIChwcmV2ZW50RGVmYXVsdCBvbiBiZWZvcmVpbnB1dCwgdGhvdWdoIHN1cHBvcnRlZCBpbiB0aGUgc3BlYyxcbiAgICAvLyBzZWVtcyB0byBkbyBub3RoaW5nIGF0IGFsbCBvbiBDaHJvbWUpLlxuICAgIGxldCBwZW5kaW5nO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQgJiYgKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkuaW5wdXRUeXBlID09IGV2ZW50LmlucHV0VHlwZSkpKSB7XG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KHBlbmRpbmcua2V5LCBwZW5kaW5nLmtleUNvZGUpO1xuICAgICAgICBpZiAocGVuZGluZy5rZXkgPT0gXCJCYWNrc3BhY2VcIiB8fCBwZW5kaW5nLmtleSA9PSBcIkRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRWaWV3SGVpZ2h0ID0gKChfYiA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodCkgfHwgMDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBCYWNrc3BhY2luZyBuZWFyIHVuZWRpdGFibGUgbm9kZXMgb24gQ2hyb21lIEFuZHJvaWQgc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgLy8gY2xvc2VzIHRoZSB2aXJ0dWFsIGtleWJvYXJkLiBUaGlzIHRyaWVzIHRvIGNydWRlbHkgZGV0ZWN0XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbmQgcmVmb2N1cyB0byBnZXQgaXQgYmFjay5cbiAgICAgICAgICAgICAgICBpZiAoKCgoX2EgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDApID4gc3RhcnRWaWV3SGVpZ2h0ICsgMTAgJiYgdmlldy5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYnJvd3Nlci5pb3MgJiYgZXZlbnQuaW5wdXRUeXBlID09IFwiZGVsZXRlQ29udGVudEZvcndhcmRcIikge1xuICAgICAgICAvLyBGb3Igc29tZSByZWFzb24sIERPTSBjaGFuZ2VzIChhbmQgYmVmb3JlaW5wdXQpIGhhcHBlbiBfYmVmb3JlX1xuICAgICAgICAvLyB0aGUga2V5IGV2ZW50IGZvciBjdHJsLWQgb24gaU9TIHdoZW4gdXNpbmcgYW4gZXh0ZXJuYWxcbiAgICAgICAgLy8ga2V5Ym9hcmQuXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgfVxuICAgIC8vIFNhZmFyaSB3aWxsIG9jY2FzaW9uYWxseSBmb3JnZXQgdG8gZmlyZSBjb21wb3NpdGlvbmVuZCBhdCB0aGUgZW5kIG9mIGEgZGVhZC1rZXkgY29tcG9zaXRpb25cbiAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgZXZlbnQuaW5wdXRUeXBlID09IFwiaW5zZXJ0VGV4dFwiICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG9ic2VydmVycy5jb21wb3NpdGlvbmVuZCh2aWV3LCBldmVudCksIDIwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGFwcGxpZWRGaXJlZm94SGFjayA9IC8qQF9fUFVSRV9fKi9uZXcgU2V0O1xuLy8gSW4gRmlyZWZveCwgd2hlbiBjdXQvY29weSBoYW5kbGVycyBhcmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50LCB0aGF0XG4vLyBzb21laG93IGF2b2lkcyBhIGJ1ZyB3aGVyZSB0aG9zZSBldmVudHMgYXJlbid0IGZpcmVkIHdoZW4gdGhlXG4vLyBzZWxlY3Rpb24gaXMgZW1wdHkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzEwODJcbi8vIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05OTU5NjFcbmZ1bmN0aW9uIGZpcmVmb3hDb3B5Q3V0SGFjayhkb2MpIHtcbiAgICBpZiAoIWFwcGxpZWRGaXJlZm94SGFjay5oYXMoZG9jKSkge1xuICAgICAgICBhcHBsaWVkRmlyZWZveEhhY2suYWRkKGRvYyk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCAoKSA9PiB7IH0pO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCAoKSA9PiB7IH0pO1xuICAgIH1cbn1cblxuY29uc3Qgd3JhcHBpbmdXaGl0ZVNwYWNlID0gW1wicHJlLXdyYXBcIiwgXCJub3JtYWxcIiwgXCJwcmUtbGluZVwiLCBcImJyZWFrLXNwYWNlc1wiXTtcbi8vIFVzZWQgdG8gdHJhY2ssIGR1cmluZyB1cGRhdGVIZWlnaHQsIGlmIGFueSBhY3R1YWwgaGVpZ2h0cyBjaGFuZ2VkXG5sZXQgaGVpZ2h0Q2hhbmdlRmxhZyA9IGZhbHNlO1xuZnVuY3Rpb24gY2xlYXJIZWlnaHRDaGFuZ2VGbGFnKCkgeyBoZWlnaHRDaGFuZ2VGbGFnID0gZmFsc2U7IH1cbmNsYXNzIEhlaWdodE9yYWNsZSB7XG4gICAgY29uc3RydWN0b3IobGluZVdyYXBwaW5nKSB7XG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmRvYyA9IFRleHQuZW1wdHk7XG4gICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSAxNDsgLy8gVGhlIGhlaWdodCBvZiBhbiBlbnRpcmUgbGluZSAobGluZS1oZWlnaHQpXG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gNztcbiAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gMTQ7IC8vIFRoZSBoZWlnaHQgb2YgdGhlIGFjdHVhbCBmb250IChmb250LXNpemUpXG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IDMwO1xuICAgIH1cbiAgICBoZWlnaHRGb3JHYXAoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGxpbmVzID0gdGhpcy5kb2MubGluZUF0KHRvKS5udW1iZXIgLSB0aGlzLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyICsgMTtcbiAgICAgICAgaWYgKHRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgbGluZXMgKz0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCgodG8gLSBmcm9tKSAtIChsaW5lcyAqIHRoaXMubGluZUxlbmd0aCAqIDAuNSkpIC8gdGhpcy5saW5lTGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQgKiBsaW5lcztcbiAgICB9XG4gICAgaGVpZ2h0Rm9yTGluZShsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGxldCBsaW5lcyA9IDEgKyBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGxlbmd0aCAtIHRoaXMubGluZUxlbmd0aCkgLyBNYXRoLm1heCgxLCB0aGlzLmxpbmVMZW5ndGggLSA1KSkpO1xuICAgICAgICByZXR1cm4gbGluZXMgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgfVxuICAgIHNldERvYyhkb2MpIHsgdGhpcy5kb2MgPSBkb2M7IHJldHVybiB0aGlzOyB9XG4gICAgbXVzdFJlZnJlc2hGb3JXcmFwcGluZyh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiAod3JhcHBpbmdXaGl0ZVNwYWNlLmluZGV4T2Yod2hpdGVTcGFjZSkgPiAtMSkgIT0gdGhpcy5saW5lV3JhcHBpbmc7XG4gICAgfVxuICAgIG11c3RSZWZyZXNoRm9ySGVpZ2h0cyhsaW5lSGVpZ2h0cykge1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUhlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBoID0gbGluZUhlaWdodHNbaV07XG4gICAgICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0pIHsgLy8gUm91bmQgdG8gLjEgcGl4ZWxzXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hlaWdodDtcbiAgICB9XG4gICAgcmVmcmVzaCh3aGl0ZVNwYWNlLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQsIGxpbmVMZW5ndGgsIGtub3duSGVpZ2h0cykge1xuICAgICAgICBsZXQgbGluZVdyYXBwaW5nID0gd3JhcHBpbmdXaGl0ZVNwYWNlLmluZGV4T2Yod2hpdGVTcGFjZSkgPiAtMTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBNYXRoLmFicyhsaW5lSGVpZ2h0IC0gdGhpcy5saW5lSGVpZ2h0KSA+IDAuMyB8fCB0aGlzLmxpbmVXcmFwcGluZyAhPSBsaW5lV3JhcHBpbmcgfHxcbiAgICAgICAgICAgIE1hdGguYWJzKGNoYXJXaWR0aCAtIHRoaXMuY2hhcldpZHRoKSA+IDAuMTtcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gY2hhcldpZHRoO1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSB0ZXh0SGVpZ2h0O1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtub3duSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0ga25vd25IZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoIDwgMClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn1cbi8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYnkgYHVwZGF0ZUhlaWdodGAgdG8gbWFrZSBET00gbWVhc3VyZW1lbnRzXG4vLyBhcnJpdmUgYXQgdGhlIHJpZ2h0IG5vZGVzLiBUaGUgYGhlaWdodHNgIGFycmF5IGlzIGEgc2VxdWVuY2Ugb2Zcbi8vIGJsb2NrIGhlaWdodHMsIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gYGZyb21gLlxuY2xhc3MgTWVhc3VyZWRIZWlnaHRzIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCBoZWlnaHRzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaGVpZ2h0cyA9IGhlaWdodHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgbW9yZSgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmhlaWdodHMubGVuZ3RoOyB9XG59XG4vKipcblJlY29yZCB1c2VkIHRvIHJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrLWxldmVsIGVsZW1lbnRcbmluIHRoZSBlZGl0b3Igdmlldy5cbiovXG5jbGFzcyBCbG9ja0luZm8ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnQpLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBJdHMgaGVpZ2h0LlxuICAgICovXG4gICAgaGVpZ2h0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWwgV2VpcmQgcGFja2VkIGZpZWxkIHRoYXQgaG9sZHMgYW4gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICBmb3IgY29tcG9zaXRlIGJsb2NrcywgYSBkZWNvcmF0aW9uIGZvciBibG9jayB3aWRnZXRzLCBhbmQgYVxuICAgIG51bWJlciBpbmRpY2F0aW5nIHRoZSBhbW91bnQgb2Ygd2lkZ2V0LWNyZWF0ZWQgbGluZSBicmVha3MgZm9yXG4gICAgdGV4dCBibG9ja3MuXG4gICAgKi9cbiAgICBfY29udGVudCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gX2NvbnRlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIGVsZW1lbnQgdGhpcyBpcy4gV2hlbiBxdWVyeWluZyBsaW5lcywgdGhpcyBtYXkgYmVcbiAgICBhbiBhcnJheSBvZiBhbGwgdGhlIGJsb2NrcyB0aGF0IG1ha2UgdXAgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9jb250ZW50ID09IFwibnVtYmVyXCIgPyBCbG9ja1R5cGUuVGV4dCA6XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuX2NvbnRlbnQpID8gdGhpcy5fY29udGVudCA6IHRoaXMuX2NvbnRlbnQudHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgZWxlbWVudCBhcyBhIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUaGUgYm90dG9tIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgICovXG4gICAgZ2V0IGJvdHRvbSgpIHsgcmV0dXJuIHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7IH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgd2lkZ2V0IGJsb2NrLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSB3aWRnZXRcbiAgICBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudCBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbiA/IHRoaXMuX2NvbnRlbnQud2lkZ2V0IDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIHRleHRibG9jaywgdGhpcyBob2xkcyB0aGUgbnVtYmVyIG9mIGxpbmUgYnJlYWtzXG4gICAgdGhhdCBhcHBlYXIgaW4gd2lkZ2V0cyBpbnNpZGUgdGhlIGJsb2NrLlxuICAgICovXG4gICAgZ2V0IHdpZGdldExpbmVCcmVha3MoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fY29udGVudCA9PSBcIm51bWJlclwiID8gdGhpcy5fY29udGVudCA6IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgam9pbihvdGhlcikge1xuICAgICAgICBsZXQgY29udGVudCA9IChBcnJheS5pc0FycmF5KHRoaXMuX2NvbnRlbnQpID8gdGhpcy5fY29udGVudCA6IFt0aGlzXSlcbiAgICAgICAgICAgIC5jb25jYXQoQXJyYXkuaXNBcnJheShvdGhlci5fY29udGVudCkgPyBvdGhlci5fY29udGVudCA6IFtvdGhlcl0pO1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyh0aGlzLmZyb20sIHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoLCB0aGlzLnRvcCwgdGhpcy5oZWlnaHQgKyBvdGhlci5oZWlnaHQsIGNvbnRlbnQpO1xuICAgIH1cbn1cbnZhciBRdWVyeVR5cGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChRdWVyeVR5cGUpIHtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlQb3NcIl0gPSAwXSA9IFwiQnlQb3NcIjtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlIZWlnaHRcIl0gPSAxXSA9IFwiQnlIZWlnaHRcIjtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlQb3NOb0hlaWdodFwiXSA9IDJdID0gXCJCeVBvc05vSGVpZ2h0XCI7XG5yZXR1cm4gUXVlcnlUeXBlfSkoUXVlcnlUeXBlIHx8IChRdWVyeVR5cGUgPSB7fSkpO1xuY29uc3QgRXBzaWxvbiA9IDFlLTM7XG5jbGFzcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgLy8gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvdmVyZWRcbiAgICBoZWlnaHQsIC8vIEhlaWdodCBvZiB0aGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50XG4gICAgZmxhZ3MgPSAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIGdldCBvdXRkYXRlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBGbGFnLk91dGRhdGVkICovKSA+IDA7IH1cbiAgICBzZXQgb3V0ZGF0ZWQodmFsdWUpIHsgdGhpcy5mbGFncyA9ICh2YWx1ZSA/IDIgLyogRmxhZy5PdXRkYXRlZCAqLyA6IDApIHwgKHRoaXMuZmxhZ3MgJiB+MiAvKiBGbGFnLk91dGRhdGVkICovKTsgfVxuICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuaGVpZ2h0IC0gaGVpZ2h0KSA+IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgaGVpZ2h0Q2hhbmdlRmxhZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCYXNlIGNhc2UgaXMgdG8gcmVwbGFjZSBhIGxlYWYgbm9kZSwgd2hpY2ggc2ltcGx5IGJ1aWxkcyBhIHRyZWVcbiAgICAvLyBmcm9tIHRoZSBuZXcgbm9kZXMgYW5kIHJldHVybnMgdGhhdCAoSGVpZ2h0TWFwQnJhbmNoIGFuZFxuICAgIC8vIEhlaWdodE1hcEdhcCBvdmVycmlkZSB0aGlzIHRvIGFjdHVhbGx5IHVzZSBmcm9tL3RvKVxuICAgIHJlcGxhY2UoX2Zyb20sIF90bywgbm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIC8vIEFnYWluLCB0aGVzZSBhcmUgYmFzZSBjYXNlcywgYW5kIGFyZSBvdmVycmlkZGVuIGZvciBicmFuY2ggYW5kIGdhcCBub2Rlcy5cbiAgICBkZWNvbXBvc2VMZWZ0KF90bywgcmVzdWx0KSB7IHJlc3VsdC5wdXNoKHRoaXMpOyB9XG4gICAgZGVjb21wb3NlUmlnaHQoX2Zyb20sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGFwcGx5Q2hhbmdlcyhkZWNvcmF0aW9ucywgb2xkRG9jLCBvcmFjbGUsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcywgZG9jID0gb3JhY2xlLmRvYztcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvcmFjbGUuc2V0RG9jKG9sZERvYyksIDAsIDApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0LnRvID49IHRvQSA/IHN0YXJ0IDogbWUubGluZUF0KHRvQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9yYWNsZSwgMCwgMCk7XG4gICAgICAgICAgICB0b0IgKz0gZW5kLnRvIC0gdG9BO1xuICAgICAgICAgICAgdG9BID0gZW5kLnRvO1xuICAgICAgICAgICAgd2hpbGUgKGkgPiAwICYmIHN0YXJ0LmZyb20gPD0gY2hhbmdlc1tpIC0gMV0udG9BKSB7XG4gICAgICAgICAgICAgICAgZnJvbUEgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQTtcbiAgICAgICAgICAgICAgICBmcm9tQiA9IGNoYW5nZXNbaSAtIDFdLmZyb21CO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUEgPCBzdGFydC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9yYWNsZSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tQiArPSBzdGFydC5mcm9tIC0gZnJvbUE7XG4gICAgICAgICAgICBmcm9tQSA9IHN0YXJ0LmZyb207XG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBOb2RlQnVpbGRlci5idWlsZChvcmFjbGUuc2V0RG9jKGRvYyksIGRlY29yYXRpb25zLCBmcm9tQiwgdG9CKTtcbiAgICAgICAgICAgIG1lID0gcmVwbGFjZShtZSwgbWUucmVwbGFjZShmcm9tQSwgdG9BLCBub2RlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZS51cGRhdGVIZWlnaHQob3JhY2xlLCAwKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkgeyByZXR1cm4gbmV3IEhlaWdodE1hcFRleHQoMCwgMCwgMCk7IH1cbiAgICAvLyBub2RlcyB1c2VzIG51bGwgdmFsdWVzIHRvIGluZGljYXRlIHRoZSBwb3NpdGlvbiBvZiBsaW5lIGJyZWFrcy5cbiAgICAvLyBUaGVyZSBhcmUgbmV2ZXIgbGluZSBicmVha3MgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgYXJyYXksIG9yXG4gICAgLy8gdHdvIGxpbmUgYnJlYWtzIG5leHQgdG8gZWFjaCBvdGhlciwgYW5kIHRoZSBhcnJheSBpc24ndCBhbGxvd2VkXG4gICAgLy8gdG8gYmUgZW1wdHkgKHNhbWUgcmVzdHJpY3Rpb25zIGFzIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBidWlsZGVyKS5cbiAgICBzdGF0aWMgb2Yobm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICBsZXQgaSA9IDAsIGogPSBub2Rlcy5sZW5ndGgsIGJlZm9yZSA9IDAsIGFmdGVyID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGkgPT0gaikge1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgPiBhZnRlciAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAxICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZnRlciA+IGJlZm9yZSAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMiArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBhZnRlciAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlIDwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzW2krK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzWy0tal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYnJrID0gMDtcbiAgICAgICAgaWYgKG5vZGVzW2kgLSAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIZWlnaHRNYXBCcmFuY2goSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKDAsIGkpKSwgYnJrLCBIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoaikpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlKG9sZCwgdmFsKSB7XG4gICAgaWYgKG9sZCA9PSB2YWwpXG4gICAgICAgIHJldHVybiBvbGQ7XG4gICAgaWYgKG9sZC5jb25zdHJ1Y3RvciAhPSB2YWwuY29uc3RydWN0b3IpXG4gICAgICAgIGhlaWdodENoYW5nZUZsYWcgPSB0cnVlO1xuICAgIHJldHVybiB2YWw7XG59XG5IZWlnaHRNYXAucHJvdG90eXBlLnNpemUgPSAxO1xuY29uc3QgU3BhY2VEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ucmVwbGFjZSh7fSk7XG5jbGFzcyBIZWlnaHRNYXBCbG9jayBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQsIGRlY28pIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmRlY28gPSBkZWNvO1xuICAgICAgICB0aGlzLnNwYWNlQWJvdmUgPSAwO1xuICAgIH1cbiAgICBtYWluQmxvY2sodG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8ob2Zmc2V0LCB0aGlzLmxlbmd0aCwgdG9wICsgdGhpcy5zcGFjZUFib3ZlLCB0aGlzLmhlaWdodCAtIHRoaXMuc3BhY2VBYm92ZSwgdGhpcy5kZWNvIHx8IDApO1xuICAgIH1cbiAgICBibG9ja0F0KGhlaWdodCwgX29yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2VBYm92ZSAmJiBoZWlnaHQgPCB0b3AgKyB0aGlzLnNwYWNlQWJvdmUgPyBuZXcgQmxvY2tJbmZvKG9mZnNldCwgMCwgdG9wLCB0aGlzLnNwYWNlQWJvdmUsIFNwYWNlRGVjbylcbiAgICAgICAgICAgIDogdGhpcy5tYWluQmxvY2sodG9wLCBvZmZzZXQpO1xuICAgIH1cbiAgICBsaW5lQXQoX3ZhbHVlLCBfdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgbWFpbiA9IHRoaXMubWFpbkJsb2NrKHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2VBYm92ZSA/IHRoaXMuYmxvY2tBdCgwLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KS5qb2luKG1haW4pIDogbWFpbjtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgaWYgKGZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgdG8gPj0gb2Zmc2V0KVxuICAgICAgICAgICAgZih0aGlzLmxpbmVBdCgwLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgdG9wLCBvZmZzZXQpKTtcbiAgICB9XG4gICAgc2V0TWVhc3VyZWRIZWlnaHQobWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IG5leHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICBpZiAobmV4dCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VBYm92ZSA9IC1uZXh0O1xuICAgICAgICAgICAgbmV4dCA9IG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwYWNlQWJvdmUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SGVpZ2h0KG5leHQpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBfZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldE1lYXN1cmVkSGVpZ2h0KG1lYXN1cmVkKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgYmxvY2soJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwVGV4dCBleHRlbmRzIEhlaWdodE1hcEJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCwgYWJvdmUpIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQsIG51bGwpO1xuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IDA7IC8vIEFtb3VudCBvZiBjb2xsYXBzZWQgY29udGVudCBpbiB0aGUgbGluZVxuICAgICAgICB0aGlzLndpZGdldEhlaWdodCA9IDA7IC8vIE1heGltdW0gaW5saW5lIHdpZGdldCBoZWlnaHRcbiAgICAgICAgdGhpcy5icmVha3MgPSAwOyAvLyBOdW1iZXIgb2Ygd2lkZ2V0LWludHJvZHVjZWQgbGluZSBicmVha3Mgb24gdGhlIGxpbmVcbiAgICAgICAgdGhpcy5zcGFjZUFib3ZlID0gYWJvdmU7XG4gICAgfVxuICAgIG1haW5CbG9jayh0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhvZmZzZXQsIHRoaXMubGVuZ3RoLCB0b3AgKyB0aGlzLnNwYWNlQWJvdmUsIHRoaXMuaGVpZ2h0IC0gdGhpcy5zcGFjZUFib3ZlLCB0aGlzLmJyZWFrcyk7XG4gICAgfVxuICAgIHJlcGxhY2UoX2Zyb20sIF90bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxICYmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCB8fCBub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmIChub2RlLmZsYWdzICYgNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi8pKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5sZW5ndGggLSBub2RlLmxlbmd0aCkgPCAxMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBIZWlnaHRNYXBUZXh0KG5vZGUubGVuZ3RoLCB0aGlzLmhlaWdodCwgdGhpcy5zcGFjZUFib3ZlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgICAgIG5vZGUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TWVhc3VyZWRIZWlnaHQobWVhc3VyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlIHx8IHRoaXMub3V0ZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VBYm92ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChNYXRoLm1heCh0aGlzLndpZGdldEhlaWdodCwgb3JhY2xlLmhlaWdodEZvckxpbmUodGhpcy5sZW5ndGggLSB0aGlzLmNvbGxhcHNlZCkpICtcbiAgICAgICAgICAgICAgICB0aGlzLmJyZWFrcyAqIG9yYWNsZS5saW5lSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBsaW5lKCR7dGhpcy5sZW5ndGh9JHt0aGlzLmNvbGxhcHNlZCA/IC10aGlzLmNvbGxhcHNlZCA6IFwiXCJ9JHt0aGlzLndpZGdldEhlaWdodCA/IFwiOlwiICsgdGhpcy53aWRnZXRIZWlnaHQgOiBcIlwifSlgO1xuICAgIH1cbn1cbmNsYXNzIEhlaWdodE1hcEdhcCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7IHN1cGVyKGxlbmd0aCwgMCk7IH1cbiAgICBoZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBmaXJzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQpLm51bWJlciwgbGFzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQgKyB0aGlzLmxlbmd0aCkubnVtYmVyO1xuICAgICAgICBsZXQgbGluZXMgPSBsYXN0TGluZSAtIGZpcnN0TGluZSArIDE7XG4gICAgICAgIGxldCBwZXJMaW5lLCBwZXJDaGFyID0gMDtcbiAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbFBlckxpbmUgPSBNYXRoLm1pbih0aGlzLmhlaWdodCwgb3JhY2xlLmxpbmVIZWlnaHQgKiBsaW5lcyk7XG4gICAgICAgICAgICBwZXJMaW5lID0gdG90YWxQZXJMaW5lIC8gbGluZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBsaW5lcyArIDEpXG4gICAgICAgICAgICAgICAgcGVyQ2hhciA9ICh0aGlzLmhlaWdodCAtIHRvdGFsUGVyTGluZSkgLyAodGhpcy5sZW5ndGggLSBsaW5lcyAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVyTGluZSA9IHRoaXMuaGVpZ2h0IC8gbGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9O1xuICAgIH1cbiAgICBibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxhc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpO1xuICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgbGV0IGd1ZXNzID0gb2Zmc2V0ICsgKGhlaWdodCA8IG9yYWNsZS5saW5lSGVpZ2h0ID8gMFxuICAgICAgICAgICAgICAgIDogTWF0aC5yb3VuZChNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoaGVpZ2h0IC0gdG9wKSAvIHRoaXMuaGVpZ2h0KSkgKiB0aGlzLmxlbmd0aCkpO1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChndWVzcyksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICAgICAgbGV0IGxpbmVUb3AgPSBNYXRoLm1heCh0b3AsIGhlaWdodCAtIGxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIGxpbmVUb3AsIGxpbmVIZWlnaHQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsYXN0TGluZSAtIGZpcnN0TGluZSwgTWF0aC5mbG9vcigoaGVpZ2h0IC0gdG9wKSAvIHBlckxpbmUpKSk7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCBsZW5ndGggfSA9IG9yYWNsZS5kb2MubGluZShmaXJzdExpbmUgKyBsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgcGVyTGluZSAqIGxpbmUsIHBlckxpbmUsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KHZhbHVlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCB0byAtIGZyb20sIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICBsZXQgbGluZXNBYm92ZSA9IGxpbmUubnVtYmVyIC0gZmlyc3RMaW5lO1xuICAgICAgICBsZXQgbGluZVRvcCA9IHRvcCArIHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChsaW5lLmZyb20gLSBvZmZzZXQgLSBsaW5lc0Fib3ZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgTWF0aC5tYXgodG9wLCBNYXRoLm1pbihsaW5lVG9wLCB0b3AgKyB0aGlzLmhlaWdodCAtIGxpbmVIZWlnaHQpKSwgbGluZUhlaWdodCwgMCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGZyb20gPSBNYXRoLm1heChmcm9tLCBvZmZzZXQpO1xuICAgICAgICB0byA9IE1hdGgubWluKHRvLCBvZmZzZXQgKyB0aGlzLmxlbmd0aCk7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbSwgbGluZVRvcCA9IHRvcDsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzQWJvdmUgPSBsaW5lLm51bWJlciAtIGZpcnN0TGluZTtcbiAgICAgICAgICAgICAgICBsaW5lVG9wICs9IHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChmcm9tIC0gb2Zmc2V0IC0gbGluZXNBYm92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGluZUhlaWdodCA9IHBlckxpbmUgKyBwZXJDaGFyICogbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBmKG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgbGluZVRvcCwgbGluZUhlaWdodCwgMCkpO1xuICAgICAgICAgICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5sZW5ndGggLSB0bztcbiAgICAgICAgaWYgKGFmdGVyID4gMCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdID0gbmV3IEhlaWdodE1hcEdhcChsYXN0Lmxlbmd0aCArIGFmdGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoYWZ0ZXIgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1swXSA9IG5ldyBIZWlnaHRNYXBHYXAoZnJvbSArIGZpcnN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMudW5zaGlmdChuZXcgSGVpZ2h0TWFwR2FwKGZyb20gLSAxKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gMSksIG51bGwpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcCh0aGlzLmxlbmd0aCAtIGZyb20gLSAxKSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiBwYXJ0IG9mIHRoaXMgZ2FwIHdpdGggbWVhc3VyZWQgbGluZXMuIFdlIGtub3cgdGhlcmVcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHdpZGdldHMgb3IgY29sbGFwc2VkIHJhbmdlcyBpbiB0aG9zZSBsaW5lcywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhleSB3b3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaGVpZ2h0bWFwIChnYXBzXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gcGxhaW4gdGV4dCkuXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXSwgcG9zID0gTWF0aC5tYXgob2Zmc2V0LCBtZWFzdXJlZC5mcm9tKSwgc2luZ2xlSGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICBpZiAobWVhc3VyZWQuZnJvbSA+IG9mZnNldClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8PSBlbmQgJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdLCBhYm92ZSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSAtaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlSGVpZ2h0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gc2luZ2xlSGVpZ2h0KSA+PSBFcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVIZWlnaHQgPSAtMjtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IG5ldyBIZWlnaHRNYXBUZXh0KGxlbiwgaGVpZ2h0LCBhYm92ZSk7XG4gICAgICAgICAgICAgICAgbGluZS5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbiArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDw9IGVuZClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoZW5kIC0gcG9zKS51cGRhdGVIZWlnaHQob3JhY2xlLCBwb3MpKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgICAgICAgICAgaWYgKHNpbmdsZUhlaWdodCA8IDAgfHwgTWF0aC5hYnMocmVzdWx0LmhlaWdodCAtIHRoaXMuaGVpZ2h0KSA+PSBFcHNpbG9uIHx8XG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoc2luZ2xlSGVpZ2h0IC0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KS5wZXJMaW5lKSA+PSBFcHNpbG9uKVxuICAgICAgICAgICAgICAgIGhlaWdodENoYW5nZUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2UodGhpcywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUuaGVpZ2h0Rm9yR2FwKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgZ2FwKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcEJyYW5jaCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVmdCwgYnJrLCByaWdodCkge1xuICAgICAgICBzdXBlcihsZWZ0Lmxlbmd0aCArIGJyayArIHJpZ2h0Lmxlbmd0aCwgbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQsIGJyayB8IChsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkpO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgfVxuICAgIGdldCBicmVhaygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxIC8qIEZsYWcuQnJlYWsgKi87IH1cbiAgICBibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgbWlkID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodDtcbiAgICAgICAgcmV0dXJuIGhlaWdodCA8IG1pZCA/IHRoaXMubGVmdC5ibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5ibG9ja0F0KGhlaWdodCwgb3JhY2xlLCBtaWQsIG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrKTtcbiAgICB9XG4gICAgbGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGxldCBsZWZ0ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQgPyB2YWx1ZSA8IHJpZ2h0VG9wIDogdmFsdWUgPCByaWdodE9mZnNldDtcbiAgICAgICAgbGV0IGJhc2UgPSBsZWZ0ID8gdGhpcy5sZWZ0LmxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5saW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgfHwgKGxlZnQgPyBiYXNlLnRvIDwgcmlnaHRPZmZzZXQgOiBiYXNlLmZyb20gPiByaWdodE9mZnNldCkpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IHN1YlF1ZXJ5ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA/IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0IDogUXVlcnlUeXBlLkJ5UG9zO1xuICAgICAgICBpZiAobGVmdClcbiAgICAgICAgICAgIHJldHVybiBiYXNlLmpvaW4odGhpcy5yaWdodC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmxpbmVBdChyaWdodE9mZnNldCwgc3ViUXVlcnksIG9yYWNsZSwgdG9wLCBvZmZzZXQpLmpvaW4oYmFzZSk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5mb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAodG8gPj0gcmlnaHRPZmZzZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1pZCA9IHRoaXMubGluZUF0KHJpZ2h0T2Zmc2V0LCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgdG9wLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBtaWQuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgbWlkLmZyb20gLSAxLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKTtcbiAgICAgICAgICAgIGlmIChtaWQudG8gPj0gZnJvbSAmJiBtaWQuZnJvbSA8PSB0bylcbiAgICAgICAgICAgICAgICBmKG1pZCk7XG4gICAgICAgICAgICBpZiAodG8gPiBtaWQudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShtaWQudG8gKyAxLCB0bywgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCByaWdodFN0YXJ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0byA8IHJpZ2h0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQucmVwbGFjZShmcm9tLCB0bywgbm9kZXMpLCB0aGlzLnJpZ2h0KTtcbiAgICAgICAgaWYgKGZyb20gPiB0aGlzLmxlZnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LCB0aGlzLnJpZ2h0LnJlcGxhY2UoZnJvbSAtIHJpZ2h0U3RhcnQsIHRvIC0gcmlnaHRTdGFydCwgbm9kZXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZUxlZnQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgbGV0IGxlZnQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIGxlZnQgLSAxKTtcbiAgICAgICAgaWYgKHRvIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZVJpZ2h0KHRvLCByZXN1bHQpO1xuICAgICAgICAgICAgbWVyZ2VHYXBzKHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YocmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRvIDw9IGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubGVmdCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBsZWZ0Kys7XG4gICAgICAgICAgICBpZiAodG8gPj0gbGVmdClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG8gPiBsZWZ0KVxuICAgICAgICAgICAgdGhpcy5yaWdodC5kZWNvbXBvc2VMZWZ0KHRvIC0gbGVmdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCwgcmlnaHQgPSBsZWZ0ICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKGZyb20gPj0gcmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5kZWNvbXBvc2VSaWdodChmcm9tIC0gcmlnaHQsIHJlc3VsdCk7XG4gICAgICAgIGlmIChmcm9tIDwgbGVmdClcbiAgICAgICAgICAgIHRoaXMubGVmdC5kZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpO1xuICAgICAgICBpZiAodGhpcy5icmVhayAmJiBmcm9tIDwgcmlnaHQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5yaWdodCk7XG4gICAgfVxuICAgIGJhbGFuY2VkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnNpemUgPiAyICogcmlnaHQuc2l6ZSB8fCByaWdodC5zaXplID4gMiAqIGxlZnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YodGhpcy5icmVhayA/IFtsZWZ0LCBudWxsLCByaWdodF0gOiBbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gcmVwbGFjZSh0aGlzLmxlZnQsIGxlZnQpO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmVwbGFjZSh0aGlzLnJpZ2h0LCByaWdodCk7XG4gICAgICAgIHRoaXMuc2V0SGVpZ2h0KGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrICsgcmlnaHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMsIHJpZ2h0U3RhcnQgPSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWssIHJlYmFsYW5jZSA9IG51bGw7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIGxlZnQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSBsZWZ0ID0gbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSk7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IHJpZ2h0U3RhcnQgKyByaWdodC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IHJpZ2h0ID0gcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UsIG1lYXN1cmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UpO1xuICAgICAgICBpZiAocmViYWxhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubGVmdC5oZWlnaHQgKyB0aGlzLnJpZ2h0LmhlaWdodDtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmxlZnQgKyAodGhpcy5icmVhayA/IFwiIFwiIDogXCItXCIpICsgdGhpcy5yaWdodDsgfVxufVxuZnVuY3Rpb24gbWVyZ2VHYXBzKG5vZGVzLCBhcm91bmQpIHtcbiAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICBpZiAobm9kZXNbYXJvdW5kXSA9PSBudWxsICYmXG4gICAgICAgIChiZWZvcmUgPSBub2Rlc1thcm91bmQgLSAxXSkgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiZcbiAgICAgICAgKGFmdGVyID0gbm9kZXNbYXJvdW5kICsgMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICBub2Rlcy5zcGxpY2UoYXJvdW5kIC0gMSwgMywgbmV3IEhlaWdodE1hcEdhcChiZWZvcmUubGVuZ3RoICsgMSArIGFmdGVyLmxlbmd0aCkpO1xufVxuY29uc3QgcmVsZXZhbnRXaWRnZXRIZWlnaHQgPSA1O1xuY2xhc3MgTm9kZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcywgb3JhY2xlKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm9yYWNsZSA9IG9yYWNsZTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSAtMTtcbiAgICAgICAgdGhpcy5jb3ZlcmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gcG9zO1xuICAgIH1cbiAgICBnZXQgaXNDb3ZlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3ZlcmluZyAmJiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gdGhpcy5jb3ZlcmluZztcbiAgICB9XG4gICAgc3BhbihfZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbih0bywgdGhpcy5saW5lRW5kKSwgbGFzdCA9IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBsYXN0Lmxlbmd0aCArPSBlbmQgLSB0aGlzLnBvcztcbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA+IHRoaXMucG9zIHx8ICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoZW5kIC0gdGhpcy5wb3MsIC0xLCAwKSk7XG4gICAgICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IGVuZDtcbiAgICAgICAgICAgIGlmICh0byA+IGVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXR0ZW5UbysrO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28pIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBkZWNvLmhlaWdodFJlbGV2YW50KSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gZGVjby53aWRnZXQgPyBkZWNvLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgOiAwO1xuICAgICAgICAgICAgbGV0IGJyZWFrcyA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQubGluZUJyZWFrcyA6IDA7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMClcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9jayhuZXcgSGVpZ2h0TWFwQmxvY2sobGVuLCBoZWlnaHQsIGRlY28pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiB8fCBicmVha3MgfHwgaGVpZ2h0ID49IHJlbGV2YW50V2lkZ2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaW5lRGVjbyhoZWlnaHQsIGJyZWFrcywgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgIHRoaXMuc3Bhbihmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGluZUVuZCA+IC0xICYmIHRoaXMubGluZUVuZCA8IHRoaXMucG9zKVxuICAgICAgICAgICAgdGhpcy5saW5lRW5kID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcykudG87XG4gICAgfVxuICAgIGVudGVyTGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSB0bztcbiAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSAtIDEgfHwgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCBmcm9tIC0gMSkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQodGhpcy5wb3MgLSBmcm9tLCAtMSwgMCkpO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zO1xuICAgIH1cbiAgICBibGFua0NvbnRlbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGdhcCA9IG5ldyBIZWlnaHRNYXBHYXAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMub3JhY2xlLmRvYy5saW5lQXQoZnJvbSkudG8gPT0gdG8pXG4gICAgICAgICAgICBnYXAuZmxhZ3MgfD0gNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi87XG4gICAgICAgIHJldHVybiBnYXA7XG4gICAgfVxuICAgIGVuc3VyZUxpbmUoKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggPyB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAtMSwgMCk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIGFkZEJsb2NrKGJsb2NrKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGxldCBkZWNvID0gYmxvY2suZGVjbztcbiAgICAgICAgaWYgKGRlY28gJiYgZGVjby5zdGFydFNpZGUgPiAwICYmICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTGluZSgpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goYmxvY2spO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyBibG9jay5sZW5ndGg7XG4gICAgICAgIGlmIChkZWNvICYmIGRlY28uZW5kU2lkZSA+IDApXG4gICAgICAgICAgICB0aGlzLmNvdmVyaW5nID0gYmxvY2s7XG4gICAgfVxuICAgIGFkZExpbmVEZWNvKGhlaWdodCwgYnJlYWtzLCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgbGluZS5sZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLmNvbGxhcHNlZCArPSBsZW5ndGg7XG4gICAgICAgIGxpbmUud2lkZ2V0SGVpZ2h0ID0gTWF0aC5tYXgobGluZS53aWRnZXRIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIGxpbmUuYnJlYWtzICs9IGJyZWFrcztcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgbGVuZ3RoO1xuICAgIH1cbiAgICBmaW5pc2goZnJvbSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID09IDAgPyBudWxsIDogdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSAmJiAhKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KSAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoMCwgLTEsIDApKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy53cml0dGVuVG8gPCB0aGlzLnBvcyB8fCBsYXN0ID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2godGhpcy5ibGFua0NvbnRlbnQodGhpcy53cml0dGVuVG8sIHRoaXMucG9zKSk7XG4gICAgICAgIGxldCBwb3MgPSBmcm9tO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZUhlaWdodCh0aGlzLm9yYWNsZSwgcG9zKTtcbiAgICAgICAgICAgIHBvcyArPSBub2RlID8gbm9kZS5sZW5ndGggOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH1cbiAgICAvLyBBbHdheXMgY2FsbGVkIHdpdGggYSByZWdpb24gdGhhdCBvbiBib3RoIHNpZGVzIGVpdGhlciBzdHJldGNoZXNcbiAgICAvLyB0byBhIGxpbmUgYnJlYWsgb3IgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgLy8gVGhlIHJldHVybmVkIGFycmF5IHVzZXMgbnVsbCB0byBpbmRpY2F0ZSBsaW5lIGJyZWFrcywgYnV0IG5ldmVyXG4gICAgLy8gc3RhcnRzIG9yIGVuZHMgaW4gYSBsaW5lIGJyZWFrLCBvciBoYXMgbXVsdGlwbGUgbGluZSBicmVha3MgbmV4dFxuICAgIC8vIHRvIGVhY2ggb3RoZXIuXG4gICAgc3RhdGljIGJ1aWxkKG9yYWNsZSwgZGVjb3JhdGlvbnMsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IE5vZGVCdWlsZGVyKGZyb20sIG9yYWNsZSk7XG4gICAgICAgIFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlciwgMCk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaChmcm9tKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvcjtcbiAgICBSYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXAsIDApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5jbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoKSB7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8sIGEsIGIpIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBhICYmIGEuaGVpZ2h0UmVsZXZhbnQgfHwgYiAmJiBiLmhlaWdodFJlbGV2YW50KVxuICAgICAgICAgICAgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcywgNSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2aXNpYmxlUGl4ZWxSYW5nZShkb20sIHBhZGRpbmdUb3ApIHtcbiAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgbGV0IGxlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQpLCByaWdodCA9IE1hdGgubWluKHdpbi5pbm5lcldpZHRoLCByZWN0LnJpZ2h0KTtcbiAgICBsZXQgdG9wID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApLCBib3R0b20gPSBNYXRoLm1pbih3aW4uaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPSBkb2MuYm9keTspIHtcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gcGFyZW50O1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWx0KTtcbiAgICAgICAgICAgIGlmICgoZWx0LnNjcm9sbEhlaWdodCA+IGVsdC5jbGllbnRIZWlnaHQgfHwgZWx0LnNjcm9sbFdpZHRoID4gZWx0LmNsaWVudFdpZHRoKSAmJlxuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ICE9IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHBhcmVudFJlY3QubGVmdCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCwgcGFyZW50UmVjdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBwYXJlbnRSZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5taW4ocGFyZW50ID09IGRvbS5wYXJlbnROb2RlID8gd2luLmlubmVySGVpZ2h0IDogYm90dG9tLCBwYXJlbnRSZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBzdHlsZS5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIgfHwgc3R5bGUucG9zaXRpb24gPT0gXCJmaXhlZFwiID8gZWx0Lm9mZnNldFBhcmVudCA6IGVsdC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gcmVjdC5sZWZ0LCByaWdodDogTWF0aC5tYXgobGVmdCwgcmlnaHQpIC0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHRvcCAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApLCBib3R0b206IE1hdGgubWF4KHRvcCwgYm90dG9tKSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG5mdW5jdGlvbiBpbldpbmRvdyhlbHQpIHtcbiAgICBsZXQgcmVjdCA9IGVsdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2luID0gZWx0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIHJldHVybiByZWN0LmxlZnQgPCB3aW4uaW5uZXJXaWR0aCAmJiByZWN0LnJpZ2h0ID4gMCAmJlxuICAgICAgICByZWN0LnRvcCA8IHdpbi5pbm5lckhlaWdodCAmJiByZWN0LmJvdHRvbSA+IDA7XG59XG5mdW5jdGlvbiBmdWxsUGl4ZWxSYW5nZShkb20sIHBhZGRpbmdUb3ApIHtcbiAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBwYWRkaW5nVG9wLCBib3R0b206IHJlY3QuYm90dG9tIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCkgfTtcbn1cbi8vIExpbmUgZ2FwcyBhcmUgcGxhY2Vob2xkZXIgd2lkZ2V0cyB1c2VkIHRvIGhpZGUgcGllY2VzIG9mIG92ZXJsb25nXG4vLyBsaW5lcyB3aXRoaW4gdGhlIHZpZXdwb3J0LCBhcyBhIGtsdWRnZSB0byBrZWVwIHRoZSBlZGl0b3Jcbi8vIHJlc3BvbnNpdmUgd2hlbiBhIHJpZGljdWxvdXNseSBsb25nIGxpbmUgaXMgbG9hZGVkIGludG8gaXQuXG5jbGFzcyBMaW5lR2FwIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgc2l6ZSwgZGlzcGxheVNpemUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmRpc3BsYXlTaXplID0gZGlzcGxheVNpemU7XG4gICAgfVxuICAgIHN0YXRpYyBzYW1lKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBnQSA9IGFbaV0sIGdCID0gYltpXTtcbiAgICAgICAgICAgIGlmIChnQS5mcm9tICE9IGdCLmZyb20gfHwgZ0EudG8gIT0gZ0IudG8gfHwgZ0Euc2l6ZSAhPSBnQi5zaXplKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJhdyh2aWV3U3RhdGUsIHdyYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgd2lkZ2V0OiBuZXcgTGluZUdhcFdpZGdldCh0aGlzLmRpc3BsYXlTaXplICogKHdyYXBwaW5nID8gdmlld1N0YXRlLnNjYWxlWSA6IHZpZXdTdGF0ZS5zY2FsZVgpLCB3cmFwcGluZylcbiAgICAgICAgfSkucmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBMaW5lR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgdmVydGljYWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCA9IHZlcnRpY2FsO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuc2l6ZSA9PSB0aGlzLnNpemUgJiYgb3RoZXIudmVydGljYWwgPT0gdGhpcy52ZXJ0aWNhbDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWwpIHtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gXCIycHhcIjtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/IHRoaXMuc2l6ZSA6IC0xOyB9XG59XG5jbGFzcyBWaWV3U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIGNvbnRlbnRET00tbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0geyBsZWZ0OiAwLCByaWdodDogd2luZG93LmlubmVyV2lkdGgsIHRvcDogMCwgYm90dG9tOiAwIH07XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gMDsgLy8gUGFkZGluZyBhYm92ZSB0aGUgZG9jdW1lbnQsIHNjYWxlZFxuICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwOyAvLyBQYWRkaW5nIGJlbG93IHRoZSBkb2N1bWVudCwgc2NhbGVkXG4gICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gMDsgLy8gY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICAgICAgICB0aGlzLmNvbnRlbnRET01IZWlnaHQgPSAwOyAvLyBjb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgICB0aGlzLmVkaXRvckhlaWdodCA9IDA7IC8vIHNjcm9sbERPTS5jbGllbnRIZWlnaHQsIHVuc2NhbGVkXG4gICAgICAgIHRoaXMuZWRpdG9yV2lkdGggPSAwOyAvLyBzY3JvbGxET00uY2xpZW50V2lkdGgsIHVuc2NhbGVkXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gMDsgLy8gTGFzdCBzZWVuIHNjcm9sbERPTS5zY3JvbGxUb3AsIHNjYWxlZFxuICAgICAgICB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPSBmYWxzZTtcbiAgICAgICAgLy8gVGhlIENTUy10cmFuc2Zvcm1hdGlvbiBzY2FsZSBvZiB0aGUgZWRpdG9yICh0cmFuc2Zvcm1lZCBzaXplIC9cbiAgICAgICAgLy8gY29uY3JldGUgc2l6ZSlcbiAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgICAgIC8vIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiAoZG9jdW1lbnQtcmVsYXRpdmUpIHRvIHdoaWNoIHRvIGFuY2hvciB0aGVcbiAgICAgICAgLy8gc2Nyb2xsIHBvc2l0aW9uLiAtMSBtZWFucyBhbmNob3IgdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gMDtcbiAgICAgICAgLy8gVGhlIGhlaWdodCBhdCB0aGUgYW5jaG9yIHBvc2l0aW9uLiBTZXQgYnkgdGhlIERPTSB1cGRhdGUgcGhhc2UuXG4gICAgICAgIC8vIC0xIG1lYW5zIG5vIGhlaWdodCBhdmFpbGFibGUuXG4gICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgIC8vIFNlZSBWUC5NYXhET01IZWlnaHRcbiAgICAgICAgdGhpcy5zY2FsZXIgPSBJZFNjYWxlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyBCcmllZmx5IHNldCB0byB0cnVlIHdoZW4gcHJpbnRpbmcsIHRvIGRpc2FibGUgdmlld3BvcnQgbGltaXRpbmdcbiAgICAgICAgdGhpcy5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBGbGFnIHNldCB3aGVuIGVkaXRvciBjb250ZW50IHdhcyByZWRyYXduLCBzbyB0aGF0IHRoZSBuZXh0XG4gICAgICAgIC8vIG1lYXN1cmUgc3RhZ2Uga25vd3MgaXQgbXVzdCByZWFkIERPTSBsYXlvdXRcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gW107XG4gICAgICAgIC8vIEN1cnNvciAnYXNzb2MnIGlzIG9ubHkgc2lnbmlmaWNhbnQgd2hlbiB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZVxuICAgICAgICAvLyB3cmFwIHBvaW50LCB3aGVyZSBpdCBtdXN0IHN0aWNrIHRvIHRoZSBjaGFyYWN0ZXIgdGhhdCBpdCBpc1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGguIFNpbmNlIGJyb3dzZXJzIGRvbid0IHByb3ZpZGUgYSByZWFzb25hYmxlXG4gICAgICAgIC8vIGludGVyZmFjZSB0byBzZXQgb3IgcXVlcnkgdGhpcywgd2hlbiBhIHNlbGVjdGlvbiBpcyBzZXQgdGhhdFxuICAgICAgICAvLyBtaWdodCBjYXVzZSB0aGlzIHRvIGJlIHNpZ25pZmljYW50LCB0aGlzIGZsYWcgaXMgc2V0LiBUaGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHBoYXNlIHdpbGwgY2hlY2sgd2hldGhlciB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZS13cmFwcGluZ1xuICAgICAgICAvLyBib3VuZGFyeSBhbmQsIGlmIHNvLCByZXNldCBpdCB0byBtYWtlIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBpblxuICAgICAgICAvLyB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICBsZXQgZ3Vlc3NXcmFwcGluZyA9IHN0YXRlLmZhY2V0KGNvbnRlbnRBdHRyaWJ1dGVzKS5zb21lKHYgPT4gdHlwZW9mIHYgIT0gXCJmdW5jdGlvblwiICYmIHYuY2xhc3MgPT0gXCJjbS1saW5lV3JhcHBpbmdcIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0T3JhY2xlID0gbmV3IEhlaWdodE9yYWNsZShndWVzc1dyYXBwaW5nKTtcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSBzdGF0aWNEZWNvKHN0YXRlKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyhzdGF0ZS5kb2MpLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKV0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXBkYXRlRm9yVmlld3BvcnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgdGhpcy5saW5lR2FwcyA9IHRoaXMuZW5zdXJlTGluZUdhcHMoW10pO1xuICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQodGhpcy5saW5lR2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KHRoaXMsIGZhbHNlKSkpO1xuICAgICAgICB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgfVxuICAgIHVwZGF0ZUZvclZpZXdwb3J0KCkge1xuICAgICAgICBsZXQgdmlld3BvcnRzID0gW3RoaXMudmlld3BvcnRdLCB7IG1haW4gfSA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBpID8gbWFpbi5oZWFkIDogbWFpbi5hbmNob3I7XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0cy5zb21lKCh7IGZyb20sIHRvIH0pID0+IHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5saW5lQmxvY2tBdChwb3MpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0cy5wdXNoKG5ldyBWaWV3cG9ydChmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVNjYWxlcigpO1xuICAgIH1cbiAgICB1cGRhdGVTY2FsZXIoKSB7XG4gICAgICAgIGxldCBzY2FsZXIgPSB0aGlzLnNjYWxlcjtcbiAgICAgICAgdGhpcy5zY2FsZXIgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQgPD0gNzAwMDAwMCAvKiBWUC5NYXhET01IZWlnaHQgKi8gPyBJZFNjYWxlciA6XG4gICAgICAgICAgICBuZXcgQmlnU2NhbGVyKHRoaXMuaGVpZ2h0T3JhY2xlLCB0aGlzLmhlaWdodE1hcCwgdGhpcy52aWV3cG9ydHMpO1xuICAgICAgICByZXR1cm4gc2NhbGVyLmVxKHRoaXMuc2NhbGVyKSA/IDAgOiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgIH1cbiAgICB1cGRhdGVWaWV3cG9ydExpbmVzKCkge1xuICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAuZm9yRWFjaExpbmUodGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCAwLCAwLCBibG9jayA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMucHVzaChzY2FsZUJsb2NrKGJsb2NrLCB0aGlzLnNjYWxlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdXBkYXRlLnN0YXRlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLnN0YXRlRGVjbztcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSBzdGF0aWNEZWNvKHRoaXMuc3RhdGUpO1xuICAgICAgICBsZXQgY29udGVudENoYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgbGV0IGhlaWdodENoYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjb250ZW50Q2hhbmdlcywgaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhwcmV2RGVjbywgdGhpcy5zdGF0ZURlY28sIHVwZGF0ZSA/IHVwZGF0ZS5jaGFuZ2VzIDogQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICAgICAgbGV0IHByZXZIZWlnaHQgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgIGxldCBzY3JvbGxBbmNob3IgPSB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPyBudWxsIDogdGhpcy5zY3JvbGxBbmNob3JBdCh0aGlzLnNjcm9sbFRvcCk7XG4gICAgICAgIGNsZWFySGVpZ2h0Q2hhbmdlRmxhZygpO1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IHRoaXMuaGVpZ2h0TWFwLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCBoZWlnaHRDaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCAhPSBwcmV2SGVpZ2h0IHx8IGhlaWdodENoYW5nZUZsYWcpXG4gICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgaWYgKHNjcm9sbEFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JQb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc2Nyb2xsQW5jaG9yLmZyb20sIC0xKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gc2Nyb2xsQW5jaG9yLnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gLTE7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IHByZXZIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gaGVpZ2h0Q2hhbmdlcy5sZW5ndGggPyB0aGlzLm1hcFZpZXdwb3J0KHRoaXMudmlld3BvcnQsIHVwZGF0ZS5jaGFuZ2VzKSA6IHRoaXMudmlld3BvcnQ7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQgJiYgKHNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHZpZXdwb3J0LnRvKSB8fFxuICAgICAgICAgICAgIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHZpZXdwb3J0KSlcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICBsZXQgdmlld3BvcnRDaGFuZ2UgPSB2aWV3cG9ydC5mcm9tICE9IHRoaXMudmlld3BvcnQuZnJvbSB8fCB2aWV3cG9ydC50byAhPSB0aGlzLnZpZXdwb3J0LnRvO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIGlmICh2aWV3cG9ydENoYW5nZSB8fCAhdXBkYXRlLmNoYW5nZXMuZW1wdHkgfHwgKHVwZGF0ZS5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHRoaXMubWFwTGluZUdhcHModGhpcy5saW5lR2FwcywgdXBkYXRlLmNoYW5nZXMpKSk7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldClcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0O1xuICAgICAgICBpZiAoIXRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyAmJiAodXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZm9jdXNDaGFuZ2VkKSAmJiB1cGRhdGUudmlldy5saW5lV3JhcHBpbmcgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uYXNzb2MgJiZcbiAgICAgICAgICAgICF1cGRhdGUuc3RhdGUuZmFjZXQobmF0aXZlU2VsZWN0aW9uSGlkZGVuKSlcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IHRydWU7XG4gICAgfVxuICAgIG1lYXN1cmUodmlldykge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5jb250ZW50RE9NLCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSk7XG4gICAgICAgIGxldCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHdoaXRlU3BhY2UgPSBzdHlsZS53aGl0ZVNwYWNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gc3R5bGUuZGlyZWN0aW9uID09IFwicnRsXCIgPyBEaXJlY3Rpb24uUlRMIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgbGV0IHJlZnJlc2ggPSB0aGlzLmhlaWdodE9yYWNsZS5tdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpIHx8IHRoaXMubXVzdE1lYXN1cmVDb250ZW50O1xuICAgICAgICBsZXQgZG9tUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IG1lYXN1cmVDb250ZW50ID0gcmVmcmVzaCB8fCB0aGlzLm11c3RNZWFzdXJlQ29udGVudCB8fCB0aGlzLmNvbnRlbnRET01IZWlnaHQgIT0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgICB0aGlzLm11c3RNZWFzdXJlQ29udGVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gMCwgYmlhcyA9IDA7XG4gICAgICAgIGlmIChkb21SZWN0LndpZHRoICYmIGRvbVJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgeyBzY2FsZVgsIHNjYWxlWSB9ID0gZ2V0U2NhbGUoZG9tLCBkb21SZWN0KTtcbiAgICAgICAgICAgIGlmIChzY2FsZVggPiAuMDA1ICYmIE1hdGguYWJzKHRoaXMuc2NhbGVYIC0gc2NhbGVYKSA+IC4wMDUgfHxcbiAgICAgICAgICAgICAgICBzY2FsZVkgPiAuMDA1ICYmIE1hdGguYWJzKHRoaXMuc2NhbGVZIC0gc2NhbGVZKSA+IC4wMDUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gMTYgLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFZlcnRpY2FsIHBhZGRpbmdcbiAgICAgICAgbGV0IHBhZGRpbmdUb3AgPSAocGFyc2VJbnQoc3R5bGUucGFkZGluZ1RvcCkgfHwgMCkgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSAocGFyc2VJbnQoc3R5bGUucGFkZGluZ0JvdHRvbSkgfHwgMCkgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgaWYgKHRoaXMucGFkZGluZ1RvcCAhPSBwYWRkaW5nVG9wIHx8IHRoaXMucGFkZGluZ0JvdHRvbSAhPSBwYWRkaW5nQm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wO1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbTtcbiAgICAgICAgICAgIHJlc3VsdCB8PSAxNiAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3JXaWR0aCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDE2IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3AgIT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gaXNTY3JvbGxlZFRvQm90dG9tKHZpZXcuc2Nyb2xsRE9NKTtcbiAgICAgICAgLy8gUGl4ZWwgdmlld3BvcnRcbiAgICAgICAgbGV0IHBpeGVsVmlld3BvcnQgPSAodGhpcy5wcmludGluZyA/IGZ1bGxQaXhlbFJhbmdlIDogdmlzaWJsZVBpeGVsUmFuZ2UpKGRvbSwgdGhpcy5wYWRkaW5nVG9wKTtcbiAgICAgICAgbGV0IGRUb3AgPSBwaXhlbFZpZXdwb3J0LnRvcCAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3AsIGRCb3R0b20gPSBwaXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b207XG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHBpeGVsVmlld3BvcnQ7XG4gICAgICAgIGxldCBpblZpZXcgPSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tID4gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCAmJiB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgPiB0aGlzLnBpeGVsVmlld3BvcnQubGVmdDtcbiAgICAgICAgaWYgKGluVmlldyAhPSB0aGlzLmluVmlldykge1xuICAgICAgICAgICAgdGhpcy5pblZpZXcgPSBpblZpZXc7XG4gICAgICAgICAgICBpZiAoaW5WaWV3KVxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3ICYmICF0aGlzLnNjcm9sbFRhcmdldCAmJiAhaW5XaW5kb3codmlldy5kb20pKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NV2lkdGggIT0gY29udGVudFdpZHRoIHx8IHRoaXMuZWRpdG9ySGVpZ2h0ICE9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICByZXN1bHQgfD0gMTYgLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVhc3VyZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lSGVpZ2h0cyA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHRoaXMudmlld3BvcnQpO1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5tdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpKVxuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHJlZnJlc2ggfHwgb3JhY2xlLmxpbmVXcmFwcGluZyAmJiBNYXRoLmFicyhjb250ZW50V2lkdGggLSB0aGlzLmNvbnRlbnRET01XaWR0aCkgPiBvcmFjbGUuY2hhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0IH0gPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IGxpbmVIZWlnaHQgPiAwICYmIG9yYWNsZS5yZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCwgTWF0aC5tYXgoNSwgY29udGVudFdpZHRoIC8gY2hhcldpZHRoKSwgbGluZUhlaWdodHMpO1xuICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9jVmlldy5taW5XaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAxNiAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkVG9wID4gMCAmJiBkQm90dG9tID4gMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5tYXgoZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChkVG9wIDwgMCAmJiBkQm90dG9tIDwgMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5taW4oZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBjbGVhckhlaWdodENoYW5nZUZsYWcoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHZwIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodHMgPSB2cC5mcm9tID09IHRoaXMudmlld3BvcnQuZnJvbSA/IGxpbmVIZWlnaHRzIDogdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModnApO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gKHJlZnJlc2ggPyBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSkgOiB0aGlzLmhlaWdodE1hcCkudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCwgcmVmcmVzaCwgbmV3IE1lYXN1cmVkSGVpZ2h0cyh2cC5mcm9tLCBoZWlnaHRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0Q2hhbmdlRmxhZylcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld3BvcnRDaGFuZ2UgPSAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUodGhpcy52aWV3cG9ydCwgYmlhcykgfHxcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ICYmICh0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHRoaXMudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAodmlld3BvcnRDaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKVxuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSB0aGlzLnVwZGF0ZVNjYWxlcigpO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoYmlhcywgdGhpcy5zY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgcmVzdWx0IHw9IHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHJlc3VsdCAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8IHZpZXdwb3J0Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHJlZnJlc2ggPyBbXSA6IHRoaXMubGluZUdhcHMsIHZpZXcpKTtcbiAgICAgICAgcmVzdWx0IHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYykge1xuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gdGhlIHJlYWQgc3RhZ2UsIGJlY2F1c2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIHRvIGEgbGluZSBlbmQgaXMgZ29pbmcgdG8gdHJpZ2dlciBhIGxheW91dCBhbnl3YXksIHNvIGl0XG4gICAgICAgICAgICAvLyBjYW4ndCBiZSBhIHB1cmUgd3JpdGUuIEl0IHNob3VsZCBiZSByYXJlIHRoYXQgaXQgZG9lcyBhbnlcbiAgICAgICAgICAgIC8vIHdyaXRpbmcuXG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcuZW5mb3JjZUN1cnNvckFzc29jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IHZpc2libGVUb3AoKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApOyB9XG4gICAgZ2V0IHZpc2libGVCb3R0b20oKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20pOyB9XG4gICAgZ2V0Vmlld3BvcnQoYmlhcywgc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBkaXZpZGUgVlAuTWFyZ2luIGJldHdlZW4gdGhlIHRvcCBhbmQgdGhlXG4gICAgICAgIC8vIGJvdHRvbSwgZGVwZW5kaW5nIG9uIHRoZSBiaWFzICh0aGUgY2hhbmdlIGluIHZpZXdwb3J0IHBvc2l0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSkuIEl0J2xsIGhvbGQgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgIGxldCBtYXJnaW5Ub3AgPSAwLjUgLSBNYXRoLm1heCgtMC41LCBNYXRoLm1pbigwLjUsIGJpYXMgLyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIpKTtcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuaGVpZ2h0TWFwLCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodmlzaWJsZVRvcCAtIG1hcmdpblRvcCAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh2aXNpYmxlQm90dG9tICsgKDEgLSBtYXJnaW5Ub3ApICogMTAwMCAvKiBWUC5NYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS50byk7XG4gICAgICAgIC8vIElmIHNjcm9sbFRhcmdldCBpcyBnaXZlbiwgbWFrZSBzdXJlIHRoZSB2aWV3cG9ydCBpbmNsdWRlcyB0aGF0IHBvc2l0aW9uXG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIGxldCB7IGhlYWQgfSA9IHNjcm9sbFRhcmdldC5yYW5nZTtcbiAgICAgICAgICAgIGlmIChoZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBoZWFkID4gdmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgdmlld0hlaWdodCA9IE1hdGgubWluKHRoaXMuZWRpdG9ySGVpZ2h0LCB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gbWFwLmxpbmVBdChoZWFkLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCksIHRvcFBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJjZW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gKGJsb2NrLnRvcCArIGJsb2NrLmJvdHRvbSkgLyAyIC0gdmlld0hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJzdGFydFwiIHx8IHNjcm9sbFRhcmdldC55ID09IFwibmVhcmVzdFwiICYmIGhlYWQgPCB2aWV3cG9ydC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay50b3A7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay5ib3R0b20gLSB2aWV3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodG9wUG9zIC0gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh0b3BQb3MgKyB2aWV3SGVpZ2h0ICsgMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG4gICAgbWFwVmlld3BvcnQodmlld3BvcnQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQudG8sIDEpO1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdwb3J0KHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS5mcm9tLCB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLnRvKTtcbiAgICB9XG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gdmlld3BvcnQgY292ZXJzIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlXG4gICAgLy8gZG9jdW1lbnQgYW5kIG5vdCB0b28gbXVjaCBiZXlvbmQgdGhhdC5cbiAgICB2aWV3cG9ydElzQXBwcm9wcmlhdGUoeyBmcm9tLCB0byB9LCBiaWFzID0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCB7IHRvcCB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApO1xuICAgICAgICBsZXQgeyBib3R0b20gfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCk7XG4gICAgICAgIGxldCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IHRvcCA8PSB2aXNpYmxlVG9wIC0gTWF0aC5tYXgoMTAgLyogVlAuTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKC1iaWFzLCAyNTAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi8pKSkgJiZcbiAgICAgICAgICAgICh0byA9PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICBib3R0b20gPj0gdmlzaWJsZUJvdHRvbSArIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbihiaWFzLCAyNTAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi8pKSkgJiZcbiAgICAgICAgICAgICh0b3AgPiB2aXNpYmxlVG9wIC0gMiAqIDEwMDAgLyogVlAuTWFyZ2luICovICYmIGJvdHRvbSA8IHZpc2libGVCb3R0b20gKyAyICogMTAwMCAvKiBWUC5NYXJnaW4gKi8pO1xuICAgIH1cbiAgICBtYXBMaW5lR2FwcyhnYXBzLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghZ2Fwcy5sZW5ndGggfHwgY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBnYXBzO1xuICAgICAgICBsZXQgbWFwcGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgaWYgKCFjaGFuZ2VzLnRvdWNoZXNSYW5nZShnYXAuZnJvbSwgZ2FwLnRvKSlcbiAgICAgICAgICAgICAgICBtYXBwZWQucHVzaChuZXcgTGluZUdhcChjaGFuZ2VzLm1hcFBvcyhnYXAuZnJvbSksIGNoYW5nZXMubWFwUG9zKGdhcC50byksIGdhcC5zaXplLCBnYXAuZGlzcGxheVNpemUpKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcG9zaXRpb25zIGluIHRoZSB2aWV3cG9ydCB3aGVyZSB0aGUgc3RhcnQgb3IgZW5kIG9mIGFcbiAgICAvLyBsaW5lIHNob3VsZCBiZSBoaWRkZW4sIHRyeWluZyB0byByZXVzZSBleGlzdGluZyBsaW5lIGdhcHMgd2hlblxuICAgIC8vIGFwcHJvcHJpYXRlIHRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlZHJhd3MuXG4gICAgLy8gVXNlcyBjcnVkZSBjaGFyYWN0ZXItY291bnRpbmcgZm9yIHRoZSBwb3NpdGlvbmluZyBhbmQgc2l6aW5nLFxuICAgIC8vIHNpbmNlIGFjdHVhbCBET00gY29vcmRpbmF0ZXMgYXJlbid0IGFsd2F5cyBhdmFpbGFibGUgYW5kXG4gICAgLy8gcHJlZGljdGFibGUuIFJlbGllcyBvbiBnZW5lcm91cyBtYXJnaW5zIChzZWUgTEcuTWFyZ2luKSB0byBoaWRlXG4gICAgLy8gdGhlIGFydGlmYWN0cyB0aGlzIG1pZ2h0IHByb2R1Y2UgZnJvbSB0aGUgdXNlci5cbiAgICBlbnN1cmVMaW5lR2FwcyhjdXJyZW50LCBtYXlNZWFzdXJlKSB7XG4gICAgICAgIGxldCB3cmFwcGluZyA9IHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZztcbiAgICAgICAgbGV0IG1hcmdpbiA9IHdyYXBwaW5nID8gMTAwMDAgLyogTEcuTWFyZ2luV3JhcCAqLyA6IDIwMDAgLyogTEcuTWFyZ2luICovLCBoYWxmTWFyZ2luID0gbWFyZ2luID4+IDEsIGRvdWJsZU1hcmdpbiA9IG1hcmdpbiA8PCAxO1xuICAgICAgICAvLyBUaGUgbm9uLXdyYXBwaW5nIGxvZ2ljIHdvbid0IHdvcmsgYXQgYWxsIGluIHByZWRvbWluYW50bHkgcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSICYmICF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgbGV0IGFkZEdhcCA9IChmcm9tLCB0bywgbGluZSwgc3RydWN0dXJlKSA9PiB7XG4gICAgICAgICAgICBpZiAodG8gLSBmcm9tIDwgaGFsZk1hcmdpbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgYXZvaWQgPSBbc2VsLmZyb21dO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkpXG4gICAgICAgICAgICAgICAgYXZvaWQucHVzaChzZWwudG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIGF2b2lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKGZyb20sIHBvcyAtIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKHBvcyArIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgdG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2FwID0gZmluZChjdXJyZW50LCBnYXAgPT4gZ2FwLmZyb20gPj0gbGluZS5mcm9tICYmIGdhcC50byA8PSBsaW5lLnRvICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FwLmZyb20gLSBmcm9tKSA8IGhhbGZNYXJnaW4gJiYgTWF0aC5hYnMoZ2FwLnRvIC0gdG8pIDwgaGFsZk1hcmdpbiAmJlxuICAgICAgICAgICAgICAgICFhdm9pZC5zb21lKHBvcyA9PiBnYXAuZnJvbSA8IHBvcyAmJiBnYXAudG8gPiBwb3MpKTtcbiAgICAgICAgICAgIGlmICghZ2FwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgZG93biwgc25hcCBnYXAgZW5kcyB0byBsaW5lIHN0YXJ0cyB0byBhdm9pZCBzaGlmdHMgaW4gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICBpZiAodG8gPCBsaW5lLnRvICYmIG1heU1lYXN1cmUgJiYgd3JhcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5TWVhc3VyZS52aXNpYmxlUmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gdG8gJiYgci50byA+PSB0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVTdGFydCA9IG1heU1lYXN1cmUubW92ZVRvTGluZUJvdW5kYXJ5KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pLCBmYWxzZSwgdHJ1ZSkuaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTdGFydCA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGxpbmVTdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLmdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3BsYXlTaXplID0gd3JhcHBpbmcgfHwgc2l6ZSA8IDIwMDAwMDAgLyogVlAuTWF4SG9yaXpHYXAgKi8gPyBzaXplIDogMjAwMDAwMCAvKiBWUC5NYXhIb3JpekdhcCAqLztcbiAgICAgICAgICAgICAgICBnYXAgPSBuZXcgTGluZUdhcChmcm9tLCB0bywgc2l6ZSwgZGlzcGxheVNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2Fwcy5wdXNoKGdhcCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjaGVja0xpbmUgPSAobGluZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgZG91YmxlTWFyZ2luIHx8IGxpbmUudHlwZSAhPSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc3RydWN0dXJlID0gbGluZVN0cnVjdHVyZShsaW5lLmZyb20sIGxpbmUudG8sIHRoaXMuc3RhdGVEZWNvKTtcbiAgICAgICAgICAgIGlmIChzdHJ1Y3R1cmUudG90YWwgPCBkb3VibGVNYXJnaW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc2Nyb2xsVGFyZ2V0ID8gdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA6IG51bGw7XG4gICAgICAgICAgICBsZXQgdmlld0Zyb20sIHZpZXdUbztcbiAgICAgICAgICAgIGlmICh3cmFwcGluZykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5IZWlnaHQgPSAobWFyZ2luIC8gdGhpcy5oZWlnaHRPcmFjbGUubGluZUxlbmd0aCkgKiB0aGlzLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCB0b3AsIGJvdDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldEZyYWMgPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VGcmFjID0gKCh0aGlzLnZpc2libGVCb3R0b20gLSB0aGlzLnZpc2libGVUb3ApIC8gMiArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9ICh0aGlzLnZpc2libGVUb3AgLSBsaW5lLnRvcCAtIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gKHRoaXMudmlzaWJsZUJvdHRvbSAtIGxpbmUudG9wICsgbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIHRvcCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgYm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoID0gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5XaWR0aCA9IG1hcmdpbiAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgaG9yaXpPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoID4gMjAwMDAwMCAvKiBWUC5NYXhIb3JpekdhcCAqLylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgb2xkIG9mIGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGQuZnJvbSA+PSBsaW5lLmZyb20gJiYgb2xkLmZyb20gPCBsaW5lLnRvICYmIG9sZC5zaXplICE9IG9sZC5kaXNwbGF5U2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZC5mcm9tICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoICsgaG9yaXpPZmZzZXQgPCB0aGlzLnBpeGVsVmlld3BvcnQubGVmdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3Jpek9mZnNldCA9IG9sZC5zaXplIC0gb2xkLmRpc3BsYXlTaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHB4TGVmdCA9IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0ICsgaG9yaXpPZmZzZXQsIHB4UmlnaHQgPSB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgKyBob3Jpek9mZnNldDtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgocHhSaWdodCAtIHB4TGVmdCkgLyAyICsgbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSAocHhMZWZ0IC0gbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAocHhSaWdodCArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdGcm9tID4gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgIGFkZEdhcChsaW5lLmZyb20sIHZpZXdGcm9tLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgaWYgKHZpZXdUbyA8IGxpbmUudG8pXG4gICAgICAgICAgICAgICAgYWRkR2FwKHZpZXdUbywgbGluZS50bywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXdwb3J0TGluZXMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpXG4gICAgICAgICAgICAgICAgbGluZS50eXBlLmZvckVhY2goY2hlY2tMaW5lKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGVja0xpbmUobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgfVxuICAgIGdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSkge1xuICAgICAgICBsZXQgZnJhY3Rpb24gPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0bykgLSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuaGVpZ2h0ICogZnJhY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoICogZnJhY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTGluZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAoIUxpbmVHYXAuc2FtZShnYXBzLCB0aGlzLmxpbmVHYXBzKSkge1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwcyA9IGdhcHM7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQoZ2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KHRoaXMsIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlVmlzaWJsZVJhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBkZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aClcbiAgICAgICAgICAgIGRlY28gPSBkZWNvLmNvbmNhdCh0aGlzLmxpbmVHYXBEZWNvKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvLCB0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHtcbiAgICAgICAgICAgIHNwYW4oZnJvbSwgdG8pIHsgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTsgfSxcbiAgICAgICAgICAgIHBvaW50KCkgeyB9XG4gICAgICAgIH0sIDIwKTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSAwO1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnZpc2libGVSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gOCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0TW92ZWQgKi8gfCA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGggJiYgIShjaGFuZ2VkICYgOCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0TW92ZWQgKi8pOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgb2xkID0gdGhpcy52aXNpYmxlUmFuZ2VzW2ldLCBudyA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkLmZyb20gIT0gbncuZnJvbSB8fCBvbGQudG8gIT0gbncudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCB8PSA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi87XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGNoYW5nZXMgJiYgY2hhbmdlcy5tYXBQb3Mob2xkLmZyb20sIC0xKSA9PSBudy5mcm9tICYmIGNoYW5nZXMubWFwUG9zKG9sZC50bywgMSkgPT0gbncudG8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCB8PSA4IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnRNb3ZlZCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiAocG9zID49IHRoaXMudmlld3BvcnQuZnJvbSAmJiBwb3MgPD0gdGhpcy52aWV3cG9ydC50byAmJlxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQoYiA9PiBiLmZyb20gPD0gcG9zICYmIGIudG8gPj0gcG9zKSkgfHxcbiAgICAgICAgICAgIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHBvcywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiAoaGVpZ2h0ID49IHRoaXMudmlld3BvcnRMaW5lc1swXS50b3AgJiYgaGVpZ2h0IDw9IHRoaXMudmlld3BvcnRMaW5lc1t0aGlzLnZpZXdwb3J0TGluZXMubGVuZ3RoIC0gMV0uYm90dG9tICYmXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMuZmluZChsID0+IGwudG9wIDw9IGhlaWdodCAmJiBsLmJvdHRvbSA+PSBoZWlnaHQpKSB8fFxuICAgICAgICAgICAgc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5saW5lQXQodGhpcy5zY2FsZXIuZnJvbURPTShoZWlnaHQpLCBRdWVyeVR5cGUuQnlIZWlnaHQsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBzY3JvbGxBbmNob3JBdChzY3JvbGxUb3ApIHtcbiAgICAgICAgbGV0IGJsb2NrID0gdGhpcy5saW5lQmxvY2tBdEhlaWdodChzY3JvbGxUb3AgKyA4KTtcbiAgICAgICAgcmV0dXJuIGJsb2NrLmZyb20gPj0gdGhpcy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlld3BvcnRMaW5lc1swXS50b3AgLSBzY3JvbGxUb3AgPiAyMDAgPyBibG9jayA6IHRoaXMudmlld3BvcnRMaW5lc1swXTtcbiAgICB9XG4gICAgZWxlbWVudEF0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5ibG9ja0F0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGdldCBkb2NIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlci50b0RPTSh0aGlzLmhlaWdodE1hcC5oZWlnaHQpO1xuICAgIH1cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jSGVpZ2h0ICsgdGhpcy5wYWRkaW5nVG9wICsgdGhpcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cbn1cbmNsYXNzIFZpZXdwb3J0IHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuZnVuY3Rpb24gbGluZVN0cnVjdHVyZShmcm9tLCB0bywgc3RhdGVEZWNvKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBwb3MgPSBmcm9tLCB0b3RhbCA9IDA7XG4gICAgUmFuZ2VTZXQuc3BhbnMoc3RhdGVEZWNvLCBmcm9tLCB0bywge1xuICAgICAgICBzcGFuKCkgeyB9LFxuICAgICAgICBwb2ludChmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG86IGZyb20gfSk7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZnJvbSAtIHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgfSwgMjApOyAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gY29sbGFwc2VkIHJhbmdlcyBvZiBhIHNpZ25pZmljYW50IHNpemVcbiAgICBpZiAocG9zIDwgdG8pIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvIH0pO1xuICAgICAgICB0b3RhbCArPSB0byAtIHBvcztcbiAgICB9XG4gICAgcmV0dXJuIHsgdG90YWwsIHJhbmdlcyB9O1xufVxuZnVuY3Rpb24gZmluZFBvc2l0aW9uKHsgdG90YWwsIHJhbmdlcyB9LCByYXRpbykge1xuICAgIGlmIChyYXRpbyA8PSAwKVxuICAgICAgICByZXR1cm4gcmFuZ2VzWzBdLmZyb207XG4gICAgaWYgKHJhdGlvID49IDEpXG4gICAgICAgIHJldHVybiByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgIGxldCBkaXN0ID0gTWF0aC5mbG9vcih0b3RhbCAqIHJhdGlvKTtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldLCBzaXplID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoZGlzdCA8PSBzaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZyb20gKyBkaXN0O1xuICAgICAgICBkaXN0IC09IHNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgcG9zKSB7XG4gICAgbGV0IGNvdW50ZWQgPSAwO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBzdHJ1Y3R1cmUucmFuZ2VzKSB7XG4gICAgICAgIGlmIChwb3MgPD0gdG8pIHtcbiAgICAgICAgICAgIGNvdW50ZWQgKz0gcG9zIC0gZnJvbTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ZWQgKz0gdG8gLSBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4gY291bnRlZCAvIHN0cnVjdHVyZS50b3RhbDtcbn1cbmZ1bmN0aW9uIGZpbmQoYXJyYXksIGYpIHtcbiAgICBmb3IgKGxldCB2YWwgb2YgYXJyYXkpXG4gICAgICAgIGlmIChmKHZhbCkpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBEb24ndCBzY2FsZSB3aGVuIHRoZSBkb2N1bWVudCBoZWlnaHQgaXMgd2l0aGluIHRoZSByYW5nZSBvZiB3aGF0XG4vLyB0aGUgRE9NIGNhbiBoYW5kbGUuXG5jb25zdCBJZFNjYWxlciA9IHtcbiAgICB0b0RPTShuKSB7IHJldHVybiBuOyB9LFxuICAgIGZyb21ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBzY2FsZTogMSxcbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIgPT0gdGhpczsgfVxufTtcbmZ1bmN0aW9uIHN0YXRpY0RlY28oc3RhdGUpIHtcbiAgICBsZXQgZGVjbyA9IHN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xuICAgIGxldCBvdXRlciA9IHN0YXRlLmZhY2V0KG91dGVyRGVjb3JhdGlvbnMpLmZpbHRlcihkID0+IHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIik7XG4gICAgaWYgKG91dGVyLmxlbmd0aClcbiAgICAgICAgZGVjby5wdXNoKFJhbmdlU2V0LmpvaW4ob3V0ZXIpKTtcbiAgICByZXR1cm4gZGVjbztcbn1cbi8vIFdoZW4gdGhlIGhlaWdodCBpcyB0b28gYmlnICg+IFZQLk1heERPTUhlaWdodCksIHNjYWxlIGRvd24gdGhlXG4vLyByZWdpb25zIG91dHNpZGUgdGhlIHZpZXdwb3J0cyBzbyB0aGF0IHRoZSB0b3RhbCBoZWlnaHQgaXNcbi8vIFZQLk1heERPTUhlaWdodC5cbmNsYXNzIEJpZ1NjYWxlciB7XG4gICAgY29uc3RydWN0b3Iob3JhY2xlLCBoZWlnaHRNYXAsIHZpZXdwb3J0cykge1xuICAgICAgICBsZXQgdnBIZWlnaHQgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgdG9wID0gaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCkudG9wO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IGhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCAwLCAwKS5ib3R0b207XG4gICAgICAgICAgICB2cEhlaWdodCArPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdG9wLCBib3R0b20sIGRvbVRvcDogMCwgZG9tQm90dG9tOiAwIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjYWxlID0gKDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovIC0gdnBIZWlnaHQpIC8gKGhlaWdodE1hcC5oZWlnaHQgLSB2cEhlaWdodCk7XG4gICAgICAgIGZvciAobGV0IG9iaiBvZiB0aGlzLnZpZXdwb3J0cykge1xuICAgICAgICAgICAgb2JqLmRvbVRvcCA9IGRvbUJhc2UgKyAob2JqLnRvcCAtIGJhc2UpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSBvYmouZG9tQm90dG9tID0gb2JqLmRvbVRvcCArIChvYmouYm90dG9tIC0gb2JqLnRvcCk7XG4gICAgICAgICAgICBiYXNlID0gb2JqLmJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0RPTShuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXZwIHx8IG4gPCB2cC50b3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJhc2UgKyAobiAtIGJhc2UpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdnAuZG9tVG9wICsgKG4gLSB2cC50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbURPTShuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXZwIHx8IG4gPCB2cC5kb21Ub3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UgKyAobiAtIGRvbUJhc2UpIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmRvbUJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdnAudG9wICsgKG4gLSB2cC5kb21Ub3ApO1xuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBCaWdTY2FsZXIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSA9PSBvdGhlci5zY2FsZSAmJiB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPT0gb3RoZXIudmlld3BvcnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydHMuZXZlcnkoKHZwLCBpKSA9PiB2cC5mcm9tID09IG90aGVyLnZpZXdwb3J0c1tpXS5mcm9tICYmIHZwLnRvID09IG90aGVyLnZpZXdwb3J0c1tpXS50byk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbGVCbG9jayhibG9jaywgc2NhbGVyKSB7XG4gICAgaWYgKHNjYWxlci5zY2FsZSA9PSAxKVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgbGV0IGJUb3AgPSBzY2FsZXIudG9ET00oYmxvY2sudG9wKSwgYkJvdHRvbSA9IHNjYWxlci50b0RPTShibG9jay5ib3R0b20pO1xuICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGJsb2NrLmZyb20sIGJsb2NrLmxlbmd0aCwgYlRvcCwgYkJvdHRvbSAtIGJUb3AsIEFycmF5LmlzQXJyYXkoYmxvY2suX2NvbnRlbnQpID8gYmxvY2suX2NvbnRlbnQubWFwKGIgPT4gc2NhbGVCbG9jayhiLCBzY2FsZXIpKSA6IGJsb2NrLl9jb250ZW50KTtcbn1cblxuY29uc3QgdGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogc3RycyA9PiBzdHJzLmpvaW4oXCIgXCIpIH0pO1xuY29uc3QgZGFya1RoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuaW5kZXhPZih0cnVlKSA+IC0xIH0pO1xuY29uc3QgYmFzZVRoZW1lSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlTGlnaHRJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VEYXJrSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuY29uc3QgbGlnaHREYXJrSURzID0geyBcIiZsaWdodFwiOiBcIi5cIiArIGJhc2VMaWdodElELCBcIiZkYXJrXCI6IFwiLlwiICsgYmFzZURhcmtJRCB9O1xuZnVuY3Rpb24gYnVpbGRUaGVtZShtYWluLCBzcGVjLCBzY29wZXMpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlTW9kdWxlKHNwZWMsIHtcbiAgICAgICAgZmluaXNoKHNlbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8mLy50ZXN0KHNlbCkgPyBzZWwucmVwbGFjZSgvJlxcdyovLCBtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobSA9PSBcIiZcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1haW47XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZXMgfHwgIXNjb3Blc1ttXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuc3VwcG9ydGVkIHNlbGVjdG9yOiAke219YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3Blc1ttXTtcbiAgICAgICAgICAgIH0pIDogbWFpbiArIFwiIFwiICsgc2VsO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9idWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHtcbiAgICBcIiZcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZSAhaW1wb3J0YW50XCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIFwiJi5jbS1mb2N1c2VkXCI6IHtcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYSBzaW1wbGUgZGVmYXVsdCBvdXRsaW5lIHRvIG1ha2Ugc3VyZSBhIGZvY3VzZWRcbiAgICAgICAgICAgIC8vIGVkaXRvciBpcyB2aXN1YWxseSBkaXN0aW5jdC4gQ2FuJ3QgbGVhdmUgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3aWxsIGFwcGx5IHRvIHRoZSBjb250ZW50IGVsZW1lbnQsIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBpbnNpZGUgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGFuZCBkb2Vzbid0IGluY2x1ZGUgdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXJzLiBXZSBhbHNvIGNhbid0IHVzZSBhbiAnYXV0bycgb3V0bGluZSwgc2luY2UgdGhvc2VcbiAgICAgICAgICAgIC8vIGFyZSwgZm9yIHNvbWUgcmVhc29uLCBkcmF3biBiZWhpbmQgdGhlIGVsZW1lbnQgY29udGVudCwgd2hpY2hcbiAgICAgICAgICAgIC8vIHdpbGwgY2F1c2UgdGhpbmdzIGxpa2UgdGhlIGFjdGl2ZSBsaW5lIGJhY2tncm91bmQgdG8gY292ZXJcbiAgICAgICAgICAgIC8vIHRoZSBvdXRsaW5lICgjMjk3KS5cbiAgICAgICAgICAgIG91dGxpbmU6IFwiMXB4IGRvdHRlZCAjMjEyMTIxXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIlxuICAgIH0sXG4gICAgXCIuY20tc2Nyb2xsZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnQgIWltcG9ydGFudFwiLFxuICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93WDogXCJhdXRvXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIHpJbmRleDogMCxcbiAgICAgICAgb3ZlcmZsb3dBbmNob3I6IFwibm9uZVwiLFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgZmxleEdyb3c6IDIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgICAgICAgd29yZFdyYXA6IFwibm9ybWFsXCIsIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDU2XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiNHB4IDBcIixcbiAgICAgICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgICAgIFwiJltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cIjoge1xuICAgICAgICAgICAgV2Via2l0VXNlck1vZGlmeTogXCJyZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5XCIsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbmVXcmFwcGluZ1wiOiB7XG4gICAgICAgIHdoaXRlU3BhY2VfZmFsbGJhY2s6IFwicHJlLXdyYXBcIiwgLy8gRm9yIElFXG4gICAgICAgIHdoaXRlU3BhY2U6IFwiYnJlYWstc3BhY2VzXCIsXG4gICAgICAgIHdvcmRCcmVhazogXCJicmVhay13b3JkXCIsIC8vIEZvciBTYWZhcmksIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBvdmVyZmxvdy13cmFwOiBhbnl3aGVyZVxuICAgICAgICBvdmVyZmxvd1dyYXA6IFwiYW55d2hlcmVcIixcbiAgICAgICAgZmxleFNocmluazogMVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcImJsYWNrXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJ3aGl0ZVwiIH0sXG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgcGFkZGluZzogXCIwIDJweCAwIDZweFwiXG4gICAgfSxcbiAgICBcIi5jbS1sYXllclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgY29udGFpbjogXCJzaXplIHN0eWxlXCIsXG4gICAgICAgIFwiJiA+ICpcIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q5ZDlkOVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjIyXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0LmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkN2Q0ZjBcIlxuICAgIH0sXG4gICAgXCImZGFyay5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLXNlbGVjdGlvbkxheWVyIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjMzXCJcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBcInN0ZXBzKDEpIGNtLWJsaW5rIDEuMnMgaW5maW5pdGVcIlxuICAgIH0sXG4gICAgLy8gVHdvIGFuaW1hdGlvbnMgZGVmaW5lZCBzbyB0aGF0IHdlIGNhbiBzd2l0Y2ggYmV0d2VlbiB0aGVtIHRvXG4gICAgLy8gcmVzdGFydCB0aGUgYW5pbWF0aW9uIHdpdGhvdXQgZm9yY2luZyBhbm90aGVyIHN0eWxlXG4gICAgLy8gcmVjb21wdXRhdGlvbi5cbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmtcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rMlwiOiB7IFwiMCVcIjoge30sIFwiNTAlXCI6IHsgb3BhY2l0eTogMCB9LCBcIjEwMCVcIjoge30gfSxcbiAgICBcIi5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjJweCBzb2xpZCBibGFja1wiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0wLjZweFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBib3JkZXJMZWZ0Q29sb3I6IFwiI2RkZFwiXG4gICAgfSxcbiAgICBcIi5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tY3Vyc29yTGF5ZXIgLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH0sXG4gICAgXCIuY20taXNvXCI6IHtcbiAgICAgICAgdW5pY29kZUJpZGk6IFwiaXNvbGF0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS1hbm5vdW5jZWRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICB0b3A6IFwiLTEwMDAwcHhcIlxuICAgIH0sXG4gICAgXCJAbWVkaWEgcHJpbnRcIjoge1xuICAgICAgICBcIi5jbS1hbm5vdW5jZWRcIjogeyBkaXNwbGF5OiBcIm5vbmVcIiB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjY2NlZWZmNDRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZWVmZjMzXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCJyZWRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwiI2Y3OFwiIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICB6SW5kZXg6IDIwMCxcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlcnMtYmVmb3JlXCI6IHsgaW5zZXRJbmxpbmVTdGFydDogMCB9LFxuICAgIFwiLmNtLWd1dHRlcnMtYWZ0ZXJcIjogeyBpbnNldElubGluZUVuZDogMCB9LFxuICAgIFwiJmxpZ2h0IC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiIzZjNmM2Y1wiLFxuICAgICAgICBib3JkZXI6IFwiMHB4IHNvbGlkICNkZGRcIixcbiAgICAgICAgXCImLmNtLWd1dHRlcnMtYmVmb3JlXCI6IHsgYm9yZGVyUmlnaHRXaWR0aDogXCIxcHhcIiB9LFxuICAgICAgICBcIiYuY20tZ3V0dGVycy1hZnRlclwiOiB7IGJvcmRlckxlZnRXaWR0aDogXCIxcHhcIiB9LFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIiNjY2NcIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIiwgLy8gTmVjZXNzYXJ5IC0tIHByZXZlbnRzIG1hcmdpbiBjb2xsYXBzaW5nXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tbGluZU51bWJlcnMgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjAgM3B4IDAgNXB4XCIsXG4gICAgICAgIG1pbldpZHRoOiBcIjIwcHhcIixcbiAgICAgICAgdGV4dEFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlMmYyZmZcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMjIyMjI3XCJcbiAgICB9LFxuICAgIFwiLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgekluZGV4OiAzMDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLXRvcFwiOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLWJvdHRvbVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS1kaWFsb2dcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCAxOXB4IDRweCA2cHhcIixcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImIGxhYmVsXCI6IHsgZm9udFNpemU6IFwiODAlXCIgfSxcbiAgICB9LFxuICAgIFwiLmNtLWRpYWxvZy1jbG9zZVwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHRvcDogXCIzcHhcIixcbiAgICAgICAgcmlnaHQ6IFwiNHB4XCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCIxNHB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiXG4gICAgfSxcbiAgICBcIi5jbS10YWJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxuICAgIH0sXG4gICAgXCIuY20td2lkZ2V0QnVmZmVyXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1wbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0b3BcIixcbiAgICAgICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFNwYWNlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcInJhZGlhbC1ncmFkaWVudChjaXJjbGUgYXQgNTAlIDU1JSwgI2FhYSAyMCUsIHRyYW5zcGFyZW50IDUlKVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwiY2VudGVyXCIsXG4gICAgfSxcbiAgICBcIi5jbS1oaWdobGlnaHRUYWJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwXCI+PHBhdGggc3Ryb2tlPVwiJTIzODg4XCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCJub25lXCIgZD1cIk0xIDEwSDE5NkwxOTAgNU0xOTAgMTVMMTk2IDEwTTE5NyA0TDE5NyAxNlwiLz48L3N2Zz4nKWAsXG4gICAgICAgIGJhY2tncm91bmRTaXplOiBcImF1dG8gMTAwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwicmlnaHQgOTAlXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwibm8tcmVwZWF0XCJcbiAgICB9LFxuICAgIFwiLmNtLXRyYWlsaW5nU3BhY2VcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMzMyMjU1XCJcbiAgICB9LFxuICAgIFwiLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiLjJlbSAxZW1cIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjFweFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjZWZmMWY1LCAjZDlkOWRmKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNiNGI0YjQsICNkMGQzZDYpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjMzkzOTM5LCAjMTExKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMxMTEsICMzMzMpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIC41ZW1cIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM1NTVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIlxuICAgIH1cbn0sIGxpZ2h0RGFya0lEcyk7XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvXG4vLyBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQgdGhlcmVcbmNvbnN0IHVzZUNoYXJEYXRhID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5jbGFzcyBET01PYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGtub3duIHNlbGVjdGlvbi4gS2VwdCBpbiBvdXIgb3duIG9iamVjdCwgYXMgb3Bwb3NlZCB0byBqdXN0XG4gICAgICAgIC8vIGRpcmVjdGx5IGFjY2Vzc2luZyB0aGUgc2VsZWN0aW9uIGJlY2F1c2U6XG4gICAgICAgIC8vICAtIFNhZmFyaSBkb2Vzbid0IHJlcG9ydCB0aGUgcmlnaHQgc2VsZWN0aW9uIGluIHNoYWRvdyBET01cbiAgICAgICAgLy8gIC0gUmVhZGluZyBmcm9tIHRoZSBzZWxlY3Rpb24gZm9yY2VzIGEgRE9NIGxheW91dFxuICAgICAgICAvLyAgLSBUaGlzIHdheSwgd2UgY2FuIGlnbm9yZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnRzIGlmIHdlIGhhdmVcbiAgICAgICAgLy8gICAgYWxyZWFkeSBzZWVuIHRoZSAnbmV3JyBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZSA9IG5ldyBET01TZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgLy8gU2V0IHdoZW4gYSBzZWxlY3Rpb24gY2hhbmdlIGlzIGRldGVjdGVkLCBjbGVhcmVkIG9uIGZsdXNoXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXRzID0gW107XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2FwcyA9IFtdO1xuICAgICAgICB0aGlzLnByaW50UXVlcnkgPSBudWxsO1xuICAgICAgICAvLyBUaW1lb3V0IGZvciBzY2hlZHVsaW5nIGNoZWNrIG9mIHRoZSBwYXJlbnRzIHRoYXQgbmVlZCBzY3JvbGwgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuY29udGVudERPTTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBtdXQgb2YgbXV0YXRpb25zKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gdHlwaW5nIG92ZXIgYSBzZWxlY3Rpb24gb3JcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCBhIHNpbmdsZSBjaGFyYWN0ZXIgdGV4dCBub2RlKSBjYWxsIHRoZVxuICAgICAgICAgICAgLy8gb2JzZXJ2ZXIgY2FsbGJhY2sgYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVW5yZWxhdGVkbHksIGlPUyBTYWZhcmkgd2lsbCwgd2hlbiBlbmRpbmcgYSBjb21wb3NpdGlvbixcbiAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBmaXJzdCBjbGVhciBpdCwgZGVsaXZlciB0aGUgbXV0YXRpb25zLCBhbmQgdGhlblxuICAgICAgICAgICAgLy8gcmVpbnNlcnQgdGhlIGZpbmlzaGVkIHRleHQuIENvZGVNaXJyb3IncyBoYW5kbGluZyBvZiB0aGVcbiAgICAgICAgICAgIC8vIGRlbGV0aW9uIHdpbGwgcHJldmVudCB0aGUgcmVpbnNlcnRpb24gZnJvbSBoYXBwZW5pbmcsXG4gICAgICAgICAgICAvLyBicmVha2luZyBjb21wb3NpdGlvbi5cbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgfHwgYnJvd3Nlci5pb3MgJiYgdmlldy5jb21wb3NpbmcpICYmXG4gICAgICAgICAgICAgICAgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAod2luZG93LkVkaXRDb250ZXh0ICYmIGJyb3dzZXIuYW5kcm9pZCAmJiB2aWV3LmNvbnN0cnVjdG9yLkVESVRfQ09OVEVYVCAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgIC8vIENocm9tZSA8MTI2IGRvZXNuJ3Qgc3VwcG9ydCBpbnZlcnRlZCBzZWxlY3Rpb25zIGluIGVkaXQgY29udGV4dCAoIzEzOTIpXG4gICAgICAgICAgICAhKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuY2hyb21lX3ZlcnNpb24gPCAxMjYpKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0ID0gbmV3IEVkaXRDb250ZXh0TWFuYWdlcih2aWV3KTtcbiAgICAgICAgICAgIGlmICh2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSlcbiAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uZWRpdENvbnRleHQgPSB0aGlzLmVkaXRDb250ZXh0LmVkaXRDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMub25DaGFyRGF0YSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh7IHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNoYXJhY3RlckRhdGFcIixcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGV2ZW50LnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZSA9IHRoaXMub25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblByaW50ID0gdGhpcy5vblByaW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TY3JvbGwgPSB0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSlcbiAgICAgICAgICAgIHRoaXMucHJpbnRRdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKFwicHJpbnRcIik7XG4gICAgICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbCA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy52aWV3LmRvY1ZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0VXBkYXRlKSA8IERhdGUubm93KCkgLSA3NSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbC5vYnNlcnZlKHZpZXcuc2Nyb2xsRE9NKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbiA9IHZpZXcud2luKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Q2hlY2sgPCAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gc2V0VGltZW91dCh0aGlzLmxpc3RlbkZvclNjcm9sbC5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIChlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSAhPSB0aGlzLmludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9ICF0aGlzLmludGVyc2VjdGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nICE9IHRoaXMudmlldy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7IHRocmVzaG9sZDogWzAsIC4wMDFdIH0pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24ub2JzZXJ2ZSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuRm9yU2Nyb2xsKCk7XG4gICAgICAgIHRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgfVxuICAgIG9uU2Nyb2xsQ2hhbmdlZChlKSB7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLnJ1bkhhbmRsZXJzKFwic2Nyb2xsXCIsIGUpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLnZpZXcubWVhc3VyZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbChlKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5lZGl0Q29udGV4dClcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLmVkaXRDb250ZXh0Lm1lYXN1cmVSZXEpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChlKTtcbiAgICB9XG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZVRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIG9uUHJpbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKChldmVudC50eXBlID09IFwiY2hhbmdlXCIgfHwgIWV2ZW50LnR5cGUpICYmICFldmVudC5tYXRjaGVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG4gICAgdXBkYXRlR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICh0aGlzLmdhcEludGVyc2VjdGlvbiAmJiAoZ2Fwcy5sZW5ndGggIT0gdGhpcy5nYXBzLmxlbmd0aCB8fCB0aGlzLmdhcHMuc29tZSgoZywgaSkgPT4gZyAhPSBnYXBzW2ldKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLm9ic2VydmUoZ2FwKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwcyA9IGdhcHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IHdhc0NoYW5nZWQgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQ7XG4gICAgICAgIGlmICghdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKSB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBzZWwgPSB0aGlzLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB0aGlzLmRvbSA6ICFoYXNTZWxlY3Rpb24odGhpcy5kb20sIHNlbCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb250ZXh0ID0gc2VsLmFuY2hvck5vZGUgJiYgdmlldy5kb2NWaWV3LnRpbGUubmVhcmVzdChzZWwuYW5jaG9yTm9kZSk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuaXNXaWRnZXQoKSAmJiBjb250ZXh0LndpZGdldC5pZ25vcmVFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIGlmICghd2FzQ2hhbmdlZClcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIGhhcyBhIHNpbWlsYXIgaXNzdWUgd2hlbiBiYWNrc3BhY2luZyBvdXQgYVxuICAgICAgICAvLyBzZWxlY3Rpb24gKCM2NDUpLlxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSkgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiZcbiAgICAgICAgICAgIC8vIChTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUUpXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgfVxuICAgIHJlYWRTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgLy8gVGhlIFNlbGVjdGlvbiBvYmplY3QgaXMgYnJva2VuIGluIHNoYWRvdyByb290cyBpbiBTYWZhcmkuIFNlZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQxNFxuICAgICAgICBsZXQgc2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcmFuZ2UgPSBicm93c2VyLnNhZmFyaSAmJiB2aWV3LnJvb3Qubm9kZVR5cGUgPT0gMTEgJiZcbiAgICAgICAgICAgIHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tICYmXG4gICAgICAgICAgICBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodGhpcy52aWV3LCBzZWxlY3Rpb24pIHx8IHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCFyYW5nZSB8fCB0aGlzLnNlbGVjdGlvblJhbmdlLmVxKHJhbmdlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGxvY2FsID0gaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCByYW5nZSk7XG4gICAgICAgIC8vIERldGVjdCB0aGUgc2l0dWF0aW9uIHdoZXJlIHRoZSBicm93c2VyIGhhcywgb24gZm9jdXMsIG1vdmVkIHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuIFJlc2V0IGl0IHRvIHRoZVxuICAgICAgICAvLyBwb3NpdGlvbiBmcm9tIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAgICAgIGlmIChsb2NhbCAmJiAhdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lIDwgRGF0ZS5ub3coKSAtIDMwMCAmJlxuICAgICAgICAgICAgYXRFbGVtZW50U3RhcnQodGhpcy5kb20sIHJhbmdlKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIGlmIChsb2NhbClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb25SYW5nZShhbmNob3IsIGhlYWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2xlYXJTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQobnVsbCwgMCwgbnVsbCwgMCk7XG4gICAgfVxuICAgIGxpc3RlbkZvclNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICBsZXQgaSA9IDAsIGNoYW5nZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBkb20gPSB0aGlzLmRvbTsgZG9tOykge1xuICAgICAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmIGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmIHRoaXMuc2Nyb2xsVGFyZ2V0c1tpXSA9PSBkb20pXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmFzc2lnbmVkU2xvdCB8fCBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmICFjaGFuZ2VkKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzID0gY2hhbmdlZClcbiAgICAgICAgICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmUoZikge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgfVxuICAgIC8vIFRocm93IGF3YXkgYW55IHBlbmRpbmcgY2hhbmdlc1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENocm9tZSBBbmRyb2lkLCBlc3BlY2lhbGx5IGluIGNvbWJpbmF0aW9uIHdpdGggR0JvYXJkLCBub3Qgb25seVxuICAgIC8vIGRvZXNuJ3QgcmVsaWFibHkgZmlyZSByZWd1bGFyIGtleSBldmVudHMsIGJ1dCBhbHNvIG9mdGVuXG4gICAgLy8gc3Vycm91bmRzIHRoZSBlZmZlY3Qgb2YgZW50ZXIgb3IgYmFja3NwYWNlIHdpdGggYSBidW5jaCBvZlxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyB0aGF0LCB3aGVuIGludGVycnVwdGVkLCBjYXVzZSB0ZXh0IGR1cGxpY2F0aW9uXG4gICAgLy8gb3Igb3RoZXIga2luZHMgb2YgY29ycnVwdGlvbi4gVGhpcyBoYWNrIG1ha2VzIHRoZSBlZGl0b3IgYmFjayBvZmZcbiAgICAvLyBmcm9tIGhhbmRsaW5nIERPTSBjaGFuZ2VzIGZvciBhIG1vbWVudCB3aGVuIHN1Y2ggYSBrZXkgaXNcbiAgICAvLyBkZXRlY3RlZCAodmlhIGJlZm9yZWlucHV0IG9yIGtleWRvd24pLCBhbmQgdGhlbiB0cmllcyB0byBmbHVzaFxuICAgIC8vIHRoZW0gb3IsIGlmIHRoYXQgaGFzIG5vIGVmZmVjdCwgZGlzcGF0Y2hlcyB0aGUgZ2l2ZW4ga2V5LlxuICAgIGRlbGF5QW5kcm9pZEtleShrZXksIGtleUNvZGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkpIHtcbiAgICAgICAgICAgIGxldCBmbHVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9IGtleS5rZXlDb2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmbHVzaGVkID0gdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZsdXNoZWQgJiYga2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodGhpcy5kb20sIGtleS5rZXksIGtleS5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZShmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgYmFja3NwYWNlIGJlZm9yZWlucHV0IGlzIHNvbWV0aW1lcyBzaWduYWxsZWQgc3B1cmlvdXNseSxcbiAgICAgICAgLy8gRW50ZXIgYWx3YXlzIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSB8fCBrZXkgPT0gXCJFbnRlclwiKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IHtcbiAgICAgICAgICAgICAgICBrZXksIGtleUNvZGUsXG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gdGhlIGtleSBoYW5kbGVyIHdoZW4gbm8gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgaWZcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGNvbWluZyByaWdodCBhZnRlciBhbm90aGVyIGNoYW5nZSwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHByb2JhYmx5IHBhcnQgb2YgYSB3ZWlyZCBjaGFpbiBvZiB1cGRhdGVzLCBhbmQgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gYmUgaWdub3JlZCBpZiBpdCByZXR1cm5zIHRoZSBET00gdG8gaXRzIHByZXZpb3VzIHN0YXRlLlxuICAgICAgICAgICAgICAgIGZvcmNlOiB0aGlzLmxhc3RDaGFuZ2UgPCBEYXRlLm5vdygpIC0gNTAgfHwgISEoKF9hID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlKVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpIHtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHRoaXMuZGVsYXllZEZsdXNoID0gLTE7IHRoaXMuZmx1c2goKTsgfSk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICBwZW5kaW5nUmVjb3JkcygpIHtcbiAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgICB9XG4gICAgcHJvY2Vzc1JlY29yZHMoKSB7XG4gICAgICAgIGxldCByZWNvcmRzID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlYWRNdXRhdGlvbihyZWNvcmQpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gTWF0aC5taW4ocmFuZ2UuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heChyYW5nZS50bywgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0eXBlT3ZlciB9O1xuICAgIH1cbiAgICByZWFkQ2hhbmdlKCkge1xuICAgICAgICBsZXQgeyBmcm9tLCB0bywgdHlwZU92ZXIgfSA9IHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJiBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMuc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgIW5ld1NlbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZnJvbSA+IC0xKVxuICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlID0gbmV3IERPTUNoYW5nZSh0aGlzLnZpZXcsIGZyb20sIHRvLCB0eXBlT3Zlcik7XG4gICAgICAgIHRoaXMudmlldy5kb2NWaWV3LmRvbUNoYW5nZWQgPSB7IG5ld1NlbDogY2hhbmdlLm5ld1NlbCA/IGNoYW5nZS5uZXdTZWwubWFpbiA6IG51bGwgfTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgcGVuZGluZyBjaGFuZ2VzLCBpZiBhbnlcbiAgICBmbHVzaChyZWFkU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgICAgICAvLyBDb21wbGV0ZWx5IGhvbGQgb2ZmIGZsdXNoaW5nIHdoZW4gcGVuZGluZyBrZXlzIGFyZSBzZXRcdTIwMTR0aGUgY29kZVxuICAgICAgICAvLyBtYW5hZ2luZyB0aG9zZSB3aWxsIG1ha2Ugc3VyZSBwcm9jZXNzUmVjb3JkcyBpcyBjYWxsZWQgYW5kIHRoZVxuICAgICAgICAvLyB2aWV3IGlzIHJlc3luY2hyb25pemVkIGFmdGVyXG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChyZWFkU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IGRvbUNoYW5nZSA9IHRoaXMucmVhZENoYW5nZSgpO1xuICAgICAgICBpZiAoIWRvbUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0U3RhdGUgPSB0aGlzLnZpZXcuc3RhdGU7XG4gICAgICAgIGxldCBoYW5kbGVkID0gYXBwbHlET01DaGFuZ2UodGhpcy52aWV3LCBkb21DaGFuZ2UpO1xuICAgICAgICAvLyBUaGUgdmlldyB3YXNuJ3QgdXBkYXRlZCBidXQgRE9NL3NlbGVjdGlvbiBjaGFuZ2VzIHdlcmUgc2Vlbi4gUmVzZXQgdGhlIHZpZXcuXG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUgPT0gc3RhcnRTdGF0ZSAmJlxuICAgICAgICAgICAgKGRvbUNoYW5nZS5kb21DaGFuZ2VkIHx8IGRvbUNoYW5nZS5uZXdTZWwgJiYgIXNhbWVTZWxQb3ModGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbiwgZG9tQ2hhbmdlLm5ld1NlbC5tYWluKSkpXG4gICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgfVxuICAgIHJlYWRNdXRhdGlvbihyZWMpIHtcbiAgICAgICAgbGV0IHRpbGUgPSB0aGlzLnZpZXcuZG9jVmlldy50aWxlLm5lYXJlc3QocmVjLnRhcmdldCk7XG4gICAgICAgIGlmICghdGlsZSB8fCB0aWxlLmlzV2lkZ2V0KCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGlsZS5tYXJrRGlydHkocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgbGV0IGNoaWxkQmVmb3JlID0gZmluZENoaWxkKHRpbGUsIHJlYy5wcmV2aW91c1NpYmxpbmcgfHwgcmVjLnRhcmdldC5wcmV2aW91c1NpYmxpbmcsIC0xKTtcbiAgICAgICAgICAgIGxldCBjaGlsZEFmdGVyID0gZmluZENoaWxkKHRpbGUsIHJlYy5uZXh0U2libGluZyB8fCByZWMudGFyZ2V0Lm5leHRTaWJsaW5nLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNoaWxkQmVmb3JlID8gdGlsZS5wb3NBZnRlcihjaGlsZEJlZm9yZSkgOiB0aWxlLnBvc0F0U3RhcnQsXG4gICAgICAgICAgICAgICAgdG86IGNoaWxkQWZ0ZXIgPyB0aWxlLnBvc0JlZm9yZShjaGlsZEFmdGVyKSA6IHRpbGUucG9zQXRFbmQsIHR5cGVPdmVyOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlYy50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiB0aWxlLnBvc0F0U3RhcnQsIHRvOiB0aWxlLnBvc0F0RW5kLCB0eXBlT3ZlcjogcmVjLnRhcmdldC5ub2RlVmFsdWUgPT0gcmVjLm9sZFZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRXaW5kb3cod2luKSB7XG4gICAgICAgIGlmICh3aW4gIT0gdGhpcy53aW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgICAgIHRoaXMud2luID0gd2luO1xuICAgICAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFdpbmRvd0xpc3RlbmVycyh3aW4pIHtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIGlmICh0aGlzLnByaW50UXVlcnkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW50UXVlcnkuYWRkRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50UXVlcnkuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRRdWVyeS5hZGRMaXN0ZW5lcih0aGlzLm9uUHJpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHdpbi5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICByZW1vdmVXaW5kb3dMaXN0ZW5lcnMod2luKSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgaWYgKHRoaXMucHJpbnRRdWVyeSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJpbnRRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25QcmludCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludFF1ZXJ5LnJlbW92ZUxpc3RlbmVyKHRoaXMub25QcmludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICB3aW4uZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5lZGl0Q29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChlZGl0YWJsZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGVkaXRhYmxlKSlcbiAgICAgICAgICAgICAgICB1cGRhdGUudmlldy5jb250ZW50RE9NLmVkaXRDb250ZXh0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IHRoaXMuZWRpdENvbnRleHQuZWRpdENvbnRleHQgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgKF9hID0gdGhpcy5pbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYiA9IHRoaXMuZ2FwSW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2MgPSB0aGlzLnJlc2l6ZVNjcm9sbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBhcmVudENoZWNrKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgICAgICBpZiAodGhpcy5lZGl0Q29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmNvbnRlbnRET00uZWRpdENvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ2hpbGQodGlsZSwgZG9tLCBkaXIpIHtcbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIGxldCBjdXJUaWxlID0gVGlsZS5nZXQoZG9tKTtcbiAgICAgICAgaWYgKGN1clRpbGUgJiYgY3VyVGlsZS5wYXJlbnQgPT0gdGlsZSlcbiAgICAgICAgICAgIHJldHVybiBjdXJUaWxlO1xuICAgICAgICBsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIGRvbSA9IHBhcmVudCAhPSB0aWxlLmRvbSA/IHBhcmVudCA6IGRpciA+IDAgPyBkb20ubmV4dFNpYmxpbmcgOiBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2VsZWN0aW9uUmFuZ2VGcm9tUmFuZ2UodmlldywgcmFuZ2UpIHtcbiAgICBsZXQgYW5jaG9yTm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICBsZXQgZm9jdXNOb2RlID0gcmFuZ2UuZW5kQ29udGFpbmVyLCBmb2N1c09mZnNldCA9IHJhbmdlLmVuZE9mZnNldDtcbiAgICBsZXQgY3VyQW5jaG9yID0gdmlldy5kb2NWaWV3LmRvbUF0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yLCAxKTtcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcbiAgICAvLyB1c2UgYSBoZXVyaXN0aWMgdGhhdCBmbGlwcyBpdCBhcm91bmQgaWYgaXRzIGVuZCBtYXRjaGVzIHRoZVxuICAgIC8vIGN1cnJlbnQgYW5jaG9yLlxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJBbmNob3Iubm9kZSwgY3VyQW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXG4gICAgICAgIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdID0gW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldF07XG4gICAgcmV0dXJuIHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH07XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1ZyAoIzQxNClcbmZ1bmN0aW9uIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh2aWV3LCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uLmdldENvbXBvc2VkUmFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcyh2aWV3LnJvb3QpWzBdO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRTZWxlY3Rpb25SYW5nZUZyb21SYW5nZSh2aWV3LCByYW5nZSk7XG4gICAgfVxuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgLy8gQmVjYXVzZSBTYWZhcmkgKGF0IGxlYXN0IGluIDIwMTgtMjAyMSkgZG9lc24ndCBwcm92aWRlIHJlZ3VsYXJcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgYSBzaGFkb3dyb290LCB3ZSBoYXZlIHRvIHBlcmZvcm0gYVxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXRcdTIwMTR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxuICAgIC8vIGBiZWZvcmVJbnB1dGAgZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gdGhlXG4gICAgLy8gZXZlbnQuXG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcbiAgICB9XG4gICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICB2aWV3LmRvbS5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuY29udGVudERPTS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZvdW5kID8gYnVpbGRTZWxlY3Rpb25SYW5nZUZyb21SYW5nZSh2aWV3LCBmb3VuZCkgOiBudWxsO1xufVxuY2xhc3MgRWRpdENvbnRleHRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIC8vIFRoZSBkb2N1bWVudCB3aW5kb3cgZm9yIHdoaWNoIHRoZSB0ZXh0IGluIHRoZSBjb250ZXh0IGlzXG4gICAgICAgIC8vIG1haW50YWluZWQuIEZvciBsYXJnZSBkb2N1bWVudHMsIHRoaXMgbWF5IGJlIHNtYWxsZXIgdGhhbiB0aGVcbiAgICAgICAgLy8gZWRpdG9yIGRvY3VtZW50LiBUaGlzIHdpbmRvdyBhbHdheXMgaW5jbHVkZXMgdGhlIHNlbGVjdGlvbiBoZWFkLlxuICAgICAgICB0aGlzLmZyb20gPSAwO1xuICAgICAgICB0aGlzLnRvID0gMDtcbiAgICAgICAgLy8gV2hlbiBhcHBseWluZyBhIHRyYW5zYWN0aW9uLCB0aGlzIGlzIHVzZWQgdG8gY29tcGFyZSB0aGUgY2hhbmdlXG4gICAgICAgIC8vIG1hZGUgdG8gdGhlIGNvbnRleHQgY29udGVudCB0byB0aGUgY2hhbmdlIGluIHRoZSB0cmFuc2FjdGlvbiBpblxuICAgICAgICAvLyBvcmRlciB0byBtYWtlIHRoZSBtaW5pbWFsIGNoYW5nZXMgdG8gdGhlIGNvbnRleHQgKHNpbmNlIHRvdWNoaW5nXG4gICAgICAgIC8vIHRoYXQgc29tZXRpbWVzIGJyZWFrcyBzZXJpZXMgb2YgbXVsdGlwbGUgZWRpdHMgbWFkZSBmb3IgYSBzaW5nbGVcbiAgICAgICAgLy8gdXNlciBhY3Rpb24gb24gc29tZSBBbmRyb2lkIGtleWJvYXJkcylcbiAgICAgICAgdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgdGhlIGZhY3QgdGhhdCBFZGl0Q29udGV4dCBkb2VzIG5vdCByZXNwb25kXG4gICAgICAgIC8vIHdlbGwgdG8gaGF2aW5nIGl0cyBjb250ZW50IHVwZGF0ZWQgZHVyaW5nIGEgY29tcG9zaXRpb24gKHNlZSAjMTQ3MilcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2V0UmFuZ2Uodmlldy5zdGF0ZSk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5lZGl0Q29udGV4dCA9IG5ldyB3aW5kb3cuRWRpdENvbnRleHQoe1xuICAgICAgICAgICAgdGV4dDogdmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcodGhpcy5mcm9tLCB0aGlzLnRvKSxcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiB0aGlzLnRvQ29udGV4dFBvcyhNYXRoLm1heCh0aGlzLmZyb20sIE1hdGgubWluKHRoaXMudG8sIHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yKSkpLFxuICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiB0aGlzLnRvQ29udGV4dFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnRleHR1cGRhdGUgPSBlID0+IHtcbiAgICAgICAgICAgIGxldCBtYWluID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgeyBhbmNob3IsIGhlYWQgfSA9IG1haW47XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG9FZGl0b3JQb3MoZS51cGRhdGVSYW5nZVN0YXJ0KSwgdG8gPSB0aGlzLnRvRWRpdG9yUG9zKGUudXBkYXRlUmFuZ2VFbmQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJiAhdGhpcy5jb21wb3NpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSB7IGNvbnRleHRCYXNlOiBlLnVwZGF0ZVJhbmdlU3RhcnQsIGVkaXRvckJhc2U6IGZyb20sIGRyaWZ0ZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICBsZXQgZGVsZXRlcyA9IHRvIC0gZnJvbSA+IGUudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAvLyBJZiB0aGUgd2luZG93IGRvZXNuJ3QgaW5jbHVkZSB0aGUgYW5jaG9yLCBhc3N1bWUgY2hhbmdlc1xuICAgICAgICAgICAgLy8gYWRqYWNlbnQgdG8gYSBzaWRlIGdvIHVwIHRvIHRoZSBhbmNob3IuXG4gICAgICAgICAgICBpZiAoZnJvbSA9PSB0aGlzLmZyb20gJiYgYW5jaG9yIDwgdGhpcy5mcm9tKVxuICAgICAgICAgICAgICAgIGZyb20gPSBhbmNob3I7XG4gICAgICAgICAgICBlbHNlIGlmICh0byA9PSB0aGlzLnRvICYmIGFuY2hvciA+IHRoaXMudG8pXG4gICAgICAgICAgICAgICAgdG8gPSBhbmNob3I7XG4gICAgICAgICAgICBsZXQgZGlmZiA9IGZpbmREaWZmKHZpZXcuc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pLCBlLnRleHQsIChkZWxldGVzID8gbWFpbi5mcm9tIDogbWFpbi50bykgLSBmcm9tLCBkZWxldGVzID8gXCJlbmRcIiA6IG51bGwpO1xuICAgICAgICAgICAgLy8gRWRpdCBjb250ZXh0cyBzb21ldGltZXMgZmlyZSBlbXB0eSBjaGFuZ2VzXG4gICAgICAgICAgICBpZiAoIWRpZmYpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZSh0aGlzLnRvRWRpdG9yUG9zKGUuc2VsZWN0aW9uU3RhcnQpLCB0aGlzLnRvRWRpdG9yUG9zKGUuc2VsZWN0aW9uRW5kKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzYW1lU2VsUG9zKG5ld1NlbCwgbWFpbikpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IG5ld1NlbCwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGFuZ2UgPSB7IGZyb206IGRpZmYuZnJvbSArIGZyb20sIHRvOiBkaWZmLnRvQSArIGZyb20sXG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBUZXh0Lm9mKGUudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKS5zcGxpdChcIlxcblwiKSkgfTtcbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5tYWMgfHwgYnJvd3Nlci5hbmRyb2lkKSAmJiBjaGFuZ2UuZnJvbSA9PSBoZWFkIC0gMSAmJlxuICAgICAgICAgICAgICAgIC9eXFwuID8kLy50ZXN0KGUudGV4dCkgJiYgdmlldy5jb250ZW50RE9NLmdldEF0dHJpYnV0ZShcImF1dG9jb3JyZWN0XCIpID09IFwib2ZmXCIpXG4gICAgICAgICAgICAgICAgY2hhbmdlID0geyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKFtlLnRleHQucmVwbGFjZShcIi5cIiwgXCIgXCIpXSkgfTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBjaGFuZ2U7XG4gICAgICAgICAgICBpZiAoIXZpZXcuc3RhdGUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TGVuID0gdGhpcy50byAtIHRoaXMuZnJvbSArIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSArIGNoYW5nZS5pbnNlcnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBhcHBseURPTUNoYW5nZUlubmVyKHZpZXcsIGNoYW5nZSwgRWRpdG9yU2VsZWN0aW9uLnNpbmdsZSh0aGlzLnRvRWRpdG9yUG9zKGUuc2VsZWN0aW9uU3RhcnQsIG5ld0xlbiksIHRoaXMudG9FZGl0b3JQb3MoZS5zZWxlY3Rpb25FbmQsIG5ld0xlbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSB0cmFuc2FjdGlvbiBkaWRuJ3QgZmx1c2ggb3VyIGNoYW5nZSwgcmV2ZXJ0IGl0IHNvXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSBjb250ZXh0IGlzIGluIHN5bmMgd2l0aCB0aGUgZWRpdG9yIHN0YXRlIGFnYWluLlxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldmVydFBlbmRpbmcodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24odmlldy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBtaXNzZWQgY29tcG9zaXRpb25lbmQgZXZlbnRzLiBTZWUgaHR0cHM6Ly9kaXNjdXNzLmNvZGVtaXJyb3IubmV0L3QvYS85NTE0XG4gICAgICAgICAgICBpZiAoY2hhbmdlLmZyb20gPCBjaGFuZ2UudG8gJiYgIWNoYW5nZS5pbnNlcnQubGVuZ3RoICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJlxuICAgICAgICAgICAgICAgICEvW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV9dLy50ZXN0KGNvbnRleHQudGV4dC5zbGljZShNYXRoLm1heCgwLCBlLnVwZGF0ZVJhbmdlU3RhcnQgLSAxKSwgTWF0aC5taW4oY29udGV4dC50ZXh0Lmxlbmd0aCwgZS51cGRhdGVSYW5nZVN0YXJ0ICsgMSkpKSlcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kKGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZXJzLmNoYXJhY3RlcmJvdW5kc3VwZGF0ZSA9IGUgPT4ge1xuICAgICAgICAgICAgbGV0IHJlY3RzID0gW10sIHByZXYgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMudG9FZGl0b3JQb3MoZS5yYW5nZVN0YXJ0KSwgZW5kID0gdGhpcy50b0VkaXRvclBvcyhlLnJhbmdlRW5kKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSB2aWV3LmNvb3Jkc0ZvckNoYXIoaSk7XG4gICAgICAgICAgICAgICAgcHJldiA9IChyZWN0ICYmIG5ldyBET01SZWN0KHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHJlY3QuYm90dG9tIC0gcmVjdC50b3ApKVxuICAgICAgICAgICAgICAgICAgICB8fCBwcmV2IHx8IG5ldyBET01SZWN0O1xuICAgICAgICAgICAgICAgIHJlY3RzLnB1c2gocHJldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnVwZGF0ZUNoYXJhY3RlckJvdW5kcyhlLnJhbmdlU3RhcnQsIHJlY3RzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy50ZXh0Zm9ybWF0dXBkYXRlID0gZSA9PiB7XG4gICAgICAgICAgICBsZXQgZGVjbyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgZm9ybWF0IG9mIGUuZ2V0VGV4dEZvcm1hdHMoKSkge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lU3R5bGUgPSBmb3JtYXQudW5kZXJsaW5lU3R5bGUsIHRoaWNrbmVzcyA9IGZvcm1hdC51bmRlcmxpbmVUaGlja25lc3M7XG4gICAgICAgICAgICAgICAgaWYgKCEvbm9uZS9pLnRlc3QobGluZVN0eWxlKSAmJiAhL25vbmUvaS50ZXN0KHRoaWNrbmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSB0aGlzLnRvRWRpdG9yUG9zKGZvcm1hdC5yYW5nZVN0YXJ0KSwgdG8gPSB0aGlzLnRvRWRpdG9yUG9zKGZvcm1hdC5yYW5nZUVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIHZhbHVlcyBjaGFuZ2VkIGZyb20gY2FwaXRhbGl6ZWQgY3VzdG9tIHN0cmluZ3MgdG8gbG93ZXItY2FzZSBDU1Mga2V5d29yZHMgaW4gMjAyNVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gYHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lICR7L15bYS16XS8udGVzdChsaW5lU3R5bGUpID8gbGluZVN0eWxlICsgXCIgXCIgOiBsaW5lU3R5bGUgPT0gXCJEYXNoZWRcIiA/IFwiZGFzaGVkIFwiIDogbGluZVN0eWxlID09IFwiU3F1aWdnbGVcIiA/IFwid2F2eSBcIiA6IFwiXCJ9JHsvdGhpbi9pLnRlc3QodGhpY2tuZXNzKSA/IDEgOiAyfXB4YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY28ucHVzaChEZWNvcmF0aW9uLm1hcmsoeyBhdHRyaWJ1dGVzOiB7IHN0eWxlIH0gfSkucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRFZGl0Q29udGV4dEZvcm1hdHRpbmcub2YoRGVjb3JhdGlvbi5zZXQoZGVjbykpIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gMDtcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuY29tcG9zaXRpb25lbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gLTE7XG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBkcmlmdGVkIH0gPSB0aGlzLmNvbXBvc2luZztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGRyaWZ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGV2ZW50IGluIHRoaXMuaGFuZGxlcnMpXG4gICAgICAgICAgICBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlcnNbZXZlbnRdKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB2aWV3ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZUNvbnRyb2xCb3VuZHModmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCAmJiBzZWwucmFuZ2VDb3VudClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVTZWxlY3Rpb25Cb3VuZHMoc2VsLmdldFJhbmdlQXQoMCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICAgICAgfSB9O1xuICAgIH1cbiAgICBhcHBseUVkaXRzKHVwZGF0ZSkge1xuICAgICAgICBsZXQgb2ZmID0gMCwgYWJvcnQgPSBmYWxzZSwgcGVuZGluZyA9IHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2U7XG4gICAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChmcm9tQSwgdG9BLCBfZnJvbUIsIF90b0IsIGluc2VydCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFib3J0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBkTGVuID0gaW5zZXJ0Lmxlbmd0aCAtICh0b0EgLSBmcm9tQSk7XG4gICAgICAgICAgICBpZiAocGVuZGluZyAmJiB0b0EgPj0gcGVuZGluZy50bykge1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nLmZyb20gPT0gZnJvbUEgJiYgcGVuZGluZy50byA9PSB0b0EgJiYgcGVuZGluZy5pbnNlcnQuZXEoaW5zZXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nID0gdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSA9IG51bGw7IC8vIE1hdGNoXG4gICAgICAgICAgICAgICAgICAgIG9mZiArPSBkTGVuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvICs9IGRMZW47XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIE1pc21hdGNoLCByZXZlcnRcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJ0UGVuZGluZyh1cGRhdGUuc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21BICs9IG9mZjtcbiAgICAgICAgICAgIHRvQSArPSBvZmY7XG4gICAgICAgICAgICBpZiAodG9BIDw9IHRoaXMuZnJvbSkgeyAvLyBCZWZvcmUgdGhlIHdpbmRvd1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSArPSBkTGVuO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gKz0gZExlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21BIDwgdGhpcy50bykgeyAvLyBPdmVybGFwcyB3aXRoIHdpbmRvd1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQSA8IHRoaXMuZnJvbSB8fCB0b0EgPiB0aGlzLnRvIHx8ICh0aGlzLnRvIC0gdGhpcy5mcm9tKSArIGluc2VydC5sZW5ndGggPiAzMDAwMCAvKiBDeFZwLk1heFNpemUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlVGV4dCh0aGlzLnRvQ29udGV4dFBvcyhmcm9tQSksIHRoaXMudG9Db250ZXh0UG9zKHRvQSksIGluc2VydC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvICs9IGRMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gZExlbjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwZW5kaW5nICYmICFhYm9ydClcbiAgICAgICAgICAgIHRoaXMucmV2ZXJ0UGVuZGluZyh1cGRhdGUuc3RhdGUpO1xuICAgICAgICByZXR1cm4gIWFib3J0O1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCByZXZlcnRlZCA9IHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UsIHN0YXJ0U2VsID0gdXBkYXRlLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyAmJlxuICAgICAgICAgICAgKHRoaXMuY29tcG9zaW5nLmRyaWZ0ZWQgfHxcbiAgICAgICAgICAgICAgICAoIXVwZGF0ZS5jaGFuZ2VzLnRvdWNoZXNSYW5nZShzdGFydFNlbC5mcm9tLCBzdGFydFNlbC50bykgJiZcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+ICF0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikgJiYgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKSkpKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcuZHJpZnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZy5lZGl0b3JCYXNlID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMuY29tcG9zaW5nLmVkaXRvckJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmFwcGx5RWRpdHModXBkYXRlKSB8fCAhdGhpcy5yYW5nZUlzVmFsaWQodXBkYXRlLnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCByZXZlcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24odXBkYXRlLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLmdlb21ldHJ5Q2hhbmdlZCB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgdXBkYXRlLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICB9XG4gICAgcmVzZXRSYW5nZShzdGF0ZSkge1xuICAgICAgICBsZXQgeyBoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgdGhpcy5mcm9tID0gTWF0aC5tYXgoMCwgaGVhZCAtIDEwMDAwIC8qIEN4VnAuTWFyZ2luICovKTtcbiAgICAgICAgdGhpcy50byA9IE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIGhlYWQgKyAxMDAwMCAvKiBDeFZwLk1hcmdpbiAqLyk7XG4gICAgfVxuICAgIHJlc2V0KHN0YXRlKSB7XG4gICAgICAgIHRoaXMucmVzZXRSYW5nZShzdGF0ZSk7XG4gICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlVGV4dCgwLCB0aGlzLmVkaXRDb250ZXh0LnRleHQubGVuZ3RoLCBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcodGhpcy5mcm9tLCB0aGlzLnRvKSk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHN0YXRlKTtcbiAgICB9XG4gICAgcmV2ZXJ0UGVuZGluZyhzdGF0ZSkge1xuICAgICAgICBsZXQgcGVuZGluZyA9IHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVRleHQodGhpcy50b0NvbnRleHRQb3MocGVuZGluZy5mcm9tKSwgdGhpcy50b0NvbnRleHRQb3MocGVuZGluZy5mcm9tICsgcGVuZGluZy5pbnNlcnQubGVuZ3RoKSwgc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHBlbmRpbmcuZnJvbSwgcGVuZGluZy50bykpO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgbGV0IHsgbWFpbiB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnRvQ29udGV4dFBvcyhNYXRoLm1heCh0aGlzLmZyb20sIE1hdGgubWluKHRoaXMudG8sIG1haW4uYW5jaG9yKSkpO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy50b0NvbnRleHRQb3MobWFpbi5oZWFkKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdENvbnRleHQuc2VsZWN0aW9uU3RhcnQgIT0gc3RhcnQgfHwgdGhpcy5lZGl0Q29udGV4dC5zZWxlY3Rpb25FbmQgIT0gZW5kKVxuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVTZWxlY3Rpb24oc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHJhbmdlSXNWYWxpZChzdGF0ZSkge1xuICAgICAgICBsZXQgeyBoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgcmV0dXJuICEodGhpcy5mcm9tID4gMCAmJiBoZWFkIC0gdGhpcy5mcm9tIDwgNTAwIC8qIEN4VnAuTWluTWFyZ2luICovIHx8XG4gICAgICAgICAgICB0aGlzLnRvIDwgc3RhdGUuZG9jLmxlbmd0aCAmJiB0aGlzLnRvIC0gaGVhZCA8IDUwMCAvKiBDeFZwLk1pbk1hcmdpbiAqLyB8fFxuICAgICAgICAgICAgdGhpcy50byAtIHRoaXMuZnJvbSA+IDEwMDAwIC8qIEN4VnAuTWFyZ2luICovICogMyk7XG4gICAgfVxuICAgIHRvRWRpdG9yUG9zKGNvbnRleHRQb3MsIGNsaXBMZW4gPSB0aGlzLnRvIC0gdGhpcy5mcm9tKSB7XG4gICAgICAgIGNvbnRleHRQb3MgPSBNYXRoLm1pbihjb250ZXh0UG9zLCBjbGlwTGVuKTtcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNvbXBvc2luZztcbiAgICAgICAgcmV0dXJuIGMgJiYgYy5kcmlmdGVkID8gYy5lZGl0b3JCYXNlICsgKGNvbnRleHRQb3MgLSBjLmNvbnRleHRCYXNlKSA6IGNvbnRleHRQb3MgKyB0aGlzLmZyb207XG4gICAgfVxuICAgIHRvQ29udGV4dFBvcyhlZGl0b3JQb3MpIHtcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNvbXBvc2luZztcbiAgICAgICAgcmV0dXJuIGMgJiYgYy5kcmlmdGVkID8gYy5jb250ZXh0QmFzZSArIChlZGl0b3JQb3MgLSBjLmVkaXRvckJhc2UpIDogZWRpdG9yUG9zIC0gdGhpcy5mcm9tO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBldmVudCBpbiB0aGlzLmhhbmRsZXJzKVxuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZXJzW2V2ZW50XSk7XG4gICAgfVxufVxuXG4vLyBUaGUgZWRpdG9yJ3MgdXBkYXRlIHN0YXRlIG1hY2hpbmUgbG9va3Mgc29tZXRoaW5nIGxpa2UgdGhpczpcbi8vXG4vLyAgICAgSWRsZSBcdTIxOTIgVXBkYXRpbmcgXHUyMUM2IElkbGUgKHVuY2hlY2tlZCkgXHUyMTkyIE1lYXN1cmluZyBcdTIxOTIgSWRsZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx1MjE5MSAgICAgIFx1MjE5M1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVwZGF0aW5nIChtZWFzdXJlKVxuLy9cbi8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gJ0lkbGUnIGFuZCAnSWRsZSAodW5jaGVja2VkKScgbGllcyBpblxuLy8gd2hldGhlciBhIGxheW91dCBjaGVjayBoYXMgYmVlbiBzY2hlZHVsZWQuIEEgcmVndWxhciB1cGRhdGUgdGhyb3VnaFxuLy8gdGhlIGB1cGRhdGVgIG1ldGhvZCB1cGRhdGVzIHRoZSBET00gaW4gYSB3cml0ZS1vbmx5IGZhc2hpb24sIGFuZFxuLy8gcmVsaWVzIG9uIGEgY2hlY2sgKHNjaGVkdWxlZCB3aXRoIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKSB0byBtYWtlXG4vLyBzdXJlIGV2ZXJ5dGhpbmcgaXMgd2hlcmUgaXQgc2hvdWxkIGJlIGFuZCB0aGUgdmlld3BvcnQgY292ZXJzIHRoZVxuLy8gdmlzaWJsZSBjb2RlLiBUaGF0IGNoZWNrIGNvbnRpbnVlcyB0byBtZWFzdXJlIGFuZCB0aGVuIG9wdGlvbmFsbHlcbi8vIHVwZGF0ZSB1bnRpbCBpdCByZWFjaGVzIGEgY29oZXJlbnQgc3RhdGUuXG4vKipcbkFuIGVkaXRvciB2aWV3IHJlcHJlc2VudHMgdGhlIGVkaXRvcidzIHVzZXIgaW50ZXJmYWNlLiBJdCBob2xkc1xudGhlIGVkaXRhYmxlIERPTSBzdXJmYWNlLCBhbmQgcG9zc2libHkgb3RoZXIgZWxlbWVudHMgc3VjaCBhcyB0aGVcbmxpbmUgbnVtYmVyIGd1dHRlci4gSXQgaGFuZGxlcyBldmVudHMgYW5kIGRpc3BhdGNoZXMgc3RhdGVcbnRyYW5zYWN0aW9ucyBmb3IgZWRpdGluZyBhY3Rpb25zLlxuKi9cbmNsYXNzIEVkaXRvclZpZXcge1xuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnN0YXRlOyB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBkaXNwbGF5IGxhcmdlIGRvY3VtZW50cyB3aXRob3V0IGNvbnN1bWluZyB0b28gbXVjaFxuICAgIG1lbW9yeSBvciBvdmVybG9hZGluZyB0aGUgYnJvd3NlciwgQ29kZU1pcnJvciBvbmx5IGRyYXdzIHRoZVxuICAgIGNvZGUgdGhhdCBpcyB2aXNpYmxlIChwbHVzIGEgbWFyZ2luIGFyb3VuZCBpdCkgdG8gdGhlIERPTS4gVGhpc1xuICAgIHByb3BlcnR5IHRlbGxzIHlvdSB0aGUgZXh0ZW50IG9mIHRoZSBjdXJyZW50IGRyYXduIHZpZXdwb3J0LCBpblxuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0OyB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBhcmUsIGZvciBleGFtcGxlLCBsYXJnZSBjb2xsYXBzZWQgcmFuZ2VzIGluIHRoZVxuICAgIHZpZXdwb3J0LCBpdHMgc2l6ZSBjYW4gYmUgYSBsb3QgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCB2aXNpYmxlXG4gICAgY29udGVudC4gVGh1cywgaWYgeW91IGFyZSBkb2luZyBzb21ldGhpbmcgbGlrZSBzdHlsaW5nIHRoZVxuICAgIGNvbnRlbnQgaW4gdGhlIHZpZXdwb3J0LCBpdCBpcyBwcmVmZXJhYmxlIHRvIG9ubHkgZG8gc28gZm9yXG4gICAgdGhlc2UgcmFuZ2VzLCB3aGljaCBhcmUgdGhlIHN1YnNldCBvZiB0aGUgdmlld3BvcnQgdGhhdCBpc1xuICAgIGFjdHVhbGx5IGRyYXduLlxuICAgICovXG4gICAgZ2V0IHZpc2libGVSYW5nZXMoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aXNpYmxlUmFuZ2VzOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBmYWxzZSB3aGVuIHRoZSBlZGl0b3IgaXMgZW50aXJlbHkgc2Nyb2xsZWQgb3V0IG9mIHZpZXdcbiAgICBvciBvdGhlcndpc2UgaGlkZGVuLlxuICAgICovXG4gICAgZ2V0IGluVmlldygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmluVmlldzsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBjb21wb3NpbmcgdGV4dCB2aWFcbiAgICBbSU1FXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnB1dF9tZXRob2QpLCBhbmQgYXQgbGVhc3RcbiAgICBvbmUgY2hhbmdlIGhhcyBiZWVuIG1hZGUgaW4gdGhlIGN1cnJlbnQgY29tcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gISF0aGlzLmlucHV0U3RhdGUgJiYgdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+IDA7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgaW4gY29tcG9zaW5nIHN0YXRlLiBOb3RlXG4gICAgdGhhdCBvbiBzb21lIHBsYXRmb3JtcywgbGlrZSBBbmRyb2lkLCB0aGlzIHdpbGwgYmUgdGhlIGNhc2UgYVxuICAgIGxvdCwgc2luY2UganVzdCBwdXR0aW5nIHRoZSBjdXJzb3Igb24gYSB3b3JkIHN0YXJ0cyBhXG4gICAgY29tcG9zaXRpb24gdGhlcmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaXRpb25TdGFydGVkKCkgeyByZXR1cm4gISF0aGlzLmlucHV0U3RhdGUgJiYgdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IG9yIHNoYWRvdyByb290IHRoYXQgdGhlIHZpZXcgbGl2ZXMgaW4uXG4gICAgKi9cbiAgICBnZXQgcm9vdCgpIHsgcmV0dXJuIHRoaXMuX3Jvb3Q7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB3aW4oKSB7IHJldHVybiB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdzsgfVxuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5ldyB2aWV3LiBZb3UnbGwgd2FudCB0byBlaXRoZXIgcHJvdmlkZSBhIGBwYXJlbnRgXG4gICAgb3B0aW9uLCBvciBwdXQgYHZpZXcuZG9tYCBpbnRvIHlvdXIgZG9jdW1lbnQgYWZ0ZXIgY3JlYXRpbmcgYVxuICAgIHZpZXcsIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHNlZSB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5NYXAgPSBuZXcgTWFwO1xuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0ge307XG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0ge307XG4gICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS50YWJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5jbGFzc05hbWUgPSBcImNtLXNjcm9sbGVyXCI7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLmNsYXNzTmFtZSA9IFwiY20tYW5ub3VuY2VkXCI7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuYW5ub3VuY2VET00pO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbERPTSk7XG4gICAgICAgIGlmIChjb25maWcucGFyZW50KVxuICAgICAgICAgICAgY29uZmlnLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgIGxldCB7IGRpc3BhdGNoIH0gPSBjb25maWc7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbnMgPSBjb25maWcuZGlzcGF0Y2hUcmFuc2FjdGlvbnMgfHxcbiAgICAgICAgICAgIChkaXNwYXRjaCAmJiAoKHRycykgPT4gdHJzLmZvckVhY2godHIgPT4gZGlzcGF0Y2godHIsIHRoaXMpKSkpIHx8XG4gICAgICAgICAgICAoKHRycykgPT4gdGhpcy51cGRhdGUodHJzKSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSAoY29uZmlnLnJvb3QgfHwgZ2V0Um9vdChjb25maWcucGFyZW50KSB8fCBkb2N1bWVudCk7XG4gICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShjb25maWcuc3RhdGUgfHwgRWRpdG9yU3RhdGUuY3JlYXRlKGNvbmZpZykpO1xuICAgICAgICBpZiAoY29uZmlnLnNjcm9sbFRvICYmIGNvbmZpZy5zY3JvbGxUby5pcyhzY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBjb25maWcuc2Nyb2xsVG8udmFsdWUuY2xpcCh0aGlzLnZpZXdTdGF0ZS5zdGF0ZSk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMuc3RhdGUuZmFjZXQodmlld1BsdWdpbikubWFwKHNwZWMgPT4gbmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi51cGRhdGUodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZSA9IG5ldyBJbnB1dFN0YXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmICgoX2EgPSBkb2N1bWVudC5mb250cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5KVxuICAgICAgICAgICAgZG9jdW1lbnQuZm9udHMucmVhZHkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzcGF0Y2goLi4uaW5wdXQpIHtcbiAgICAgICAgbGV0IHRycyA9IGlucHV0Lmxlbmd0aCA9PSAxICYmIGlucHV0WzBdIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24gPyBpbnB1dFxuICAgICAgICAgICAgOiBpbnB1dC5sZW5ndGggPT0gMSAmJiBBcnJheS5pc0FycmF5KGlucHV0WzBdKSA/IGlucHV0WzBdXG4gICAgICAgICAgICAgICAgOiBbdGhpcy5zdGF0ZS51cGRhdGUoLi4uaW5wdXQpXTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9ucyh0cnMsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiB0cmFuc2FjdGlvbnMuIFRoaXMgd2lsbFxuICAgIHVwZGF0ZSB0aGUgdmlzaWJsZSBkb2N1bWVudCBhbmQgc2VsZWN0aW9uIHRvIG1hdGNoIHRoZSBzdGF0ZVxuICAgIHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbnMsIGFuZCBub3RpZnkgdmlldyBwbHVnaW5zIG9mIHRoZVxuICAgIGNoYW5nZS4gWW91IHNob3VsZCB1c3VhbGx5IGNhbGxcbiAgICBbYGRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpIGluc3RlYWQsIHdoaWNoIHVzZXMgdGhpc1xuICAgIGFzIGEgcHJpbWl0aXZlLlxuICAgICovXG4gICAgdXBkYXRlKHRyYW5zYWN0aW9ucykge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSAhPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxscyB0byBFZGl0b3JWaWV3LnVwZGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICBsZXQgcmVkcmF3biA9IGZhbHNlLCBhdHRyc0NoYW5nZWQgPSBmYWxzZSwgdXBkYXRlO1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0ci5zdGFydFN0YXRlICE9IHN0YXRlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIHVwZGF0ZSBzdGF0ZSB3aXRoIGEgdHJhbnNhY3Rpb24gdGhhdCBkb2Vzbid0IHN0YXJ0IGZyb20gdGhlIHByZXZpb3VzIHN0YXRlLlwiKTtcbiAgICAgICAgICAgIHN0YXRlID0gdHIuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb2N1cyA9IHRoaXMuaGFzRm9jdXMsIGZvY3VzRmxhZyA9IDAsIGRpc3BhdGNoRm9jdXMgPSBudWxsO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuYW5ub3RhdGlvbihpc0ZvY3VzQ2hhbmdlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIC8vIElmIGEgZm9jdXMtY2hhbmdlIHRyYW5zYWN0aW9uIGlzIGJlaW5nIGRpc3BhdGNoZWQsIHNldCB0aGlzIHVwZGF0ZSBmbGFnLlxuICAgICAgICAgICAgZm9jdXNGbGFnID0gMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvY3VzICE9IHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgc2VwYXJhdGUgZm9jdXMgdHJhbnNhY3Rpb24gaWYgbmVjZXNzYXJ5LCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGFkZCBhIGZsYWcgdG8gdGhpcyB1cGRhdGVcbiAgICAgICAgICAgIGRpc3BhdGNoRm9jdXMgPSBmb2N1c0NoYW5nZVRyYW5zYWN0aW9uKHN0YXRlLCBmb2N1cyk7XG4gICAgICAgICAgICBpZiAoIWRpc3BhdGNoRm9jdXMpXG4gICAgICAgICAgICAgICAgZm9jdXNGbGFnID0gMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHBlbmRpbmcgRE9NIGNoYW5nZSwgZWFnZXJseSByZWFkIGl0IGFuZCB0cnkgdG9cbiAgICAgICAgLy8gYXBwbHkgaXQgYWZ0ZXIgdGhlIGdpdmVuIHRyYW5zYWN0aW9ucy5cbiAgICAgICAgbGV0IHBlbmRpbmdLZXkgPSB0aGlzLm9ic2VydmVyLmRlbGF5ZWRBbmRyb2lkS2V5LCBkb21DaGFuZ2UgPSBudWxsO1xuICAgICAgICBpZiAocGVuZGluZ0tleSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5jbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCk7XG4gICAgICAgICAgICBkb21DaGFuZ2UgPSB0aGlzLm9ic2VydmVyLnJlYWRDaGFuZ2UoKTtcbiAgICAgICAgICAgIC8vIE9ubHkgdHJ5IHRvIGFwcGx5IERPTSBjaGFuZ2VzIGlmIHRoZSB0cmFuc2FjdGlvbnMgZGlkbid0XG4gICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIGRvYyBvciBzZWxlY3Rpb24uXG4gICAgICAgICAgICBpZiAoZG9tQ2hhbmdlICYmICF0aGlzLnN0YXRlLmRvYy5lcShzdGF0ZS5kb2MpIHx8ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgcGhyYXNlcyBjaGFuZ2UsIHJlZHJhdyB0aGUgZWRpdG9yXG4gICAgICAgIGlmIChzdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSAhPSB0aGlzLnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICB1cGRhdGUgPSBWaWV3VXBkYXRlLmNyZWF0ZSh0aGlzLCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICAgICAgdXBkYXRlLmZsYWdzIHw9IGZvY3VzRmxhZztcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldCA9IHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0Lm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAodHIuc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgbWFpbiB9ID0gdHIuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBuZXcgU2Nyb2xsVGFyZ2V0KG1haW4uZW1wdHkgPyBtYWluIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihtYWluLmhlYWQsIG1haW4uaGVhZCA+IG1haW4uYW5jaG9yID8gLTEgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuaXMoc2Nyb2xsSW50b1ZpZXcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gZS52YWx1ZS5jbGlwKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUudXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gQ2FjaGVkT3JkZXIudXBkYXRlKHRoaXMuYmlkaUNhY2hlLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSkgIT0gdGhpcy5zdHlsZU1vZHVsZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICAgICAgYXR0cnNDaGFuZ2VkID0gdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgdGhpcy5zaG93QW5ub3VuY2VtZW50cyh0cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbihyZWRyYXduLCB0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5pc1VzZXJFdmVudChcInNlbGVjdC5wb2ludGVyXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldCh0aGVtZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHRoZW1lKSlcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIGlmIChyZWRyYXduIHx8IGF0dHJzQ2hhbmdlZCB8fCBzY3JvbGxUYXJnZXQgfHwgdGhpcy52aWV3U3RhdGUubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgdGhpcy5kb2NWaWV3VXBkYXRlKCk7XG4gICAgICAgIGlmICghdXBkYXRlLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSwgXCJ1cGRhdGUgbGlzdGVuZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGF0Y2hGb2N1cyB8fCBkb21DaGFuZ2UpXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2hGb2N1cyAmJiB0aGlzLnN0YXRlID09IGRpc3BhdGNoRm9jdXMuc3RhcnRTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChkaXNwYXRjaEZvY3VzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXBwbHlET01DaGFuZ2UodGhpcywgZG9tQ2hhbmdlKSAmJiBwZW5kaW5nS2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodGhpcy5jb250ZW50RE9NLCBwZW5kaW5nS2V5LmtleSwgcGVuZGluZ0tleS5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgdGhlIHZpZXcgdG8gdGhlIGdpdmVuIHN0YXRlLiAoVGhpcyB3aWxsIGNhdXNlIHRoZSBlbnRpcmVcbiAgICBkb2N1bWVudCB0byBiZSByZWRyYXduIGFuZCBhbGwgdmlldyBwbHVnaW5zIHRvIGJlIHJlaW5pdGlhbGl6ZWQsXG4gICAgc28geW91IHNob3VsZCBwcm9iYWJseSBvbmx5IHVzZSBpdCB3aGVuIHRoZSBuZXcgc3RhdGUgaXNuJ3RcbiAgICBkZXJpdmVkIGZyb20gdGhlIG9sZCBzdGF0ZS4gT3RoZXJ3aXNlLCB1c2VcbiAgICBbYGRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpIGluc3RlYWQuKVxuICAgICovXG4gICAgc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy5zZXRTdGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgIGxldCBoYWRGb2N1cyA9IHRoaXMuaGFzRm9jdXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUgPSBuZXcgVmlld1N0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucyA9IG5ld1N0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5jbGVhcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFkRm9jdXMpXG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2lucyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZTcGVjcyA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLCBzcGVjcyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcykge1xuICAgICAgICAgICAgbGV0IG5ld1BsdWdpbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBwcmV2U3BlY3MuaW5kZXhPZihzcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubXVzdFVwZGF0ZSAhPSB1cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwLm11c3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnBsdWdpbnNbaV0udXBkYXRlKHRoaXMpO1xuICAgICAgICBpZiAocHJldlNwZWNzICE9IHNwZWNzKVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgfVxuICAgIGRvY1ZpZXdVcGRhdGUoKSB7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBwbHVnaW4udmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsICYmIHZhbC5kb2NWaWV3VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRvY1ZpZXdVcGRhdGUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlLCBcImRvYyB2aWV3IHVwZGF0ZSBsaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtZWFzdXJlKGZsdXNoID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLmRlbGF5ZWRBbmRyb2lkS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAwOyAvLyBQcmV2ZW50IHJlcXVlc3RNZWFzdXJlIGNhbGxzIGZyb20gc2NoZWR1bGluZyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBpZiAoZmx1c2gpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICBsZXQgc0RPTSA9IHRoaXMuc2Nyb2xsRE9NLCBzY3JvbGxUb3AgPSBzRE9NLnNjcm9sbFRvcCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsZXQgeyBzY3JvbGxBbmNob3JQb3MsIHNjcm9sbEFuY2hvckhlaWdodCB9ID0gdGhpcy52aWV3U3RhdGU7XG4gICAgICAgIGlmIChNYXRoLmFicyhzY3JvbGxUb3AgLSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUb3ApID4gMSlcbiAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbEFuY2hvckhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2Nyb2xsZWRUb0JvdHRvbShzRE9NKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9yUG9zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvclBvcyA9IGJsb2NrLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSBibG9jay50b3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDEgLyogVXBkYXRlU3RhdGUuTWVhc3VyaW5nICovO1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy52aWV3U3RhdGUubWVhc3VyZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgIXRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCAmJiB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJNZWFzdXJlIGxvb3AgcmVzdGFydGVkIG1vcmUgdGhhbiA1IHRpbWVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJWaWV3cG9ydCBmYWlsZWQgdG8gc3RhYmlsaXplXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmluZyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIG1lYXN1cmUgcmVxdWVzdHMgaW4gdGhpcyBjeWNsZSB3aGVuIHRoZSB2aWV3cG9ydCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKCEoY2hhbmdlZCAmIDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLykpXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLm1lYXN1cmVSZXF1ZXN0cywgbWVhc3VyaW5nXSA9IFttZWFzdXJpbmcsIHRoaXMubWVhc3VyZVJlcXVlc3RzXTtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZWQgPSBtZWFzdXJpbmcubWFwKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ucmVhZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhZE1lYXN1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgdGhpcy5zdGF0ZSwgW10pLCByZWRyYXduID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZHJhd24pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXdVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWFzdXJpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZFtpXSAhPSBCYWRNZWFzdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWVhc3VyaW5nW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLndyaXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLndyaXRlKG1lYXN1cmVkW2ldLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhd24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUudmlld3BvcnRDaGFuZ2VkICYmIHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcuc2Nyb2xsSW50b1ZpZXcodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0FuY2hvckhlaWdodCA9IHNjcm9sbEFuY2hvclBvcyA8IDAgPyB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRNYXAuaGVpZ2h0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQoc2Nyb2xsQW5jaG9yUG9zKS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmYgPSBuZXdBbmNob3JIZWlnaHQgLSBzY3JvbGxBbmNob3JIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAxIHx8IGRpZmYgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3AgPSBzY3JvbGxUb3AgKyBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzRE9NLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCAvIHRoaXMuc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCAmJiAhdXBkYXRlZC5lbXB0eSlcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGUuZmFjZXQodXBkYXRlTGlzdGVuZXIpKVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHVwZGF0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIENTUyBjbGFzc2VzIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZGl0b3IgdGhlbWVzLlxuICAgICovXG4gICAgZ2V0IHRoZW1lQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VUaGVtZUlEICsgXCIgXCIgK1xuICAgICAgICAgICAgKHRoaXMuc3RhdGUuZmFjZXQoZGFya1RoZW1lKSA/IGJhc2VEYXJrSUQgOiBiYXNlTGlnaHRJRCkgKyBcIiBcIiArXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmZhY2V0KHRoZW1lKTtcbiAgICB9XG4gICAgdXBkYXRlQXR0cnMoKSB7XG4gICAgICAgIGxldCBlZGl0b3JBdHRycyA9IGF0dHJzRnJvbUZhY2V0KHRoaXMsIGVkaXRvckF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWVkaXRvclwiICsgKHRoaXMuaGFzRm9jdXMgPyBcIiBjbS1mb2N1c2VkIFwiIDogXCIgXCIpICsgdGhpcy50aGVtZUNsYXNzZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjb250ZW50QXR0cnMgPSB7XG4gICAgICAgICAgICBzcGVsbGNoZWNrOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBhdXRvY29ycmVjdDogXCJvZmZcIixcbiAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiBcIm9mZlwiLFxuICAgICAgICAgICAgd3JpdGluZ3N1Z2dlc3Rpb25zOiBcImZhbHNlXCIsXG4gICAgICAgICAgICB0cmFuc2xhdGU6IFwibm9cIixcbiAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogIXRoaXMuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gXCJmYWxzZVwiIDogXCJ0cnVlXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1jb250ZW50XCIsXG4gICAgICAgICAgICBzdHlsZTogYCR7YnJvd3Nlci50YWJTaXplfTogJHt0aGlzLnN0YXRlLnRhYlNpemV9YCxcbiAgICAgICAgICAgIHJvbGU6IFwidGV4dGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiBcInRydWVcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIGNvbnRlbnRBdHRyc1tcImFyaWEtcmVhZG9ubHlcIl0gPSBcInRydWVcIjtcbiAgICAgICAgYXR0cnNGcm9tRmFjZXQodGhpcywgY29udGVudEF0dHJpYnV0ZXMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRDb250ZW50ID0gdXBkYXRlQXR0cnModGhpcy5jb250ZW50RE9NLCB0aGlzLmNvbnRlbnRBdHRycywgY29udGVudEF0dHJzKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkRWRpdG9yID0gdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMuZWRpdG9yQXR0cnMsIGVkaXRvckF0dHJzKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkQ29udGVudCB8fCBjaGFuZ2VkRWRpdG9yO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IGVkaXRvckF0dHJzO1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IGNvbnRlbnRBdHRycztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIHNob3dBbm5vdW5jZW1lbnRzKHRycykge1xuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKEVkaXRvclZpZXcuYW5ub3VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VET00udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gdGhpcy5hbm5vdW5jZURPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnRleHRDb250ZW50ID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICB9XG4gICAgbW91bnRTdHlsZXMoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVNb2R1bGVzID0gdGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSk7XG4gICAgICAgIGxldCBub25jZSA9IHRoaXMuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5jc3BOb25jZSk7XG4gICAgICAgIFN0eWxlTW9kdWxlLm1vdW50KHRoaXMucm9vdCwgdGhpcy5zdHlsZU1vZHVsZXMuY29uY2F0KGJhc2VUaGVtZSQxKS5yZXZlcnNlKCksIG5vbmNlID8geyBub25jZSB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmVhZE1lYXN1cmVkKCkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhZGluZyB0aGUgZWRpdG9yIGxheW91dCBpc24ndCBhbGxvd2VkIGR1cmluZyBhbiB1cGRhdGVcIik7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLyAmJiB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZShmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNjaGVkdWxlIGEgbGF5b3V0IG1lYXN1cmVtZW50LCBvcHRpb25hbGx5IHByb3ZpZGluZyBjYWxsYmFja3MgdG9cbiAgICBkbyBjdXN0b20gRE9NIG1lYXN1cmluZyBmb2xsb3dlZCBieSBhIERPTSB3cml0ZSBwaGFzZS4gVXNpbmdcbiAgICB0aGlzIGlzIHByZWZlcmFibGUgcmVhZGluZyBET00gbGF5b3V0IGRpcmVjdGx5IGZyb20sIGZvclxuICAgIGV4YW1wbGUsIGFuIGV2ZW50IGhhbmRsZXIsIGJlY2F1c2UgaXQnbGwgbWFrZSBzdXJlIG1lYXN1cmluZyBhbmRcbiAgICBkcmF3aW5nIGRvbmUgYnkgb3RoZXIgY29tcG9uZW50cyBpcyBzeW5jaHJvbml6ZWQsIGF2b2lkaW5nXG4gICAgdW5uZWNlc3NhcnkgRE9NIGxheW91dCBjb21wdXRhdGlvbnMuXG4gICAgKi9cbiAgICByZXF1ZXN0TWVhc3VyZShyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPCAwKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gdGhpcy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMubWVhc3VyZSgpKTtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0cy5pbmRleE9mKHJlcXVlc3QpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Qua2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZWFzdXJlUmVxdWVzdHNbaV0ua2V5ID09PSByZXF1ZXN0LmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHNbaV0gPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWMgcGx1Z2luLCBpZiBwcmVzZW50LiBOb3RlIHRoYXRcbiAgICBwbHVnaW5zIHRoYXQgY3Jhc2ggY2FuIGJlIGRyb3BwZWQgZnJvbSBhIHZpZXcsIHNvIGV2ZW4gd2hlbiB5b3VcbiAgICBrbm93IHlvdSByZWdpc3RlcmVkIGEgZ2l2ZW4gcGx1Z2luLCBpdCBpcyByZWNvbW1lbmRlZCB0byBjaGVja1xuICAgIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBtZXRob2QuXG4gICAgKi9cbiAgICBwbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGxldCBrbm93biA9IHRoaXMucGx1Z2luTWFwLmdldChwbHVnaW4pO1xuICAgICAgICBpZiAoa25vd24gPT09IHVuZGVmaW5lZCB8fCBrbm93biAmJiBrbm93bi5wbHVnaW4gIT0gcGx1Z2luKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuc2V0KHBsdWdpbiwga25vd24gPSB0aGlzLnBsdWdpbnMuZmluZChwID0+IHAucGx1Z2luID09IHBsdWdpbikgfHwgbnVsbCk7XG4gICAgICAgIHJldHVybiBrbm93biAmJiBrbm93bi51cGRhdGUodGhpcykudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGRvY3VtZW50LCBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuIFRoaXNcbiAgICBtYXkgYmUgbmVnYXRpdmUgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGVkIGRvd24uIFBvaW50c1xuICAgIGRpcmVjdGx5IHRvIHRoZSB0b3Agb2YgdGhlIGZpcnN0IGxpbmUsIG5vdCBhYm92ZSB0aGUgcGFkZGluZy5cbiAgICAqL1xuICAgIGdldCBkb2N1bWVudFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBvcnRzIHRoZSBwYWRkaW5nIGFib3ZlIGFuZCBiZWxvdyB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3AsIGJvdHRvbTogdGhpcy52aWV3U3RhdGUucGFkZGluZ0JvdHRvbSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBJZiB0aGUgZWRpdG9yIGlzIHRyYW5zZm9ybWVkIHdpdGggQ1NTLCB0aGlzIHByb3ZpZGVzIHRoZSBzY2FsZVxuICAgIGFsb25nIHRoZSBYIGF4aXMuIE90aGVyd2lzZSwgaXQgd2lsbCBqdXN0IGJlIDEuIE5vdGUgdGhhdFxuICAgIHRyYW5zZm9ybXMgb3RoZXIgdGhhbiB0cmFuc2xhdGlvbiBhbmQgc2NhbGluZyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAqL1xuICAgIGdldCBzY2FsZVgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVg7IH1cbiAgICAvKipcbiAgICBQcm92aWRlIHRoZSBDU1MgdHJhbnNmb3JtZWQgc2NhbGUgYWxvbmcgdGhlIFkgYXhpcy5cbiAgICAqL1xuICAgIGdldCBzY2FsZVkoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVk7IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGxpbmUgb3IgYmxvY2sgd2lkZ2V0IGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbFxuICAgIHBvc2l0aW9uICh3aGljaCBpcyBpbnRlcnByZXRlZCBhcyByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApKS5cbiAgICAqL1xuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmVsZW1lbnRBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIGJsb2NrIChzZWVcbiAgICBbYGxpbmVCbG9ja0F0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpKSBhdCB0aGUgZ2l2ZW5cbiAgICBoZWlnaHQsIGFnYWluIGludGVycHJldGVkIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50IGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhbGwgW2xpbmVcbiAgICBibG9ja3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBpbiB0aGUgdmlld3BvcnQuIFBvc2l0aW9uc1xuICAgIGFyZSByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0TGluZUJsb2NrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0TGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgYXJvdW5kIHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gQSBsaW5lXG4gICAgYmxvY2sgaXMgYSByYW5nZSBkZWxpbWl0ZWQgb24gYm90aCBzaWRlcyBieSBlaXRoZXIgYVxuICAgIG5vbi1baGlkZGVuXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBsaW5lIGJyZWFrLCBvciB0aGVcbiAgICBzdGFydC9lbmQgb2YgdGhlIGRvY3VtZW50LiBJdCB3aWxsIHVzdWFsbHkganVzdCBob2xkIGEgbGluZSBvZlxuICAgIHRleHQsIGJ1dCBtYXkgYmUgYnJva2VuIGludG8gbXVsdGlwbGUgdGV4dGJsb2NrcyBieSBibG9ja1xuICAgIHdpZGdldHMuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IncyB0b3RhbCBjb250ZW50IGhlaWdodC5cbiAgICAqL1xuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuY29udGVudEhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBieSBbZ3JhcGhlbWVcbiAgICBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspLiBgZm9yd2FyZGAgZGV0ZXJtaW5lcyB3aGV0aGVyXG4gICAgdGhlIG1vdGlvbiBpcyBhd2F5IGZyb20gdGhlIGxpbmUgc3RhcnQsIG9yIHRvd2FyZHMgaXQuIEluXG4gICAgYmlkaXJlY3Rpb25hbCB0ZXh0LCB0aGUgbGluZSBpcyB0cmF2ZXJzZWQgaW4gdmlzdWFsIG9yZGVyLCB1c2luZ1xuICAgIHRoZSBlZGl0b3IncyBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuICAgIFdoZW4gdGhlIHN0YXJ0IHBvc2l0aW9uIHdhcyB0aGUgbGFzdCBvbmUgb24gdGhlIGxpbmUsIHRoZVxuICAgIHJldHVybmVkIHBvc2l0aW9uIHdpbGwgYmUgYWNyb3NzIHRoZSBsaW5lIGJyZWFrLiBJZiB0aGVyZSBpcyBub1xuICAgIGZ1cnRoZXIgbGluZSwgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIG1vdmVzIG92ZXIgYSBzaW5nbGUgY2x1c3Rlci4gVGhlXG4gICAgb3B0aW9uYWwgYGJ5YCBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBtb3ZlIGFjcm9zcyBtb3JlLiBJdCB3aWxsXG4gICAgYmUgY2FsbGVkIHdpdGggdGhlIGZpcnN0IGNsdXN0ZXIgYXMgYXJndW1lbnQsIGFuZCBzaG91bGQgcmV0dXJuXG4gICAgYSBwcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzLCBmb3IgZWFjaCBzdWJzZXF1ZW50IGNsdXN0ZXIsXG4gICAgd2hldGhlciBpdCBzaG91bGQgYWxzbyBiZSBtb3ZlZCBvdmVyLlxuICAgICovXG4gICAgbW92ZUJ5Q2hhcihzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgYnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBhY3Jvc3MgdGhlIG5leHQgZ3JvdXAgb2YgZWl0aGVyXG4gICAgW2xldHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBvciBub24tbGV0dGVyXG4gICAgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIG1vdmVCeUdyb3VwKHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGluaXRpYWwgPT4gYnlHcm91cCh0aGlzLCBzdGFydC5oZWFkLCBpbml0aWFsKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnNvciBwb3NpdGlvbiB2aXN1YWxseSBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbGluZS5cbiAgICBOb3RlIHRoYXQgdGhpcyBtYXkgZGlmZmVyIGZyb20gdGhlIF9sb2dpY2FsXyBwb3NpdGlvbiBhdCBpdHNcbiAgICBzdGFydCBvciBlbmQgKHdoaWNoIGlzIHNpbXBseSBhdCBgbGluZS5mcm9tYC9gbGluZS50b2ApIGlmIHRleHRcbiAgICBhdCB0aGUgc3RhcnQgb3IgZW5kIGdvZXMgYWdhaW5zdCB0aGUgbGluZSdzIGJhc2UgdGV4dCBkaXJlY3Rpb24uXG4gICAgKi9cbiAgICB2aXN1YWxMaW5lU2lkZShsaW5lLCBlbmQpIHtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5iaWRpU3BhbnMobGluZSksIGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBzcGFuID0gb3JkZXJbZW5kID8gb3JkZXIubGVuZ3RoIC0gMSA6IDBdO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzcGFuLnNpZGUoZW5kLCBkaXIpICsgbGluZS5mcm9tLCBzcGFuLmZvcndhcmQoIWVuZCwgZGlyKSA/IDEgOiAtMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeSBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLiBJZlxuICAgIGBpbmNsdWRlV3JhcGAgaXMgdHJ1ZSwgbGluZSB3cmFwcGluZyBpcyBvbiwgYW5kIHRoZXJlIGlzIGFcbiAgICBmdXJ0aGVyIHdyYXAgcG9pbnQgb24gdGhlIGN1cnJlbnQgbGluZSwgdGhlIHdyYXAgcG9pbnQgd2lsbCBiZVxuICAgIHJldHVybmVkLiBPdGhlcndpc2UgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc3RhcnQgb3IgZW5kXG4gICAgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBtb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbW92ZVRvTGluZUJvdW5kYXJ5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gdmVydGljYWxseS4gV2hlbiBgZGlzdGFuY2VgIGlzbid0IGdpdmVuLFxuICAgIGl0IGRlZmF1bHRzIHRvIG1vdmluZyB0byB0aGUgbmV4dCBsaW5lIChpbmNsdWRpbmcgd3JhcHBlZFxuICAgIGxpbmVzKS4gT3RoZXJ3aXNlLCBgZGlzdGFuY2VgIHNob3VsZCBwcm92aWRlIGEgcG9zaXRpdmUgZGlzdGFuY2VcbiAgICBpbiBwaXhlbHMuXG4gICAgXG4gICAgV2hlbiBgc3RhcnRgIGhhcyBhXG4gICAgW2Bnb2FsQ29sdW1uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5nb2FsQ29sdW1uKSwgdGhlIHZlcnRpY2FsXG4gICAgbW90aW9uIHdpbGwgdXNlIHRoYXQgYXMgYSB0YXJnZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLFxuICAgIHRoZSBjdXJzb3IncyBvd24gaG9yaXpvbnRhbCBwb3NpdGlvbiBpcyB1c2VkLiBUaGUgcmV0dXJuZWRcbiAgICBjdXJzb3Igd2lsbCBoYXZlIGl0cyBnb2FsIGNvbHVtbiBzZXQgdG8gd2hpY2hldmVyIGNvbHVtbiB3YXNcbiAgICB1c2VkLlxuICAgICovXG4gICAgbW92ZVZlcnRpY2FsbHkoc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVWZXJ0aWNhbGx5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcGFyZW50IG5vZGUgYW5kIG9mZnNldCAoY2hpbGQgb2Zmc2V0IGlmIGBub2RlYCBpc1xuICAgIGFuIGVsZW1lbnQsIGNoYXJhY3RlciBvZmZzZXQgd2hlbiBpdCBpcyBhIHRleHQgbm9kZSkgYXQgdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgXG4gICAgTm90ZSB0aGF0IGZvciBwb3NpdGlvbnMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IGluXG4gICAgYHZpc2libGVSYW5nZXNgLCB0aGUgcmVzdWx0aW5nIERPTSBwb3NpdGlvbiBpc24ndCBuZWNlc3NhcmlseVxuICAgIG1lYW5pbmdmdWwgKGl0IG1heSBqdXN0IHBvaW50IGJlZm9yZSBvciBhZnRlciBhIHBsYWNlaG9sZGVyXG4gICAgZWxlbWVudCkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuZG9tQXRQb3MocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcG9zaXRpb24gYXQgdGhlIGdpdmVuIERPTSBub2RlLiBDYW4gYmUgdXNlZnVsXG4gICAgZm9yIGFzc29jaWF0aW5nIHBvc2l0aW9ucyB3aXRoIERPTSBldmVudHMuIFdpbGwgcmFpc2UgYW4gZXJyb3JcbiAgICB3aGVuIGBub2RlYCBpc24ndCBwYXJ0IG9mIHRoZSBlZGl0b3IgY29udGVudC5cbiAgICAqL1xuICAgIHBvc0F0RE9NKG5vZGUsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICAgIHBvc0F0Q29vcmRzKGNvb3JkcywgcHJlY2lzZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgbGV0IGZvdW5kID0gcG9zQXRDb29yZHModGhpcywgY29vcmRzLCBwcmVjaXNlKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kICYmIGZvdW5kLnBvcztcbiAgICB9XG4gICAgcG9zQW5kU2lkZUF0Q29vcmRzKGNvb3JkcywgcHJlY2lzZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHBvc0F0Q29vcmRzKHRoaXMsIGNvb3JkcywgcHJlY2lzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgc2NyZWVuIGNvb3JkaW5hdGVzIGF0IHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBgc2lkZWAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb29yZGluYXRlcyBhcmUgYmFzZWQgb24gdGhlXG4gICAgZWxlbWVudCBiZWZvcmUgKC0xKSBvciBhZnRlciAoMSkgdGhlIHBvc2l0aW9uIChpZiBubyBlbGVtZW50IGlzXG4gICAgYXZhaWxhYmxlIG9uIHRoZSBnaXZlbiBzaWRlLCB0aGUgbWV0aG9kIHdpbGwgdHJhbnNwYXJlbnRseSB1c2VcbiAgICBhbm90aGVyIHN0cmF0ZWd5IHRvIGdldCByZWFzb25hYmxlIGNvb3JkaW5hdGVzKS5cbiAgICAqL1xuICAgIGNvb3Jkc0F0UG9zKHBvcywgc2lkZSA9IDEpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmRvY1ZpZXcuY29vcmRzQXQocG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKCFyZWN0IHx8IHJlY3QubGVmdCA9PSByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHBvcyksIG9yZGVyID0gdGhpcy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgIGxldCBzcGFuID0gb3JkZXJbQmlkaVNwYW4uZmluZChvcmRlciwgcG9zIC0gbGluZS5mcm9tLCAtMSwgc2lkZSldO1xuICAgICAgICByZXR1cm4gZmxhdHRlblJlY3QocmVjdCwgKHNwYW4uZGlyID09IERpcmVjdGlvbi5MVFIpID09IChzaWRlID4gMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIHJlY3RhbmdsZSBhcm91bmQgYSBnaXZlbiBjaGFyYWN0ZXIuIElmIGBwb3NgIGRvZXMgbm90XG4gICAgcG9pbnQgaW4gZnJvbnQgb2YgYSBjaGFyYWN0ZXIgdGhhdCBpcyBpbiB0aGUgdmlld3BvcnQgYW5kXG4gICAgcmVuZGVyZWQgKGkuZS4gbm90IHJlcGxhY2VkLCBub3QgYSBsaW5lIGJyZWFrKSwgdGhpcyB3aWxsIHJldHVyblxuICAgIG51bGwuIEZvciBzcGFjZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIGEgbGluZSB3cmFwIHBvaW50LCB0aGlzIHdpbGxcbiAgICByZXR1cm4gdGhlIHBvc2l0aW9uIGJlZm9yZSB0aGUgbGluZSBicmVhay5cbiAgICAqL1xuICAgIGNvb3Jkc0ZvckNoYXIocG9zKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuY29vcmRzRm9yQ2hhcihwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCB3aWR0aCBvZiBhIGNoYXJhY3RlciBpbiB0aGUgZWRpdG9yLiBNYXkgbm90XG4gICAgYWNjdXJhdGVseSByZWZsZWN0IHRoZSB3aWR0aCBvZiBhbGwgY2hhcmFjdGVycyAoZ2l2ZW4gdmFyaWFibGVcbiAgICB3aWR0aCBmb250cyBvciBzdHlsaW5nIG9mIGludmlkaWR1YWwgcmFuZ2VzKS5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0Q2hhcmFjdGVyV2lkdGgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUuY2hhcldpZHRoOyB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgaGVpZ2h0IG9mIGEgbGluZSBpbiB0aGUgZWRpdG9yLiBNYXkgbm90IGJlIGFjY3VyYXRlXG4gICAgZm9yIGFsbCBsaW5lcy5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0TGluZUhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgVGhlIHRleHQgZGlyZWN0aW9uXG4gICAgKFtgZGlyZWN0aW9uYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2RpcmVjdGlvbilcbiAgICBDU1MgcHJvcGVydHkpIG9mIHRoZSBlZGl0b3IncyBjb250ZW50IGVsZW1lbnQuXG4gICAgKi9cbiAgICBnZXQgdGV4dERpcmVjdGlvbigpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmRlZmF1bHRUZXh0RGlyZWN0aW9uOyB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGJsb2NrIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYXNcbiAgICBhc3NpZ25lZCBieSBDU1MuIElmXG4gICAgW2BwZXJMaW5lVGV4dERpcmVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnBlckxpbmVUZXh0RGlyZWN0aW9uKVxuICAgIGlzbid0IGVuYWJsZWQsIG9yIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCxcbiAgICB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSBhc1xuICAgIFtgdGV4dERpcmVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLiBOb3RlIHRoYXRcbiAgICB0aGlzIG1heSB0cmlnZ2VyIGEgRE9NIGxheW91dC5cbiAgICAqL1xuICAgIHRleHREaXJlY3Rpb25BdChwb3MpIHtcbiAgICAgICAgbGV0IHBlckxpbmUgPSB0aGlzLnN0YXRlLmZhY2V0KHBlckxpbmVUZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKCFwZXJMaW5lIHx8IHBvcyA8IHRoaXMudmlld3BvcnQuZnJvbSB8fCBwb3MgPiB0aGlzLnZpZXdwb3J0LnRvKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dERpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy50ZXh0RGlyZWN0aW9uQXQocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGlzIGVkaXRvciBbd3JhcHMgbGluZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVXcmFwcGluZylcbiAgICAoYXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICBbYHdoaXRlLXNwYWNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3doaXRlLXNwYWNlKVxuICAgIENTUyBwcm9wZXJ0eSBvZiBpdHMgY29udGVudCBlbGVtZW50KS5cbiAgICAqL1xuICAgIGdldCBsaW5lV3JhcHBpbmcoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgYmlkaXJlY3Rpb25hbCB0ZXh0IHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW4gbGluZVxuICAgICh3aGljaCBzaG91bGQgYmUgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQpIGFzIGFuIGFycmF5IG9mIHNwYW5cbiAgICBvYmplY3RzLiBUaGUgb3JkZXIgb2YgdGhlc2Ugc3BhbnMgbWF0Y2hlcyB0aGUgW3RleHRcbiAgICBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pXHUyMDE0aWYgdGhhdCBpc1xuICAgIGxlZnQtdG8tcmlnaHQsIHRoZSBsZWZ0bW9zdCBzcGFucyBjb21lIGZpcnN0LCBvdGhlcndpc2UgdGhlXG4gICAgcmlnaHRtb3N0IHNwYW5zIGNvbWUgZmlyc3QuXG4gICAgKi9cbiAgICBiaWRpU3BhbnMobGluZSkge1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPiBNYXhCaWRpTGluZSlcbiAgICAgICAgICAgIHJldHVybiB0cml2aWFsT3JkZXIobGluZS5sZW5ndGgpO1xuICAgICAgICBsZXQgZGlyID0gdGhpcy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKSwgaXNvbGF0ZXM7XG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHRoaXMuYmlkaUNhY2hlKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuZnJvbSA9PSBsaW5lLmZyb20gJiYgZW50cnkuZGlyID09IGRpciAmJlxuICAgICAgICAgICAgICAgIChlbnRyeS5mcmVzaCB8fCBpc29sYXRlc0VxKGVudHJ5Lmlzb2xhdGVzLCBpc29sYXRlcyA9IGdldElzb2xhdGVkUmFuZ2VzKHRoaXMsIGxpbmUpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNvbGF0ZXMpXG4gICAgICAgICAgICBpc29sYXRlcyA9IGdldElzb2xhdGVkUmFuZ2VzKHRoaXMsIGxpbmUpO1xuICAgICAgICBsZXQgb3JkZXIgPSBjb21wdXRlT3JkZXIobGluZS50ZXh0LCBkaXIsIGlzb2xhdGVzKTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUucHVzaChuZXcgQ2FjaGVkT3JkZXIobGluZS5mcm9tLCBsaW5lLnRvLCBkaXIsIGlzb2xhdGVzLCB0cnVlLCBvcmRlcikpO1xuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlIGVkaXRvciBoYXMgZm9jdXMuXG4gICAgKi9cbiAgICBnZXQgaGFzRm9jdXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gU2FmYXJpIHJldHVybiBmYWxzZSBmb3IgaGFzRm9jdXMgd2hlbiB0aGUgY29udGV4dCBtZW51IGlzIG9wZW5cbiAgICAgICAgLy8gb3IgY2xvc2luZywgd2hpY2ggbGVhZHMgdXMgdG8gaWdub3JlIHNlbGVjdGlvbiBjaGFuZ2VzIGZyb20gdGhlXG4gICAgICAgIC8vIGNvbnRleHQgbWVudSBiZWNhdXNlIGl0IGxvb2tzIGxpa2UgdGhlIGVkaXRvciBpc24ndCBmb2N1c2VkLlxuICAgICAgICAvLyBUaGlzIGtsdWRnZXMgYXJvdW5kIHRoYXQuXG4gICAgICAgIHJldHVybiAodGhpcy5kb20ub3duZXJEb2N1bWVudC5oYXNGb2N1cygpIHx8IGJyb3dzZXIuc2FmYXJpICYmICgoX2EgPSB0aGlzLmlucHV0U3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q29udGV4dE1lbnUpID4gRGF0ZS5ub3coKSAtIDNlNCkgJiZcbiAgICAgICAgICAgIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuY29udGVudERPTTtcbiAgICB9XG4gICAgLyoqXG4gICAgUHV0IGZvY3VzIG9uIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHRoaXMuY29udGVudERPTSk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIFtyb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvIyN2aWV3LkVkaXRvclZpZXdDb25maWcucm9vdCkgaW4gd2hpY2ggdGhlIGVkaXRvciBsaXZlcy4gVGhpcyBpcyBvbmx5XG4gICAgbmVjZXNzYXJ5IHdoZW4gbW92aW5nIHRoZSBlZGl0b3IncyBleGlzdGluZyBET00gdG8gYSBuZXcgd2luZG93IG9yIHNoYWRvdyByb290LlxuICAgICovXG4gICAgc2V0Um9vdChyb290KSB7XG4gICAgICAgIGlmICh0aGlzLl9yb290ICE9IHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSByb290O1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5zZXRXaW5kb3coKHJvb3Qubm9kZVR5cGUgPT0gOSA/IHJvb3QgOiByb290Lm93bmVyRG9jdW1lbnQpLmRlZmF1bHRWaWV3IHx8IHdpbmRvdyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2xlYW4gdXAgdGhpcyBlZGl0b3IgdmlldywgcmVtb3ZpbmcgaXRzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICBkb2N1bWVudCwgdW5yZWdpc3RlcmluZyBldmVudCBoYW5kbGVycywgYW5kIG5vdGlmeWluZ1xuICAgIHBsdWdpbnMuIFRoZSB2aWV3IGluc3RhbmNlIGNhbiBubyBsb25nZXIgYmUgdXNlZCBhZnRlclxuICAgIGNhbGxpbmcgdGhpcy5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET00uYmx1cigpO1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBlZmZlY3QgdGhhdCBjYW4gYmVcbiAgICBbYWRkZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRvIGEgdHJhbnNhY3Rpb24gdG9cbiAgICBjYXVzZSBpdCB0byBzY3JvbGwgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIHJhbmdlIGludG8gdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBzY3JvbGxJbnRvVmlldyhwb3MsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW50b1ZpZXcub2YobmV3IFNjcm9sbFRhcmdldCh0eXBlb2YgcG9zID09IFwibnVtYmVyXCIgPyBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcykgOiBwb3MsIG9wdGlvbnMueSwgb3B0aW9ucy54LCBvcHRpb25zLnlNYXJnaW4sIG9wdGlvbnMueE1hcmdpbikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYW4gZWZmZWN0IHRoYXQgcmVzZXRzIHRoZSBlZGl0b3IgdG8gaXRzIGN1cnJlbnQgKGF0IHRoZVxuICAgIHRpbWUgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCkgc2Nyb2xsIHBvc2l0aW9uLiBOb3RlIHRoYXQgdGhpc1xuICAgIG9ubHkgYWZmZWN0cyB0aGUgZWRpdG9yJ3Mgb3duIHNjcm9sbGFibGUgZWxlbWVudCwgbm90IHBhcmVudHMuXG4gICAgU2VlIGFsc29cbiAgICBbYEVkaXRvclZpZXdDb25maWcuc2Nyb2xsVG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld0NvbmZpZy5zY3JvbGxUbykuXG4gICAgXG4gICAgVGhlIGVmZmVjdCBzaG91bGQgYmUgdXNlZCB3aXRoIGEgZG9jdW1lbnQgaWRlbnRpY2FsIHRvIHRoZSBvbmVcbiAgICBpdCB3YXMgY3JlYXRlZCBmb3IuIEZhaWxpbmcgdG8gZG8gc28gaXMgbm90IGFuIGVycm9yLCBidXQgbWF5XG4gICAgbm90IHNjcm9sbCB0byB0aGUgZXhwZWN0ZWQgcG9zaXRpb24uIFlvdSBjYW5cbiAgICBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0Lm1hcCkgdGhlIGVmZmVjdCB0byBhY2NvdW50IGZvciBjaGFuZ2VzLlxuICAgICovXG4gICAgc2Nyb2xsU25hcHNob3QoKSB7XG4gICAgICAgIGxldCB7IHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCB9ID0gdGhpcy5zY3JvbGxET007XG4gICAgICAgIGxldCByZWYgPSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxBbmNob3JBdChzY3JvbGxUb3ApO1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW50b1ZpZXcub2YobmV3IFNjcm9sbFRhcmdldChFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJlZi5mcm9tKSwgXCJzdGFydFwiLCBcInN0YXJ0XCIsIHJlZi50b3AgLSBzY3JvbGxUb3AsIHNjcm9sbExlZnQsIHRydWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRW5hYmxlIG9yIGRpc2FibGUgdGFiLWZvY3VzIG1vZGUsIHdoaWNoIGRpc2FibGVzIGtleSBiaW5kaW5nc1xuICAgIGZvciBUYWIgYW5kIFNoaWZ0LVRhYiwgbGV0dGluZyB0aGUgYnJvd3NlcidzIGRlZmF1bHRcbiAgICBmb2N1cy1jaGFuZ2luZyBiZWhhdmlvciBnbyB0aHJvdWdoIGluc3RlYWQuIFRoaXMgaXMgdXNlZnVsIHRvXG4gICAgcHJldmVudCB0cmFwcGluZyBrZXlib2FyZCB1c2VycyBpbiB5b3VyIGVkaXRvci5cbiAgICBcbiAgICBXaXRob3V0IGFyZ3VtZW50LCB0aGlzIHRvZ2dsZXMgdGhlIG1vZGUuIFdpdGggYSBib29sZWFuLCBpdFxuICAgIGVuYWJsZXMgKHRydWUpIG9yIGRpc2FibGVzIGl0IChmYWxzZSkuIEdpdmVuIGEgbnVtYmVyLCBpdFxuICAgIHRlbXBvcmFyaWx5IGVuYWJsZXMgdGhlIG1vZGUgdW50aWwgdGhhdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gICAgaGF2ZSBwYXNzZWQgb3IgYW5vdGhlciBub24tVGFiIGtleSBpcyBwcmVzc2VkLlxuICAgICovXG4gICAgc2V0VGFiRm9jdXNNb2RlKHRvKSB7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSA9IHRoaXMuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgPCAwID8gMCA6IC0xO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdG8gPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudGFiRm9jdXNNb2RlID0gdG8gPyAwIDogLTE7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgIT0gMClcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgPSBEYXRlLm5vdygpICsgdG87XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIERPTSBldmVudCBoYW5kbGVycy5cbiAgICBUaGUgdmFsdWUgc2hvdWxkIGJlIGFuIG9iamVjdCBtYXBwaW5nIGV2ZW50IG5hbWVzIHRvIGhhbmRsZXJcbiAgICBmdW5jdGlvbnMuIEZvciBhbnkgZ2l2ZW4gZXZlbnQsIHN1Y2ggZnVuY3Rpb25zIGFyZSBvcmRlcmVkIGJ5XG4gICAgZXh0ZW5zaW9uIHByZWNlZGVuY2UsIGFuZCB0aGUgZmlyc3QgaGFuZGxlciB0byByZXR1cm4gdHJ1ZSB3aWxsXG4gICAgYmUgYXNzdW1lZCB0byBoYXZlIGhhbmRsZWQgdGhhdCBldmVudCwgYW5kIG5vIG90aGVyIGhhbmRsZXJzIG9yXG4gICAgYnVpbHQtaW4gYmVoYXZpb3Igd2lsbCBiZSBhY3RpdmF0ZWQgZm9yIGl0LiBUaGVzZSBhcmUgcmVnaXN0ZXJlZFxuICAgIG9uIHRoZSBbY29udGVudCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb250ZW50RE9NKSwgZXhjZXB0XG4gICAgZm9yIGBzY3JvbGxgIGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSB0aGVcbiAgICBlZGl0b3IncyBbc2Nyb2xsIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnNjcm9sbERPTSkgb3Igb25lIG9mXG4gICAgaXRzIHBhcmVudCBub2RlcyBpcyBzY3JvbGxlZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkb21FdmVudEhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSgoKSA9PiAoe30pLCB7IGV2ZW50SGFuZGxlcnM6IGhhbmRsZXJzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIERPTSBldmVudCBvYnNlcnZlcnMuIENvbnRyYXJ5XG4gICAgdG8gZXZlbnQgW2hhbmRsZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kb21FdmVudEhhbmRsZXJzKSxcbiAgICBvYnNlcnZlcnMgY2FuJ3QgYmUgcHJldmVudGVkIGZyb20gcnVubmluZyBieSBhIGhpZ2hlci1wcmVjZWRlbmNlXG4gICAgaGFuZGxlciByZXR1cm5pbmcgdHJ1ZS4gVGhleSBhbHNvIGRvbid0IHByZXZlbnQgb3RoZXIgaGFuZGxlcnNcbiAgICBhbmQgb2JzZXJ2ZXJzIGZyb20gcnVubmluZyB3aGVuIHRoZXkgcmV0dXJuIHRydWUsIGFuZCBzaG91bGQgbm90XG4gICAgY2FsbCBgcHJldmVudERlZmF1bHRgLlxuICAgICovXG4gICAgc3RhdGljIGRvbUV2ZW50T2JzZXJ2ZXJzKG9ic2VydmVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudE9ic2VydmVyczogb2JzZXJ2ZXJzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0aGVtZSBleHRlbnNpb24uIFRoZSBmaXJzdCBhcmd1bWVudCBjYW4gYmUgYVxuICAgIFtgc3R5bGUtbW9kYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pXG4gICAgc3R5bGUgc3BlYyBwcm92aWRpbmcgdGhlIHN0eWxlcyBmb3IgdGhlIHRoZW1lLiBUaGVzZSB3aWxsIGJlXG4gICAgcHJlZml4ZWQgd2l0aCBhIGdlbmVyYXRlZCBjbGFzcyBmb3IgdGhlIHN0eWxlLlxuICAgIFxuICAgIEJlY2F1c2UgdGhlIHNlbGVjdG9ycyB3aWxsIGJlIHByZWZpeGVkIHdpdGggYSBzY29wZSBjbGFzcywgcnVsZVxuICAgIHRoYXQgZGlyZWN0bHkgbWF0Y2ggdGhlIGVkaXRvcidzIFt3cmFwcGVyXG4gICAgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9tKVx1MjAxNHRvIHdoaWNoIHRoZSBzY29wZSBjbGFzcyB3aWxsIGJlXG4gICAgYWRkZWRcdTIwMTRuZWVkIHRvIGJlIGV4cGxpY2l0bHkgZGlmZmVyZW50aWF0ZWQgYnkgYWRkaW5nIGFuIGAmYCB0b1xuICAgIHRoZSBzZWxlY3RvciBmb3IgdGhhdCBlbGVtZW50XHUyMDE0Zm9yIGV4YW1wbGVcbiAgICBgJi5jbS1mb2N1c2VkYC5cbiAgICBcbiAgICBXaGVuIGBkYXJrYCBpcyBzZXQgdG8gdHJ1ZSwgdGhlIHRoZW1lIHdpbGwgYmUgbWFya2VkIGFzIGRhcmssXG4gICAgd2hpY2ggd2lsbCBjYXVzZSB0aGUgYCZkYXJrYCBydWxlcyBmcm9tIFtiYXNlXG4gICAgdGhlbWVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15iYXNlVGhlbWUpIHRvIGJlIHVzZWQgKGFzIG9wcG9zZWQgdG9cbiAgICBgJmxpZ2h0YCB3aGVuIGEgbGlnaHQgdGhlbWUgaXMgYWN0aXZlKS5cbiAgICAqL1xuICAgIHN0YXRpYyB0aGVtZShzcGVjLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBTdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbdGhlbWUub2YocHJlZml4KSwgc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShgLiR7cHJlZml4fWAsIHNwZWMpKV07XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGFyaylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhcmtUaGVtZS5vZih0cnVlKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBhZGRzIHN0eWxlcyB0byB0aGUgYmFzZSB0aGVtZS4gTGlrZVxuICAgIHdpdGggW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSwgdXNlIGAmYCB0byBpbmRpY2F0ZSB0aGVcbiAgICBwbGFjZSBvZiB0aGUgZWRpdG9yIHdyYXBwZXIgZWxlbWVudCB3aGVuIGRpcmVjdGx5IHRhcmdldGluZ1xuICAgIHRoYXQuIFlvdSBjYW4gYWxzbyB1c2UgYCZkYXJrYCBvciBgJmxpZ2h0YCBpbnN0ZWFkIHRvIG9ubHlcbiAgICB0YXJnZXQgZWRpdG9ycyB3aXRoIGEgZGFyayBvciBsaWdodCB0aGVtZS5cbiAgICAqL1xuICAgIHN0YXRpYyBiYXNlVGhlbWUoc3BlYykge1xuICAgICAgICByZXR1cm4gUHJlYy5sb3dlc3Qoc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCBzcGVjLCBsaWdodERhcmtJRHMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIGFuIGVkaXRvciB2aWV3IGluc3RhbmNlIGZyb20gdGhlIHZpZXcncyBET01cbiAgICByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kRnJvbURPTShkb20pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY29udGVudCA9IGRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLWNvbnRlbnRcIik7XG4gICAgICAgIGxldCB0aWxlID0gY29udGVudCAmJiBUaWxlLmdldChjb250ZW50KSB8fCBUaWxlLmdldChkb20pO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRpbGUgPT09IG51bGwgfHwgdGlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGlsZS5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmlldykgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkZhY2V0IHRvIGFkZCBhIFtzdHlsZVxubW9kdWxlXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbikgdG9cbmFuIGVkaXRvciB2aWV3LiBUaGUgdmlldyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBtb2R1bGUgaXNcbm1vdW50ZWQgaW4gaXRzIFtkb2N1bWVudFxucm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29uc3RydWN0b3JeY29uZmlnLnJvb3QpLlxuKi9cbkVkaXRvclZpZXcuc3R5bGVNb2R1bGUgPSBzdHlsZU1vZHVsZTtcbi8qKlxuQW4gaW5wdXQgaGFuZGxlciBjYW4gb3ZlcnJpZGUgdGhlIHdheSBjaGFuZ2VzIHRvIHRoZSBlZGl0YWJsZVxuRE9NIGNvbnRlbnQgYXJlIGhhbmRsZWQuIEhhbmRsZXJzIGFyZSBwYXNzZWQgdGhlIGRvY3VtZW50XG5wb3NpdGlvbnMgYmV0d2VlbiB3aGljaCB0aGUgY2hhbmdlIHdhcyBmb3VuZCwgYW5kIHRoZSBuZXdcbmNvbnRlbnQuIFdoZW4gb25lIHJldHVybnMgdHJ1ZSwgbm8gZnVydGhlciBpbnB1dCBoYW5kbGVycyBhcmVcbmNhbGxlZCBhbmQgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgcHJldmVudGVkLlxuXG5UaGUgYGluc2VydGAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSBkZWZhdWx0IHRyYW5zYWN0aW9uXG50aGF0IHdvdWxkIGJlIGFwcGxpZWQgZm9yIHRoaXMgaW5wdXQuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuXG5kaXNwYXRjaGluZyB0aGUgY3VzdG9tIGJlaGF2aW9yIGFzIGEgc2VwYXJhdGUgdHJhbnNhY3Rpb24uXG4qL1xuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4vKipcbkZ1bmN0aW9ucyBwcm92aWRlZCBpbiB0aGlzIGZhY2V0IHdpbGwgYmUgdXNlZCB0byB0cmFuc2Zvcm0gdGV4dFxucGFzdGVkIG9yIGRyb3BwZWQgaW50byB0aGUgZWRpdG9yLlxuKi9cbkVkaXRvclZpZXcuY2xpcGJvYXJkSW5wdXRGaWx0ZXIgPSBjbGlwYm9hcmRJbnB1dEZpbHRlcjtcbi8qKlxuVHJhbnNmb3JtIHRleHQgY29waWVkIG9yIGRyYWdnZWQgZnJvbSB0aGUgZWRpdG9yLlxuKi9cbkVkaXRvclZpZXcuY2xpcGJvYXJkT3V0cHV0RmlsdGVyID0gY2xpcGJvYXJkT3V0cHV0RmlsdGVyO1xuLyoqXG5TY3JvbGwgaGFuZGxlcnMgY2FuIG92ZXJyaWRlIGhvdyB0aGluZ3MgYXJlIHNjcm9sbGVkIGludG8gdmlldy5cbklmIHRoZXkgcmV0dXJuIGB0cnVlYCwgbm8gZnVydGhlciBoYW5kbGluZyBoYXBwZW5zIGZvciB0aGVcbnNjcm9sbGluZy4gSWYgdGhleSByZXR1cm4gZmFsc2UsIHRoZSBkZWZhdWx0IHNjcm9sbCBiZWhhdmlvciBpc1xuYXBwbGllZC4gU2Nyb2xsIGhhbmRsZXJzIHNob3VsZCBuZXZlciBpbml0aWF0ZSBlZGl0b3IgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnNjcm9sbEhhbmRsZXIgPSBzY3JvbGxIYW5kbGVyO1xuLyoqXG5UaGlzIGZhY2V0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgZnVuY3Rpb25zIHRoYXQgY3JlYXRlIGVmZmVjdHNcbnRvIGJlIGRpc3BhdGNoZWQgd2hlbiB0aGUgZWRpdG9yJ3MgZm9jdXMgc3RhdGUgY2hhbmdlcy5cbiovXG5FZGl0b3JWaWV3LmZvY3VzQ2hhbmdlRWZmZWN0ID0gZm9jdXNDaGFuZ2VFZmZlY3Q7XG4vKipcbkJ5IGRlZmF1bHQsIHRoZSBlZGl0b3IgYXNzdW1lcyBhbGwgaXRzIGNvbnRlbnQgaGFzIHRoZSBzYW1lXG5bdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EaXJlY3Rpb24pLiBDb25maWd1cmUgdGhpcyB3aXRoIGEgYHRydWVgXG52YWx1ZSB0byBtYWtlIGl0IHJlYWQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIGV2ZXJ5IChyZW5kZXJlZClcbmxpbmUgc2VwYXJhdGVseS5cbiovXG5FZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uID0gcGVyTGluZVRleHREaXJlY3Rpb247XG4vKipcbkFsbG93cyB5b3UgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZVxubGlicmFyeSBjYXRjaGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIGV4dGVuc2lvbiAobW9zdGx5IGZyb20gdmlld1xucGx1Z2lucywgYnV0IG1heSBiZSB1c2VkIGJ5IG90aGVyIGV4dGVuc2lvbnMgdG8gcm91dGUgZXhjZXB0aW9uc1xuZnJvbSB1c2VyLWNvZGUtcHJvdmlkZWQgY2FsbGJhY2tzKS4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvclxuZGVidWdnaW5nIGFuZCBsb2dnaW5nLiBTZWUgW2Bsb2dFeGNlcHRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubG9nRXhjZXB0aW9uKS5cbiovXG5FZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmsgPSBleGNlcHRpb25TaW5rO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbmV2ZXJ5IHRpbWUgdGhlIHZpZXcgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyID0gdXBkYXRlTGlzdGVuZXI7XG4vKipcbkZhY2V0IHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yIGNvbnRlbnQgRE9NIGlzIGVkaXRhYmxlLlxuV2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzIGBmYWxzZWAsIHRoZSBlbGVtZW50IHdpbGxcbm5vdCBoYXZlIGl0cyBgY29udGVudGVkaXRhYmxlYCBhdHRyaWJ1dGUgc2V0LiAoTm90ZSB0aGF0IHRoaXNcbmRvZXNuJ3QgYWZmZWN0IEFQSSBjYWxscyB0aGF0IGNoYW5nZSB0aGUgZWRpdG9yIGNvbnRlbnQsIGV2ZW5cbndoZW4gdGhvc2UgYXJlIGJvdW5kIHRvIGtleXMgb3IgYnV0dG9ucy4gU2VlIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGZhY2V0IGZvciB0aGF0LilcbiovXG5FZGl0b3JWaWV3LmVkaXRhYmxlID0gZWRpdGFibGU7XG4vKipcbkFsbG93cyB5b3UgdG8gaW5mbHVlbmNlIHRoZSB3YXkgbW91c2Ugc2VsZWN0aW9uIGhhcHBlbnMuIFRoZVxuZnVuY3Rpb25zIGluIHRoaXMgZmFjZXQgd2lsbCBiZSBjYWxsZWQgZm9yIGEgYG1vdXNlZG93bmAgZXZlbnRcbm9uIHRoZSBlZGl0b3IsIGFuZCBjYW4gcmV0dXJuIGFuIG9iamVjdCB0aGF0IG92ZXJyaWRlcyB0aGUgd2F5IGFcbnNlbGVjdGlvbiBpcyBjb21wdXRlZCBmcm9tIHRoYXQgbW91c2UgY2xpY2sgb3IgZHJhZy5cbiovXG5FZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUgPSBtb3VzZVNlbGVjdGlvblN0eWxlO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW9uIGRyYWcgZXZlbnRcbnNob3VsZCBtb3ZlIG9yIGNvcHkgdGhlIHNlbGVjdGlvbi4gVGhlIGdpdmVuIHByZWRpY2F0ZSB3aWxsIGJlXG5jYWxsZWQgd2l0aCB0aGUgYG1vdXNlZG93bmAgZXZlbnQsIGFuZCBjYW4gcmV0dXJuIGB0cnVlYCB3aGVuXG50aGUgZHJhZyBzaG91bGQgbW92ZSB0aGUgY29udGVudC5cbiovXG5FZGl0b3JWaWV3LmRyYWdNb3Zlc1NlbGVjdGlvbiA9IGRyYWdNb3Zlc1NlbGVjdGlvbiQxO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW5nIGNsaWNrIGFkZHMgYVxubmV3IHJhbmdlIHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb24gb3IgcmVwbGFjZXMgaXQgZW50aXJlbHkuIFRoZVxuZGVmYXVsdCBiZWhhdmlvciBpcyB0byBjaGVjayBgZXZlbnQubWV0YUtleWAgb24gbWFjT1MsIGFuZFxuYGV2ZW50LmN0cmxLZXlgIGVsc2V3aGVyZS5cbiovXG5FZGl0b3JWaWV3LmNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2U7XG4vKipcbkEgZmFjZXQgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pXG5hcmUgc2hvd24gaW4gdGhlIHZpZXcuIERlY29yYXRpb25zIGNhbiBiZSBwcm92aWRlZCBpbiB0d29cbndheXNcdTIwMTRkaXJlY3RseSwgb3IgdmlhIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBlZGl0b3Igdmlldy5cblxuT25seSBkZWNvcmF0aW9uIHNldHMgcHJvdmlkZWQgZGlyZWN0bHkgYXJlIGFsbG93ZWQgdG8gaW5mbHVlbmNlXG50aGUgZWRpdG9yJ3MgdmVydGljYWwgbGF5b3V0IHN0cnVjdHVyZS4gVGhlIG9uZXMgcHJvdmlkZWQgYXNcbmZ1bmN0aW9ucyBhcmUgY2FsbGVkIF9hZnRlcl8gdGhlIG5ldyB2aWV3cG9ydCBoYXMgYmVlbiBjb21wdXRlZCxcbmFuZCB0aHVzICoqbXVzdCBub3QqKiBpbnRyb2R1Y2UgYmxvY2sgd2lkZ2V0cyBvciByZXBsYWNpbmdcbmRlY29yYXRpb25zIHRoYXQgY292ZXIgbGluZSBicmVha3MuXG5cbklmIHlvdSB3YW50IGRlY29yYXRlZCByYW5nZXMgdG8gYmVoYXZlIGxpa2UgYXRvbWljIHVuaXRzIGZvclxuY3Vyc29yIG1vdGlvbiBhbmQgZGVsZXRpb24gcHVycG9zZXMsIGFsc28gcHJvdmlkZSB0aGUgcmFuZ2Ugc2V0XG5jb250YWluaW5nIHRoZSBkZWNvcmF0aW9ucyB0b1xuW2BFZGl0b3JWaWV3LmF0b21pY1Jhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmF0b21pY1JhbmdlcykuXG4qL1xuRWRpdG9yVmlldy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuLyoqXG5bQmxvY2sgd3JhcHBlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5CbG9ja1dyYXBwZXIpIHByb3ZpZGUgYSB3YXkgdG8gYWRkIERPTVxuc3RydWN0dXJlIGFyb3VuZCBlZGl0b3IgbGluZXMgYW5kIGJsb2NrIHdpZGdldHMuIFNldHMgb2ZcbndyYXBwZXJzIGFyZSBwcm92aWRlZCBpbiBhIHNpbWlsYXIgd2F5IHRvIGRlY29yYXRpb25zLCBhbmQgYXJlXG5uZXN0ZWQgaW4gYSBzaW1pbGFyIHdheSB3aGVuIHRoZXkgb3ZlcmxhcC4gQSB3cmFwcGVyIGFmZmVjdHMgYWxsXG5saW5lcyBhbmQgYmxvY2sgd2lkZ2V0cyB0aGF0IHN0YXJ0IGluc2lkZSBpdHMgcmFuZ2UuXG4qL1xuRWRpdG9yVmlldy5ibG9ja1dyYXBwZXJzID0gYmxvY2tXcmFwcGVycztcbi8qKlxuRmFjZXQgdGhhdCB3b3JrcyBtdWNoIGxpa2VcbltgZGVjb3JhdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIGJ1dCBwdXRzIGl0c1xuaW5wdXRzIGF0IHRoZSB2ZXJ5IGJvdHRvbSBvZiB0aGUgcHJlY2VkZW5jZSBzdGFjaywgbWVhbmluZyBtYXJrXG5kZWNvcmF0aW9ucyBwcm92aWRlZCBoZXJlIHdpbGwgb25seSBiZSBzcGxpdCBieSBvdGhlciwgcGFydGlhbGx5XG5vdmVybGFwcGluZyBgb3V0ZXJEZWNvcmF0aW9uc2AgcmFuZ2VzLCBhbmQgd3JhcCBhcm91bmQgYWxsXG5yZWd1bGFyIGRlY29yYXRpb25zLiBVc2UgdGhpcyBmb3IgbWFyayBlbGVtZW50cyB0aGF0IHNob3VsZCwgYXNcbm11Y2ggYXMgcG9zc2libGUsIHJlbWFpbiBpbiBvbmUgcGllY2UuXG4qL1xuRWRpdG9yVmlldy5vdXRlckRlY29yYXRpb25zID0gb3V0ZXJEZWNvcmF0aW9ucztcbi8qKlxuVXNlZCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGF0b21zIGFzIGZhciBhc1xuY3Vyc29yIG1vdGlvbiBpcyBjb25jZXJuZWQuIFRoaXMgY2F1c2VzIG1ldGhvZHMgbGlrZVxuW2Btb3ZlQnlDaGFyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5Q2hhcikgYW5kXG5bYG1vdmVWZXJ0aWNhbGx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIChhbmQgdGhlXG5jb21tYW5kcyBidWlsdCBvbiB0b3Agb2YgdGhlbSkgdG8gc2tpcCBhY3Jvc3Mgc3VjaCByZWdpb25zIHdoZW5cbmEgc2VsZWN0aW9uIGVuZHBvaW50IHdvdWxkIGVudGVyIHRoZW0uIFRoaXMgZG9lcyBfbm90XyBwcmV2ZW50XG5kaXJlY3QgcHJvZ3JhbW1hdGljIFtzZWxlY3Rpb25cbnVwZGF0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgZnJvbSBtb3ZpbmcgaW50byBzdWNoXG5yZWdpb25zLlxuKi9cbkVkaXRvclZpZXcuYXRvbWljUmFuZ2VzID0gYXRvbWljUmFuZ2VzO1xuLyoqXG5XaGVuIHJhbmdlIGRlY29yYXRpb25zIGFkZCBhIGB1bmljb2RlLWJpZGk6IGlzb2xhdGVgIHN0eWxlLCB0aGV5XG5zaG91bGQgYWxzbyBpbmNsdWRlIGFcbltgYmlkaUlzb2xhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTWFya0RlY29yYXRpb25TcGVjLmJpZGlJc29sYXRlKSBwcm9wZXJ0eVxuaW4gdGhlaXIgZGVjb3JhdGlvbiBzcGVjLCBhbmQgYmUgZXhwb3NlZCB0aHJvdWdoIHRoaXMgZmFjZXQsIHNvXG50aGF0IHRoZSBlZGl0b3IgY2FuIGNvbXB1dGUgdGhlIHByb3BlciB0ZXh0IG9yZGVyLiAoT3RoZXIgdmFsdWVzXG5mb3IgYHVuaWNvZGUtYmlkaWAsIGV4Y2VwdCBvZiBjb3Vyc2UgYG5vcm1hbGAsIGFyZSBub3RcbnN1cHBvcnRlZC4pXG4qL1xuRWRpdG9yVmlldy5iaWRpSXNvbGF0ZWRSYW5nZXMgPSBiaWRpSXNvbGF0ZWRSYW5nZXM7XG4vKipcbkZhY2V0IHRoYXQgYWxsb3dzIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIHNjcm9sbFxubWFyZ2lucyAoc3BhY2UgYXJvdW5kIHRoZSBzaWRlcyBvZiB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQgdGhhdFxuc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52aXNpYmxlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlXG5wbHVnaW4gaW50cm9kdWNlcyBlbGVtZW50cyB0aGF0IGNvdmVyIHBhcnQgb2YgdGhhdCBlbGVtZW50IChmb3JcbmV4YW1wbGUgYSBob3Jpem9udGFsbHkgZml4ZWQgZ3V0dGVyKS5cbiovXG5FZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMgPSBzY3JvbGxNYXJnaW5zO1xuLyoqXG5UaGlzIGZhY2V0IHJlY29yZHMgd2hldGhlciBhIGRhcmsgdGhlbWUgaXMgYWN0aXZlLiBUaGUgZXh0ZW5zaW9uXG5yZXR1cm5lZCBieSBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpIGF1dG9tYXRpY2FsbHlcbmluY2x1ZGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgd2hlbiB0aGUgYGRhcmtgIG9wdGlvbiBpcyBzZXQgdG9cbnRydWUuXG4qL1xuRWRpdG9yVmlldy5kYXJrVGhlbWUgPSBkYXJrVGhlbWU7XG4vKipcblByb3ZpZGVzIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgbm9uY2UgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbnRoZSBzdHlsZSBzaGVldHMgZm9yIHRoZSBlZGl0b3IuIEhvbGRzIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiBub1xubm9uY2UgaGFzIGJlZW4gcHJvdmlkZWQuXG4qL1xuRWRpdG9yVmlldy5jc3BOb25jZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IFwiXCIgfSk7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgYWRkaXRpb25hbCBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzXG5lZGl0YWJsZSBET00gZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzID0gY29udGVudEF0dHJpYnV0ZXM7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3IncyBvdXRlclxuZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmVkaXRvckF0dHJpYnV0ZXMgPSBlZGl0b3JBdHRyaWJ1dGVzO1xuLyoqXG5BbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGxpbmUgd3JhcHBpbmcgaW4gdGhlIGVkaXRvciAoYnlcbnNldHRpbmcgQ1NTIGB3aGl0ZS1zcGFjZWAgdG8gYHByZS13cmFwYCBpbiB0aGUgY29udGVudCkuXG4qL1xuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih7IFwiY2xhc3NcIjogXCJjbS1saW5lV3JhcHBpbmdcIiB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHVzZWQgdG8gaW5jbHVkZSBzY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudHMgaW4gYVxudHJhbnNhY3Rpb24uIFRoZXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHZpc3VhbGx5IGhpZGRlblxuZWxlbWVudCB3aXRoIGBhcmlhLWxpdmU9XCJwb2xpdGVcImAgc2V0LCBhbmQgc2hvdWxkIGJlIHVzZWQgdG9cbmRlc2NyaWJlIGVmZmVjdHMgdGhhdCBhcmUgdmlzdWFsbHkgb2J2aW91cyBidXQgbWF5IG5vdCBiZVxubm90aWNlZCBieSBzY3JlZW4gcmVhZGVyIHVzZXJzIChzdWNoIGFzIG1vdmluZyB0byB0aGUgbmV4dFxuc2VhcmNoIG1hdGNoKS5cbiovXG5FZGl0b3JWaWV3LmFubm91bmNlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLy8gTWF4aW11bSBsaW5lIGxlbmd0aCBmb3Igd2hpY2ggd2UgY29tcHV0ZSBhY2N1cmF0ZSBiaWRpIGluZm9cbmNvbnN0IE1heEJpZGlMaW5lID0gNDA5NjtcbmNvbnN0IEJhZE1lYXN1cmUgPSB7fTtcbmNsYXNzIENhY2hlZE9yZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgZGlyLCBpc29sYXRlcywgZnJlc2gsIG9yZGVyKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuaXNvbGF0ZXMgPSBpc29sYXRlcztcbiAgICAgICAgdGhpcy5mcmVzaCA9IGZyZXNoO1xuICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gICAgfVxuICAgIHN0YXRpYyB1cGRhdGUoY2FjaGUsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgJiYgIWNhY2hlLnNvbWUoYyA9PiBjLmZyZXNoKSlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBsYXN0RGlyID0gY2FjaGUubGVuZ3RoID8gY2FjaGVbY2FjaGUubGVuZ3RoIC0gMV0uZGlyIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGgubWF4KDAsIGNhY2hlLmxlbmd0aCAtIDEwKTsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSBjYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5kaXIgPT0gbGFzdERpciAmJiAhY2hhbmdlcy50b3VjaGVzUmFuZ2UoZW50cnkuZnJvbSwgZW50cnkudG8pKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBDYWNoZWRPcmRlcihjaGFuZ2VzLm1hcFBvcyhlbnRyeS5mcm9tLCAxKSwgY2hhbmdlcy5tYXBQb3MoZW50cnkudG8sIC0xKSwgZW50cnkuZGlyLCBlbnRyeS5pc29sYXRlcywgZmFsc2UsIGVudHJ5Lm9yZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyc0Zyb21GYWNldCh2aWV3LCBmYWNldCwgYmFzZSkge1xuICAgIGZvciAobGV0IHNvdXJjZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGZhY2V0KSwgaSA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHNvdXJjZXNbaV0sIHZhbHVlID0gdHlwZW9mIHNvdXJjZSA9PSBcImZ1bmN0aW9uXCIgPyBzb3VyY2UodmlldykgOiBzb3VyY2U7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGNvbWJpbmVBdHRycyh2YWx1ZSwgYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuXG5jb25zdCBjdXJyZW50UGxhdGZvcm0gPSBicm93c2VyLm1hYyA/IFwibWFjXCIgOiBicm93c2VyLndpbmRvd3MgPyBcIndpblwiIDogYnJvd3Nlci5saW51eCA/IFwibGludXhcIiA6IFwia2V5XCI7XG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUsIHBsYXRmb3JtKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpXG4gICAgICAgIHJlc3VsdCA9IFwiIFwiO1xuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtID09IFwibWFjXCIpXG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICB9XG4gICAgaWYgKGFsdClcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gICAgaWYgKGN0cmwpXG4gICAgICAgIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgcmVzdWx0ID0gXCJNZXRhLVwiICsgcmVzdWx0O1xuICAgIGlmIChzaGlmdClcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcbiAgICBpZiAoc2hpZnQgIT09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5jb25zdCBoYW5kbGVLZXlFdmVudHMgPSAvKkBfX1BVUkVfXyovUHJlYy5kZWZhdWx0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIGtleWRvd24oZXZlbnQsIHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIFwiZWRpdG9yXCIpO1xuICAgIH1cbn0pKTtcbi8qKlxuRmFjZXQgdXNlZCBmb3IgcmVnaXN0ZXJpbmcga2V5bWFwcy5cblxuWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwcyB0byBhbiBlZGl0b3IuIFRoZWlyIHByaW9yaXRpZXNcbmRldGVybWluZSB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBzcGVjaWZpZWQgZWFybHkgb3Igd2l0aCBoaWdoXG5wcmlvcml0eSBnZXQgY2hlY2tlZCBmaXJzdCkuIFdoZW4gYSBoYW5kbGVyIGhhcyByZXR1cm5lZCBgdHJ1ZWBcbmZvciBhIGdpdmVuIGtleSwgbm8gZnVydGhlciBoYW5kbGVycyBhcmUgY2FsbGVkLlxuKi9cbmNvbnN0IGtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBlbmFibGVzOiBoYW5kbGVLZXlFdmVudHMgfSk7XG5jb25zdCBLZXltYXBzID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vLyBUaGlzIGlzIGhpZGRlbiBiZWhpbmQgYW4gaW5kaXJlY3Rpb24sIHJhdGhlciB0aGFuIGRpcmVjdGx5IGNvbXB1dGVkXG4vLyBieSB0aGUgZmFjZXQsIHRvIGtlZXAgaW50ZXJuYWwgdHlwZXMgb3V0IG9mIHRoZSBmYWNldCdzIHR5cGUuXG5mdW5jdGlvbiBnZXRLZXltYXAoc3RhdGUpIHtcbiAgICBsZXQgYmluZGluZ3MgPSBzdGF0ZS5mYWNldChrZXltYXApO1xuICAgIGxldCBtYXAgPSBLZXltYXBzLmdldChiaW5kaW5ncyk7XG4gICAgaWYgKCFtYXApXG4gICAgICAgIEtleW1hcHMuc2V0KGJpbmRpbmdzLCBtYXAgPSBidWlsZEtleW1hcChiaW5kaW5ncy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSkpKTtcbiAgICByZXR1cm4gbWFwO1xufVxuLyoqXG5SdW4gdGhlIGtleSBoYW5kbGVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHNjb3BlLiBUaGUgZXZlbnRcbm9iamVjdCBzaG91bGQgYmUgYSBgXCJrZXlkb3duXCJgIGV2ZW50LiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZVxuaGFuZGxlcnMgaGFuZGxlZCBpdC5cbiovXG5mdW5jdGlvbiBydW5TY29wZUhhbmRsZXJzKHZpZXcsIGV2ZW50LCBzY29wZSkge1xuICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBzY29wZSk7XG59XG5sZXQgc3RvcmVkUHJlZml4ID0gbnVsbDtcbmNvbnN0IFByZWZpeFRpbWVvdXQgPSA0MDAwO1xuZnVuY3Rpb24gYnVpbGRLZXltYXAoYmluZGluZ3MsIHBsYXRmb3JtID0gY3VycmVudFBsYXRmb3JtKSB7XG4gICAgbGV0IGJvdW5kID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaXNQcmVmaXggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjaGVja1ByZWZpeCA9IChuYW1lLCBpcykgPT4ge1xuICAgICAgICBsZXQgY3VycmVudCA9IGlzUHJlZml4W25hbWVdO1xuICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsKVxuICAgICAgICAgICAgaXNQcmVmaXhbbmFtZV0gPSBpcztcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudCAhPSBpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBiaW5kaW5nIFwiICsgbmFtZSArIFwiIGlzIHVzZWQgYm90aCBhcyBhIHJlZ3VsYXIgYmluZGluZyBhbmQgYXMgYSBtdWx0aS1zdHJva2UgcHJlZml4XCIpO1xuICAgIH07XG4gICAgbGV0IGFkZCA9IChzY29wZSwga2V5LCBjb21tYW5kLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgvICg/ISQpLykubWFwKGsgPT4gbm9ybWFsaXplS2V5TmFtZShrLCBwbGF0Zm9ybSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICBjaGVja1ByZWZpeChwcmVmaXgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzY29wZU9ialtwcmVmaXhdKVxuICAgICAgICAgICAgICAgIHNjb3BlT2JqW3ByZWZpeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBydW46IFsodmlldykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXJPYmogPSBzdG9yZWRQcmVmaXggPSB7IHZpZXcsIHByZWZpeCwgc2NvcGUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgaWYgKHN0b3JlZFByZWZpeCA9PSBvdXJPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7IH0sIFByZWZpeFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsID0gcGFydHMuam9pbihcIiBcIik7XG4gICAgICAgIGNoZWNrUHJlZml4KGZ1bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSBzY29wZU9ialtmdWxsXSB8fCAoc2NvcGVPYmpbZnVsbF0gPSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgcnVuOiAoKF9iID0gKF9hID0gc2NvcGVPYmouX2FueSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJ1bikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWNlKCkpIHx8IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29tbWFuZClcbiAgICAgICAgICAgIGJpbmRpbmcucnVuLnB1c2goY29tbWFuZCk7XG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGJpbmRpbmcucHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICBpZiAoc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgYmluZGluZy5zdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgIH07XG4gICAgZm9yIChsZXQgYiBvZiBiaW5kaW5ncykge1xuICAgICAgICBsZXQgc2NvcGVzID0gYi5zY29wZSA/IGIuc2NvcGUuc3BsaXQoXCIgXCIpIDogW1wiZWRpdG9yXCJdO1xuICAgICAgICBpZiAoYi5hbnkpXG4gICAgICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVPYmouX2FueSlcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmouX2FueSA9IHsgcHJldmVudERlZmF1bHQ6IGZhbHNlLCBzdG9wUHJvcGFnYXRpb246IGZhbHNlLCBydW46IFtdIH07XG4gICAgICAgICAgICAgICAgbGV0IHsgYW55IH0gPSBiO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzY29wZU9iailcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmpba2V5XS5ydW4ucHVzaCh2aWV3ID0+IGFueSh2aWV3LCBjdXJyZW50S2V5RXZlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBiW3BsYXRmb3JtXSB8fCBiLmtleTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgYWRkKHNjb3BlLCBuYW1lLCBiLnJ1biwgYi5wcmV2ZW50RGVmYXVsdCwgYi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgaWYgKGIuc2hpZnQpXG4gICAgICAgICAgICAgICAgYWRkKHNjb3BlLCBcIlNoaWZ0LVwiICsgbmFtZSwgYi5zaGlmdCwgYi5wcmV2ZW50RGVmYXVsdCwgYi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3VuZDtcbn1cbmxldCBjdXJyZW50S2V5RXZlbnQgPSBudWxsO1xuZnVuY3Rpb24gcnVuSGFuZGxlcnMobWFwLCBldmVudCwgdmlldywgc2NvcGUpIHtcbiAgICBjdXJyZW50S2V5RXZlbnQgPSBldmVudDtcbiAgICBsZXQgbmFtZSA9IGtleU5hbWUoZXZlbnQpO1xuICAgIGxldCBjaGFyQ29kZSA9IGNvZGVQb2ludEF0KG5hbWUsIDApLCBpc0NoYXIgPSBjb2RlUG9pbnRTaXplKGNoYXJDb2RlKSA9PSBuYW1lLmxlbmd0aCAmJiBuYW1lICE9IFwiIFwiO1xuICAgIGxldCBwcmVmaXggPSBcIlwiLCBoYW5kbGVkID0gZmFsc2UsIHByZXZlbnRlZCA9IGZhbHNlLCBzdG9wUHJvcGFnYXRpb24gPSBmYWxzZTtcbiAgICBpZiAoc3RvcmVkUHJlZml4ICYmIHN0b3JlZFByZWZpeC52aWV3ID09IHZpZXcgJiYgc3RvcmVkUHJlZml4LnNjb3BlID09IHNjb3BlKSB7XG4gICAgICAgIHByZWZpeCA9IHN0b3JlZFByZWZpeC5wcmVmaXggKyBcIiBcIjtcbiAgICAgICAgaWYgKG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApIHtcbiAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICBzdG9yZWRQcmVmaXggPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByYW4gPSBuZXcgU2V0O1xuICAgIGxldCBydW5Gb3IgPSAoYmluZGluZykgPT4ge1xuICAgICAgICBpZiAoYmluZGluZykge1xuICAgICAgICAgICAgZm9yIChsZXQgY21kIG9mIGJpbmRpbmcucnVuKVxuICAgICAgICAgICAgICAgIGlmICghcmFuLmhhcyhjbWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbi5hZGQoY21kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtZCh2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5kaW5nLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgbGV0IHNjb3BlT2JqID0gbWFwW3Njb3BlXSwgYmFzZU5hbWUsIHNoaWZ0TmFtZTtcbiAgICBpZiAoc2NvcGVPYmopIHtcbiAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsICFpc0NoYXIpXSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkgJiZcbiAgICAgICAgICAgIC8vIEN0cmwtQWx0IG1heSBiZSB1c2VkIGZvciBBbHRHciBvbiBXaW5kb3dzXG4gICAgICAgICAgICAhKGJyb3dzZXIud2luZG93cyAmJiBldmVudC5jdHJsS2V5ICYmIGV2ZW50LmFsdEtleSkgJiZcbiAgICAgICAgICAgIC8vIEFsdC1jb21iaW5hdGlvbnMgb24gbWFjT1MgdGVuZCB0byBiZSB0eXBlZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAhKGJyb3dzZXIubWFjICYmIGV2ZW50LmFsdEtleSAmJiAhKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkpICYmXG4gICAgICAgICAgICAoYmFzZU5hbWUgPSBiYXNlW2V2ZW50LmtleUNvZGVdKSAmJiBiYXNlTmFtZSAhPSBuYW1lKSB7XG4gICAgICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQsIHRydWUpXSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIChzaGlmdE5hbWUgPSBzaGlmdFtldmVudC5rZXlDb2RlXSkgIT0gbmFtZSAmJiBzaGlmdE5hbWUgIT0gYmFzZU5hbWUgJiZcbiAgICAgICAgICAgICAgICBydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKHNoaWZ0TmFtZSwgZXZlbnQsIGZhbHNlKV0pKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDaGFyICYmIGV2ZW50LnNoaWZ0S2V5ICYmXG4gICAgICAgICAgICBydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCB0cnVlKV0pKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhbmRsZWQgJiYgcnVuRm9yKHNjb3BlT2JqLl9hbnkpKVxuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcmV2ZW50ZWQpXG4gICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgIGlmIChoYW5kbGVkICYmIHN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgY3VycmVudEtleUV2ZW50ID0gbnVsbDtcbiAgICByZXR1cm4gaGFuZGxlZDtcbn1cblxuLyoqXG5JbXBsZW1lbnRhdGlvbiBvZiBbYExheWVyTWFya2VyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkxheWVyTWFya2VyKSB0aGF0IGNyZWF0ZXNcbmEgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gc2V0IG9mIGNvb3JkaW5hdGVzLlxuKi9cbmNsYXNzIFJlY3RhbmdsZU1hcmtlciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFya2VyIHdpdGggdGhlIGdpdmVuIGNsYXNzIGFuZCBkaW1lbnNpb25zLiBJZiBgd2lkdGhgXG4gICAgaXMgbnVsbCwgdGhlIERPTSBlbGVtZW50IHdpbGwgZ2V0IG5vIHdpZHRoIHN0eWxlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY2xhc3NOYW1lLCBcbiAgICAvKipcbiAgICBUaGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyIChpbiBwaXhlbHMsIGRvY3VtZW50LXJlbGF0aXZlKS5cbiAgICAqL1xuICAgIGxlZnQsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cbiAgICAqL1xuICAgIHRvcCwgXG4gICAgLyoqXG4gICAgVGhlIHdpZHRoIG9mIHRoZSBtYXJrZXIsIG9yIG51bGwgaWYgaXQgc2hvdWxkbid0IGdldCBhIHdpZHRoIGFzc2lnbmVkLlxuICAgICovXG4gICAgd2lkdGgsIFxuICAgIC8qKlxuICAgIFRoZSBoZWlnaHQgb2YgdGhlIG1hcmtlci5cbiAgICAqL1xuICAgIGhlaWdodCkge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIHVwZGF0ZShlbHQsIHByZXYpIHtcbiAgICAgICAgaWYgKHByZXYuY2xhc3NOYW1lICE9IHRoaXMuY2xhc3NOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmFkanVzdChlbHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYWRqdXN0KGVsdCkge1xuICAgICAgICBlbHQuc3R5bGUubGVmdCA9IHRoaXMubGVmdCArIFwicHhcIjtcbiAgICAgICAgZWx0LnN0eWxlLnRvcCA9IHRoaXMudG9wICsgXCJweFwiO1xuICAgICAgICBpZiAodGhpcy53aWR0aCAhPSBudWxsKVxuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgIH1cbiAgICBlcShwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQgPT0gcC5sZWZ0ICYmIHRoaXMudG9wID09IHAudG9wICYmIHRoaXMud2lkdGggPT0gcC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PSBwLmhlaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPT0gcC5jbGFzc05hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiByZWN0YW5nbGVzIGZvciB0aGUgZ2l2ZW4gc2VsZWN0aW9uIHJhbmdlLFxuICAgIGFzc2lnbmluZyB0aGVtIHRoZWNsYXNzYGNsYXNzTmFtZWAuIFdpbGwgY3JlYXRlIGEgc2luZ2xlXG4gICAgcmVjdGFuZ2xlIGZvciBlbXB0eSByYW5nZXMsIGFuZCBhIHNldCBvZiBzZWxlY3Rpb24tc3R5bGVcbiAgICByZWN0YW5nbGVzIGNvdmVyaW5nIHRoZSByYW5nZSdzIGNvbnRlbnQgKGluIGEgYmlkaS1hd2FyZVxuICAgIHdheSkgZm9yIG5vbi1lbXB0eSBvbmVzLlxuICAgICovXG4gICAgc3RhdGljIGZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgcmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gdmlldy5jb29yZHNBdFBvcyhyYW5nZS5oZWFkLCByYW5nZS5hc3NvYyB8fCAxKTtcbiAgICAgICAgICAgIGlmICghcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gZ2V0QmFzZSh2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFJlY3RhbmdsZU1hcmtlcihjbGFzc05hbWUsIHBvcy5sZWZ0IC0gYmFzZS5sZWZ0LCBwb3MudG9wIC0gYmFzZS50b3AsIG51bGwsIHBvcy5ib3R0b20gLSBwb3MudG9wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdGFuZ2xlc0ZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QmFzZSh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgbGVmdCA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodCAtIHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoICogdmlldy5zY2FsZVg7XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgKiB2aWV3LnNjYWxlWCwgdG9wOiByZWN0LnRvcCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHZpZXcuc2NhbGVZIH07XG59XG5mdW5jdGlvbiB3cmFwcGVkTGluZSh2aWV3LCBwb3MsIHNpZGUsIGluc2lkZSkge1xuICAgIGxldCBjb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcywgc2lkZSAqIDIpO1xuICAgIGlmICghY29vcmRzKVxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgIGxldCBlZGl0b3JSZWN0ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHkgPSAoY29vcmRzLnRvcCArIGNvb3Jkcy5ib3R0b20pIC8gMjtcbiAgICBsZXQgbGVmdCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBlZGl0b3JSZWN0LmxlZnQgKyAxLCB5IH0pO1xuICAgIGxldCByaWdodCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBlZGl0b3JSZWN0LnJpZ2h0IC0gMSwgeSB9KTtcbiAgICBpZiAobGVmdCA9PSBudWxsIHx8IHJpZ2h0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgcmV0dXJuIHsgZnJvbTogTWF0aC5tYXgoaW5zaWRlLmZyb20sIE1hdGgubWluKGxlZnQsIHJpZ2h0KSksIHRvOiBNYXRoLm1pbihpbnNpZGUudG8sIE1hdGgubWF4KGxlZnQsIHJpZ2h0KSkgfTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZXNGb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnRvIDw9IHZpZXcudmlld3BvcnQuZnJvbSB8fCByYW5nZS5mcm9tID49IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHJhbmdlLmZyb20sIHZpZXcudmlld3BvcnQuZnJvbSksIHRvID0gTWF0aC5taW4ocmFuZ2UudG8sIHZpZXcudmlld3BvcnQudG8pO1xuICAgIGxldCBsdHIgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTSwgY29udGVudFJlY3QgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBiYXNlID0gZ2V0QmFzZSh2aWV3KTtcbiAgICBsZXQgbGluZUVsdCA9IGNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5jbS1saW5lXCIpLCBsaW5lU3R5bGUgPSBsaW5lRWx0ICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGxpbmVFbHQpO1xuICAgIGxldCBsZWZ0U2lkZSA9IGNvbnRlbnRSZWN0LmxlZnQgK1xuICAgICAgICAobGluZVN0eWxlID8gcGFyc2VJbnQobGluZVN0eWxlLnBhZGRpbmdMZWZ0KSArIE1hdGgubWluKDAsIHBhcnNlSW50KGxpbmVTdHlsZS50ZXh0SW5kZW50KSkgOiAwKTtcbiAgICBsZXQgcmlnaHRTaWRlID0gY29udGVudFJlY3QucmlnaHQgLSAobGluZVN0eWxlID8gcGFyc2VJbnQobGluZVN0eWxlLnBhZGRpbmdSaWdodCkgOiAwKTtcbiAgICBsZXQgc3RhcnRCbG9jayA9IGJsb2NrQXQodmlldywgZnJvbSwgMSksIGVuZEJsb2NrID0gYmxvY2tBdCh2aWV3LCB0bywgLTEpO1xuICAgIGxldCB2aXN1YWxTdGFydCA9IHN0YXJ0QmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IHN0YXJ0QmxvY2sgOiBudWxsO1xuICAgIGxldCB2aXN1YWxFbmQgPSBlbmRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gZW5kQmxvY2sgOiBudWxsO1xuICAgIGlmICh2aXN1YWxTdGFydCAmJiAodmlldy5saW5lV3JhcHBpbmcgfHwgc3RhcnRCbG9jay53aWRnZXRMaW5lQnJlYWtzKSlcbiAgICAgICAgdmlzdWFsU3RhcnQgPSB3cmFwcGVkTGluZSh2aWV3LCBmcm9tLCAxLCB2aXN1YWxTdGFydCk7XG4gICAgaWYgKHZpc3VhbEVuZCAmJiAodmlldy5saW5lV3JhcHBpbmcgfHwgZW5kQmxvY2sud2lkZ2V0TGluZUJyZWFrcykpXG4gICAgICAgIHZpc3VhbEVuZCA9IHdyYXBwZWRMaW5lKHZpZXcsIHRvLCAtMSwgdmlzdWFsRW5kKTtcbiAgICBpZiAodmlzdWFsU3RhcnQgJiYgdmlzdWFsRW5kICYmIHZpc3VhbFN0YXJ0LmZyb20gPT0gdmlzdWFsRW5kLmZyb20gJiYgdmlzdWFsU3RhcnQudG8gPT0gdmlzdWFsRW5kLnRvKSB7XG4gICAgICAgIHJldHVybiBwaWVjZXMoZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHZpc3VhbFN0YXJ0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdG9wID0gdmlzdWFsU3RhcnQgPyBkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCBudWxsLCB2aXN1YWxTdGFydCkgOiBkcmF3Rm9yV2lkZ2V0KHN0YXJ0QmxvY2ssIGZhbHNlKTtcbiAgICAgICAgbGV0IGJvdHRvbSA9IHZpc3VhbEVuZCA/IGRyYXdGb3JMaW5lKG51bGwsIHJhbmdlLnRvLCB2aXN1YWxFbmQpIDogZHJhd0ZvcldpZGdldChlbmRCbG9jaywgdHJ1ZSk7XG4gICAgICAgIGxldCBiZXR3ZWVuID0gW107XG4gICAgICAgIGlmICgodmlzdWFsU3RhcnQgfHwgc3RhcnRCbG9jaykudG8gPCAodmlzdWFsRW5kIHx8IGVuZEJsb2NrKS5mcm9tIC0gKHZpc3VhbFN0YXJ0ICYmIHZpc3VhbEVuZCA/IDEgOiAwKSB8fFxuICAgICAgICAgICAgc3RhcnRCbG9jay53aWRnZXRMaW5lQnJlYWtzID4gMSAmJiB0b3AuYm90dG9tICsgdmlldy5kZWZhdWx0TGluZUhlaWdodCAvIDIgPCBib3R0b20udG9wKVxuICAgICAgICAgICAgYmV0d2Vlbi5wdXNoKHBpZWNlKGxlZnRTaWRlLCB0b3AuYm90dG9tLCByaWdodFNpZGUsIGJvdHRvbS50b3ApKTtcbiAgICAgICAgZWxzZSBpZiAodG9wLmJvdHRvbSA8IGJvdHRvbS50b3AgJiYgdmlldy5lbGVtZW50QXRIZWlnaHQoKHRvcC5ib3R0b20gKyBib3R0b20udG9wKSAvIDIpLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICB0b3AuYm90dG9tID0gYm90dG9tLnRvcCA9ICh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyO1xuICAgICAgICByZXR1cm4gcGllY2VzKHRvcCkuY29uY2F0KGJldHdlZW4pLmNvbmNhdChwaWVjZXMoYm90dG9tKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpZWNlKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZU1hcmtlcihjbGFzc05hbWUsIGxlZnQgLSBiYXNlLmxlZnQsIHRvcCAtIGJhc2UudG9wLCBNYXRoLm1heCgwLCByaWdodCAtIGxlZnQpLCBib3R0b20gLSB0b3ApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZXMoeyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9KSB7XG4gICAgICAgIGxldCBwaWVjZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3Jpem9udGFsLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcGllY2VzLnB1c2gocGllY2UoaG9yaXpvbnRhbFtpXSwgdG9wLCBob3Jpem9udGFsW2kgKyAxXSwgYm90dG9tKSk7XG4gICAgICAgIHJldHVybiBwaWVjZXM7XG4gICAgfVxuICAgIC8vIEdldHMgcGFzc2VkIGZyb20vdG8gaW4gbGluZS1sb2NhbCBwb3NpdGlvbnNcbiAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShmcm9tLCB0bywgbGluZSkge1xuICAgICAgICBsZXQgdG9wID0gMWU5LCBib3R0b20gPSAtMWU5LCBob3Jpem9udGFsID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZFNwYW4oZnJvbSwgZnJvbU9wZW4sIHRvLCB0b09wZW4sIGRpcikge1xuICAgICAgICAgICAgLy8gUGFzc2luZyAyLy0yIGlzIGEga2x1ZGdlIHRvIGZvcmNlIHRoZSB2aWV3IHRvIHJldHVyblxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZXMgb24gdGhlIHByb3BlciBzaWRlIG9mIGJsb2NrIHdpZGdldHMsIHNpbmNlXG4gICAgICAgICAgICAvLyBub3JtYWxpemluZyB0aGUgc2lkZSB0aGVyZSwgdGhvdWdoIGFwcHJvcHJpYXRlIGZvciBtb3N0XG4gICAgICAgICAgICAvLyBjb29yZHNBdFBvcyBxdWVyaWVzLCB3b3VsZCBicmVhayBzZWxlY3Rpb24gZHJhd2luZy5cbiAgICAgICAgICAgIGxldCBmcm9tQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhmcm9tLCAoZnJvbSA9PSBsaW5lLnRvID8gLTIgOiAyKSk7XG4gICAgICAgICAgICBsZXQgdG9Db29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHRvLCAodG8gPT0gbGluZS5mcm9tID8gMiA6IC0yKSk7XG4gICAgICAgICAgICBpZiAoIWZyb21Db29yZHMgfHwgIXRvQ29vcmRzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKGZyb21Db29yZHMudG9wLCB0b0Nvb3Jkcy50b3AsIHRvcCk7XG4gICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChmcm9tQ29vcmRzLmJvdHRvbSwgdG9Db29yZHMuYm90dG9tLCBib3R0b20pO1xuICAgICAgICAgICAgaWYgKGRpciA9PSBEaXJlY3Rpb24uTFRSKVxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaChsdHIgJiYgZnJvbU9wZW4gPyBsZWZ0U2lkZSA6IGZyb21Db29yZHMubGVmdCwgbHRyICYmIHRvT3BlbiA/IHJpZ2h0U2lkZSA6IHRvQ29vcmRzLnJpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2goIWx0ciAmJiB0b09wZW4gPyBsZWZ0U2lkZSA6IHRvQ29vcmRzLmxlZnQsICFsdHIgJiYgZnJvbU9wZW4gPyByaWdodFNpZGUgOiBmcm9tQ29vcmRzLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBsaW5lLmZyb20sIGVuZCA9IHRvICE9PSBudWxsICYmIHRvICE9PSB2b2lkIDAgPyB0byA6IGxpbmUudG87XG4gICAgICAgIC8vIFNwbGl0IHRoZSByYW5nZSBieSB2aXNpYmxlIHJhbmdlIGFuZCBkb2N1bWVudCBsaW5lXG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKVxuICAgICAgICAgICAgaWYgKHIudG8gPiBzdGFydCAmJiByLmZyb20gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSBNYXRoLm1heChyLmZyb20sIHN0YXJ0KSwgZW5kUG9zID0gTWF0aC5taW4oci50bywgZW5kKTs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkb2NMaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNwYW4gb2Ygdmlldy5iaWRpU3BhbnMoZG9jTGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFuRnJvbSA9IHNwYW4uZnJvbSArIGRvY0xpbmUuZnJvbSwgc3BhblRvID0gc3Bhbi50byArIGRvY0xpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuRnJvbSA+PSBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhblRvID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNwYW4oTWF0aC5tYXgoc3BhbkZyb20sIHBvcyksIGZyb20gPT0gbnVsbCAmJiBzcGFuRnJvbSA8PSBzdGFydCwgTWF0aC5taW4oc3BhblRvLCBlbmRQb3MpLCB0byA9PSBudWxsICYmIHNwYW5UbyA+PSBlbmQsIHNwYW4uZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBkb2NMaW5lLnRvICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChob3Jpem9udGFsLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgYWRkU3BhbihzdGFydCwgZnJvbSA9PSBudWxsLCBlbmQsIHRvID09IG51bGwsIHZpZXcudGV4dERpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB7IHRvcCwgYm90dG9tLCBob3Jpem9udGFsIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYXdGb3JXaWRnZXQoYmxvY2ssIHRvcCkge1xuICAgICAgICBsZXQgeSA9IGNvbnRlbnRSZWN0LnRvcCArICh0b3AgPyBibG9jay50b3AgOiBibG9jay5ib3R0b20pO1xuICAgICAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgaG9yaXpvbnRhbDogW10gfTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lTWFya2VyKGEsIGIpIHtcbiAgICByZXR1cm4gYS5jb25zdHJ1Y3RvciA9PSBiLmNvbnN0cnVjdG9yICYmIGEuZXEoYik7XG59XG5jbGFzcyBMYXllclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGxheWVyKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgdGhpcy5kcmF3biA9IFtdO1xuICAgICAgICB0aGlzLnNjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuc2NhbGVZID0gMTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLm1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhdy5iaW5kKHRoaXMpIH07XG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllclwiKTtcbiAgICAgICAgaWYgKGxheWVyLmFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxheWVyLWFib3ZlXCIpO1xuICAgICAgICBpZiAobGF5ZXIuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKGxheWVyLmNsYXNzKTtcbiAgICAgICAgdGhpcy5zY2FsZSgpO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuc2V0T3JkZXIodmlldy5zdGF0ZSk7XG4gICAgICAgIHZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgaWYgKGxheWVyLm1vdW50KVxuICAgICAgICAgICAgbGF5ZXIubW91bnQodGhpcy5kb20sIHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsYXllck9yZGVyKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGF5ZXJPcmRlcikpXG4gICAgICAgICAgICB0aGlzLnNldE9yZGVyKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLnVwZGF0ZSh1cGRhdGUsIHRoaXMuZG9tKSB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlKCk7XG4gICAgICAgICAgICB1cGRhdGUudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvY1ZpZXdVcGRhdGUodmlldykge1xuICAgICAgICBpZiAodGhpcy5sYXllci51cGRhdGVPbkRvY1ZpZXdVcGRhdGUgIT09IGZhbHNlKVxuICAgICAgICAgICAgdmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgIH1cbiAgICBzZXRPcmRlcihzdGF0ZSkge1xuICAgICAgICBsZXQgcG9zID0gMCwgb3JkZXIgPSBzdGF0ZS5mYWNldChsYXllck9yZGVyKTtcbiAgICAgICAgd2hpbGUgKHBvcyA8IG9yZGVyLmxlbmd0aCAmJiBvcmRlcltwb3NdICE9IHRoaXMubGF5ZXIpXG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgdGhpcy5kb20uc3R5bGUuekluZGV4ID0gU3RyaW5nKCh0aGlzLmxheWVyLmFib3ZlID8gMTUwIDogLTEpIC0gcG9zKTtcbiAgICB9XG4gICAgbWVhc3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIubWFya2Vycyh0aGlzLnZpZXcpO1xuICAgIH1cbiAgICBzY2FsZSgpIHtcbiAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgaWYgKHNjYWxlWCAhPSB0aGlzLnNjYWxlWCB8fCBzY2FsZVkgIT0gdGhpcy5zY2FsZVkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHsxIC8gc2NhbGVYfSwgJHsxIC8gc2NhbGVZfSlgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcobWFya2Vycykge1xuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggIT0gdGhpcy5kcmF3bi5sZW5ndGggfHwgbWFya2Vycy5zb21lKChwLCBpKSA9PiAhc2FtZU1hcmtlcihwLCB0aGlzLmRyYXduW2ldKSkpIHtcbiAgICAgICAgICAgIGxldCBvbGQgPSB0aGlzLmRvbS5maXJzdENoaWxkLCBvbGRJID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci51cGRhdGUgJiYgb2xkICYmIG1hcmtlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmRyYXduW29sZEldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci51cGRhdGUob2xkLCB0aGlzLmRyYXduW29sZEldKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9sZEkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIuZHJhdygpLCBvbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChvbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG9sZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBvbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgb2xkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhd24gPSBtYXJrZXJzO1xuICAgICAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmIGJyb3dzZXIuc2FmYXJpX3ZlcnNpb24gPj0gMjYpIC8vIElzc3VlICMxNjAwLCAxNjI3XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuZGlzcGxheSA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQgPyBcIlwiIDogXCJub25lXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMubGF5ZXIuZGVzdHJveSh0aGlzLmRvbSwgdGhpcy52aWV3KTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufVxuY29uc3QgbGF5ZXJPcmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGEgbGF5ZXIuXG4qL1xuZnVuY3Rpb24gbGF5ZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodiA9PiBuZXcgTGF5ZXJWaWV3KHYsIGNvbmZpZykpLFxuICAgICAgICBsYXllck9yZGVyLm9mKGNvbmZpZylcbiAgICBdO1xufVxuXG5jb25zdCBzZWxlY3Rpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAxMjAwLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGN1cnNvckJsaW5rUmF0ZTogKGEsIGIpID0+IE1hdGgubWluKGEsIGIpLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGhpZGVzIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNlbGVjdGlvbiBhbmRcbmN1cnNvciwgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBhIGJhY2tncm91bmQgYmVoaW5kIHRoZSB0ZXh0XG4od2l0aCB0aGUgYGNtLXNlbGVjdGlvbkJhY2tncm91bmRgIGNsYXNzKSwgYW5kIHRoZVxuY3Vyc29ycyB3aXRoIGVsZW1lbnRzIG92ZXJsYWlkIG92ZXIgdGhlIGNvZGUgKHVzaW5nXG5gY20tY3Vyc29yLXByaW1hcnlgIGFuZCBgY20tY3Vyc29yLXNlY29uZGFyeWApLlxuXG5UaGlzIGFsbG93cyB0aGUgZWRpdG9yIHRvIGRpc3BsYXkgc2Vjb25kYXJ5IHNlbGVjdGlvbiByYW5nZXMsIGFuZFxudGVuZHMgdG8gcHJvZHVjZSBhIHR5cGUgb2Ygc2VsZWN0aW9uIG1vcmUgaW4gbGluZSB3aXRoIHRoYXQgdXNlcnNcbmV4cGVjdCBpbiBhIHRleHQgZWRpdG9yICh0aGUgbmF0aXZlIHNlbGVjdGlvbiBzdHlsaW5nIHdpbGwgb2Z0ZW5cbmxlYXZlIGdhcHMgYmV0d2VlbiBsaW5lcyBhbmQgd29uJ3QgZmlsbCB0aGUgaG9yaXpvbnRhbCBzcGFjZSBhZnRlclxuYSBsaW5lIHdoZW4gdGhlIHNlbGVjdGlvbiBjb250aW51ZXMgcGFzdCBpdCkuXG5cbkl0IGRvZXMgaGF2ZSBhIHBlcmZvcm1hbmNlIGNvc3QsIGluIHRoYXQgaXQgcmVxdWlyZXMgYW4gZXh0cmEgRE9NXG5sYXlvdXQgY3ljbGUgZm9yIG1hbnkgdXBkYXRlcyAodGhlIHNlbGVjdGlvbiBpcyBkcmF3biBiYXNlZCBvbiBET01cbmxheW91dCBpbmZvcm1hdGlvbiB0aGF0J3Mgb25seSBhdmFpbGFibGUgYWZ0ZXIgbGF5aW5nIG91dCB0aGVcbmNvbnRlbnQpLlxuKi9cbmZ1bmN0aW9uIGRyYXdTZWxlY3Rpb24oY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzZWxlY3Rpb25Db25maWcub2YoY29uZmlnKSxcbiAgICAgICAgY3Vyc29yTGF5ZXIsXG4gICAgICAgIHNlbGVjdGlvbkxheWVyLFxuICAgICAgICBoaWRlTmF0aXZlU2VsZWN0aW9uLFxuICAgICAgICBuYXRpdmVTZWxlY3Rpb25IaWRkZW4ub2YodHJ1ZSlcbiAgICBdO1xufVxuLyoqXG5SZXRyaWV2ZSB0aGUgW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNvbmZpZ3VyYXRpb25cbmZvciB0aGlzIHN0YXRlLiAoTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gYSBzZXQgb2YgZGVmYXVsdHMgZXZlblxuaWYgYGRyYXdTZWxlY3Rpb25gIGlzbid0IGVuYWJsZWQuKVxuKi9cbmZ1bmN0aW9uIGdldERyYXdTZWxlY3Rpb25Db25maWcoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ0NoYW5nZWQodXBkYXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG59XG5jb25zdCBjdXJzb3JMYXllciA9IC8qQF9fUFVSRV9fKi9sYXllcih7XG4gICAgYWJvdmU6IHRydWUsXG4gICAgbWFya2Vycyh2aWV3KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IGN1cnNvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgcHJpbSA9IHIgPT0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICBpZiAoci5lbXB0eSB8fCBjb25mLmRyYXdSYW5nZUN1cnNvcikge1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBwcmltID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIjtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gci5lbXB0eSA/IHIgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHIuaGVhZCwgci5oZWFkID4gci5hbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBpZWNlIG9mIFJlY3RhbmdsZU1hcmtlci5mb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIGN1cnNvcikpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcnM7XG4gICAgfSxcbiAgICB1cGRhdGUodXBkYXRlLCBkb20pIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSBkb20uc3R5bGUuYW5pbWF0aW9uTmFtZSA9PSBcImNtLWJsaW5rXCIgPyBcImNtLWJsaW5rMlwiIDogXCJjbS1ibGlua1wiO1xuICAgICAgICBsZXQgY29uZkNoYW5nZSA9IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2UpXG4gICAgICAgICAgICBzZXRCbGlua1JhdGUodXBkYXRlLnN0YXRlLCBkb20pO1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCBjb25mQ2hhbmdlO1xuICAgIH0sXG4gICAgbW91bnQoZG9tLCB2aWV3KSB7XG4gICAgICAgIHNldEJsaW5rUmF0ZSh2aWV3LnN0YXRlLCBkb20pO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tY3Vyc29yTGF5ZXJcIlxufSk7XG5mdW5jdGlvbiBzZXRCbGlua1JhdGUoc3RhdGUsIGRvbSkge1xuICAgIGRvbS5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykuY3Vyc29yQmxpbmtSYXRlICsgXCJtc1wiO1xufVxuY29uc3Qgc2VsZWN0aW9uTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xuICAgIGFib3ZlOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAociA9PiByLmVtcHR5ID8gW10gOiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgXCJjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCIsIHIpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgY29uZmlnQ2hhbmdlZCh1cGRhdGUpO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tc2VsZWN0aW9uTGF5ZXJcIlxufSk7XG5jb25zdCBoaWRlTmF0aXZlU2VsZWN0aW9uID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy50aGVtZSh7XG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIFwiJiA6OnNlbGVjdGlvbiwgJjo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9LFxuICAgICAgICBjYXJldENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIlxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIGNhcmV0Q29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiLFxuICAgICAgICBcIiYgOmZvY3VzXCI6IHtcbiAgICAgICAgICAgIGNhcmV0Q29sb3I6IFwiaW5pdGlhbCAhaW1wb3J0YW50XCIsXG4gICAgICAgICAgICBcIiY6OnNlbGVjdGlvbiwgJiA6OnNlbGVjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIkhpZ2hsaWdodCAhaW1wb3J0YW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pKTtcblxuY29uc3Qgc2V0RHJvcEN1cnNvclBvcyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChwb3MsIG1hcHBpbmcpIHsgcmV0dXJuIHBvcyA9PSBudWxsID8gbnVsbCA6IG1hcHBpbmcubWFwUG9zKHBvcyk7IH1cbn0pO1xuY29uc3QgZHJvcEN1cnNvclBvcyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUocG9zLCB0cikge1xuICAgICAgICBpZiAocG9zICE9IG51bGwpXG4gICAgICAgICAgICBwb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyhwb3MpO1xuICAgICAgICByZXR1cm4gdHIuZWZmZWN0cy5yZWR1Y2UoKHBvcywgZSkgPT4gZS5pcyhzZXREcm9wQ3Vyc29yUG9zKSA/IGUudmFsdWUgOiBwb3MsIHBvcyk7XG4gICAgfVxufSk7XG5jb25zdCBkcmF3RHJvcEN1cnNvciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkUG9zLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXdDdXJzb3IuYmluZCh0aGlzKSB9O1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGN1cnNvclBvcyA9IHVwZGF0ZS5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKTtcbiAgICAgICAgaWYgKGN1cnNvclBvcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJzb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY3Vyc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy52aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5jbGFzc05hbWUgPSBcImNtLWRyb3BDdXJzb3JcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBjdXJzb3JQb3MgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkUG9zKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBsZXQgcG9zID0gdmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKTtcbiAgICAgICAgbGV0IHJlY3QgPSBwb3MgIT0gbnVsbCAmJiB2aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgb3V0ZXIgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG91dGVyLmxlZnQgKyB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ICogdmlldy5zY2FsZVgsXG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wIC0gb3V0ZXIudG9wICsgdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdmlldy5zY2FsZVksXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZHJhd0N1cnNvcihwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICBsZXQgeyBzY2FsZVgsIHNjYWxlWSB9ID0gdGhpcy52aWV3O1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS50b3AgPSBwb3MudG9wIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmhlaWdodCA9IHBvcy5oZWlnaHQgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gXCItMTAwMDAwcHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IpXG4gICAgICAgICAgICB0aGlzLmN1cnNvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgc2V0RHJvcFBvcyhwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBwb3MpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXREcm9wQ3Vyc29yUG9zLm9mKHBvcykgfSk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgIGRyYWdvdmVyKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3ModGhpcy52aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdsZWF2ZShldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PSB0aGlzLnZpZXcuY29udGVudERPTSB8fCAhdGhpcy52aWV3LmNvbnRlbnRET00uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnZW5kKCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBkcm9wKCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vKipcbkRyYXdzIGEgY3Vyc29yIGF0IHRoZSBjdXJyZW50IGRyb3AgcG9zaXRpb24gd2hlbiBzb21ldGhpbmcgaXNcbmRyYWdnZWQgb3ZlciB0aGUgZWRpdG9yLlxuKi9cbmZ1bmN0aW9uIGRyb3BDdXJzb3IoKSB7XG4gICAgcmV0dXJuIFtkcm9wQ3Vyc29yUG9zLCBkcmF3RHJvcEN1cnNvcl07XG59XG5cbmZ1bmN0aW9uIGl0ZXJNYXRjaGVzKGRvYywgcmUsIGZyb20sIHRvLCBmKSB7XG4gICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBjdXJzb3IgPSBkb2MuaXRlclJhbmdlKGZyb20sIHRvKSwgcG9zID0gZnJvbSwgbTsgIWN1cnNvci5uZXh0KCkuZG9uZTsgcG9zICs9IGN1cnNvci52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFjdXJzb3IubGluZUJyZWFrKVxuICAgICAgICAgICAgd2hpbGUgKG0gPSByZS5leGVjKGN1cnNvci52YWx1ZSkpXG4gICAgICAgICAgICAgICAgZihwb3MgKyBtLmluZGV4LCBtKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXRjaFJhbmdlcyh2aWV3LCBtYXhMZW5ndGgpIHtcbiAgICBsZXQgdmlzaWJsZSA9IHZpZXcudmlzaWJsZVJhbmdlcztcbiAgICBpZiAodmlzaWJsZS5sZW5ndGggPT0gMSAmJiB2aXNpYmxlWzBdLmZyb20gPT0gdmlldy52aWV3cG9ydC5mcm9tICYmXG4gICAgICAgIHZpc2libGVbMF0udG8gPT0gdmlldy52aWV3cG9ydC50bylcbiAgICAgICAgcmV0dXJuIHZpc2libGU7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aXNpYmxlKSB7XG4gICAgICAgIGZyb20gPSBNYXRoLm1heCh2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSkuZnJvbSwgZnJvbSAtIG1heExlbmd0aCk7XG4gICAgICAgIHRvID0gTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKS50bywgdG8gKyBtYXhMZW5ndGgpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLnRvID49IGZyb20pXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLnRvID0gdG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkhlbHBlciBjbGFzcyB1c2VkIHRvIG1ha2UgaXQgZWFzaWVyIHRvIG1haW50YWluIGRlY29yYXRpb25zIG9uXG52aXNpYmxlIGNvZGUgdGhhdCBtYXRjaGVzIGEgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uLiBUbyBiZSB1c2VkXG5pbiBhIFt2aWV3IHBsdWdpbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlZpZXdQbHVnaW4pLiBJbnN0YW5jZXMgb2YgdGhpcyBvYmplY3RcbnJlcHJlc2VudCBhIG1hdGNoaW5nIGNvbmZpZ3VyYXRpb24uXG4qL1xuY2xhc3MgTWF0Y2hEZWNvcmF0b3Ige1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGRlY29yYXRvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBjb25zdCB7IHJlZ2V4cCwgZGVjb3JhdGlvbiwgZGVjb3JhdGUsIGJvdW5kYXJ5LCBtYXhMZW5ndGggPSAxMDAwIH0gPSBjb25maWc7XG4gICAgICAgIGlmICghcmVnZXhwLmdsb2JhbClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnaXZlbiB0byBNYXRjaERlY29yYXRvciBzaG91bGQgaGF2ZSBpdHMgJ2cnIGZsYWcgc2V0XCIpO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9IHJlZ2V4cDtcbiAgICAgICAgaWYgKGRlY29yYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCB2aWV3LCBmcm9tLCBhZGQpID0+IGRlY29yYXRlKGFkZCwgZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgbWF0Y2gsIHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZWNvcmF0aW9uID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGRlY28gPSBkZWNvcmF0aW9uKG1hdGNoLCB2aWV3LCBmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjbylcbiAgICAgICAgICAgICAgICAgICAgYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY28pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCBfdmlldywgZnJvbSwgYWRkKSA9PiBhZGQoZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgZGVjb3JhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVpdGhlciAnZGVjb3JhdGUnIG9yICdkZWNvcmF0aW9uJyBzaG91bGQgYmUgcHJvdmlkZWQgdG8gTWF0Y2hEZWNvcmF0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib3VuZGFyeSA9IGJvdW5kYXJ5O1xuICAgICAgICB0aGlzLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcHV0ZSB0aGUgZnVsbCBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIG1hdGNoZXMgaW4gdGhlIGdpdmVuXG4gICAgdmlldydzIHZpZXdwb3J0LiBZb3UnbGwgd2FudCB0byBjYWxsIHRoaXMgd2hlbiBpbml0aWFsaXppbmcgeW91clxuICAgIHBsdWdpbi5cbiAgICAqL1xuICAgIGNyZWF0ZURlY28odmlldykge1xuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCksIGFkZCA9IGJ1aWxkLmFkZC5iaW5kKGJ1aWxkKTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1hdGNoUmFuZ2VzKHZpZXcsIHRoaXMubWF4TGVuZ3RoKSlcbiAgICAgICAgICAgIGl0ZXJNYXRjaGVzKHZpZXcuc3RhdGUuZG9jLCB0aGlzLnJlZ2V4cCwgZnJvbSwgdG8sIChmcm9tLCBtKSA9PiB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIGZyb20sIGFkZCkpO1xuICAgICAgICByZXR1cm4gYnVpbGQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgYSB2aWV3IHVwZGF0ZS4gYGRlY29gIF9tdXN0XyBiZVxuICAgIHRoZSBzZXQgb2YgZGVjb3JhdGlvbnMgcHJvZHVjZWQgYnkgX3RoaXNfIGBNYXRjaERlY29yYXRvcmAgZm9yXG4gICAgdGhlIHZpZXcgc3RhdGUgYmVmb3JlIHRoZSB1cGRhdGUuXG4gICAgKi9cbiAgICB1cGRhdGVEZWNvKHVwZGF0ZSwgZGVjbykge1xuICAgICAgICBsZXQgY2hhbmdlRnJvbSA9IDFlOSwgY2hhbmdlVG8gPSAtMTtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdXBkYXRlLmNoYW5nZXMuaXRlckNoYW5nZXMoKF9mLCBfdCwgZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodG8gPj0gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSAmJiBmcm9tIDw9IHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUZyb20gPSBNYXRoLm1pbihmcm9tLCBjaGFuZ2VGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVG8gPSBNYXRoLm1heCh0bywgY2hhbmdlVG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlLnZpZXdwb3J0TW92ZWQgfHwgY2hhbmdlVG8gLSBjaGFuZ2VGcm9tID4gMTAwMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICBpZiAoY2hhbmdlVG8gPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVJhbmdlKHVwZGF0ZS52aWV3LCBkZWNvLm1hcCh1cGRhdGUuY2hhbmdlcyksIGNoYW5nZUZyb20sIGNoYW5nZVRvKTtcbiAgICAgICAgcmV0dXJuIGRlY287XG4gICAgfVxuICAgIHVwZGF0ZVJhbmdlKHZpZXcsIGRlY28sIHVwZGF0ZUZyb20sIHVwZGF0ZVRvKSB7XG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHIuZnJvbSwgdXBkYXRlRnJvbSksIHRvID0gTWF0aC5taW4oci50bywgdXBkYXRlVG8pO1xuICAgICAgICAgICAgaWYgKHRvID49IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIHRvTGluZSA9IGZyb21MaW5lLnRvIDwgdG8gPyB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pIDogZnJvbUxpbmU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoci5mcm9tLCBmcm9tTGluZS5mcm9tKSwgZW5kID0gTWF0aC5taW4oci50bywgdG9MaW5lLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZnJvbSA+IGZyb21MaW5lLmZyb207IGZyb20tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QoZnJvbUxpbmUudGV4dFtmcm9tIC0gMSAtIGZyb21MaW5lLmZyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHRvIDwgdG9MaW5lLnRvOyB0bysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdCh0b0xpbmUudGV4dFt0byAtIHRvTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdLCBtO1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSAoZnJvbSwgdG8sIGRlY28pID0+IHJhbmdlcy5wdXNoKGRlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUxpbmUgPT0gdG9MaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0IC0gZnJvbUxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtID0gdGhpcy5yZWdleHAuZXhlYyhmcm9tTGluZS50ZXh0KSkgJiYgbS5pbmRleCA8IGVuZCAtIGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIG0uaW5kZXggKyBmcm9tTGluZS5mcm9tLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBzdGFydCwgZW5kLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbyA9IGRlY28udXBkYXRlKHsgZmlsdGVyRnJvbTogc3RhcnQsIGZpbHRlclRvOiBlbmQsIGZpbHRlcjogKGZyb20sIHRvKSA9PiBmcm9tIDwgc3RhcnQgfHwgdG8gPiBlbmQsIGFkZDogcmFuZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbn1cblxuY29uc3QgVW5pY29kZVJlZ2V4cFN1cHBvcnQgPSAveC8udW5pY29kZSAhPSBudWxsID8gXCJndVwiIDogXCJnXCI7XG5jb25zdCBTcGVjaWFscyA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcdTAwMDAtXFx1MDAwOFxcdTAwMGEtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYlxcdTIwMGVcXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHUyMDJkXFx1MjAyZVxcdTIwNjZcXHUyMDY3XFx1MjA2OVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdXCIsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbmNvbnN0IE5hbWVzID0ge1xuICAgIDA6IFwibnVsbFwiLFxuICAgIDc6IFwiYmVsbFwiLFxuICAgIDg6IFwiYmFja3NwYWNlXCIsXG4gICAgMTA6IFwibmV3bGluZVwiLFxuICAgIDExOiBcInZlcnRpY2FsIHRhYlwiLFxuICAgIDEzOiBcImNhcnJpYWdlIHJldHVyblwiLFxuICAgIDI3OiBcImVzY2FwZVwiLFxuICAgIDgyMDM6IFwiemVybyB3aWR0aCBzcGFjZVwiLFxuICAgIDgyMDQ6IFwiemVybyB3aWR0aCBub24tam9pbmVyXCIsXG4gICAgODIwNTogXCJ6ZXJvIHdpZHRoIGpvaW5lclwiLFxuICAgIDgyMDY6IFwibGVmdC10by1yaWdodCBtYXJrXCIsXG4gICAgODIwNzogXCJyaWdodC10by1sZWZ0IG1hcmtcIixcbiAgICA4MjMyOiBcImxpbmUgc2VwYXJhdG9yXCIsXG4gICAgODIzNzogXCJsZWZ0LXRvLXJpZ2h0IG92ZXJyaWRlXCIsXG4gICAgODIzODogXCJyaWdodC10by1sZWZ0IG92ZXJyaWRlXCIsXG4gICAgODI5NDogXCJsZWZ0LXRvLXJpZ2h0IGlzb2xhdGVcIixcbiAgICA4Mjk1OiBcInJpZ2h0LXRvLWxlZnQgaXNvbGF0ZVwiLFxuICAgIDgyOTc6IFwicG9wIGRpcmVjdGlvbmFsIGlzb2xhdGVcIixcbiAgICA4MjMzOiBcInBhcmFncmFwaCBzZXBhcmF0b3JcIixcbiAgICA2NTI3OTogXCJ6ZXJvIHdpZHRoIG5vLWJyZWFrIHNwYWNlXCIsXG4gICAgNjU1MzI6IFwib2JqZWN0IHJlcGxhY2VtZW50XCJcbn07XG5sZXQgX3N1cHBvcnRzVGFiU2l6ZSA9IG51bGw7XG5mdW5jdGlvbiBzdXBwb3J0c1RhYlNpemUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChfc3VwcG9ydHNUYWJTaXplID09IG51bGwgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBsZXQgc3R5bGVzID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgX3N1cHBvcnRzVGFiU2l6ZSA9ICgoX2EgPSBzdHlsZXMudGFiU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3R5bGVzLk1velRhYlNpemUpICE9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfc3VwcG9ydHNUYWJTaXplIHx8IGZhbHNlO1xufVxuY29uc3Qgc3BlY2lhbENoYXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICAgICAgc3BlY2lhbENoYXJzOiBTcGVjaWFscyxcbiAgICAgICAgICAgIGFkZFNwZWNpYWxDaGFyczogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5yZXBsYWNlVGFicyA9ICFzdXBwb3J0c1RhYlNpemUoKSlcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKFwiXFx0fFwiICsgY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSArIFwifFwiICsgY29uZmlnLmFkZFNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBpbnN0YWxscyBoaWdobGlnaHRpbmcgb2Ygc3BlY2lhbFxuY2hhcmFjdGVycy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTcGVjaWFsQ2hhcnMoXG4vKipcbkNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiovXG5jb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbc3BlY2lhbENoYXJDb25maWcub2YoY29uZmlnKSwgc3BlY2lhbENoYXJQbHVnaW4oKV07XG59XG5sZXQgX3BsdWdpbiA9IG51bGw7XG5mdW5jdGlvbiBzcGVjaWFsQ2hhclBsdWdpbigpIHtcbiAgICByZXR1cm4gX3BsdWdpbiB8fCAoX3BsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRvciA9IHRoaXMubWFrZURlY29yYXRvcih2aWV3LnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlRGVjb3JhdG9yKGNvbmYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgICAgICAgICAgICAgIHJlZ2V4cDogY29uZi5zcGVjaWFsQ2hhcnMsXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogKG0sIHZpZXcsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZVBvaW50QXQobVswXSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSB2aWV3LnN0YXRlLnRhYlNpemUsIGNvbCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgc2l6ZSwgcG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IFRhYldpZGdldCgoc2l6ZSAtIChjb2wgJSBzaXplKSkgKiB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoIC8gdGhpcy52aWV3LnNjYWxlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdID0gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgU3BlY2lhbENoYXJXaWRnZXQoY29uZiwgY29kZSkgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmRhcnk6IGNvbmYucmVwbGFjZVRhYnMgPyB1bmRlZmluZWQgOiAvW15dL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSAhPSBjb25mKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3IoY29uZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLnVwZGF0ZURlY28odXBkYXRlLCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pKTtcbn1cbmNvbnN0IERlZmF1bHRQbGFjZWhvbGRlciA9IFwiXFx1MjAyMlwiO1xuLy8gQXNzaWducyBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzIGZyb20gdGhlIENvbnRyb2wgUGljdHVyZXMgYmxvY2sgdG9cbi8vIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyc1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIkMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPj0gMzIpXG4gICAgICAgIHJldHVybiBEZWZhdWx0UGxhY2Vob2xkZXI7XG4gICAgaWYgKGNvZGUgPT0gMTApXG4gICAgICAgIHJldHVybiBcIlxcdTI0MjRcIjtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5MjE2ICsgY29kZSk7XG59XG5jbGFzcyBTcGVjaWFsQ2hhcldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvZGUgPT0gdGhpcy5jb2RlOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgcGggPSBwbGFjZWhvbGRlciQxKHRoaXMuY29kZSk7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5zdGF0ZS5waHJhc2UoXCJDb250cm9sIGNoYXJhY3RlclwiKSArIFwiIFwiICsgKE5hbWVzW3RoaXMuY29kZV0gfHwgXCIweFwiICsgdGhpcy5jb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLm9wdGlvbnMucmVuZGVyICYmIHRoaXMub3B0aW9ucy5yZW5kZXIodGhpcy5jb2RlLCBkZXNjLCBwaCk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gcGg7XG4gICAgICAgIHNwYW4udGl0bGUgPSBkZXNjO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGVzYyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zcGVjaWFsQ2hhclwiO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuY2xhc3MgVGFiV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIud2lkdGggPT0gdGhpcy53aWR0aDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJcXHRcIjtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXRhYlwiO1xuICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuY29uc3QgcGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDAwO1xuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB1cGRhdGU7XG4gICAgICAgIGxldCBoZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQgLVxuICAgICAgICAgICAgdmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCAtIDAuNTtcbiAgICAgICAgaWYgKGhlaWdodCA+PSAwICYmIGhlaWdodCAhPSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogYHBhZGRpbmctYm90dG9tOiAke2hlaWdodH1weGAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IG1ha2VzIHN1cmUgdGhlIGNvbnRlbnQgaGFzIGEgYm90dG9tXG5tYXJnaW4gZXF1aXZhbGVudCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBlZGl0b3IsIG1pbnVzIG9uZSBsaW5lXG5oZWlnaHQsIHNvIHRoYXQgZXZlcnkgbGluZSBpbiB0aGUgZG9jdW1lbnQgY2FuIGJlIHNjcm9sbGVkIHRvIHRoZVxudG9wIG9mIHRoZSBlZGl0b3IuXG5cblRoaXMgaXMgb25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxhYmxlLCBhbmQgc2hvdWxkXG5ub3QgYmUgZW5hYmxlZCBpbiBlZGl0b3JzIHRoYXQgdGFrZSB0aGUgc2l6ZSBvZiB0aGVpciBjb250ZW50LlxuKi9cbmZ1bmN0aW9uIHNjcm9sbFBhc3RFbmQoKSB7XG4gICAgcmV0dXJuIFtwbHVnaW4sIGNvbnRlbnRBdHRyaWJ1dGVzLm9mKHZpZXcgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzKSB8fCBudWxsOyB9KV07XG59XG5cbi8qKlxuTWFyayBsaW5lcyB0aGF0IGhhdmUgYSBjdXJzb3Igb24gdGhlbSB3aXRoIHRoZSBgXCJjbS1hY3RpdmVMaW5lXCJgXG5ET00gY2xhc3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgbGluZURlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5saW5lKHsgY2xhc3M6IFwiY20tYWN0aXZlTGluZVwiIH0pO1xuY29uc3QgYWN0aXZlTGluZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBsYXN0TGluZVN0YXJ0ID0gLTEsIGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChyLmhlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IGxhc3RMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2gobGluZURlY28ucmFuZ2UobGluZS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVTdGFydCA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuXG5jbGFzcyBQbGFjZWhvbGRlciBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB3cmFwLmNsYXNzTmFtZSA9IFwiY20tcGxhY2Vob2xkZXJcIjtcbiAgICAgICAgd3JhcC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jb250ZW50KSA6XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5jb250ZW50ID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuY29udGVudCh2aWV3KSA6XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgIHdyYXAuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICByZXR1cm4gd3JhcDtcbiAgICB9XG4gICAgY29vcmRzQXQoZG9tKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGRvbS5maXJzdENoaWxkID8gY2xpZW50UmVjdHNGb3IoZG9tLmZpcnN0Q2hpbGQpIDogW107XG4gICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbS5wYXJlbnROb2RlKTtcbiAgICAgICAgbGV0IHJlY3QgPSBmbGF0dGVuUmVjdChyZWN0c1swXSwgc3R5bGUuZGlyZWN0aW9uICE9IFwicnRsXCIpO1xuICAgICAgICBsZXQgbGluZUhlaWdodCA9IHBhcnNlSW50KHN0eWxlLmxpbmVIZWlnaHQpO1xuICAgICAgICBpZiAocmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IGxpbmVIZWlnaHQgKiAxLjUpXG4gICAgICAgICAgICByZXR1cm4geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgbGluZUhlaWdodCB9O1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLyoqXG5FeHRlbnNpb24gdGhhdCBlbmFibGVzIGEgcGxhY2Vob2xkZXJcdTIwMTRhIHBpZWNlIG9mIGV4YW1wbGUgY29udGVudFxudG8gc2hvdyB3aGVuIHRoZSBlZGl0b3IgaXMgZW1wdHkuXG4qL1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIoY29udGVudCkge1xuICAgIGxldCBwbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gY29udGVudFxuICAgICAgICAgICAgICAgID8gRGVjb3JhdGlvbi5zZXQoW0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiBuZXcgUGxhY2Vob2xkZXIoY29udGVudCksIHNpZGU6IDEgfSkucmFuZ2UoMCldKVxuICAgICAgICAgICAgICAgIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkZWNvcmF0aW9ucygpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoID8gRGVjb3JhdGlvbi5ub25lIDogdGhpcy5wbGFjZWhvbGRlcjsgfVxuICAgIH0sIHsgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9ucyB9KTtcbiAgICByZXR1cm4gdHlwZW9mIGNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IFtcbiAgICAgICAgcGx1Z2luLCBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHsgXCJhcmlhLXBsYWNlaG9sZGVyXCI6IGNvbnRlbnQgfSlcbiAgICBdIDogcGx1Z2luO1xufVxuXG4vLyBEb24ndCBjb21wdXRlIHByZWNpc2UgY29sdW1uIHBvc2l0aW9ucyBmb3IgbGluZSBvZmZzZXRzIGFib3ZlIHRoaXNcbi8vIChzaW5jZSBpdCBjb3VsZCBnZXQgZXhwZW5zaXZlKS4gQXNzdW1lIG9mZnNldD09Y29sdW1uIGZvciB0aGVtLlxuY29uc3QgTWF4T2ZmID0gMjAwMDtcbmZ1bmN0aW9uIHJlY3RhbmdsZUZvcihzdGF0ZSwgYSwgYikge1xuICAgIGxldCBzdGFydExpbmUgPSBNYXRoLm1pbihhLmxpbmUsIGIubGluZSksIGVuZExpbmUgPSBNYXRoLm1heChhLmxpbmUsIGIubGluZSk7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGlmIChhLm9mZiA+IE1heE9mZiB8fCBiLm9mZiA+IE1heE9mZiB8fCBhLmNvbCA8IDAgfHwgYi5jb2wgPCAwKSB7XG4gICAgICAgIGxldCBzdGFydE9mZiA9IE1hdGgubWluKGEub2ZmLCBiLm9mZiksIGVuZE9mZiA9IE1hdGgubWF4KGEub2ZmLCBiLm9mZik7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IGVuZE9mZilcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnRPZmYsIGxpbmUudG8gKyBlbmRPZmYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHN0YXJ0Q29sID0gTWF0aC5taW4oYS5jb2wsIGIuY29sKSwgZW5kQ29sID0gTWF0aC5tYXgoYS5jb2wsIGIuY29sKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgc3RhcnRDb2wsIHN0YXRlLnRhYlNpemUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBlbmRDb2wsIHN0YXRlLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydCwgbGluZS5mcm9tICsgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGFic29sdXRlQ29sdW1uKHZpZXcsIHgpIHtcbiAgICBsZXQgcmVmID0gdmlldy5jb29yZHNBdFBvcyh2aWV3LnZpZXdwb3J0LmZyb20pO1xuICAgIHJldHVybiByZWYgPyBNYXRoLnJvdW5kKE1hdGguYWJzKChyZWYubGVmdCAtIHgpIC8gdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpKSA6IC0xO1xufVxuZnVuY3Rpb24gZ2V0UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG9mZnNldCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChvZmZzZXQpLCBvZmYgPSBvZmZzZXQgLSBsaW5lLmZyb207XG4gICAgbGV0IGNvbCA9IG9mZiA+IE1heE9mZiA/IC0xXG4gICAgICAgIDogb2ZmID09IGxpbmUubGVuZ3RoID8gYWJzb2x1dGVDb2x1bW4odmlldywgZXZlbnQuY2xpZW50WClcbiAgICAgICAgICAgIDogY291bnRDb2x1bW4obGluZS50ZXh0LCB2aWV3LnN0YXRlLnRhYlNpemUsIG9mZnNldCAtIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIHsgbGluZTogbGluZS5udW1iZXIsIGNvbCwgb2ZmIH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IGdldFBvcyh2aWV3LCBldmVudCksIHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCFzdGFydClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lKHN0YXJ0LmxpbmUpLmZyb20pO1xuICAgICAgICAgICAgICAgIGxldCBuZXdMaW5lID0gdXBkYXRlLnN0YXRlLmRvYy5saW5lQXQobmV3U3RhcnQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0geyBsaW5lOiBuZXdMaW5lLm51bWJlciwgY29sOiBzdGFydC5jb2wsIG9mZjogTWF0aC5taW4oc3RhcnQub2ZmLCBuZXdMaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgX2V4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBnZXRQb3ModmlldywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFjdXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHJlY3RhbmdsZUZvcih2aWV3LnN0YXRlLCBzdGFydCwgY3VyKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmNvbmNhdChzdGFydFNlbC5yYW5nZXMpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgcmVjdGFuZ3VsYXIgc2VsZWN0aW9ucy4gQnlcbmRlZmF1bHQsIGl0IHdpbGwgcmVhY3QgdG8gbGVmdCBtb3VzZSBkcmFnIHdpdGggdGhlIEFsdCBrZXkgaGVsZFxuZG93bi4gV2hlbiBzdWNoIGEgc2VsZWN0aW9uIG9jY3VycywgdGhlIHRleHQgd2l0aGluIHRoZSByZWN0YW5nbGVcbnRoYXQgd2FzIGRyYWdnZWQgb3ZlciB3aWxsIGJlIHNlbGVjdGVkLCBhcyBvbmUgc2VsZWN0aW9uXG5bcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UpIHBlciBsaW5lLlxuKi9cbmZ1bmN0aW9uIHJlY3Rhbmd1bGFyU2VsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlsdGVyID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudEZpbHRlcikgfHwgKGUgPT4gZS5hbHRLZXkgJiYgZS5idXR0b24gPT0gMCk7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZS5vZigodmlldywgZXZlbnQpID0+IGZpbHRlcihldmVudCkgPyByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkgOiBudWxsKTtcbn1cbmNvbnN0IGtleXMgPSB7XG4gICAgQWx0OiBbMTgsIGUgPT4gISFlLmFsdEtleV0sXG4gICAgQ29udHJvbDogWzE3LCBlID0+ICEhZS5jdHJsS2V5XSxcbiAgICBTaGlmdDogWzE2LCBlID0+ICEhZS5zaGlmdEtleV0sXG4gICAgTWV0YTogWzkxLCBlID0+ICEhZS5tZXRhS2V5XVxufTtcbmNvbnN0IHNob3dDcm9zc2hhaXIgPSB7IHN0eWxlOiBcImN1cnNvcjogY3Jvc3NoYWlyXCIgfTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCB0dXJucyB0aGUgcG9pbnRlciBjdXJzb3IgaW50byBhXG5jcm9zc2hhaXIgd2hlbiBhIGdpdmVuIG1vZGlmaWVyIGtleSwgZGVmYXVsdGluZyB0byBBbHQsIGlzIGhlbGRcbmRvd24uIENhbiBzZXJ2ZSBhcyBhIHZpc3VhbCBoaW50IHRoYXQgcmVjdGFuZ3VsYXIgc2VsZWN0aW9uIGlzXG5nb2luZyB0byBoYXBwZW4gd2hlbiBwYWlyZWQgd2l0aFxuW2ByZWN0YW5ndWxhclNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5yZWN0YW5ndWxhclNlbGVjdGlvbikuXG4qL1xuZnVuY3Rpb24gY3Jvc3NoYWlyQ3Vyc29yKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBbY29kZSwgZ2V0dGVyXSA9IGtleXNbb3B0aW9ucy5rZXkgfHwgXCJBbHRcIl07XG4gICAgbGV0IHBsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGlzRG93bikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEb3duICE9IGlzRG93bikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEb3duID0gaXNEb3duO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICAgICAga2V5ZG93bihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZS5rZXlDb2RlID09IGNvZGUgfHwgZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXl1cChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSBjb2RlIHx8ICFnZXR0ZXIoZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZW1vdmUoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGdldHRlcihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwbHVnaW4sXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEb3duKSA/IHNob3dDcm9zc2hhaXIgOiBudWxsOyB9KVxuICAgIF07XG59XG5cbmNvbnN0IE91dHNpZGUgPSBcIi0xMDAwMHB4XCI7XG5jbGFzcyBUb29sdGlwVmlld01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGZhY2V0LCBjcmVhdGVUb29sdGlwVmlldywgcmVtb3ZlVG9vbHRpcFZpZXcpIHtcbiAgICAgICAgdGhpcy5mYWNldCA9IGZhY2V0O1xuICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3ID0gY3JlYXRlVG9vbHRpcFZpZXc7XG4gICAgICAgIHRoaXMucmVtb3ZlVG9vbHRpcFZpZXcgPSByZW1vdmVUb29sdGlwVmlldztcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdGhpcy5pbnB1dC5maWx0ZXIodCA9PiB0KTtcbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRoaXMudG9vbHRpcHMubWFwKHQgPT4gcHJldiA9IGNyZWF0ZVRvb2x0aXBWaWV3KHQsIHByZXYpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgYWJvdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhpcy5mYWNldCk7XG4gICAgICAgIGxldCB0b29sdGlwcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgaWYgKHQudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b29sdGlwVmlld3MgPSBbXSwgbmV3QWJvdmUgPSBhYm92ZSA/IFtdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpcCA9IHRvb2x0aXBzW2ldLCBrbm93biA9IC0xO1xuICAgICAgICAgICAgaWYgKCF0aXApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSB0aGlzLnRvb2x0aXBzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlciAmJiBvdGhlci5jcmVhdGUgPT0gdGlwLmNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAga25vd24gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcodGlwLCBpID8gdG9vbHRpcFZpZXdzW2kgLSAxXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdBYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgbmV3QWJvdmVbaV0gPSAhIXRpcC5hYm92ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMudG9vbHRpcFZpZXdzW2tub3duXTtcbiAgICAgICAgICAgICAgICBpZiAobmV3QWJvdmUpXG4gICAgICAgICAgICAgICAgICAgIG5ld0Fib3ZlW2ldID0gYWJvdmVba25vd25dO1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwVmlldy51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICBpZiAodG9vbHRpcFZpZXdzLmluZGV4T2YodCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUb29sdGlwVmlldyh0KTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoYWJvdmUpIHtcbiAgICAgICAgICAgIG5ld0Fib3ZlLmZvckVhY2goKHZhbCwgaSkgPT4gYWJvdmVbaV0gPSB2YWwpO1xuICAgICAgICAgICAgYWJvdmUubGVuZ3RoID0gbmV3QWJvdmUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy50b29sdGlwcyA9IHRvb2x0aXBzO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRvb2x0aXBWaWV3cztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG5DcmVhdGVzIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgdG9vbHRpcCBiZWhhdmlvci5cbiovXG5mdW5jdGlvbiB0b29sdGlwcyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiB0b29sdGlwQ29uZmlnLm9mKGNvbmZpZyk7XG59XG5mdW5jdGlvbiB3aW5kb3dTcGFjZSh2aWV3KSB7XG4gICAgbGV0IGRvY0VsdCA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiBkb2NFbHQuY2xpZW50SGVpZ2h0LCByaWdodDogZG9jRWx0LmNsaWVudFdpZHRoIH07XG59XG5jb25zdCB0b29sdGlwQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgcG9zaXRpb246IGJyb3dzZXIuaW9zID8gXCJhYnNvbHV0ZVwiIDogKChfYSA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wb3NpdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbikgfHwgXCJmaXhlZFwiLFxuICAgICAgICAgICAgcGFyZW50OiAoKF9iID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBhcmVudCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQpIHx8IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwU3BhY2U6ICgoX2MgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYudG9vbHRpcFNwYWNlKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvb2x0aXBTcGFjZSkgfHwgd2luZG93U3BhY2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3Qga25vd25IZWlnaHQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRvb2x0aXBQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5hYm92ZSA9IFtdO1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMubWFkZUFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gMDtcbiAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGNvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBjb25maWcucGFyZW50O1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSB2aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRNZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLndyaXRlTWVhc3VyZS5iaW5kKHRoaXMpLCBrZXk6IHRoaXMgfTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy5tZWFzdXJlU29vbigpKSA6IG51bGw7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd1Rvb2x0aXAsICh0LCBwKSA9PiB0aGlzLmNyZWF0ZVRvb2x0aXAodCwgcCksIHQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodC5kb20pO1xuICAgICAgICAgICAgdC5kb20ucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFib3ZlID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCh0ID0+ICEhdC5hYm92ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiID8gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiB0aGlzLmxhc3RUcmFuc2FjdGlvbiAtIDUwICYmXG4gICAgICAgICAgICAgICAgZW50cmllcy5sZW5ndGggPiAwICYmIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA8IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlU29vbigpO1xuICAgICAgICB9LCB7IHRocmVzaG9sZDogWzFdIH0pIDogbnVsbDtcbiAgICAgICAgdGhpcy5vYnNlcnZlSW50ZXJzZWN0aW9uKCk7XG4gICAgICAgIHZpZXcud2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbiA9IHRoaXMubWVhc3VyZVNvb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMudmlldy5kb207XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZUludGVyc2VjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0b29sdGlwLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUsIHRoaXMuYWJvdmUpO1xuICAgICAgICBpZiAodXBkYXRlZClcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICBsZXQgc2hvdWxkTWVhc3VyZSA9IHVwZGF0ZWQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZDtcbiAgICAgICAgbGV0IG5ld0NvbmZpZyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wb3NpdGlvbiAhPSB0aGlzLnBvc2l0aW9uICYmICF0aGlzLm1hZGVBYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ld0NvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q29uZmlnLnBhcmVudCAhPSB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBuZXdDb25maWcucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0LmRvbSk7XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnZpZXcudGhlbWVDbGFzc2VzICE9IHRoaXMuY2xhc3Nlcykge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkTWVhc3VyZSlcbiAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAodG9vbHRpcCwgcHJldikge1xuICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBsZXQgYmVmb3JlID0gcHJldiA/IHByZXYuZG9tIDogbnVsbDtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwXCIpO1xuICAgICAgICBpZiAodG9vbHRpcC5hcnJvdyAmJiAhdG9vbHRpcFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcCA+IC5jbS10b29sdGlwLWFycm93XCIpKSB7XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgYXJyb3cuY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWFycm93XCI7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20uYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgICB9XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZSh0b29sdGlwVmlldy5kb20sIGJlZm9yZSk7XG4gICAgICAgIGlmICh0b29sdGlwVmlldy5tb3VudClcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRvb2x0aXBWaWV3LmRvbSk7XG4gICAgICAgIHJldHVybiB0b29sdGlwVmlldztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMudmlldy53aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uKTtcbiAgICAgICAgZm9yIChsZXQgdG9vbHRpcFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgKF9hID0gdG9vbHRpcFZpZXcuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodG9vbHRpcFZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAoX2IgPSB0aGlzLnJlc2l6ZU9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2MgPSB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzY29ubmVjdCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tZWFzdXJlVGltZW91dCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlKCkge1xuICAgICAgICBsZXQgc2NhbGVYID0gMSwgc2NhbGVZID0gMSwgbWFrZUFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IFwiZml4ZWRcIiAmJiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgZG9tIH0gPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzWzBdO1xuICAgICAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGFsd2F5cyBzZXRzIG9mZnNldFBhcmVudCB0byBudWxsLCBldmVuIGlmIGEgZml4ZWRcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gYSB0cmFuc2Zvcm1lZCBwYXJlbnQuIFNvXG4gICAgICAgICAgICAgICAgLy8gd2UgdXNlIHRoaXMga2x1ZGdlIHRvIHRyeSBhbmQgZGV0ZWN0IHRoaXMuXG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbWFrZUFic29sdXRlID0gTWF0aC5hYnMocmVjdC50b3AgKyAxMDAwMCkgPiAxIHx8IE1hdGguYWJzKHJlY3QubGVmdCkgPiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTW9yZSBjb25mb3JtaW5nIGJyb3dzZXJzIHdpbGwgc2V0IG9mZnNldFBhcmVudCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1lZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIG1ha2VBYnNvbHV0ZSA9ICEhZG9tLm9mZnNldFBhcmVudCAmJiBkb20ub2Zmc2V0UGFyZW50ICE9IHRoaXMuY29udGFpbmVyLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWFrZUFic29sdXRlIHx8IHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHRoaXMucGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWCA9IHJlY3Qud2lkdGggLyB0aGlzLnBhcmVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyB0aGlzLnBhcmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldy52aWV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB2aXNpYmxlID0gdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbWFyZ2lucyA9IGdldFNjcm9sbE1hcmdpbnModGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB2aXNpYmxlLmxlZnQgKyBtYXJnaW5zLmxlZnQsIHRvcDogdmlzaWJsZS50b3AgKyBtYXJnaW5zLnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogdmlzaWJsZS5yaWdodCAtIG1hcmdpbnMucmlnaHQsIGJvdHRvbTogdmlzaWJsZS5ib3R0b20gLSBtYXJnaW5zLmJvdHRvbVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQgPyB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHRoaXMudmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBwb3M6IHRoaXMubWFuYWdlci50b29sdGlwcy5tYXAoKHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiB0di5nZXRDb29yZHMgPyB0di5nZXRDb29yZHModC5wb3MpIDogdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHQucG9zKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5tYXAoKHsgZG9tIH0pID0+IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXG4gICAgICAgICAgICBzcGFjZTogdGhpcy52aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpLnRvb2x0aXBTcGFjZSh0aGlzLnZpZXcpLFxuICAgICAgICAgICAgc2NhbGVYLCBzY2FsZVksIG1ha2VBYnNvbHV0ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICB3cml0ZU1lYXN1cmUobWVhc3VyZWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobWVhc3VyZWQubWFrZUFic29sdXRlKSB7XG4gICAgICAgICAgICB0aGlzLm1hZGVBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHQuZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHZpc2libGUsIHNwYWNlLCBzY2FsZVgsIHNjYWxlWSB9ID0gbWVhc3VyZWQ7XG4gICAgICAgIGxldCBvdGhlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzW2ldLCB0VmlldyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV0sIHsgZG9tIH0gPSB0VmlldztcbiAgICAgICAgICAgIGxldCBwb3MgPSBtZWFzdXJlZC5wb3NbaV0sIHNpemUgPSBtZWFzdXJlZC5zaXplW2ldO1xuICAgICAgICAgICAgLy8gSGlkZSB0b29sdGlwcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICBpZiAoIXBvcyB8fCB0b29sdGlwLmNsaXAgIT09IGZhbHNlICYmIChwb3MuYm90dG9tIDw9IE1hdGgubWF4KHZpc2libGUudG9wLCBzcGFjZS50b3ApIHx8XG4gICAgICAgICAgICAgICAgcG9zLnRvcCA+PSBNYXRoLm1pbih2aXNpYmxlLmJvdHRvbSwgc3BhY2UuYm90dG9tKSB8fFxuICAgICAgICAgICAgICAgIHBvcy5yaWdodCA8IE1hdGgubWF4KHZpc2libGUubGVmdCwgc3BhY2UubGVmdCkgLSAuMSB8fFxuICAgICAgICAgICAgICAgIHBvcy5sZWZ0ID4gTWF0aC5taW4odmlzaWJsZS5yaWdodCwgc3BhY2UucmlnaHQpICsgLjEpKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSB0b29sdGlwLmFycm93ID8gdFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcC1hcnJvd1wiKSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJyb3dIZWlnaHQgPSBhcnJvdyA/IDcgLyogQXJyb3cuU2l6ZSAqLyA6IDA7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBzaXplLnJpZ2h0IC0gc2l6ZS5sZWZ0LCBoZWlnaHQgPSAoX2EgPSBrbm93bkhlaWdodC5nZXQodFZpZXcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzaXplLmJvdHRvbSAtIHNpemUudG9wO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRWaWV3Lm9mZnNldCB8fCBub09mZnNldCwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gc2l6ZS53aWR0aCA+IHNwYWNlLnJpZ2h0IC0gc3BhY2UubGVmdFxuICAgICAgICAgICAgICAgID8gKGx0ciA/IHNwYWNlLmxlZnQgOiBzcGFjZS5yaWdodCAtIHNpemUud2lkdGgpXG4gICAgICAgICAgICAgICAgOiBsdHIgPyBNYXRoLm1heChzcGFjZS5sZWZ0LCBNYXRoLm1pbihwb3MubGVmdCAtIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApICsgb2Zmc2V0LngsIHNwYWNlLnJpZ2h0IC0gd2lkdGgpKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKE1hdGgubWF4KHNwYWNlLmxlZnQsIHBvcy5sZWZ0IC0gd2lkdGggKyAoYXJyb3cgPyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gOiAwKSAtIG9mZnNldC54KSwgc3BhY2UucmlnaHQgLSB3aWR0aCk7XG4gICAgICAgICAgICBsZXQgYWJvdmUgPSB0aGlzLmFib3ZlW2ldO1xuICAgICAgICAgICAgaWYgKCF0b29sdGlwLnN0cmljdFNpZGUgJiYgKGFib3ZlXG4gICAgICAgICAgICAgICAgPyBwb3MudG9wIC0gaGVpZ2h0IC0gYXJyb3dIZWlnaHQgLSBvZmZzZXQueSA8IHNwYWNlLnRvcFxuICAgICAgICAgICAgICAgIDogcG9zLmJvdHRvbSArIGhlaWdodCArIGFycm93SGVpZ2h0ICsgb2Zmc2V0LnkgPiBzcGFjZS5ib3R0b20pICYmXG4gICAgICAgICAgICAgICAgYWJvdmUgPT0gKHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20gPiBwb3MudG9wIC0gc3BhY2UudG9wKSlcbiAgICAgICAgICAgICAgICBhYm92ZSA9IHRoaXMuYWJvdmVbaV0gPSAhYWJvdmU7XG4gICAgICAgICAgICBsZXQgc3BhY2VWZXJ0ID0gKGFib3ZlID8gcG9zLnRvcCAtIHNwYWNlLnRvcCA6IHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20pIC0gYXJyb3dIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgaGVpZ2h0ICYmIHRWaWV3LnJlc2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgdGhpcy52aWV3LmRlZmF1bHRMaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga25vd25IZWlnaHQuc2V0KHRWaWV3LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0ID0gc3BhY2VWZXJ0KSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5zdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSBhYm92ZSA/IHBvcy50b3AgLSBoZWlnaHQgLSBhcnJvd0hlaWdodCAtIG9mZnNldC55IDogcG9zLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgb2Zmc2V0Lnk7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgICAgICBpZiAodFZpZXcub3ZlcmxhcCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG90aGVycylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIubGVmdCA8IHJpZ2h0ICYmIHIucmlnaHQgPiBsZWZ0ICYmIHIudG9wIDwgdG9wICsgaGVpZ2h0ICYmIHIuYm90dG9tID4gdG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gYWJvdmUgPyByLnRvcCAtIGhlaWdodCAtIDIgLSBhcnJvd0hlaWdodCA6IHIuYm90dG9tICsgYXJyb3dIZWlnaHQgKyAyO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9ICh0b3AgLSBtZWFzdXJlZC5wYXJlbnQudG9wKSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBzZXRMZWZ0U3R5bGUoZG9tLCAobGVmdCAtIG1lYXN1cmVkLnBhcmVudC5sZWZ0KSAvIHNjYWxlWCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gdG9wIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNldExlZnRTdHlsZShkb20sIGxlZnQgLyBzY2FsZVgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFycm93KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFycm93TGVmdCA9IHBvcy5sZWZ0ICsgKGx0ciA/IG9mZnNldC54IDogLW9mZnNldC54KSAtIChsZWZ0ICsgMTQgLyogQXJyb3cuT2Zmc2V0ICovIC0gNyAvKiBBcnJvdy5TaXplICovKTtcbiAgICAgICAgICAgICAgICBhcnJvdy5zdHlsZS5sZWZ0ID0gYXJyb3dMZWZ0IC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgb3RoZXJzLnB1c2goeyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b206IHRvcCArIGhlaWdodCB9KTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1hYm92ZVwiLCBhYm92ZSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYmVsb3dcIiwgIWFib3ZlKTtcbiAgICAgICAgICAgIGlmICh0Vmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIHRWaWV3LnBvc2l0aW9uZWQobWVhc3VyZWQuc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlTWVhc3VyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci50b29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5WaWV3ICE9IHRoaXMudmlldy5pblZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMudmlldy5pblZpZXc7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHYgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgIHNjcm9sbCgpIHsgdGhpcy5tYXliZU1lYXN1cmUoKTsgfVxuICAgIH1cbn0pO1xuZnVuY3Rpb24gc2V0TGVmdFN0eWxlKGVsdCwgdmFsdWUpIHtcbiAgICBsZXQgY3VycmVudCA9IHBhcnNlSW50KGVsdC5zdHlsZS5sZWZ0LCAxMCk7XG4gICAgaWYgKGlzTmFOKGN1cnJlbnQpIHx8IE1hdGguYWJzKHZhbHVlIC0gY3VycmVudCkgPiAxKVxuICAgICAgICBlbHQuc3R5bGUubGVmdCA9IHZhbHVlICsgXCJweFwiO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgekluZGV4OiA1MDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLXNlY3Rpb246bm90KDpmaXJzdC1jaGlsZClcIjoge1xuICAgICAgICBib3JkZXJUb3A6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgaGVpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICB3aWR0aDogYCR7NyAvKiBBcnJvdy5TaXplICovICogMn1weGAsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHpJbmRleDogLTEsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICBcIiY6YmVmb3JlLCAmOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiJydcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1hYm92ZSAmXCI6IHtcbiAgICAgICAgICAgIGJvdHRvbTogYC0kezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWJlbG93ICZcIjoge1xuICAgICAgICAgICAgdG9wOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgdG9wOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCIjMzMzMzM4XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IG5vT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4vKipcbkZhY2V0IHRvIHdoaWNoIGFuIGV4dGVuc2lvbiBjYW4gYWRkIGEgdmFsdWUgdG8gc2hvdyBhIHRvb2x0aXAuXG4qL1xuY29uc3Qgc2hvd1Rvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBbdG9vbHRpcFBsdWdpbiwgYmFzZVRoZW1lXVxufSk7XG5jb25zdCBzaG93SG92ZXJUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogaW5wdXRzID0+IGlucHV0cy5yZWR1Y2UoKGEsIGkpID0+IGEuY29uY2F0KGkpLCBbXSlcbn0pO1xuY2xhc3MgSG92ZXJUb29sdGlwSG9zdCB7XG4gICAgLy8gTmVlZHMgdG8gYmUgc3RhdGljIHNvIHRoYXQgaG9zdCB0b29sdGlwIGluc3RhbmNlcyBhbHdheXMgbWF0Y2hcbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIb3ZlclRvb2x0aXBIb3N0KHZpZXcpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLWhvdmVyXCIpO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgVG9vbHRpcFZpZXdNYW5hZ2VyKHZpZXcsIHNob3dIb3ZlclRvb2x0aXAsICh0LCBwKSA9PiB0aGlzLmNyZWF0ZUhvc3RlZFZpZXcodCwgcCksIHQgPT4gdC5kb20ucmVtb3ZlKCkpO1xuICAgIH1cbiAgICBjcmVhdGVIb3N0ZWRWaWV3KHRvb2x0aXAsIHByZXYpIHtcbiAgICAgICAgbGV0IGhvc3RlZFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBob3N0ZWRWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1zZWN0aW9uXCIpO1xuICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUoaG9zdGVkVmlldy5kb20sIHByZXYgPyBwcmV2LmRvbS5uZXh0U2libGluZyA6IHRoaXMuZG9tLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkICYmIGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiBob3N0ZWRWaWV3O1xuICAgIH1cbiAgICBtb3VudCh2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3LnBvc2l0aW9uZWQoc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgfVxuICAgIHBhc3NQcm9wKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGxldCBnaXZlbiA9IHZpZXdbbmFtZV07XG4gICAgICAgICAgICBpZiAoZ2l2ZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdpdmVuO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSBnaXZlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwib2Zmc2V0XCIpOyB9XG4gICAgZ2V0IGdldENvb3JkcygpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJnZXRDb29yZHNcIik7IH1cbiAgICBnZXQgb3ZlcmxhcCgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJvdmVybGFwXCIpOyB9XG4gICAgZ2V0IHJlc2l6ZSgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJyZXNpemVcIik7IH1cbn1cbmNvbnN0IHNob3dIb3ZlclRvb2x0aXBIb3N0ID0gLypAX19QVVJFX18qL3Nob3dUb29sdGlwLmNvbXB1dGUoW3Nob3dIb3ZlclRvb2x0aXBdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IHRvb2x0aXBzID0gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCk7XG4gICAgaWYgKHRvb2x0aXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBNYXRoLm1pbiguLi50b29sdGlwcy5tYXAodCA9PiB0LnBvcykpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KC4uLnRvb2x0aXBzLm1hcCh0ID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHQucG9zOyB9KSksXG4gICAgICAgIGNyZWF0ZTogSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUsXG4gICAgICAgIGFib3ZlOiB0b29sdGlwc1swXS5hYm92ZSxcbiAgICAgICAgYXJyb3c6IHRvb2x0aXBzLnNvbWUodCA9PiB0LmFycm93KSxcbiAgICB9O1xufSk7XG5jbGFzcyBIb3ZlclBsdWdpbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc291cmNlLCBmaWVsZCwgc2V0SG92ZXIsIGhvdmVyVGltZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLnNldEhvdmVyID0gc2V0SG92ZXI7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lID0gaG92ZXJUaW1lO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IDAsIHk6IDAsIHRhcmdldDogdmlldy5kb20sIHRpbWU6IDAgfTtcbiAgICAgICAgdGhpcy5jaGVja0hvdmVyID0gdGhpcy5jaGVja0hvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSA9IHRoaXMubW91c2VsZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSA9IHRoaXMubW91c2Vtb3ZlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0SG92ZXIoKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5maWVsZCk7XG4gICAgfVxuICAgIGNoZWNrSG92ZXIoKSB7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBob3ZlcmVkID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdE1vdmUudGltZTtcbiAgICAgICAgaWYgKGhvdmVyZWQgPCB0aGlzLmhvdmVyVGltZSlcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lIC0gaG92ZXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIb3ZlcigpO1xuICAgIH1cbiAgICBzdGFydEhvdmVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgIGxldCB7IHZpZXcsIGxhc3RNb3ZlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdGlsZSA9IHZpZXcuZG9jVmlldy50aWxlLm5lYXJlc3QobGFzdE1vdmUudGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0aWxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zLCBzaWRlID0gMTtcbiAgICAgICAgaWYgKHRpbGUuaXNXaWRnZXQoKSkge1xuICAgICAgICAgICAgcG9zID0gdGlsZS5wb3NBdFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gdmlldy5wb3NBdENvb3JkcyhsYXN0TW92ZSk7XG4gICAgICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHBvc0Nvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgICAgIGlmICghcG9zQ29vcmRzIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueSA8IHBvc0Nvb3Jkcy50b3AgfHwgbGFzdE1vdmUueSA+IHBvc0Nvb3Jkcy5ib3R0b20gfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgLSB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnggPiBwb3NDb29yZHMucmlnaHQgKyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgYmlkaSA9IHZpZXcuYmlkaVNwYW5zKHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpKS5maW5kKHMgPT4gcy5mcm9tIDw9IHBvcyAmJiBzLnRvID49IHBvcyk7XG4gICAgICAgICAgICBsZXQgcnRsID0gYmlkaSAmJiBiaWRpLmRpciA9PSBEaXJlY3Rpb24uUlRMID8gLTEgOiAxO1xuICAgICAgICAgICAgc2lkZSA9IChsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgPyAtcnRsIDogcnRsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuc291cmNlKHZpZXcsIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChvcGVuID09PSBudWxsIHx8IG9wZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW4udGhlbikge1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcgPSB7IHBvcyB9O1xuICAgICAgICAgICAgb3Blbi50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgIShBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgIXJlc3VsdC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0IDogW3Jlc3VsdF0pIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGUgPT4gbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiaG92ZXIgdG9vbHRpcFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlbiAmJiAhKEFycmF5LmlzQXJyYXkob3BlbikgJiYgIW9wZW4ubGVuZ3RoKSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoQXJyYXkuaXNBcnJheShvcGVuKSA/IG9wZW4gOiBbb3Blbl0pIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkge1xuICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy52aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICAgICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLm1hbmFnZXIudG9vbHRpcHMuZmluZEluZGV4KHQgPT4gdC5jcmVhdGUgPT0gSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUpIDogLTE7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gcGx1Z2luLm1hbmFnZXIudG9vbHRpcFZpZXdzW2luZGV4XSA6IG51bGw7XG4gICAgfVxuICAgIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmxhc3RNb3ZlID0geyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZLCB0YXJnZXQ6IGV2ZW50LnRhcmdldCwgdGltZTogRGF0ZS5ub3coKSB9O1xuICAgICAgICBpZiAodGhpcy5ob3ZlclRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUpO1xuICAgICAgICBsZXQgeyBhY3RpdmUsIHRvb2x0aXAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoICYmIHRvb2x0aXAgJiYgIWlzSW5Ub29sdGlwKHRvb2x0aXAuZG9tLCBldmVudCkgfHwgdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICBsZXQgeyBwb3MgfSA9IGFjdGl2ZVswXSB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYiA9IChfYSA9IGFjdGl2ZVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcG9zO1xuICAgICAgICAgICAgaWYgKChwb3MgPT0gZW5kID8gdGhpcy52aWV3LnBvc0F0Q29vcmRzKHRoaXMubGFzdE1vdmUpICE9IHBvc1xuICAgICAgICAgICAgICAgIDogIWlzT3ZlclJhbmdlKHRoaXMudmlldywgcG9zLCBlbmQsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoW10pIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VsZWF2ZShldmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgeyBhY3RpdmUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyB0b29sdGlwIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IGluVG9vbHRpcCA9IHRvb2x0aXAgJiYgdG9vbHRpcC5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWluVG9vbHRpcClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKFtdKSB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLndhdGNoVG9vbHRpcExlYXZlKHRvb2x0aXAuZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YXRjaFRvb2x0aXBMZWF2ZSh0b29sdGlwKSB7XG4gICAgICAgIGxldCB3YXRjaCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3YXRjaCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUubGVuZ3RoICYmICF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoW10pIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHdhdGNoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdGFydFRpbWVvdXQpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSk7XG4gICAgfVxufVxuY29uc3QgdG9vbHRpcE1hcmdpbiA9IDQ7XG5mdW5jdGlvbiBpc0luVG9vbHRpcCh0b29sdGlwLCBldmVudCkge1xuICAgIGxldCB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gdG9vbHRpcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYXJyb3c7XG4gICAgaWYgKGFycm93ID0gdG9vbHRpcC5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAtYXJyb3dcIikpIHtcbiAgICAgICAgbGV0IGFycm93UmVjdCA9IGFycm93LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0b3AgPSBNYXRoLm1pbihhcnJvd1JlY3QudG9wLCB0b3ApO1xuICAgICAgICBib3R0b20gPSBNYXRoLm1heChhcnJvd1JlY3QuYm90dG9tLCBib3R0b20pO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQuY2xpZW50WCA+PSBsZWZ0IC0gdG9vbHRpcE1hcmdpbiAmJiBldmVudC5jbGllbnRYIDw9IHJpZ2h0ICsgdG9vbHRpcE1hcmdpbiAmJlxuICAgICAgICBldmVudC5jbGllbnRZID49IHRvcCAtIHRvb2x0aXBNYXJnaW4gJiYgZXZlbnQuY2xpZW50WSA8PSBib3R0b20gKyB0b29sdGlwTWFyZ2luO1xufVxuZnVuY3Rpb24gaXNPdmVyUmFuZ2UodmlldywgZnJvbSwgdG8sIHgsIHksIG1hcmdpbikge1xuICAgIGxldCByZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvY0JvdHRvbSA9IHZpZXcuZG9jdW1lbnRUb3AgKyB2aWV3LmRvY3VtZW50UGFkZGluZy50b3AgKyB2aWV3LmNvbnRlbnRIZWlnaHQ7XG4gICAgaWYgKHJlY3QubGVmdCA+IHggfHwgcmVjdC5yaWdodCA8IHggfHwgcmVjdC50b3AgPiB5IHx8IE1hdGgubWluKHJlY3QuYm90dG9tLCBkb2NCb3R0b20pIDwgeSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeCwgeSB9LCBmYWxzZSk7XG4gICAgcmV0dXJuIHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bztcbn1cbi8qKlxuU2V0IHVwIGEgaG92ZXIgdG9vbHRpcCwgd2hpY2ggc2hvd3MgdXAgd2hlbiB0aGUgcG9pbnRlciBob3ZlcnNcbm92ZXIgcmFuZ2VzIG9mIHRleHQuIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgaG92ZXJzXG5vdmVyIHRoZSBkb2N1bWVudCB0ZXh0LiBJdCBzaG91bGQsIGlmIHRoZXJlIGlzIGEgdG9vbHRpcFxuYXNzb2NpYXRlZCB3aXRoIHBvc2l0aW9uIGBwb3NgLCByZXR1cm4gdGhlIHRvb2x0aXAgZGVzY3JpcHRpb25cbihlaXRoZXIgZGlyZWN0bHkgb3IgaW4gYSBwcm9taXNlKS4gVGhlIGBzaWRlYCBhcmd1bWVudCBpbmRpY2F0ZXNcbm9uIHdoaWNoIHNpZGUgb2YgdGhlIHBvc2l0aW9uIHRoZSBwb2ludGVyIGlzXHUyMDE0aXQgd2lsbCBiZSAtMSBpZiB0aGVcbnBvaW50ZXIgaXMgYmVmb3JlIHRoZSBwb3NpdGlvbiwgMSBpZiBhZnRlciB0aGUgcG9zaXRpb24uXG5cbk5vdGUgdGhhdCBhbGwgaG92ZXIgdG9vbHRpcHMgYXJlIGhvc3RlZCB3aXRoaW4gYSBzaW5nbGUgdG9vbHRpcFxuY29udGFpbmVyIGVsZW1lbnQuIFRoaXMgYWxsb3dzIG11bHRpcGxlIHRvb2x0aXBzIG92ZXIgdGhlIHNhbWVcbnJhbmdlIHRvIGJlIFwibWVyZ2VkXCIgdG9nZXRoZXIgd2l0aG91dCBvdmVybGFwcGluZy5cblxuVGhlIHJldHVybiB2YWx1ZSBpcyBhIHZhbGlkIFtlZGl0b3IgZXh0ZW5zaW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkV4dGVuc2lvbilcbmJ1dCBhbHNvIHByb3ZpZGVzIGFuIGBhY3RpdmVgIHByb3BlcnR5IGhvbGRpbmcgYSBzdGF0ZSBmaWVsZCB0aGF0XG5jYW4gYmUgdXNlZCB0byByZWFkIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRvb2x0aXBzIHByb2R1Y2VkIGJ5IHRoaXNcbmV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBob3ZlclRvb2x0aXAoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgc2V0SG92ZXIgPSBTdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbiAgICBsZXQgaG92ZXJTdGF0ZSA9IFN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICAgICAgY3JlYXRlKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oaWRlT25DaGFuZ2UgJiYgKHRyLmRvY0NoYW5nZWQgfHwgdHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhpZGVPbilcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5maWx0ZXIodiA9PiAhb3B0aW9ucy5oaWRlT24odHIsIHYpKTtcbiAgICAgICAgICAgICAgICBpZiAodHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdQb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyh0b29sdGlwLnBvcywgLTEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1BvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHRvb2x0aXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkucG9zID0gbmV3UG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3B5LmVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmVuZCA9IHRyLmNoYW5nZXMubWFwUG9zKGNvcHkuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWQucHVzaChjb3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hcHBlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0SG92ZXIpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvdmlkZTogZiA9PiBzaG93SG92ZXJUb29sdGlwLmZyb20oZilcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY3RpdmU6IGhvdmVyU3RhdGUsXG4gICAgICAgIGV4dGVuc2lvbjogW1xuICAgICAgICAgICAgaG92ZXJTdGF0ZSxcbiAgICAgICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IEhvdmVyUGx1Z2luKHZpZXcsIHNvdXJjZSwgaG92ZXJTdGF0ZSwgc2V0SG92ZXIsIG9wdGlvbnMuaG92ZXJUaW1lIHx8IDMwMCAvKiBIb3Zlci5UaW1lICovKSksXG4gICAgICAgICAgICBzaG93SG92ZXJUb29sdGlwSG9zdFxuICAgICAgICBdXG4gICAgfTtcbn1cbi8qKlxuR2V0IHRoZSBhY3RpdmUgdG9vbHRpcCB2aWV3IGZvciBhIGdpdmVuIHRvb2x0aXAsIGlmIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBnZXRUb29sdGlwKHZpZXcsIHRvb2x0aXApIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgaWYgKCFwbHVnaW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmb3VuZCA9IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBzLmluZGV4T2YodG9vbHRpcCk7XG4gICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiBwbHVnaW4ubWFuYWdlci50b29sdGlwVmlld3NbZm91bmRdO1xufVxuLyoqXG5SZXR1cm5zIHRydWUgaWYgYW55IGhvdmVyIHRvb2x0aXBzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIGhhc0hvdmVyVG9vbHRpcHMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuc29tZSh4ID0+IHgpO1xufVxuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGVmZmVjdCB0aGF0IGNsb3NlcyBhbGwgaG92ZXIgdG9vbHRpcHMuXG4qL1xuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBzID0gLypAX19QVVJFX18qL2Nsb3NlSG92ZXJUb29sdGlwRWZmZWN0Lm9mKG51bGwpO1xuLyoqXG5UZWxsIHRoZSB0b29sdGlwIGV4dGVuc2lvbiB0byByZWNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RpdmVcbnRvb2x0aXBzLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBzb21ldGhpbmcgaGFwcGVucyAoc3VjaCBhcyBhXG5yZS1wb3NpdGlvbmluZyBvciBDU1MgY2hhbmdlIGFmZmVjdGluZyB0aGUgZWRpdG9yKSB0aGF0IGNvdWxkXG5pbnZhbGlkYXRlIHRoZSBleGlzdGluZyB0b29sdGlwIHBvc2l0aW9ucy5cbiovXG5mdW5jdGlvbiByZXBvc2l0aW9uVG9vbHRpcHModmlldykge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICBpZiAocGx1Z2luKVxuICAgICAgICBwbHVnaW4ubWF5YmVNZWFzdXJlKCk7XG59XG5cbmNvbnN0IHBhbmVsQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjb25maWdzKSB7XG4gICAgICAgICAgICB0b3BDb250YWluZXIgPSB0b3BDb250YWluZXIgfHwgYy50b3BDb250YWluZXI7XG4gICAgICAgICAgICBib3R0b21Db250YWluZXIgPSBib3R0b21Db250YWluZXIgfHwgYy5ib3R0b21Db250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXIgfTtcbiAgICB9XG59KTtcbi8qKlxuQ29uZmlndXJlcyB0aGUgcGFuZWwtbWFuYWdpbmcgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIHBhbmVscyhjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3BhbmVsQ29uZmlnLm9mKGNvbmZpZyldIDogW107XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHBhbmVsIGNyZWF0ZWQgYnkgdGhlIGdpdmVuIGNvbnN0cnVjdG9yLCBpZiBhbnkuXG5UaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCBhY2Nlc3MgdG8geW91ciBwYW5lbHMnIERPTVxuc3RydWN0dXJlLlxuKi9cbmZ1bmN0aW9uIGdldFBhbmVsKHZpZXcsIHBhbmVsKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHBhbmVsUGx1Z2luKTtcbiAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4uc3BlY3MuaW5kZXhPZihwYW5lbCkgOiAtMTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5wYW5lbHNbaW5kZXhdIDogbnVsbDtcbn1cbmNvbnN0IHBhbmVsUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIHRoaXMuc3BlY3MgPSB0aGlzLmlucHV0LmZpbHRlcihzID0+IHMpO1xuICAgICAgICB0aGlzLnBhbmVscyA9IHRoaXMuc3BlY3MubWFwKHNwZWMgPT4gc3BlYyh2aWV3KSk7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XG4gICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMudG9wLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gcC50b3ApKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiAhcC50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChcImNtLXBhbmVsXCIpO1xuICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICBpZiAodGhpcy50b3AuY29udGFpbmVyICE9IGNvbmYudG9wQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3R0b20uY29udGFpbmVyICE9IGNvbmYuYm90dG9tQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3Auc3luY0NsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luY0NsYXNzZXMoKTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBsZXQgc3BlY3MgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgICAgIGxldCBwYW5lbHMgPSBbXSwgdG9wID0gW10sIGJvdHRvbSA9IFtdLCBtb3VudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHRoaXMuc3BlY3MuaW5kZXhPZihzcGVjKSwgcGFuZWw7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHNwZWModXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBtb3VudC5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gdGhpcy5wYW5lbHNba25vd25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZWwudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICAocGFuZWwudG9wID8gdG9wIDogYm90dG9tKS5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhib3R0b20pO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBtb3VudCkge1xuICAgICAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgICAgICBpZiAocC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHAudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgeyB0b3A6IHZhbHVlLnRvcC5zY3JvbGxNYXJnaW4oKSwgYm90dG9tOiB2YWx1ZS5ib3R0b20uc2Nyb2xsTWFyZ2luKCkgfTtcbiAgICB9KVxufSk7XG5jbGFzcyBQYW5lbEdyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCB0b3AsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBcIlwiO1xuICAgICAgICB0aGlzLnBhbmVscyA9IFtdO1xuICAgICAgICB0aGlzLnN5bmNDbGFzc2VzKCk7XG4gICAgfVxuICAgIHN5bmMocGFuZWxzKSB7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICBpZiAocC5kZXN0cm95ICYmIHBhbmVscy5pbmRleE9mKHApIDwgMClcbiAgICAgICAgICAgICAgICBwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XG4gICAgICAgIHRoaXMuc3luY0RPTSgpO1xuICAgIH1cbiAgICBzeW5jRE9NKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IHRoaXMudG9wID8gXCJjbS1wYW5lbHMgY20tcGFuZWxzLXRvcFwiIDogXCJjbS1wYW5lbHMgY20tcGFuZWxzLWJvdHRvbVwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGVbdGhpcy50b3AgPyBcInRvcFwiIDogXCJib3R0b21cIl0gPSBcIjBcIjtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbnRhaW5lciB8fCB0aGlzLnZpZXcuZG9tO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdGhpcy50b3AgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJET00gPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBwYW5lbCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgaWYgKHBhbmVsLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckRPTSAhPSBwYW5lbC5kb20pXG4gICAgICAgICAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gY3VyRE9NLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHBhbmVsLmRvbSwgY3VyRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY3VyRE9NKVxuICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICB9XG4gICAgc2Nyb2xsTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZG9tIHx8IHRoaXMuY29udGFpbmVyID8gMFxuICAgICAgICAgICAgOiBNYXRoLm1heCgwLCB0aGlzLnRvcCA/XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gTWF0aC5tYXgoMCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIDpcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihpbm5lckhlaWdodCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pIC0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKTtcbiAgICB9XG4gICAgc3luY0NsYXNzZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIgfHwgdGhpcy5jbGFzc2VzID09IHRoaXMudmlldy50aGVtZUNsYXNzZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB0aGlzLmNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiAodGhpcy5jbGFzc2VzID0gdGhpcy52aWV3LnRoZW1lQ2xhc3Nlcykuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcm0obm9kZSkge1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybiBuZXh0O1xufVxuLyoqXG5PcGVuaW5nIGEgcGFuZWwgaXMgZG9uZSBieSBwcm92aWRpbmcgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3JcbnRoZSBwYW5lbCB0aHJvdWdoIHRoaXMgZmFjZXQuIChUaGUgcGFuZWwgaXMgY2xvc2VkIGFnYWluIHdoZW4gaXRzXG5jb25zdHJ1Y3RvciBpcyBubyBsb25nZXIgcHJvdmlkZWQuKSBWYWx1ZXMgb2YgYG51bGxgIGFyZSBpZ25vcmVkLlxuKi9cbmNvbnN0IHNob3dQYW5lbCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IHBhbmVsUGx1Z2luXG59KTtcblxuLyoqXG5TaG93IGEgcGFuZWwgYWJvdmUgb3IgYmVsb3cgdGhlIGVkaXRvciB0byBzaG93IHRoZSB1c2VyIGEgbWVzc2FnZVxub3IgcHJvbXB0IHRoZW0gZm9yIGlucHV0LiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IGNhbiBiZSBkaXNwYXRjaGVkXG50byBjbG9zZSB0aGUgZGlhbG9nLCBhbmQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZGlhbG9nXG5pcyBjbG9zZWQgb3IgYSBmb3JtIGluc2lkZSBvZiBpdCBpcyBzdWJtaXR0ZWQuXG5cbllvdSBhcmUgZW5jb3VyYWdlZCwgaWYgeW91ciBoYW5kbGluZyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBwcm9taXNlXG5kaXNwYXRjaGVzIGEgdHJhbnNhY3Rpb24sIHRvIGluY2x1ZGUgdGhlIGBjbG9zZWAgZWZmZWN0IGluIGl0LiBJZlxueW91IGRvbid0LCB0aGlzIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBkaXNwYXRjaCBhIHNlcGFyYXRlXG50cmFuc2FjdGlvbiByaWdodCBhZnRlci5cbiovXG5mdW5jdGlvbiBzaG93RGlhbG9nKHZpZXcsIGNvbmZpZykge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UociA9PiByZXNvbHZlID0gcik7XG4gICAgbGV0IHBhbmVsQ3RvciA9ICh2aWV3KSA9PiBjcmVhdGVEaWFsb2codmlldywgY29uZmlnLCByZXNvbHZlKTtcbiAgICBpZiAodmlldy5zdGF0ZS5maWVsZChkaWFsb2dGaWVsZCwgZmFsc2UpKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBvcGVuRGlhbG9nRWZmZWN0Lm9mKHBhbmVsQ3RvcikgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGRpYWxvZ0ZpZWxkLmluaXQoKCkgPT4gW3BhbmVsQ3Rvcl0pKSB9KTtcbiAgICB9XG4gICAgbGV0IGNsb3NlID0gY2xvc2VEaWFsb2dFZmZlY3Qub2YocGFuZWxDdG9yKTtcbiAgICByZXR1cm4geyBjbG9zZSwgcmVzdWx0OiBwcm9taXNlLnRoZW4oZm9ybSA9PiB7XG4gICAgICAgICAgICBsZXQgcXVldWUgPSB2aWV3Lndpbi5xdWV1ZU1pY3JvdGFzayB8fCAoKGYpID0+IHZpZXcud2luLnNldFRpbWVvdXQoZiwgMTApKTtcbiAgICAgICAgICAgIHF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChkaWFsb2dGaWVsZCkuaW5kZXhPZihwYW5lbEN0b3IpID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm07XG4gICAgICAgIH0pIH07XG59XG4vKipcbkZpbmQgdGhlIFtgUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuUGFuZWwpIGZvciBhbiBvcGVuIGRpYWxvZywgdXNpbmcgYSBjbGFzc1xubmFtZSBhcyBpZGVudGlmaWVyLlxuKi9cbmZ1bmN0aW9uIGdldERpYWxvZyh2aWV3LCBjbGFzc05hbWUpIHtcbiAgICBsZXQgZGlhbG9ncyA9IHZpZXcuc3RhdGUuZmllbGQoZGlhbG9nRmllbGQsIGZhbHNlKSB8fCBbXTtcbiAgICBmb3IgKGxldCBvcGVuIG9mIGRpYWxvZ3MpIHtcbiAgICAgICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgb3Blbik7XG4gICAgICAgIGlmIChwYW5lbCAmJiBwYW5lbC5kb20uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gcGFuZWw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgZGlhbG9nRmllbGQgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIFtdOyB9LFxuICAgIHVwZGF0ZShkaWFsb2dzLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlLmlzKG9wZW5EaWFsb2dFZmZlY3QpKVxuICAgICAgICAgICAgICAgIGRpYWxvZ3MgPSBbZS52YWx1ZV0uY29uY2F0KGRpYWxvZ3MpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZS5pcyhjbG9zZURpYWxvZ0VmZmVjdCkpXG4gICAgICAgICAgICAgICAgZGlhbG9ncyA9IGRpYWxvZ3MuZmlsdGVyKGQgPT4gZCAhPSBlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlhbG9ncztcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gc2hvd1BhbmVsLmNvbXB1dGVOKFtmXSwgc3RhdGUgPT4gc3RhdGUuZmllbGQoZikpXG59KTtcbmNvbnN0IG9wZW5EaWFsb2dFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjbG9zZURpYWxvZ0VmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGNyZWF0ZURpYWxvZyh2aWV3LCBjb25maWcsIHJlc3VsdCkge1xuICAgIGxldCBjb250ZW50ID0gY29uZmlnLmNvbnRlbnQgPyBjb25maWcuY29udGVudCh2aWV3LCAoKSA9PiBkb25lKG51bGwpKSA6IG51bGw7XG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIGNvbnRlbnQgPSBlbHQoXCJmb3JtXCIpO1xuICAgICAgICBpZiAoY29uZmlnLmlucHV0KSB7XG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBlbHQoXCJpbnB1dFwiLCBjb25maWcuaW5wdXQpO1xuICAgICAgICAgICAgaWYgKC9eKHRleHR8cGFzc3dvcmR8bnVtYmVyfGVtYWlsfHRlbHx1cmwpJC8udGVzdChpbnB1dC50eXBlKSlcbiAgICAgICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKFwiY20tdGV4dGZpZWxkXCIpO1xuICAgICAgICAgICAgaWYgKCFpbnB1dC5uYW1lKVxuICAgICAgICAgICAgICAgIGlucHV0Lm5hbWUgPSBcImlucHV0XCI7XG4gICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcImxhYmVsXCIsIChjb25maWcubGFiZWwgfHwgXCJcIikgKyBcIjogXCIsIGlucHV0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbmZpZy5sYWJlbCB8fCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBcIikpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCB0eXBlOiBcInN1Ym1pdFwiIH0sIGNvbmZpZy5zdWJtaXRMYWJlbCB8fCBcIk9LXCIpKTtcbiAgICB9XG4gICAgbGV0IGZvcm1zID0gY29udGVudC5ub2RlTmFtZSA9PSBcIkZPUk1cIiA/IFtjb250ZW50XSA6IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbChcImZvcm1cIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZm9ybSA9IGZvcm1zW2ldO1xuICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpIHsgLy8gRXNjYXBlXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZG9uZShmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkb25lKGZvcm0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHBhbmVsID0gZWx0KFwiZGl2XCIsIGNvbnRlbnQsIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgIG9uY2xpY2s6ICgpID0+IGRvbmUobnVsbCksXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiB2aWV3LnN0YXRlLnBocmFzZShcImNsb3NlXCIpLFxuICAgICAgICBjbGFzczogXCJjbS1kaWFsb2ctY2xvc2VcIixcbiAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgIH0sIFtcIlx1MDBEN1wiXSkpO1xuICAgIGlmIChjb25maWcuY2xhc3MpXG4gICAgICAgIHBhbmVsLmNsYXNzTmFtZSA9IGNvbmZpZy5jbGFzcztcbiAgICBwYW5lbC5jbGFzc0xpc3QuYWRkKFwiY20tZGlhbG9nXCIpO1xuICAgIGZ1bmN0aW9uIGRvbmUoZm9ybSkge1xuICAgICAgICBpZiAocGFuZWwuY29udGFpbnMocGFuZWwub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50KSlcbiAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgcmVzdWx0KGZvcm0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkb206IHBhbmVsLFxuICAgICAgICB0b3A6IGNvbmZpZy50b3AsXG4gICAgICAgIG1vdW50OiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmZvY3VzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvY3VzO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmZvY3VzID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzID0gY29udGVudC5xdWVyeVNlbGVjdG9yKGNvbmZpZy5mb2N1cyk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb2N1cyA9IGNvbnRlbnQucXVlcnlTZWxlY3RvcihcImlucHV0XCIpIHx8IGNvbnRlbnQucXVlcnlTZWxlY3RvcihcImJ1dHRvblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZm9jdXMgJiYgXCJzZWxlY3RcIiBpbiBmb2N1cylcbiAgICAgICAgICAgICAgICAgICAgZm9jdXMuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9jdXMgJiYgXCJmb2N1c1wiIGluIGZvY3VzKVxuICAgICAgICAgICAgICAgICAgICBmb2N1cy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqXG5BIGd1dHRlciBtYXJrZXIgcmVwcmVzZW50cyBhIGJpdCBvZiBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byBhIGxpbmVcbmluIGEgc3BlY2lmaWMgZ3V0dGVyLiBZb3VyIG93biBjdXN0b20gbWFya2VycyBoYXZlIHRvIGV4dGVuZCB0aGlzXG5jbGFzcy5cbiovXG5jbGFzcyBHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIG1hcmtlciB0byBhbm90aGVyIG1hcmtlciBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ2FsbGVkIGlmIHRoZSBtYXJrZXIgaGFzIGEgYHRvRE9NYCBtZXRob2QgYW5kIGl0cyByZXByZXNlbnRhdGlvblxuICAgIHdhcyByZW1vdmVkIGZyb20gYSBndXR0ZXIuXG4gICAgKi9cbiAgICBkZXN0cm95KGRvbSkgeyB9XG59XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLmVsZW1lbnRDbGFzcyA9IFwiXCI7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnRvRE9NID0gdW5kZWZpbmVkO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUuc3RhcnRTaWRlID0gR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbmRTaWRlID0gLTE7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBhZGQgYSBjbGFzcyB0byBhbGwgZ3V0dGVyIGVsZW1lbnRzIGZvciBhIGdpdmVuIGxpbmUuXG5NYXJrZXJzIGdpdmVuIHRvIHRoaXMgZmFjZXQgc2hvdWxkIF9vbmx5XyBkZWZpbmUgYW5cbltgZWxlbWVudGNsYXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lkd1dHRlck1hcmtlci5lbGVtZW50Q2xhc3MpLCBub3QgYVxuW2B0b0RPTWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIudG9ET00pIChvciB0aGUgbWFya2VyIHdpbGwgYXBwZWFyXG5pbiBhbGwgZ3V0dGVycyBmb3IgdGhlIGxpbmUpLlxuKi9cbmNvbnN0IGd1dHRlckxpbmVDbGFzcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRmFjZXQgdXNlZCB0byBhZGQgYSBjbGFzcyB0byBhbGwgZ3V0dGVyIGVsZW1lbnRzIG5leHQgdG8gYSB3aWRnZXQuXG5TaG91bGQgbm90IHByb3ZpZGUgd2lkZ2V0cyB3aXRoIGEgYHRvRE9NYCBtZXRob2QuXG4qL1xuY29uc3QgZ3V0dGVyV2lkZ2V0Q2xhc3MgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgICBjbGFzczogXCJcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBlbGVtZW50U3R5bGU6IFwiXCIsXG4gICAgbWFya2VyczogKCkgPT4gUmFuZ2VTZXQuZW1wdHksXG4gICAgbGluZU1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICB3aWRnZXRNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgbGluZU1hcmtlckNoYW5nZTogbnVsbCxcbiAgICBpbml0aWFsU3BhY2VyOiBudWxsLFxuICAgIHVwZGF0ZVNwYWNlcjogbnVsbCxcbiAgICBkb21FdmVudEhhbmRsZXJzOiB7fSxcbiAgICBzaWRlOiBcImJlZm9yZVwiXG59O1xuY29uc3QgYWN0aXZlR3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGFuIGVkaXRvciBndXR0ZXIuIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgZ3V0dGVycyBhcHBlYXIgaXNcbmRldGVybWluZWQgYnkgdGhlaXIgZXh0ZW5zaW9uIHByaW9yaXR5LlxuKi9cbmZ1bmN0aW9uIGd1dHRlcihjb25maWcpIHtcbiAgICByZXR1cm4gW2d1dHRlcnMoKSwgYWN0aXZlR3V0dGVycy5vZih7IC4uLmRlZmF1bHRzLCAuLi5jb25maWcgfSldO1xufVxuY29uc3QgdW5maXhHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuLyoqXG5UaGUgZ3V0dGVyLWRyYXdpbmcgcGx1Z2luIGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCB3aGVuIHlvdSBhZGQgYVxuZ3V0dGVyLCBidXQgeW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvbiB0byBleHBsaWNpdGx5IGNvbmZpZ3VyZSBpdC5cblxuVW5sZXNzIGBmaXhlZGAgaXMgZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYCwgdGhlIGd1dHRlcnMgYXJlXG5maXhlZCwgbWVhbmluZyB0aGV5IGRvbid0IHNjcm9sbCBhbG9uZyB3aXRoIHRoZSBjb250ZW50XG5ob3Jpem9udGFsbHkgKGV4Y2VwdCBvbiBJbnRlcm5ldCBFeHBsb3Jlciwgd2hpY2ggZG9lc24ndCBzdXBwb3J0XG5DU1MgW2Bwb3NpdGlvbjpcbnN0aWNreWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9wb3NpdGlvbiNzdGlja3kpKS5cbiovXG5mdW5jdGlvbiBndXR0ZXJzKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbXG4gICAgICAgIGd1dHRlclZpZXcsXG4gICAgXTtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5maXhlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJlc3VsdC5wdXNoKHVuZml4R3V0dGVycy5vZih0cnVlKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGd1dHRlclZpZXcgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kb21BZnRlciA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdmlldy52aWV3cG9ydDtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlcnMgY20tZ3V0dGVycy1iZWZvcmVcIjtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5taW5IZWlnaHQgPSAodGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZKSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5ndXR0ZXJzID0gdmlldy5zdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKS5tYXAoY29uZiA9PiBuZXcgU2luZ2xlR3V0dGVyVmlldyh2aWV3LCBjb25mKSk7XG4gICAgICAgIHRoaXMuZml4ZWQgPSAhdmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpO1xuICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoZ3V0dGVyLmNvbmZpZy5zaWRlID09IFwiYWZ0ZXJcIilcbiAgICAgICAgICAgICAgICB0aGlzLmdldERPTUFmdGVyKCkuYXBwZW5kQ2hpbGQoZ3V0dGVyLmRvbSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZ3V0dGVyLmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIElFMTEgZmFsbGJhY2ssIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwb3NpdGlvbjogc3RpY2t5LFxuICAgICAgICAgICAgLy8gYnkgdXNpbmcgcG9zaXRpb246IHJlbGF0aXZlICsgZXZlbnQgaGFuZGxlcnMgdGhhdCByZWFsaWduIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVyIChvciBqdXN0IGZvcmNlIGZpeGVkPWZhbHNlIG9uIElFMTE/KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSBcInN0aWNreVwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY0d1dHRlcnMoZmFsc2UpO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHZpZXcuY29udGVudERPTSk7XG4gICAgfVxuICAgIGdldERPTUFmdGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9tQWZ0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tQWZ0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5kb21BZnRlci5jbGFzc05hbWUgPSBcImNtLWd1dHRlcnMgY20tZ3V0dGVycy1hZnRlclwiO1xuICAgICAgICAgICAgdGhpcy5kb21BZnRlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICB0aGlzLmRvbUFmdGVyLnN0eWxlLm1pbkhlaWdodCA9ICh0aGlzLnZpZXcuY29udGVudEhlaWdodCAvIHRoaXMudmlldy5zY2FsZVkpICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5kb21BZnRlci5zdHlsZS5wb3NpdGlvbiA9IHRoaXMuZml4ZWQgPyBcInN0aWNreVwiIDogXCJcIjtcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQodGhpcy5kb21BZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tQWZ0ZXI7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlR3V0dGVycyh1cGRhdGUpKSB7XG4gICAgICAgICAgICAvLyBEZXRhY2ggZHVyaW5nIHN5bmMgd2hlbiB0aGUgdmlld3BvcnQgY2hhbmdlZCBzaWduaWZpY2FudGx5XG4gICAgICAgICAgICAvLyAoc3VjaCBhcyBkdXJpbmcgc2Nyb2xsaW5nKSwgc2luY2UgZm9yIGxhcmdlIHVwZGF0ZXMgdGhhdCBpc1xuICAgICAgICAgICAgLy8gZmFzdGVyLlxuICAgICAgICAgICAgbGV0IHZwQSA9IHRoaXMucHJldlZpZXdwb3J0LCB2cEIgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgICAgIGxldCB2cE92ZXJsYXAgPSBNYXRoLm1pbih2cEEudG8sIHZwQi50bykgLSBNYXRoLm1heCh2cEEuZnJvbSwgdnBCLmZyb20pO1xuICAgICAgICAgICAgdGhpcy5zeW5jR3V0dGVycyh2cE92ZXJsYXAgPCAodnBCLnRvIC0gdnBCLmZyb20pICogMC44KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLmdlb21ldHJ5Q2hhbmdlZCkge1xuICAgICAgICAgICAgbGV0IG1pbiA9ICh0aGlzLnZpZXcuY29udGVudEhlaWdodCAvIHRoaXMudmlldy5zY2FsZVkpICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gbWluO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tQWZ0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5kb21BZnRlci5zdHlsZS5taW5IZWlnaHQgPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpICE9ICF0aGlzLmZpeGVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpeGVkID0gIXRoaXMuZml4ZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMuZml4ZWQgPyBcInN0aWNreVwiIDogXCJcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbUFmdGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tQWZ0ZXIuc3R5bGUucG9zaXRpb24gPSB0aGlzLmZpeGVkID8gXCJzdGlja3lcIiA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICB9XG4gICAgc3luY0d1dHRlcnMoZGV0YWNoKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMuZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoZGV0YWNoKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbUFmdGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tQWZ0ZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVDbGFzc2VzID0gUmFuZ2VTZXQuaXRlcih0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdGhpcy52aWV3LnZpZXdwb3J0LmZyb20pO1xuICAgICAgICBsZXQgY2xhc3NTZXQgPSBbXTtcbiAgICAgICAgbGV0IGNvbnRleHRzID0gdGhpcy5ndXR0ZXJzLm1hcChndXR0ZXIgPT4gbmV3IFVwZGF0ZUNvbnRleHQoZ3V0dGVyLCB0aGlzLnZpZXcudmlld3BvcnQsIC10aGlzLnZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCkpO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudmlldy52aWV3cG9ydExpbmVCbG9ja3MpIHtcbiAgICAgICAgICAgIGlmIChjbGFzc1NldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY2xhc3NTZXQgPSBbXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgb2YgbGluZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgJiYgZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDdXJzb3IobGluZUNsYXNzZXMsIGNsYXNzU2V0LCBiLmZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gubGluZSh0aGlzLnZpZXcsIGIsIGNsYXNzU2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYi53aWRnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LndpZGdldCh0aGlzLnZpZXcsIGIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS50eXBlID09IEJsb2NrVHlwZS5UZXh0KSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgIGN4LmxpbmUodGhpcy52aWV3LCBsaW5lLCBjbGFzc1NldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLndpZGdldCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgICAgICBjeC53aWRnZXQodGhpcy52aWV3LCBsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgIGN4LmZpbmlzaCgpO1xuICAgICAgICBpZiAoZGV0YWNoKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgYWZ0ZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tQWZ0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZCh0aGlzLmRvbUFmdGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVHdXR0ZXJzKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldiA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLCBjdXIgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyk7XG4gICAgICAgIGxldCBjaGFuZ2UgPSB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuaGVpZ2h0Q2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAhUmFuZ2VTZXQuZXEodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20sIHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHByZXYgPT0gY3VyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgICAgIGlmIChndXR0ZXIudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGd1dHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmYgb2YgY3VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gcHJldi5pbmRleE9mKGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHRoaXMudmlldywgY29uZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndXR0ZXJzW2tub3duXS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKHRoaXMuZ3V0dGVyc1trbm93bl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgdGhpcy5ndXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlcnMuaW5kZXhPZihnKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGcuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiBndXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGcuY29uZmlnLnNpZGUgPT0gXCJhZnRlclwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldERPTUFmdGVyKCkuYXBwZW5kQ2hpbGQoZy5kb20pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZy5kb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ndXR0ZXJzID0gZ3V0dGVycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tQWZ0ZXIpXG4gICAgICAgICAgICB0aGlzLmRvbUFmdGVyLnJlbW92ZSgpO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmd1dHRlcnMubGVuZ3RoID09IDAgfHwgIXZhbHVlLmZpeGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBiZWZvcmUgPSB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggKiB2aWV3LnNjYWxlWCwgYWZ0ZXIgPSB2YWx1ZS5kb21BZnRlciA/IHZhbHVlLmRvbUFmdGVyLm9mZnNldFdpZHRoICogdmlldy5zY2FsZVggOiAwO1xuICAgICAgICByZXR1cm4gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFJcbiAgICAgICAgICAgID8geyBsZWZ0OiBiZWZvcmUsIHJpZ2h0OiBhZnRlciB9XG4gICAgICAgICAgICA6IHsgcmlnaHQ6IGJlZm9yZSwgbGVmdDogYWZ0ZXIgfTtcbiAgICB9KVxufSk7XG5mdW5jdGlvbiBhc0FycmF5KHZhbCkgeyByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdKTsgfVxuZnVuY3Rpb24gYWR2YW5jZUN1cnNvcihjdXJzb3IsIGNvbGxlY3QsIHBvcykge1xuICAgIHdoaWxlIChjdXJzb3IudmFsdWUgJiYgY3Vyc29yLmZyb20gPD0gcG9zKSB7XG4gICAgICAgIGlmIChjdXJzb3IuZnJvbSA9PSBwb3MpXG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICB9XG59XG5jbGFzcyBVcGRhdGVDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihndXR0ZXIsIHZpZXdwb3J0LCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5ndXR0ZXIgPSBndXR0ZXI7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmN1cnNvciA9IFJhbmdlU2V0Lml0ZXIoZ3V0dGVyLm1hcmtlcnMsIHZpZXdwb3J0LmZyb20pO1xuICAgIH1cbiAgICBhZGRFbGVtZW50KHZpZXcsIGJsb2NrLCBtYXJrZXJzKSB7XG4gICAgICAgIGxldCB7IGd1dHRlciB9ID0gdGhpcywgYWJvdmUgPSAoYmxvY2sudG9wIC0gdGhpcy5oZWlnaHQpIC8gdmlldy5zY2FsZVksIGhlaWdodCA9IGJsb2NrLmhlaWdodCAvIHZpZXcuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5pID09IGd1dHRlci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXdFbHQgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKTtcbiAgICAgICAgICAgIGd1dHRlci5lbGVtZW50cy5wdXNoKG5ld0VsdCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLmFwcGVuZENoaWxkKG5ld0VsdC5kb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzW3RoaXMuaV0udXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gYmxvY2suYm90dG9tO1xuICAgICAgICB0aGlzLmkrKztcbiAgICB9XG4gICAgbGluZSh2aWV3LCBsaW5lLCBleHRyYU1hcmtlcnMpIHtcbiAgICAgICAgbGV0IGxvY2FsTWFya2VycyA9IFtdO1xuICAgICAgICBhZHZhbmNlQ3Vyc29yKHRoaXMuY3Vyc29yLCBsb2NhbE1hcmtlcnMsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChleHRyYU1hcmtlcnMubGVuZ3RoKVxuICAgICAgICAgICAgbG9jYWxNYXJrZXJzID0gbG9jYWxNYXJrZXJzLmNvbmNhdChleHRyYU1hcmtlcnMpO1xuICAgICAgICBsZXQgZm9yTGluZSA9IHRoaXMuZ3V0dGVyLmNvbmZpZy5saW5lTWFya2VyKHZpZXcsIGxpbmUsIGxvY2FsTWFya2Vycyk7XG4gICAgICAgIGlmIChmb3JMaW5lKVxuICAgICAgICAgICAgbG9jYWxNYXJrZXJzLnVuc2hpZnQoZm9yTGluZSk7XG4gICAgICAgIGxldCBndXR0ZXIgPSB0aGlzLmd1dHRlcjtcbiAgICAgICAgaWYgKGxvY2FsTWFya2Vycy5sZW5ndGggPT0gMCAmJiAhZ3V0dGVyLmNvbmZpZy5yZW5kZXJFbXB0eUVsZW1lbnRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFkZEVsZW1lbnQodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICB9XG4gICAgd2lkZ2V0KHZpZXcsIGJsb2NrKSB7XG4gICAgICAgIGxldCBtYXJrZXIgPSB0aGlzLmd1dHRlci5jb25maWcud2lkZ2V0TWFya2VyKHZpZXcsIGJsb2NrLndpZGdldCwgYmxvY2spLCBtYXJrZXJzID0gbWFya2VyID8gW21hcmtlcl0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2Ygdmlldy5zdGF0ZS5mYWNldChndXR0ZXJXaWRnZXRDbGFzcykpIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXIgPSBjbHModmlldywgYmxvY2sud2lkZ2V0LCBibG9jayk7XG4gICAgICAgICAgICBpZiAobWFya2VyKVxuICAgICAgICAgICAgICAgIChtYXJrZXJzIHx8IChtYXJrZXJzID0gW10pKS5wdXNoKG1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlcnMpXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQodmlldywgYmxvY2ssIG1hcmtlcnMpO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGxldCBndXR0ZXIgPSB0aGlzLmd1dHRlcjtcbiAgICAgICAgd2hpbGUgKGd1dHRlci5lbGVtZW50cy5sZW5ndGggPiB0aGlzLmkpIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gZ3V0dGVyLmVsZW1lbnRzLnBvcCgpO1xuICAgICAgICAgICAgZ3V0dGVyLmRvbS5yZW1vdmVDaGlsZChsYXN0LmRvbSk7XG4gICAgICAgICAgICBsYXN0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNpbmdsZUd1dHRlclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGNvbmZpZykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnNwYWNlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJcIiArICh0aGlzLmNvbmZpZy5jbGFzcyA/IFwiIFwiICsgdGhpcy5jb25maWcuY2xhc3MgOiBcIlwiKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBjb25maWcuZG9tRXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihwcm9wLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0LCB5O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGFyZ2V0LnBhcmVudE5vZGUgIT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdEhlaWdodCh5IC0gdmlldy5kb2N1bWVudFRvcCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kb21FdmVudEhhbmRsZXJzW3Byb3BdKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya2VycyA9IGFzQXJyYXkoY29uZmlnLm1hcmtlcnModmlldykpO1xuICAgICAgICBpZiAoY29uZmlnLmluaXRpYWxTcGFjZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyID0gbmV3IEd1dHRlckVsZW1lbnQodmlldywgMCwgMCwgW2NvbmZpZy5pbml0aWFsU3BhY2VyKHZpZXcpXSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLnNwYWNlci5kb20pO1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIuZG9tLnN0eWxlLmNzc1RleHQgKz0gXCJ2aXNpYmlsaXR5OiBoaWRkZW47IHBvaW50ZXItZXZlbnRzOiBub25lXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldk1hcmtlcnMgPSB0aGlzLm1hcmtlcnM7XG4gICAgICAgIHRoaXMubWFya2VycyA9IGFzQXJyYXkodGhpcy5jb25maWcubWFya2Vycyh1cGRhdGUudmlldykpO1xuICAgICAgICBpZiAodGhpcy5zcGFjZXIgJiYgdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlZCA9IHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcih0aGlzLnNwYWNlci5tYXJrZXJzWzBdLCB1cGRhdGUpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZWQgIT0gdGhpcy5zcGFjZXIubWFya2Vyc1swXSlcbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlci51cGRhdGUodXBkYXRlLnZpZXcsIDAsIDAsIFt1cGRhdGVkXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZwID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgICAgIHJldHVybiAhUmFuZ2VTZXQuZXEodGhpcy5tYXJrZXJzLCBwcmV2TWFya2VycywgdnAuZnJvbSwgdnAudG8pIHx8XG4gICAgICAgICAgICAodGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSA/IHRoaXMuY29uZmlnLmxpbmVNYXJrZXJDaGFuZ2UodXBkYXRlKSA6IGZhbHNlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgZWx0IG9mIHRoaXMuZWxlbWVudHMpXG4gICAgICAgICAgICBlbHQuZGVzdHJveSgpO1xuICAgIH1cbn1cbmNsYXNzIEd1dHRlckVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAtMTtcbiAgICAgICAgdGhpcy5hYm92ZSA9IDA7XG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyRWxlbWVudFwiO1xuICAgICAgICB0aGlzLnVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKTtcbiAgICB9XG4gICAgdXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWJvdmUgIT0gYWJvdmUpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5tYXJnaW5Ub3AgPSAodGhpcy5hYm92ZSA9IGFib3ZlKSA/IGFib3ZlICsgXCJweFwiIDogXCJcIjtcbiAgICAgICAgaWYgKCFzYW1lTWFya2Vycyh0aGlzLm1hcmtlcnMsIG1hcmtlcnMpKVxuICAgICAgICAgICAgdGhpcy5zZXRNYXJrZXJzKHZpZXcsIG1hcmtlcnMpO1xuICAgIH1cbiAgICBzZXRNYXJrZXJzKHZpZXcsIG1hcmtlcnMpIHtcbiAgICAgICAgbGV0IGNscyA9IFwiY20tZ3V0dGVyRWxlbWVudFwiLCBkb21Qb3MgPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBpTmV3ID0gMCwgaU9sZCA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IHNraXBUbyA9IGlPbGQsIG1hcmtlciA9IGlOZXcgPCBtYXJrZXJzLmxlbmd0aCA/IG1hcmtlcnNbaU5ldysrXSA6IG51bGwsIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IG1hcmtlci5lbGVtZW50Q2xhc3M7XG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIiArIGM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGlPbGQ7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlcnNbaV0uY29tcGFyZShtYXJrZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwVG8gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2tpcFRvID0gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpT2xkIDwgc2tpcFRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLm1hcmtlcnNbaU9sZCsrXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC50b0RPTSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0LmRlc3Ryb3koZG9tUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gZG9tUG9zLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBkb21Qb3MucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcyA9IGFmdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG1hcmtlci50b0RPTSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKVxuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBkb21Qb3MubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUobWFya2VyLnRvRE9NKHZpZXcpLCBkb21Qb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoZWQpXG4gICAgICAgICAgICAgICAgaU9sZCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IGNscztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXRNYXJrZXJzKG51bGwsIFtdKTsgLy8gRmlyc3QgYXJndW1lbnQgbm90IHVzZWQgdW5sZXNzIGNyZWF0aW5nIG1hcmtlcnNcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lTWFya2VycyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uY29tcGFyZShiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuRmFjZXQgdXNlZCB0byBwcm92aWRlIG1hcmtlcnMgdG8gdGhlIGxpbmUgbnVtYmVyIGd1dHRlci5cbiovXG5jb25zdCBsaW5lTnVtYmVyTWFya2VycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjcmVhdGUgbWFya2VycyBpbiB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIG5leHQgdG8gd2lkZ2V0cy5cbiovXG5jb25zdCBsaW5lTnVtYmVyV2lkZ2V0TWFya2VyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgbGluZU51bWJlckNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKHZhbHVlcywgeyBmb3JtYXROdW1iZXI6IFN0cmluZywgZG9tRXZlbnRIYW5kbGVyczoge30gfSwge1xuICAgICAgICAgICAgZG9tRXZlbnRIYW5kbGVycyhhLCBiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGV2ZW50IGluIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4aXN0cyA9IHJlc3VsdFtldmVudF0sIGFkZCA9IGJbZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZXZlbnRdID0gZXhpc3RzID8gKHZpZXcsIGxpbmUsIGV2ZW50KSA9PiBleGlzdHModmlldywgbGluZSwgZXZlbnQpIHx8IGFkZCh2aWV3LCBsaW5lLCBldmVudCkgOiBhZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY2xhc3MgTnVtYmVyTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcihudW1iZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLm51bWJlciA9PSBvdGhlci5udW1iZXI7IH1cbiAgICB0b0RPTSgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubnVtYmVyKTsgfVxufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHZpZXcsIG51bWJlcikge1xuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmZvcm1hdE51bWJlcihudW1iZXIsIHZpZXcuc3RhdGUpO1xufVxuY29uc3QgbGluZU51bWJlckd1dHRlciA9IC8qQF9fUFVSRV9fKi9hY3RpdmVHdXR0ZXJzLmNvbXB1dGUoW2xpbmVOdW1iZXJDb25maWddLCBzdGF0ZSA9PiAoe1xuICAgIGNsYXNzOiBcImNtLWxpbmVOdW1iZXJzXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgbWFya2Vycyh2aWV3KSB7IHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJNYXJrZXJzKTsgfSxcbiAgICBsaW5lTWFya2VyKHZpZXcsIGxpbmUsIG90aGVycykge1xuICAgICAgICBpZiAob3RoZXJzLnNvbWUobSA9PiBtLnRvRE9NKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgdmlldy5zdGF0ZS5kb2MubGluZUF0KGxpbmUuZnJvbSkubnVtYmVyKSk7XG4gICAgfSxcbiAgICB3aWRnZXRNYXJrZXI6ICh2aWV3LCB3aWRnZXQsIGJsb2NrKSA9PiB7XG4gICAgICAgIGZvciAobGV0IG0gb2Ygdmlldy5zdGF0ZS5mYWNldChsaW5lTnVtYmVyV2lkZ2V0TWFya2VyKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG0odmlldywgd2lkZ2V0LCBibG9jayk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiB1cGRhdGUgPT4gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLFxuICAgIGluaXRpYWxTcGFjZXIodmlldykge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgbWF4TGluZU51bWJlcih2aWV3LnN0YXRlLmRvYy5saW5lcykpKTtcbiAgICB9LFxuICAgIHVwZGF0ZVNwYWNlcihzcGFjZXIsIHVwZGF0ZSkge1xuICAgICAgICBsZXQgbWF4ID0gZm9ybWF0TnVtYmVyKHVwZGF0ZS52aWV3LCBtYXhMaW5lTnVtYmVyKHVwZGF0ZS52aWV3LnN0YXRlLmRvYy5saW5lcykpO1xuICAgICAgICByZXR1cm4gbWF4ID09IHNwYWNlci5udW1iZXIgPyBzcGFjZXIgOiBuZXcgTnVtYmVyTWFya2VyKG1heCk7XG4gICAgfSxcbiAgICBkb21FdmVudEhhbmRsZXJzOiBzdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKS5kb21FdmVudEhhbmRsZXJzLFxuICAgIHNpZGU6IFwiYmVmb3JlXCJcbn0pKTtcbi8qKlxuQ3JlYXRlIGEgbGluZSBudW1iZXIgZ3V0dGVyIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBsaW5lTnVtYmVycyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGxpbmVOdW1iZXJDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgZ3V0dGVycygpLFxuICAgICAgICBsaW5lTnVtYmVyR3V0dGVyXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG1heExpbmVOdW1iZXIobGluZXMpIHtcbiAgICBsZXQgbGFzdCA9IDk7XG4gICAgd2hpbGUgKGxhc3QgPCBsaW5lcylcbiAgICAgICAgbGFzdCA9IGxhc3QgKiAxMCArIDk7XG4gICAgcmV0dXJuIGxhc3Q7XG59XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVyTWFya2VyID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZWxlbWVudENsYXNzID0gXCJjbS1hY3RpdmVMaW5lR3V0dGVyXCI7XG4gICAgfVxufTtcbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9ndXR0ZXJMaW5lQ2xhc3MuY29tcHV0ZShbXCJzZWxlY3Rpb25cIl0sIHN0YXRlID0+IHtcbiAgICBsZXQgbWFya3MgPSBbXSwgbGFzdCA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGxpbmVQb3MgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmhlYWQpLmZyb207XG4gICAgICAgIGlmIChsaW5lUG9zID4gbGFzdCkge1xuICAgICAgICAgICAgbGFzdCA9IGxpbmVQb3M7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIucmFuZ2UobGluZVBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSYW5nZVNldC5vZihtYXJrcyk7XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLWFjdGl2ZUxpbmVHdXR0ZXJgIGNsYXNzIHRvXG5hbGwgZ3V0dGVyIGVsZW1lbnRzIG9uIHRoZSBbYWN0aXZlXG5saW5lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0QWN0aXZlTGluZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcigpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyKGRlY29yYXRvcikge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+ICh7XG4gICAgICAgIGRlY29yYXRpb25zOiBkZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KSxcbiAgICAgICAgdXBkYXRlKHUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0b3IudXBkYXRlRGVjbyh1LCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9KSwge1xuICAgICAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG4gICAgfSk7XG59XG5jb25zdCB0YWJEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWhpZ2hsaWdodFRhYlwiIH0pO1xuY29uc3Qgc3BhY2VEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWhpZ2hsaWdodFNwYWNlXCIgfSk7XG5jb25zdCB3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovbWF0Y2hlcigvKkBfX1BVUkVfXyovbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHR8IC9nLFxuICAgIGRlY29yYXRpb246IG1hdGNoID0+IG1hdGNoWzBdID09IFwiXFx0XCIgPyB0YWJEZWNvIDogc3BhY2VEZWNvLFxuICAgIGJvdW5kYXJ5OiAvXFxTLyxcbn0pKTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBoaWdobGlnaHRzIHdoaXRlc3BhY2UsIGFkZGluZyBhXG5gY20taGlnaGxpZ2h0U3BhY2VgIGNsYXNzIHRvIHN0cmV0Y2hlcyBvZiBzcGFjZXMsIGFuZCBhXG5gY20taGlnaGxpZ2h0VGFiYCBjbGFzcyB0byBpbmRpdmlkdWFsIHRhYiBjaGFyYWN0ZXJzLiBCeSBkZWZhdWx0LFxudGhlIGZvcm1lciBhcmUgc2hvd24gYXMgZmFpbnQgZG90cywgYW5kIHRoZSBsYXR0ZXIgYXMgYXJyb3dzLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFdoaXRlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHdoaXRlc3BhY2VIaWdobGlnaHRlcjtcbn1cbmNvbnN0IHRyYWlsaW5nSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovbWF0Y2hlcigvKkBfX1BVUkVfXyovbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHMrJC9nLFxuICAgIGRlY29yYXRpb246IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS10cmFpbGluZ1NwYWNlXCIgfSlcbn0pKTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLXRyYWlsaW5nU3BhY2VgIGNsYXNzIHRvIGFsbFxudHJhaWxpbmcgd2hpdGVzcGFjZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRyYWlsaW5nSGlnaGxpZ2h0ZXI7XG59XG5cbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX190ZXN0ID0geyBIZWlnaHRNYXAsIEhlaWdodE9yYWNsZSwgTWVhc3VyZWRIZWlnaHRzLCBRdWVyeVR5cGUsIENoYW5nZWRSYW5nZSwgY29tcHV0ZU9yZGVyLFxuICAgIG1vdmVWaXN1YWxseSwgY2xlYXJIZWlnaHRDaGFuZ2VGbGFnLCBnZXRIZWlnaHRDaGFuZ2VGbGFnOiAoKSA9PiBoZWlnaHRDaGFuZ2VGbGFnIH07XG5cbmV4cG9ydCB7IEJpZGlTcGFuLCBCbG9ja0luZm8sIEJsb2NrVHlwZSwgQmxvY2tXcmFwcGVyLCBEZWNvcmF0aW9uLCBEaXJlY3Rpb24sIEVkaXRvclZpZXcsIEd1dHRlck1hcmtlciwgTWF0Y2hEZWNvcmF0b3IsIFJlY3RhbmdsZU1hcmtlciwgVmlld1BsdWdpbiwgVmlld1VwZGF0ZSwgV2lkZ2V0VHlwZSwgX190ZXN0LCBjbG9zZUhvdmVyVG9vbHRpcHMsIGNyb3NzaGFpckN1cnNvciwgZHJhd1NlbGVjdGlvbiwgZHJvcEN1cnNvciwgZ2V0RGlhbG9nLCBnZXREcmF3U2VsZWN0aW9uQ29uZmlnLCBnZXRQYW5lbCwgZ2V0VG9vbHRpcCwgZ3V0dGVyLCBndXR0ZXJMaW5lQ2xhc3MsIGd1dHRlcldpZGdldENsYXNzLCBndXR0ZXJzLCBoYXNIb3ZlclRvb2x0aXBzLCBoaWdobGlnaHRBY3RpdmVMaW5lLCBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyLCBoaWdobGlnaHRTcGVjaWFsQ2hhcnMsIGhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSwgaGlnaGxpZ2h0V2hpdGVzcGFjZSwgaG92ZXJUb29sdGlwLCBrZXltYXAsIGxheWVyLCBsaW5lTnVtYmVyTWFya2VycywgbGluZU51bWJlcldpZGdldE1hcmtlciwgbGluZU51bWJlcnMsIGxvZ0V4Y2VwdGlvbiwgcGFuZWxzLCBwbGFjZWhvbGRlciwgcmVjdGFuZ3VsYXJTZWxlY3Rpb24sIHJlcG9zaXRpb25Ub29sdGlwcywgcnVuU2NvcGVIYW5kbGVycywgc2Nyb2xsUGFzdEVuZCwgc2hvd0RpYWxvZywgc2hvd1BhbmVsLCBzaG93VG9vbHRpcCwgdG9vbHRpcHMgfTtcbiIsICIvKipcblRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG4qL1xuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8qKlxuRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG5jYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbiovXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbmZpZy5jb21iaW5lIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgaXQgZG9lcy5cbiAgICAqL1xuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5Qcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbnNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbmZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbiovXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG5hdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xub2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuKi9cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5Vc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG50eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG5gXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbiovXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuQXR0YWNoZWQgdG8gbm9kZXMgdG8gaW5kaWNhdGUgdGhlc2Ugc2hvdWxkIGJlXG5bZGlzcGxheWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKVxuaW4gYSBiaWRpcmVjdGlvbmFsIHRleHQgaXNvbGF0ZSwgc28gdGhhdCBkaXJlY3Rpb24tbmV1dHJhbFxuY2hhcmFjdGVycyBvbiB0aGVpciBzaWRlcyBkb24ndCBpbmNvcnJlY3RseSBnZXQgYXNzb2NpYXRlZCB3aXRoXG5zdXJyb3VuZGluZyB0ZXh0LiBZb3UnbGwgZ2VuZXJhbGx5IHdhbnQgdG8gc2V0IHRoaXMgZm9yIG5vZGVzXG50aGF0IGNvbnRhaW4gYXJiaXRyYXJ5IHRleHQsIGxpa2Ugc3RyaW5ncyBhbmQgY29tbWVudHMsIGFuZCBmb3Jcbm5vZGVzIHRoYXQgYXBwZWFyIF9pbnNpZGVfIGFyYml0cmFyeSB0ZXh0LCBsaWtlIEhUTUwgdGFncy4gV2hlblxubm90IGdpdmVuIGEgdmFsdWUsIGluIGEgZ3JhbW1hciBkZWNsYXJhdGlvbiwgZGVmYXVsdHMgdG9cbmBcImF1dG9cImAuXG4qL1xuTm9kZVByb3AuaXNvbGF0ZSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPSBcInJ0bFwiICYmIHZhbHVlICE9IFwibHRyXCIgJiYgdmFsdWUgIT0gXCJhdXRvXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIGlzb2xhdGU6IFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgXCJhdXRvXCI7XG4gICAgfSB9KTtcbi8qKlxuVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG50aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuY29udGV4dHVhbCBub2Rlcy5cbiovXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbmxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG5wYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3JcbmVmZmljaWVuY3kgcmVhc29ucy4pXG4qL1xuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxubm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuZGlmZmVyZW50IGxhbmd1YWdlcyBpbiBtaXhlZC1sYW5ndWFnZSBwYXJzZXJzLlxuKi9cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5BIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbmEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG5yZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG4qL1xuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBpbm5lciB0cmVlLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgKi9cbiAgICBvdmVybGF5LCBcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICAqL1xuICAgIHBhcnNlciwgXG4gICAgLyoqXG4gICAgW0luZGljYXRlc10oI2NvbW1vbi5JdGVyTW9kZS5FbnRlckJyYWNrZXRlZCkgdGhhdCB0aGUgbmVzdGVkXG4gICAgY29udGVudCBpcyBkZWxpbmVhdGVkIHdpdGggc29tZSBraW5kXG4gICAgb2YgYnJhY2tldCB0b2tlbi5cbiAgICAqL1xuICAgIGJyYWNrZXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmJyYWNrZXRlZCA9IGJyYWNrZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wcyAmJiB0cmVlLnByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5FYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIHJvbGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByb3BzLCBcbiAgICAvKipcbiAgICBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIE5vZGVGbGFnLlRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBOb2RlRmxhZy5FcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgICovXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICAqL1xuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogTm9kZUZsYWcuRXJyb3IgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgICovXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbiovXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8qKlxuQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG5mdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG5baGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG5idWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG5mcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxudHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG4qL1xuY2xhc3MgTm9kZVNldCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICAqL1xuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBjYW4gYmUgY3JlYXRlZCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgKi9cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gYWRkWzFdLCBwcm9wID0gYWRkWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5jb21iaW5lICYmIHByb3AuaWQgaW4gbmV3UHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3AuY29tYmluZShuZXdQcm9wc1twcm9wLmlkXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1twcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1R5cGVzLnB1c2gobmV3UHJvcHMgPyBuZXcgTm9kZVR5cGUodHlwZS5uYW1lLCBuZXdQcm9wcywgdHlwZS5pZCwgdHlwZS5mbGFncykgOiB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZXQobmV3VHlwZXMpO1xuICAgIH1cbn1cbmNvbnN0IENhY2hlZE5vZGUgPSBuZXcgV2Vha01hcCgpLCBDYWNoZWRJbm5lck5vZGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG5PcHRpb25zIHRoYXQgY29udHJvbCBpdGVyYXRpb24uIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgfGBcbm9wZXJhdG9yIHRvIGVuYWJsZSBtdWx0aXBsZSBvbmVzLlxuKi9cbnZhciBJdGVyTW9kZTtcbihmdW5jdGlvbiAoSXRlck1vZGUpIHtcbiAgICAvKipcbiAgICBXaGVuIGVuYWJsZWQsIGl0ZXJhdGlvbiB3aWxsIG9ubHkgdmlzaXQgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICAgIG9iamVjdHMsIG5vdCBub2RlcyBwYWNrZWQgaW50b1xuICAgIFtgVHJlZUJ1ZmZlcmBdKCNjb21tb24uVHJlZUJ1ZmZlcilzLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJFeGNsdWRlQnVmZmVyc1wiXSA9IDFdID0gXCJFeGNsdWRlQnVmZmVyc1wiO1xuICAgIC8qKlxuICAgIEVuYWJsZSB0aGlzIHRvIG1ha2UgaXRlcmF0aW9uIGluY2x1ZGUgYW5vbnltb3VzIG5vZGVzIChzdWNoIGFzXG4gICAgdGhlIG5vZGVzIHRoYXQgd3JhcCByZXBlYXRlZCBncmFtbWFyIGNvbnN0cnVjdHMgaW50byBhIGJhbGFuY2VkXG4gICAgdHJlZSkuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkluY2x1ZGVBbm9ueW1vdXNcIl0gPSAyXSA9IFwiSW5jbHVkZUFub255bW91c1wiO1xuICAgIC8qKlxuICAgIEJ5IGRlZmF1bHQsIHJlZ3VsYXIgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgbm9kZXNcbiAgICByZXBsYWNlIHRoZWlyIGJhc2Ugbm9kZSBpbiBpdGVyYXRpb24uIEVuYWJsZSB0aGlzIHRvIGlnbm9yZSB0aGVtXG4gICAgaW5zdGVhZC5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlTW91bnRzXCJdID0gNF0gPSBcIklnbm9yZU1vdW50c1wiO1xuICAgIC8qKlxuICAgIFRoaXMgb3B0aW9uIG9ubHkgYXBwbGllcyBpblxuICAgIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLXN0eWxlIG1ldGhvZHMuIEl0IHRlbGxzIHRoZVxuICAgIGxpYnJhcnkgdG8gbm90IGVudGVyIG1vdW50ZWQgb3ZlcmxheXMgaWYgb25lIGNvdmVycyB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlT3ZlcmxheXNcIl0gPSA4XSA9IFwiSWdub3JlT3ZlcmxheXNcIjtcbiAgICAvKipcbiAgICBXaGVuIHNldCwgcG9zaXRpb25zIG9uIHRoZSBib3VuZGFyeSBvZiBhIG1vdW50ZWQgb3ZlcmxheSB0cmVlXG4gICAgdGhhdCBoYXMgaXRzIFtgYnJhY2tldGVkYF0oI2NvbW1vbi5OZXN0ZWRQYXJzZS5icmFja2V0ZWQpIGZsYWdcbiAgICBzZXQgd2lsbCBlbnRlciB0aGF0IHRyZWUgcmVnYXJkbGVzcyBvZiBzaWRlLiBPbmx5IHN1cHBvcnRlZCBpblxuICAgIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLCBub3QgaW4gY3Vyc29ycy5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiRW50ZXJCcmFja2V0ZWRcIl0gPSAxNl0gPSBcIkVudGVyQnJhY2tldGVkXCI7XG59KShJdGVyTW9kZSB8fCAoSXRlck1vZGUgPSB7fSkpO1xuLyoqXG5BIHBpZWNlIG9mIHN5bnRheCB0cmVlLiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gYXBwcm9hY2ggdGhlc2VcbnRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbmNvbnZlbmllbnQgd2F5LlxuXG5TeW50YXggdHJlZXMgYXJlIHN0b3JlZCBhcyBhIHRyZWUgb2YgYFRyZWVgIGFuZCBgVHJlZUJ1ZmZlcmBcbm9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbm5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG5cbkhvd2V2ZXIsIHdoZW4geW91IHdhbnQgdG8gYWN0dWFsbHkgd29yayB3aXRoIHRyZWUgbm9kZXMsIHRoaXNcbnJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbnVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuW2BTeW50YXhOb2RlYF0oI2NvbW1vbi5TeW50YXhOb2RlKSBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXNcbmEgdmlldyBvbiBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5tb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbiovXG5jbGFzcyBUcmVlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgICovXG4gICAgY2hpbGRyZW4sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICB0aGUgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgdGhlIHRyZWUuIE1vZGUgY2FuIGJlIHVzZWQgdG8gW2NvbnRyb2xdKCNjb21tb24uSXRlck1vZGUpIHdoaWNoXG4gICAgbm9kZXMgdGhlIGN1cnNvciB2aXNpdHMuXG4gICAgKi9cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb2ludGluZyBpbnRvIHRoaXMgdHJlZVxuICAgIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZSAoc2VlXG4gICAgW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICAqL1xuICAgIGN1cnNvckF0KHBvcywgc2lkZSA9IDAsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIHRyZWUuXG4gICAgKi9cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIGZyb20gYm90aCBzaWRlcy5cbiAgICBcbiAgICBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlbnRlclxuICAgIFtvdmVybGF5c10oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSwgYW5kIHlvdSBvZnRlbiB3YW50XG4gICAgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgcmVzb2x2ZWBdKCNjb21tb24uVHJlZS5yZXNvbHZlKSwgYnV0IHdpbGwgZW50ZXJcbiAgICBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgKHdpdGggcGFyZW50IGxpbmtzIGdvaW5nIHRocm91Z2ggYWxsIHBhcmVudCBzdHJ1Y3R1cmUsIGluY2x1ZGluZ1xuICAgIHRoZSBob3N0IHRyZWVzKS5cbiAgICAqL1xuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbiBzb21lIHNpdHVhdGlvbnMsIGl0IGNhbiBiZSB1c2VmdWwgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbFxuICAgIG5vZGVzIGFyb3VuZCBhIHBvc2l0aW9uLCBpbmNsdWRpbmcgdGhvc2UgaW4gb3ZlcmxheXMgdGhhdCBkb24ndFxuICAgIGRpcmVjdGx5IGNvdmVyIHRoZSBwb3NpdGlvbi4gVGhpcyBtZXRob2QgZ2l2ZXMgeW91IGFuIGl0ZXJhdG9yXG4gICAgdGhhdCB3aWxsIHByb2R1Y2UgYWxsIG5vZGVzLCBmcm9tIHNtYWxsIHRvIGJpZywgYXJvdW5kIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgcmVzb2x2ZVN0YWNrKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrSXRlcmF0b3IodGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxuICAgIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgKi9cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgbGV0IG1vZGUgPSBzcGVjLm1vZGUgfHwgMCwgYW5vbiA9IChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPiAwO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IobW9kZSB8IEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoIWFub24gJiYgYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmIChhbm9uIHx8ICFjLnR5cGUuaXNBbm9ueW1vdXMpKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgY29uc3RydWN0b3IuXG4gICAgKi9cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgICovXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgICovXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgdHJlZVxuKi9cblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8qKlxuVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxubm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbmJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG5jaGlsZHJlbiBiZWxvbmcgdG8gaXQpLlxuKi9cbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGJ1ZmZlcidzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgICovXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSksIGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIGxlbiwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogU2lkZS5CZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIC0xIC8qIFNpZGUuQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogU2lkZS5Bcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogU2lkZS5BdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAyIC8qIFNpZGUuQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIFNpZGUuRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKG5vZGUsIHBvcywgc2lkZSwgb3ZlcmxheXMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUgKG5vZGUuZnJvbSA9PSBub2RlLnRvIHx8XG4gICAgICAgIChzaWRlIDwgMSA/IG5vZGUuZnJvbSA+PSBwb3MgOiBub2RlLmZyb20gPiBwb3MpIHx8XG4gICAgICAgIChzaWRlID4gLTEgPyBub2RlLnRvIDw9IHBvcyA6IG5vZGUudG8gPCBwb3MpKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAhb3ZlcmxheXMgJiYgbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIG5vZGUuaW5kZXggPCAwID8gbnVsbCA6IG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBsZXQgbW9kZSA9IG92ZXJsYXlzID8gMCA6IEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzO1xuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgbW9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBCYXNlTm9kZSB7XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMucGFyZW50LCBjb250ZXh0KTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7XG4gICAgICAgIGxldCBzY2FuID0gdGhpcy5jaGlsZEJlZm9yZShwb3MpLCBub2RlID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHNjYW4pIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gc2Nhbi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGxhc3QudHlwZS5pc0Vycm9yICYmIGxhc3QuZnJvbSA9PSBsYXN0LnRvKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICAgICAgc2NhbiA9IGxhc3QucHJldlNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnBhcmVudDsgfVxufVxuY2xhc3MgVHJlZU5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gICAgY29uc3RydWN0b3IoX3RyZWUsIGZyb20sIFxuICAgIC8vIEluZGV4IGluIHBhcmVudCBub2RlLCBzZXQgdG8gLTEgaWYgdGhlIG5vZGUgaXMgbm90IGEgZGlyZWN0IGNoaWxkIG9mIF9wYXJlbnQubm9kZSAob3ZlcmxheSlcbiAgICBpbmRleCwgX3BhcmVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90cmVlID0gX3RyZWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZS5uYW1lOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5fdHJlZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXM7Oykge1xuICAgICAgICAgICAgZm9yIChsZXQgeyBjaGlsZHJlbiwgcG9zaXRpb25zIH0gPSBwYXJlbnQuX3RyZWUsIGUgPSBkaXIgPiAwID8gY2hpbGRyZW4ubGVuZ3RoIDogLTE7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2ldLCBzdGFydCA9IHBvc2l0aW9uc1tpXSArIHBhcmVudC5mcm9tLCBtb3VudGVkO1xuICAgICAgICAgICAgICAgIGlmICghKChtb2RlICYgSXRlck1vZGUuRW50ZXJCcmFja2V0ZWQpICYmIG5leHQgaW5zdGFuY2VvZiBUcmVlICYmXG4gICAgICAgICAgICAgICAgICAgIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KG5leHQpKSAmJiAhbW91bnRlZC5vdmVybGF5ICYmIG1vdW50ZWQuYnJhY2tldGVkICYmXG4gICAgICAgICAgICAgICAgICAgIHBvcyA+PSBzdGFydCAmJiBwb3MgPD0gc3RhcnQgKyBuZXh0Lmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNoZWNrU2lkZShzaWRlLCBwb3MsIHN0YXJ0LCBzdGFydCArIG5leHQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUobmV3IEJ1ZmZlckNvbnRleHQocGFyZW50LCBuZXh0LCBpLCBzdGFydCksIG51bGwsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAoIW5leHQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1vZGUgJiBJdGVyTW9kZS5JZ25vcmVNb3VudHMpICYmIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KG5leHQpKSAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFpbm5lci50eXBlLmlzQW5vbnltb3VzID8gaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5uZXIubmV4dENoaWxkKGRpciA8IDAgPyBuZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSwgbW9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5pbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCBwb3MsIC0yIC8qIFNpZGUuQmVmb3JlICovKTsgfVxuICAgIHByb3AocHJvcCkgeyByZXR1cm4gdGhpcy5fdHJlZS5wcm9wKHByb3ApOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzKSAmJiAobW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldCh0aGlzLl90cmVlKSkgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgclBvcyA9IHBvcyAtIHRoaXMuZnJvbSwgZW50ZXJCcmFja2V0ZWQgPSAobW9kZSAmIEl0ZXJNb2RlLkVudGVyQnJhY2tldGVkKSAmJiBtb3VudGVkLmJyYWNrZXRlZDtcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPiAwIHx8IGVudGVyQnJhY2tldGVkID8gZnJvbSA8PSByUG9zIDogZnJvbSA8IHJQb3MpICYmXG4gICAgICAgICAgICAgICAgICAgIChzaWRlIDwgMCB8fCBlbnRlckJyYWNrZXRlZCA/IHRvID49IHJQb3MgOiB0byA+IHJQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgbW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyB0aGlzLmZyb20sIC0xLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCBzaWRlLCBtb2RlKTtcbiAgICB9XG4gICAgbmV4dFNpZ25pZmljYW50UGFyZW50KCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHZhbC50eXBlLmlzQW5vbnltb3VzICYmIHZhbC5fcGFyZW50KVxuICAgICAgICAgICAgdmFsID0gdmFsLl9wYXJlbnQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4ICsgMSwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50b1N0cmluZygpOyB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlLCB0eXBlLCBiZWZvcmUsIGFmdGVyKSB7XG4gICAgbGV0IGN1ciA9IG5vZGUuY3Vyc29yKCksIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIGZvciAobGV0IGZvdW5kID0gZmFsc2U7ICFmb3VuZDspIHtcbiAgICAgICAgICAgIGZvdW5kID0gY3VyLnR5cGUuaXMoYmVmb3JlKTtcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGFmdGVyICE9IG51bGwgJiYgY3VyLnR5cGUuaXMoYWZ0ZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKGN1ci50eXBlLmlzKHR5cGUpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyLm5vZGUpO1xuICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgcmV0dXJuIGFmdGVyID09IG51bGwgPyByZXN1bHQgOiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXRjaE5vZGVDb250ZXh0KG5vZGUsIGNvbnRleHQsIGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICBmb3IgKGxldCBwID0gbm9kZTsgaSA+PSAwOyBwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXAudHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSBwLm5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDJdOyB9XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgX3BhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSBjb250ZXh0LmJ1ZmZlci5zZXQudHlwZXNbY29udGV4dC5idWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgfVxuICAgIGNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCBwb3MsIC0yIC8qIFNpZGUuQmVmb3JlICovKTsgfVxuICAgIHByb3AocHJvcCkgeyByZXR1cm4gdGhpcy50eXBlLnByb3AocHJvcCk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG59XG5mdW5jdGlvbiBpdGVyU3RhY2soaGVhZHMpIHtcbiAgICBpZiAoIWhlYWRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHBpY2sgPSAwLCBwaWNrZWQgPSBoZWFkc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gaGVhZHNbaV07XG4gICAgICAgIGlmIChub2RlLmZyb20gPiBwaWNrZWQuZnJvbSB8fCBub2RlLnRvIDwgcGlja2VkLnRvKSB7XG4gICAgICAgICAgICBwaWNrZWQgPSBub2RlO1xuICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHQgPSBwaWNrZWQgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBwaWNrZWQuaW5kZXggPCAwID8gbnVsbCA6IHBpY2tlZC5wYXJlbnQ7XG4gICAgbGV0IG5ld0hlYWRzID0gaGVhZHMuc2xpY2UoKTtcbiAgICBpZiAobmV4dClcbiAgICAgICAgbmV3SGVhZHNbcGlja10gPSBuZXh0O1xuICAgIGVsc2VcbiAgICAgICAgbmV3SGVhZHMuc3BsaWNlKHBpY2ssIDEpO1xuICAgIHJldHVybiBuZXcgU3RhY2tJdGVyYXRvcihuZXdIZWFkcywgcGlja2VkKTtcbn1cbmNsYXNzIFN0YWNrSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYWRzLCBub2RlKSB7XG4gICAgICAgIHRoaXMuaGVhZHMgPSBoZWFkcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiBpdGVyU3RhY2sodGhpcy5oZWFkcyk7IH1cbn1cbmZ1bmN0aW9uIHN0YWNrSXRlcmF0b3IodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGlubmVyID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBzaWRlKSwgbGF5ZXJzID0gbnVsbDtcbiAgICBmb3IgKGxldCBzY2FuID0gaW5uZXIgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IGlubmVyIDogaW5uZXIuY29udGV4dC5wYXJlbnQ7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbi5pbmRleCA8IDApIHsgLy8gVGhpcyBpcyBhbiBvdmVybGF5IHJvb3RcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzY2FuLnBhcmVudDtcbiAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHBhcmVudC5yZXNvbHZlKHBvcywgc2lkZSkpO1xuICAgICAgICAgICAgc2NhbiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3VudCA9IE1vdW50ZWRUcmVlLmdldChzY2FuLnRyZWUpO1xuICAgICAgICAgICAgLy8gUmVsZXZhbnQgb3ZlcmxheSBicmFuY2hpbmcgb2ZmXG4gICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQub3ZlcmxheSAmJiBtb3VudC5vdmVybGF5WzBdLmZyb20gPD0gcG9zICYmIG1vdW50Lm92ZXJsYXlbbW91bnQub3ZlcmxheS5sZW5ndGggLSAxXS50byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdCA9IG5ldyBUcmVlTm9kZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBzY2FuLmZyb20sIC0xLCBzY2FuKTtcbiAgICAgICAgICAgICAgICAobGF5ZXJzIHx8IChsYXllcnMgPSBbaW5uZXJdKSkucHVzaChyZXNvbHZlTm9kZShyb290LCBwb3MsIHNpZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVycyA/IGl0ZXJTdGFjayhsYXllcnMpIDogaW5uZXI7XG59XG4vKipcbkEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8qKlxuICAgIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSwgbW9kZSA9IDApIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZSAmIH5JdGVyTW9kZS5FbnRlckJyYWNrZXRlZDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gbm9kZS5jb250ZXh0LnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IG5vZGUuX3BhcmVudDsgbjsgbiA9IG4uX3BhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnVuc2hpZnQobi5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB5aWVsZChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4LCBub2RlLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW50ZXJDaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZGlyIDwgMCA/IHRoaXMuX3RyZWUuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlLCB0aGlzLm1vZGUpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5idWZmZXIuc3RhcnQsIHNpZGUpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIGZhbHNlLCB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIGFuZCB0aGUgY3Vyc29yIGhhcyBub3QgYmVlbiBtb3ZlZC5cbiAgICAqL1xuICAgIGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgICovXG4gICAgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdCBjaGlsZCB0aGF0IGVuZHMgYWZ0ZXIgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIGxhc3QgY2hpbGQgdGhhdCBzdGFydHMgYmVmb3JlIGBwb3NgLlxuICAgICovXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgY2hpbGQgbWF5IGVuZCBhdCB0aGF0IHBvc2l0aW9uLCB3aGVuIDEgaXQgbWF5IHN0YXJ0IHRoZXJlLiBUaGlzXG4gICAgd2lsbCBhbHNvIGVudGVyIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KVxuICAgIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgc2V0IHRvIGZhbHNlLlxuICAgICovXG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gdGhpcy5tb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLmVudGVyKHBvcywgc2lkZSwgbW9kZSkpO1xuICAgICAgICByZXR1cm4gbW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzID8gZmFsc2UgOiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICAqL1xuICAgIHBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZSgodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID8gdGhpcy5idWZmZXIucGFyZW50IDogdGhpcy5idWZmZXIucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShwYXJlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNpYmxpbmcoZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3RyZWUuX3BhcmVudCA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuaW5kZXggPCAwID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3RyZWUuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5fdHJlZS5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gZCA8IDAgPyAwIDogdGhpcy5zdGFja1tkXSArIDQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCAhPSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovLCB0aGlzLm1vZGUpKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoaXMgbm9kZSdzIG5leHQgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoaXMgbm9kZSdzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGFueS5cbiAgICAqL1xuICAgIHByZXZTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKC0xKTsgfVxuICAgIGF0TGFzdE5vZGUoZGlyKSB7XG4gICAgICAgIGxldCBpbmRleCwgcGFyZW50LCB7IGJ1ZmZlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IGJ1ZmZlci5idWZmZXIuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnVmZmVyLmJ1ZmZlcltpICsgM10gPCB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHsgaW5kZXgsIHBhcmVudCB9ID0gYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHRoaXMuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBwYXJlbnQ7IHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyBkaXIsIGUgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5fdHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGQoY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbW92ZShkaXIsIGVudGVyKSB7XG4gICAgICAgIGlmIChlbnRlciAmJiB0aGlzLmVudGVyQ2hpbGQoZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGFcbiAgICBbcHJlLW9yZGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmVlX3RyYXZlcnNhbCNQcmUtb3JkZXIsX05MUilcbiAgICB0cmF2ZXJzYWwsIGdvaW5nIGZyb20gYSBub2RlIHRvIGl0cyBmaXJzdCBjaGlsZCBvciwgaWYgdGhlXG4gICAgY3VycmVudCBub2RlIGlzIGVtcHR5IG9yIGBlbnRlcmAgaXMgZmFsc2UsIGl0cyBuZXh0IHNpYmxpbmcgb3JcbiAgICB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgKi9cbiAgICBuZXh0KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKDEsIGVudGVyKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhIGxhc3QtdG8tZmlyc3QgcHJlLW9yZGVyIHRyYXZlcnNhbC4gQVxuICAgIG5vZGUgaXMgZm9sbG93ZWQgYnkgaXRzIGxhc3QgY2hpbGQgb3IsIGlmIGl0IGhhcyBub25lLCBpdHNcbiAgICBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIHByZXYoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoLTEsIGVudGVyKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgYHNpZGVgIGlzIC0xLCBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgZW5kIGF0IGBwb3NgLiBJZiBpdCBpcyAxLFxuICAgIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBzdGFydCBhdCBgcG9zYC5cbiAgICAqL1xuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgY3Vyc29yJ3MgY3VycmVudFxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgW3RyZWVdKCNjb21tb24uVHJlZSkgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG5vZGUsIGlmXG4gICAgYW55LiBXaWxsIHJldHVybiBudWxsIHdoZW4gdGhlIG5vZGUgaXMgaW4gYSBbdHJlZVxuICAgIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICAqL1xuICAgIGdldCB0cmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyBudWxsIDogdGhpcy5fdHJlZS5fdHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSBjdXJyZW50IG5vZGUgYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMsIGNhbGxpbmdcbiAgICBgZW50ZXJgIHdoZW4gZW50ZXJpbmcgYSBub2RlIGFuZCBgbGVhdmVgLCBpZiBnaXZlbiwgd2hlbiBsZWF2aW5nXG4gICAgb25lLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCBhbnkgY2hpbGRyZW4gb2YgdGhhdCBub2RlIGFyZVxuICAgIHNraXBwZWQsIGFuZCBgbGVhdmVgIGlzbid0IGNhbGxlZCBmb3IgaXQuXG4gICAgKi9cbiAgICBpdGVyYXRlKGVudGVyLCBsZWF2ZSkge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG11c3RMZWF2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcih0aGlzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKHRoaXMpO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRoaXMudHlwZS5pc0Fub255bW91cztcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBjdXJyZW50IG5vZGUgbWF0Y2hlcyBhIGdpdmVuIGNvbnRleHRcdTIwMTRhIHNlcXVlbmNlXG4gICAgb2YgZGlyZWN0IHBhcmVudCBub2RlIG5hbWVzLiBFbXB0eSBzdHJpbmdzIGluIHRoZSBjb250ZXh0IGFycmF5XG4gICAgYXJlIHRyZWF0ZWQgYXMgd2lsZGNhcmRzLlxuICAgICovXG4gICAgbWF0Y2hDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZS5wYXJlbnQsIGNvbnRleHQpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCB7IHR5cGVzIH0gPSBidWZmZXIuc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xuICAgICAgICAgICAgaWYgKGQgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMuX3RyZWUsIGNvbnRleHQsIGkpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF1dXTtcbiAgICAgICAgICAgIGlmICghdHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gdHlwZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NoaWxkKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2gudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaCkpO1xufVxuZnVuY3Rpb24gYnVpbGRUcmVlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgYnVmZmVyLCBub2RlU2V0LCBtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoLCByZXVzZWQgPSBbXSwgbWluUmVwZWF0VHlwZSA9IG5vZGVTZXQudHlwZXMubGVuZ3RoIH0gPSBkYXRhO1xuICAgIGxldCBjdXJzb3IgPSBBcnJheS5pc0FycmF5KGJ1ZmZlcikgPyBuZXcgRmxhdEJ1ZmZlckN1cnNvcihidWZmZXIsIGJ1ZmZlci5sZW5ndGgpIDogYnVmZmVyO1xuICAgIGxldCB0eXBlcyA9IG5vZGVTZXQudHlwZXM7XG4gICAgbGV0IGNvbnRleHRIYXNoID0gMCwgbG9va0FoZWFkID0gMDtcbiAgICBmdW5jdGlvbiB0YWtlTm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpblJlcGVhdCwgZGVwdGgpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgbGV0IGxvb2tBaGVhZEF0U3RhcnQgPSBsb29rQWhlYWQsIGNvbnRleHRBdFN0YXJ0ID0gY29udGV4dEhhc2g7XG4gICAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChzaXplID09IC0xIC8qIFNwZWNpYWxSZWNvcmQuUmV1c2UgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHJldXNlZFtpZF07XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLykgeyAvLyBDb250ZXh0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnJlY29nbml6ZWQgcmVjb3JkIHNpemU6ICR7c2l6ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2lkXSwgbm9kZSwgYnVmZmVyO1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBzdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPD0gbWF4QnVmZmVyTGVuZ3RoICYmIChidWZmZXIgPSBmaW5kQnVmZmVyU2l6ZShjdXJzb3IucG9zIC0gbWluUG9zLCBpblJlcGVhdCkpKSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBlbm91Z2ggZm9yIGEgYnVmZmVyLCBhbmQgbm8gcmV1c2VkIG5vZGVzIGluc2lkZVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIGJ1ZmZlci5zaXplLCBpbmRleCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICBub2RlID0gbmV3IFRyZWVCdWZmZXIoZGF0YSwgZW5kIC0gYnVmZmVyLnN0YXJ0LCBub2RlU2V0KTtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gYnVmZmVyLnN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1ha2UgaXQgYSBub2RlXG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIHNpemU7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBsb2NhbEluUmVwZWF0ID0gaWQgPj0gbWluUmVwZWF0VHlwZSA/IGlkIDogLTE7XG4gICAgICAgICAgICBsZXQgbGFzdEdyb3VwID0gMCwgbGFzdEVuZCA9IGVuZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBjdXJzb3IuaWQgPT0gbG9jYWxJblJlcGVhdCAmJiBjdXJzb3Iuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZW5kIDw9IGxhc3RFbmQgLSBtYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBjdXJzb3IuZW5kLCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0LCBjb250ZXh0QXRTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R3JvdXAgPSBsb2NhbENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbmQgPSBjdXJzb3IuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID4gMjUwMCAvKiBDdXRPZmYuRGVwdGggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZUZsYXROb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VOb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsb2NhbEluUmVwZWF0LCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgbGFzdEdyb3VwID4gMCAmJiBsYXN0R3JvdXAgPCBsb2NhbENoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgc3RhcnQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSwgY29udGV4dEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBiYWxhbmNlUmFuZ2UodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIDAsIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoLCAwLCBlbmQgLSBzdGFydCwgbWFrZSwgbWFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWFrZVRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0LCBsb29rQWhlYWRBdFN0YXJ0IC0gZW5kLCBjb250ZXh0QXRTdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0YWtlRmxhdE5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucykge1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTsgLy8gVGVtcG9yYXJ5LCBpbnZlcnRlZCBhcnJheSBvZiBsZWFmIG5vZGVzIGZvdW5kLCB3aXRoIGFic29sdXRlIHBvc2l0aW9uc1xuICAgICAgICBsZXQgbm9kZUNvdW50ID0gMCwgc3RvcEF0ID0gLTE7XG4gICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gbWluUG9zKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7IC8vIE5vdCBhIGxlYWZcbiAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RvcEF0ID4gLTEgJiYgc3RhcnQgPCBzdG9wQXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdG9wQXQgPCAwKVxuICAgICAgICAgICAgICAgICAgICBzdG9wQXQgPSBlbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChpZCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgbm9kZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZUNvdW50KSB7XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KG5vZGVDb3VudCAqIDQpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMywgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2kgKyAxXSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaSArIDJdIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgVHJlZUJ1ZmZlcihidWZmZXIsIG5vZGVzWzJdIC0gc3RhcnQsIG5vZGVTZXQpKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VCYWxhbmNlZCh0eXBlLCBjb250ZXh0SGFzaCkge1xuICAgICAgICByZXR1cm4gKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIGlmIChsYXN0SSA+PSAwICYmIChsYXN0ID0gY2hpbGRyZW5bbGFzdEldKSBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RJICYmIGxhc3QudHlwZSA9PSB0eXBlICYmIGxhc3QubGVuZ3RoID09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZFByb3AgPSBsYXN0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gcG9zaXRpb25zW2xhc3RJXSArIGxhc3QubGVuZ3RoICsgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCwgY29udGV4dEhhc2gpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUmVwZWF0TGVhZihjaGlsZHJlbiwgcG9zaXRpb25zLCBiYXNlLCBpLCBmcm9tLCB0bywgdHlwZSwgbG9va0FoZWFkLCBjb250ZXh0SGFzaCkge1xuICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoID4gaSkge1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuLnBvcCgpKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gocG9zaXRpb25zLnBvcCgpICsgYmFzZSAtIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRyZWUobm9kZVNldC50eXBlc1t0eXBlXSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHRvIC0gZnJvbSwgbG9va0FoZWFkIC0gdG8sIGNvbnRleHRIYXNoKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQsIGNvbnRleHRIYXNoLCBwcm9wcykge1xuICAgICAgICBpZiAoY29udGV4dEhhc2gpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5sb29rQWhlYWQsIGxvb2tBaGVhZF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZTtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCAmJiBub2RlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLyB8fCBmb3JrLnNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gbm9kZVN0YXJ0O1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZTtcbiAgICAgICAgICAgIHNraXAgKz0gbG9jYWxTa2lwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpblJlcGVhdCA8IDAgfHwgc2l6ZSA9PSBtYXhTaXplKSB7XG4gICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnNpemUgPiA0ID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKHNpemUgPj0gMCAmJiBpZCA8IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIChzaXplIC0gNCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBlbmQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLykge1xuICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgZGF0YS5idWZmZXJTdGFydCB8fCAwLCBjaGlsZHJlbiwgcG9zaXRpb25zLCAtMSwgMCk7XG4gICAgbGV0IGxlbmd0aCA9IChfYSA9IGRhdGEubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY2hpbGRyZW4ubGVuZ3RoID8gcG9zaXRpb25zWzBdICsgY2hpbGRyZW5bMF0ubGVuZ3RoIDogMCk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW2RhdGEudG9wSURdLCBjaGlsZHJlbi5yZXZlcnNlKCksIHBvc2l0aW9ucy5yZXZlcnNlKCksIGxlbmd0aCk7XG59XG5jb25zdCBub2RlU2l6ZUNhY2hlID0gbmV3IFdlYWtNYXA7XG5mdW5jdGlvbiBub2RlU2l6ZShiYWxhbmNlVHlwZSwgbm9kZSkge1xuICAgIGlmICghYmFsYW5jZVR5cGUuaXNBbm9ueW1vdXMgfHwgbm9kZSBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgbm9kZS50eXBlICE9IGJhbGFuY2VUeXBlKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgc2l6ZSA9IG5vZGVTaXplQ2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9IGJhbGFuY2VUeXBlIHx8ICEoY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVTaXplQ2FjaGUuc2V0KG5vZGUsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShcbi8vIFRoZSB0eXBlIHRoZSBiYWxhbmNlZCB0cmVlJ3MgaW5uZXIgbm9kZXMuXG5iYWxhbmNlVHlwZSwgXG4vLyBUaGUgZGlyZWN0IGNoaWxkcmVuIGFuZCB0aGVpciBwb3NpdGlvbnNcbmNoaWxkcmVuLCBwb3NpdGlvbnMsIFxuLy8gVGhlIGluZGV4IHJhbmdlIGluIGNoaWxkcmVuL3Bvc2l0aW9ucyB0byB1c2VcbmZyb20sIHRvLCBcbi8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgbm9kZXMsIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudC5cbnN0YXJ0LCBcbi8vIExlbmd0aCBvZiB0aGUgb3V0ZXIgbm9kZVxubGVuZ3RoLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIHRoZSB0b3Agbm9kZSBvZiB0aGUgYmFsYW5jZWQgdHJlZVxubWtUb3AsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgaW50ZXJuYWwgbm9kZXMgZm9yIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RyZWUpIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgICAgdG90YWwgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICBsZXQgbWF4Q2hpbGQgPSBNYXRoLmNlaWwoKHRvdGFsICogMS41KSAvIDggLyogQmFsYW5jZS5CcmFuY2hGYWN0b3IgKi8pO1xuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgZnVuY3Rpb24gZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldLCBncm91cFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplICsgbmV4dFNpemUgPj0gbWF4Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZSArPSBuZXh0U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09IGdyb3VwRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplID4gbWF4Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9ubHkgPSBjaGlsZHJlbltncm91cEZyb21dOyAvLyBPbmx5IHRyZWVzIGNhbiBoYXZlIGEgc2l6ZSA+IDFcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlKG9ubHkuY2hpbGRyZW4sIG9ubHkucG9zaXRpb25zLCAwLCBvbmx5LmNoaWxkcmVuLmxlbmd0aCwgcG9zaXRpb25zW2dyb3VwRnJvbV0gKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2dyb3VwRnJvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHBvc2l0aW9uc1tpIC0gMV0gKyBjaGlsZHJlbltpIC0gMV0ubGVuZ3RoIC0gZ3JvdXBTdGFydDtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goYmFsYW5jZVJhbmdlKGJhbGFuY2VUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBncm91cEZyb20sIGksIGdyb3VwU3RhcnQsIGxlbmd0aCwgbnVsbCwgbWtUcmVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKGdyb3VwU3RhcnQgKyBvZmZzZXQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCAwKTtcbiAgICByZXR1cm4gKG1rVG9wIHx8IG1rVHJlZSkobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxlbmd0aCk7XG59XG4vKipcblByb3ZpZGVzIGEgd2F5IHRvIGFzc29jaWF0ZSB2YWx1ZXMgd2l0aCBwaWVjZXMgb2YgdHJlZXMuIEFzIGxvbmdcbmFzIHRoYXQgcGFydCBvZiB0aGUgdHJlZSBpcyByZXVzZWQsIHRoZSBhc3NvY2lhdGVkIHZhbHVlcyBjYW4gYmVcbnJldHJpZXZlZCBmcm9tIGFuIHVwZGF0ZWQgdHJlZS5cbiovXG5jbGFzcyBOb2RlV2Vha01hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgc2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMubWFwLmdldChidWZmZXIpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGJ1ZmZlciwgaW5uZXIgPSBuZXcgTWFwKTtcbiAgICAgICAgaW5uZXIuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldEJ1ZmZlcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMubWFwLmdldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gaW5uZXIgJiYgaW5uZXIuZ2V0KGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZS5cbiAgICAqL1xuICAgIHNldChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSlcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChub2RlLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdmFsdWUgZm9yIHRoaXMgc3ludGF4IG5vZGUsIGlmIGl0IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgICovXG4gICAgZ2V0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBCdWZmZXJOb2RlID8gdGhpcy5nZXRCdWZmZXIobm9kZS5jb250ZXh0LmJ1ZmZlciwgbm9kZS5pbmRleClcbiAgICAgICAgICAgIDogbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlID8gdGhpcy5tYXAuZ2V0KG5vZGUudHJlZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50cyB0by5cbiAgICAqL1xuICAgIGN1cnNvclNldChjdXJzb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChjdXJzb3IuYnVmZmVyKVxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCwgdmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoY3Vyc29yLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdGhlIHZhbHVlIGZvciB0aGUgbm9kZSB0aGF0IGEgY3Vyc29yIGN1cnJlbnRseSBwb2ludHNcbiAgICB0by5cbiAgICAqL1xuICAgIGN1cnNvckdldChjdXJzb3IpIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5idWZmZXIgPyB0aGlzLmdldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4KSA6IHRoaXMubWFwLmdldChjdXJzb3IudHJlZSk7XG4gICAgfVxufVxuXG4vKipcblRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbnBhcnNpbmddKCNjb21tb24uUGFyc2VyLnN0YXJ0UGFyc2UpIHRvIHRyYWNrIHBhcnRzIG9mIG9sZCB0cmVlc1xudGhhdCBjYW4gYmUgcmV1c2VkIGluIGEgbmV3IHBhcnNlLiBBbiBhcnJheSBvZiBmcmFnbWVudHMgaXMgdXNlZFxudG8gdHJhY2sgcmVnaW9ucyBvZiBhbiBvbGQgdHJlZSB3aG9zZSBub2RlcyBtaWdodCBiZSByZXVzZWQgaW4gbmV3XG5wYXJzZXMuIFVzZSB0aGUgc3RhdGljXG5bYGFwcGx5Q2hhbmdlc2BdKCNjb21tb24uVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgbWV0aG9kIHRvXG51cGRhdGUgZnJhZ21lbnRzIGZvciBkb2N1bWVudCBjaGFuZ2VzLlxuKi9cbmNsYXNzIFRyZWVGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgdHJlZSBmcmFnbWVudC4gWW91J2xsIHVzdWFsbHkgd2FudCB0byB1c2VcbiAgICBbYGFkZFRyZWVgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hZGRUcmVlKSBhbmRcbiAgICBbYGFwcGx5Q2hhbmdlc2BdKCNjb21tb24uVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgaW5zdGVhZCBvZlxuICAgIGNhbGxpbmcgdGhpcyBkaXJlY3RseS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlIHBvaW50ZWQgdG8gYnkgdGhpcyBmcmFnbWVudC5cbiAgICBUaGlzIHJlZmVycyB0byBhbiBvZmZzZXQgaW4gdGhlIF91cGRhdGVkXyBkb2N1bWVudCAoYXMgb3Bwb3NlZFxuICAgIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgdHJlZSB0aGF0IHRoaXMgZnJhZ21lbnQgaXMgYmFzZWQgb24uXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICB0aGlzIGZyYWdtZW50IGNhbiBiZSB1c2VkIGFnYWluc3QuIEFkZCB0aGlzIHdoZW4gZ29pbmcgZnJvbVxuICAgIGRvY3VtZW50IHRvIHRyZWUgcG9zaXRpb25zLCBzdWJ0cmFjdCBpdCB0byBnbyBmcm9tIHRyZWUgdG9cbiAgICBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBvZmZzZXQsIG9wZW5TdGFydCA9IGZhbHNlLCBvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5vcGVuID0gKG9wZW5TdGFydCA/IDEgLyogT3Blbi5TdGFydCAqLyA6IDApIHwgKG9wZW5FbmQgPyAyIC8qIE9wZW4uRW5kICovIDogMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhXG4gICAgcGFyc2UsIG9yIHRoZSBlbmQgb2YgYSBjaGFuZ2UuIChJbiB0aGUgc2Vjb25kIGNhc2UsIGl0IG1heSBub3RcbiAgICBiZSBzYWZlIHRvIHJldXNlIHNvbWUgbm9kZXMgYXQgdGhlIHN0YXJ0LCBkZXBlbmRpbmcgb24gdGhlXG4gICAgcGFyc2luZyBhbGdvcml0aG0uKVxuICAgICovXG4gICAgZ2V0IG9wZW5TdGFydCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAxIC8qIE9wZW4uU3RhcnQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIGFcbiAgICBmdWxsLWRvY3VtZW50IHBhcnNlLCBvciB0aGUgc3RhcnQgb2YgYSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIE9wZW4uRW5kICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgZnJhZ21lbnRzIGZyb20gYSBmcmVzaGx5IHBhcnNlZCB0cmVlLCBvciB1cGRhdGVcbiAgICBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICB3aXRoIGEgdHJlZSB3aXRoIGNvbnRlbnQgZnJvbSB0aGUgbmV3IHRyZWUuIFdoZW4gYHBhcnRpYWxgIGlzXG4gICAgdHJ1ZSwgdGhlIHBhcnNlIGlzIHRyZWF0ZWQgYXMgaW5jb21wbGV0ZSwgYW5kIHRoZSByZXN1bHRpbmdcbiAgICBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgdHJ1ZS5cbiAgICAqL1xuICAgIHN0YXRpYyBhZGRUcmVlKHRyZWUsIGZyYWdtZW50cyA9IFtdLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtuZXcgVHJlZUZyYWdtZW50KDAsIHRyZWUubGVuZ3RoLCB0cmVlLCAwLCBmYWxzZSwgcGFydGlhbCldO1xuICAgICAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cylcbiAgICAgICAgICAgIGlmIChmLnRvID4gdHJlZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICBzcGxpdHRpbmcgZnJhZ21lbnRzIGFzIG5lY2Vzc2FyeSB0byByZW1vdmUgZWRpdGVkIHJhbmdlcywgYW5kXG4gICAgYWRqdXN0aW5nIG9mZnNldHMgZm9yIGZyYWdtZW50cyB0aGF0IG1vdmVkLlxuICAgICovXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5BIHN1cGVyY2xhc3MgdGhhdCBwYXJzZXJzIHNob3VsZCBleHRlbmQuXG4qL1xuY2xhc3MgUGFyc2VyIHtcbiAgICAvKipcbiAgICBTdGFydCBhIHBhcnNlLCByZXR1cm5pbmcgYSBbcGFydGlhbCBwYXJzZV0oI2NvbW1vbi5QYXJ0aWFsUGFyc2UpXG4gICAgb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgbWFrZSB0aGUgcGFyc2UgaW5jcmVtZW50YWwuXG4gICAgXG4gICAgQnkgZGVmYXVsdCwgdGhlIGVudGlyZSBpbnB1dCBpcyBwYXJzZWQuIFlvdSBjYW4gcGFzcyBgcmFuZ2VzYCxcbiAgICB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICByYW5nZXMsIHRvIHBhcnNlIG9ubHkgdGhvc2UgcmFuZ2VzLiBUaGUgdHJlZSByZXR1cm5lZCBpbiB0aGF0XG4gICAgY2FzZSB3aWxsIHN0YXJ0IGF0IGByYW5nZXNbMF0uZnJvbWAuXG4gICAgKi9cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIGEgZnVsbCBwYXJzZSwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgdHJlZS5cbiAgICAqL1xuICAgIHBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBwYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFN0cmluZ0lucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICBjaHVuayhmcm9tKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tKTsgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICByZWFkKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tLCB0byk7IH1cbn1cblxuLyoqXG5DcmVhdGUgYSBwYXJzZSB3cmFwcGVyIHRoYXQsIGFmdGVyIHRoZSBpbm5lciBwYXJzZSBjb21wbGV0ZXMsXG5zY2FucyBpdHMgdHJlZSBmb3IgbWl4ZWQgbGFuZ3VhZ2UgcmVnaW9ucyB3aXRoIHRoZSBgbmVzdGBcbmZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG5hbmQgdGhlbiBbbW91bnRzXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRoZWlyIHJlc3VsdHMgb250byB0aGVcbnRyZWUuXG4qL1xuZnVuY3Rpb24gcGFyc2VNaXhlZChuZXN0KSB7XG4gICAgcmV0dXJuIChwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSA9PiBuZXcgTWl4ZWRQYXJzZShwYXJzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbn1cbmNsYXNzIElubmVyUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcGFyc2UsIG92ZXJsYXksIGJyYWNrZXRlZCwgdGFyZ2V0LCBmcm9tKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMuYnJhY2tldGVkID0gYnJhY2tldGVkO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1JhbmdlcyhyYW5nZXMpIHtcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGggfHwgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPj0gci50bykpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbm5lciBwYXJzZSByYW5nZXMgZ2l2ZW46IFwiICsgSlNPTi5zdHJpbmdpZnkocmFuZ2VzKSk7XG59XG5jbGFzcyBBY3RpdmVPdmVybGF5IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHByZWRpY2F0ZSwgbW91bnRzLCBpbmRleCwgc3RhcnQsIGJyYWNrZXRlZCwgdGFyZ2V0LCBwcmV2KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5tb3VudHMgPSBtb3VudHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmJyYWNrZXRlZCA9IGJyYWNrZXRlZDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgIH1cbn1cbmNvbnN0IHN0b3BwZWRJbm5lciA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG5jbGFzcyBNaXhlZFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5uZXN0ID0gbmVzdDtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pbm5lckRvbmUgPSAwO1xuICAgICAgICB0aGlzLmJhc2VUcmVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IGJhc2U7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSkge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmJhc2VQYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJhc2VUcmVlID0gZG9uZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRJbm5lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5uZXIgb2YgdGhpcy5pbm5lcilcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIucGFyc2Uuc3RvcEF0KHRoaXMuc3RvcHBlZEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbm5lckRvbmUgPT0gdGhpcy5pbm5lci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmJhc2VUcmVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRyZWUocmVzdWx0LnR5cGUsIHJlc3VsdC5jaGlsZHJlbiwgcmVzdWx0LnBvc2l0aW9ucywgcmVzdWx0Lmxlbmd0aCwgcmVzdWx0LnByb3BWYWx1ZXMuY29uY2F0KFtbc3RvcHBlZElubmVyLCB0aGlzLnN0b3BwZWRBdF1dKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMuaW5uZXJbdGhpcy5pbm5lckRvbmVdLCBkb25lID0gaW5uZXIucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5pbm5lckRvbmUrKztcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzb21ld2hhdCBkb2RneSBidXQgc3VwZXIgaGVscGZ1bCBoYWNrIHdoZXJlIHdlXG4gICAgICAgICAgICAvLyBwYXRjaCB1cCBub2RlcyBjcmVhdGVkIGJ5IHRoZSBpbm5lciBwYXJzZSAoYW5kIHRodXNcbiAgICAgICAgICAgIC8vIHByZXN1bWFibHkgbm90IGFsaWFzZWQgYW55d2hlcmUgZWxzZSkgdG8gaG9sZCB0aGUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIC8vIGFib3V0IHRoZSBpbm5lciBwYXJzZS5cbiAgICAgICAgICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgaW5uZXIudGFyZ2V0LnByb3BzKTtcbiAgICAgICAgICAgIHByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdID0gbmV3IE1vdW50ZWRUcmVlKGRvbmUsIGlubmVyLm92ZXJsYXksIGlubmVyLnBhcnNlciwgaW5uZXIuYnJhY2tldGVkKTtcbiAgICAgICAgICAgIGlubmVyLnRhcmdldC5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbm5lcltpXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgY3Vyc29yLmZyb20gPj0gdGhpcy5zdG9wcGVkQXQpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJhZ21lbnRDdXJzb3IuaGFzTm9kZShjdXJzb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gb3ZlcmxheS5tb3VudHMuZmluZChtID0+IG0uZnJhZy5mcm9tIDw9IGN1cnNvci5mcm9tICYmIG0uZnJhZy50byA+PSBjdXJzb3IudG8gJiYgbS5tb3VudC5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtYXRjaC5tb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSByLmZyb20gKyBtYXRjaC5wb3MsIHRvID0gci50byArIG1hdGNoLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjdXJzb3IuZnJvbSAmJiB0byA8PSBjdXJzb3IudG8gJiYgIW92ZXJsYXkucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPCB0byAmJiByLnRvID4gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdmVyZWQgJiYgKGlzQ292ZXJlZCA9IGNoZWNrQ292ZXIoY292ZXJlZC5yYW5nZXMsIGN1cnNvci5mcm9tLCBjdXJzb3IudG8pKSkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gaXNDb3ZlcmVkICE9IDIgLyogQ292ZXIuRnVsbCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IudHlwZS5pc0Fub255bW91cyAmJiAobmVzdCA9IHRoaXMubmVzdChjdXJzb3IsIHRoaXMuaW5wdXQpKSAmJlxuICAgICAgICAgICAgICAgIChjdXJzb3IuZnJvbSA8IGN1cnNvci50byB8fCAhbmVzdC5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0ZXJpYWxpemUgY3JlYXRlIG9uZSBtb3JlIGxldmVsIG9mIG5lc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhZGQgZGVwdGggdG8gYWN0aXZlIG92ZXJsYXkgZm9yIGdvaW5nIGJhY2t3YXJkc1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBvbGRNb3VudHMgPSBmcmFnbWVudEN1cnNvci5maW5kTW91bnRzKGN1cnNvci5mcm9tLCBuZXN0LnBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXN0Lm92ZXJsYXkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBuZXcgQWN0aXZlT3ZlcmxheShuZXN0LnBhcnNlciwgbmVzdC5vdmVybGF5LCBvbGRNb3VudHMsIHRoaXMuaW5uZXIubGVuZ3RoLCBjdXJzb3IuZnJvbSwgISFuZXN0LmJyYWNrZXRlZCwgY3Vyc29yLnRyZWUsIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBuZXN0Lm92ZXJsYXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJzb3IuZnJvbSA8IGN1cnNvci50byA/IFtuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byldIDogW10pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1JhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCB8fCAhbmVzdC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5wdXNoKG5ldyBJbm5lclBhcnNlKG5lc3QucGFyc2VyLCByYW5nZXMubGVuZ3RoID8gbmVzdC5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvbGRNb3VudHMsIHJhbmdlcyksIHJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UoXCJcIiksIG5lc3Qub3ZlcmxheSA/IG5lc3Qub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gY3Vyc29yLmZyb20sIHIudG8gLSBjdXJzb3IuZnJvbSkpIDogbnVsbCwgISFuZXN0LmJyYWNrZXRlZCwgY3Vyc29yLnRyZWUsIHJhbmdlcy5sZW5ndGggPyByYW5nZXNbMF0uZnJvbSA6IGN1cnNvci5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmVzdC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSB7IHJhbmdlcywgZGVwdGg6IDAsIHByZXY6IGNvdmVyZWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybGF5ICYmIChyYW5nZSA9IG92ZXJsYXkucHJlZGljYXRlKGN1cnNvcikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gb3ZlcmxheS5yYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgPj0gMCAmJiBvdmVybGF5LnJhbmdlc1tsYXN0XS50byA9PSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXNbbGFzdF0gPSB7IGZyb206IG92ZXJsYXkucmFuZ2VzW2xhc3RdLmZyb20sIHRvOiByYW5nZS50byB9O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50ZXIgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmRlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgJiYgIS0tb3ZlcmxheS5kZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBvdmVybGF5LnJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5zcGxpY2Uob3ZlcmxheS5pbmRleCwgMCwgbmV3IElubmVyUGFyc2Uob3ZlcmxheS5wYXJzZXIsIG92ZXJsYXkucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob3ZlcmxheS5tb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG92ZXJsYXkucmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBvdmVybGF5LnN0YXJ0LCByLnRvIC0gb3ZlcmxheS5zdGFydCkpLCBvdmVybGF5LmJyYWNrZXRlZCwgb3ZlcmxheS50YXJnZXQsIHJhbmdlc1swXS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBDb3Zlci5GdWxsICovIDogMSAvKiBDb3Zlci5QYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBzdGFjayA9IFtdO1xuICAgIGxldCBidWZmZXIgPSBub2RlLmNvbnRleHQuYnVmZmVyO1xuICAgIC8vIFNjYW4gdXAgdG8gdGhlIG5lYXJlc3QgdHJlZVxuICAgIGRvIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXJzb3IuaW5kZXgpO1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBiYXNlID0gY3Vyc29yLnRyZWUsIGkgPSBiYXNlLmNoaWxkcmVuLmluZGV4T2YoYnVmZmVyKTtcbiAgICBsZXQgYnVmID0gYmFzZS5jaGlsZHJlbltpXSwgYiA9IGJ1Zi5idWZmZXIsIG5ld1N0YWNrID0gW2ldO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCwgc3RhY2tQb3MpIHtcbiAgICAgICAgbGV0IHRhcmdldEkgPSBzdGFja1tzdGFja1Bvc107XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBzdGFydEksIHRhcmdldEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgbGV0IGZyb20gPSBiW3RhcmdldEkgKyAxXSwgdG8gPSBiW3RhcmdldEkgKyAyXTtcbiAgICAgICAgbmV3U3RhY2sucHVzaChjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICBsZXQgY2hpbGQgPSBzdGFja1Bvc1xuICAgICAgICAgICAgPyBzcGxpdCh0YXJnZXRJICsgNCwgYlt0YXJnZXRJICsgM10sIGJ1Zi5zZXQudHlwZXNbYlt0YXJnZXRJXV0sIGZyb20sIHRvIC0gZnJvbSwgc3RhY2tQb3MgLSAxKVxuICAgICAgICAgICAgOiBub2RlLnRvVHJlZSgpO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBiW3RhcmdldEkgKyAzXSwgZW5kSSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKTtcbiAgICB9XG4gICAgYmFzZS5jaGlsZHJlbltpXSA9IHNwbGl0KDAsIGIubGVuZ3RoLCBOb2RlVHlwZS5ub25lLCAwLCBidWYubGVuZ3RoLCBzdGFjay5sZW5ndGggLSAxKTtcbiAgICAvLyBNb3ZlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgdGFyZ2V0IG5vZGVcbiAgICBmb3IgKGxldCBpbmRleCBvZiBuZXdTdGFjaykge1xuICAgICAgICBsZXQgdHJlZSA9IGN1cnNvci50cmVlLmNoaWxkcmVuW2luZGV4XSwgcG9zID0gY3Vyc29yLnRyZWUucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgY3Vyc29yLnlpZWxkKG5ldyBUcmVlTm9kZSh0cmVlLCBwb3MgKyBjdXJzb3IuZnJvbSwgaW5kZXgsIGN1cnNvci5fdHJlZSkpO1xuICAgIH1cbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cyB8IEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci5uZXh0KGZhbHNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUoY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKGN1cnNvci5mcm9tKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5jdXJzb3IuZnJvbSArIHRoaXMub2Zmc2V0ID09IGN1cnNvci5mcm9tICYmIHRoaXMuY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRyZWUgPSB0aGlzLmN1cnNvci50cmVlOzspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJlZSA9PSBjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoICYmIHRyZWUucG9zaXRpb25zWzBdID09IDAgJiYgdHJlZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5jdXJUbyA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ0kgPSAwO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5jdXJGcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZpcnN0LnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaXJzdC50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmN1ckZyYWcgJiYgbm9kZS5mcm9tID49IHRoaXMuY3VyVG8pXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gbm9kZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gbm9kZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUobm9kZSk7XG4gICAgfVxuICAgIG5leHRGcmFnKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ0krKztcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0kgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZnJhZy50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnJhZy50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZyYWcudHJlZSwgLWZyYWcub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW91bnRzKHBvcywgcGFyc2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLmlubmVyLmN1cnNvci5ub2RlOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW91bnQgPSAoX2EgPSBwb3MudHJlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJhZ0k7IGkgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcudHJlZSA9PSB0aGlzLmN1ckZyYWcudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLmZyb20gLSBmcmFnLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcbiAgICBsZXQgY29weSA9IG51bGwsIGN1cnJlbnQgPSByYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcbiAgICAgICAgZm9yICg7IGogPCBjdXJyZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgciA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPD0gZ2FwRnJvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29weSA9IHJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2pdID0gbmV3IFJhbmdlKHIuZnJvbSwgZ2FwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHIudG8gPiBnYXBUbylcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoci50byA+IGdhcFRvKSB7XG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XG4gICAgbGV0IGlBID0gMCwgaUIgPSAwLCBpbkEgPSBmYWxzZSwgaW5CID0gZmFsc2UsIHBvcyA9IC0xZTk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHRBID0gaUEgPT0gYS5sZW5ndGggPyAxZTkgOiBpbkEgPyBhW2lBXS50byA6IGFbaUFdLmZyb207XG4gICAgICAgIGxldCBuZXh0QiA9IGlCID09IGIubGVuZ3RoID8gMWU5IDogaW5CID8gYltpQl0udG8gOiBiW2lCXS5mcm9tO1xuICAgICAgICBpZiAoaW5BICE9IGluQikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4obmV4dEEsIG5leHRCLCB0byk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIpO1xuICAgICAgICBpZiAocG9zID09IDFlOSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dEEgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQSlcbiAgICAgICAgICAgICAgICBpbkEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEIgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQilcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5CID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xuLy8gdG8gcGFyc2UsIGZpbmQgZnJhZ21lbnRzIGZvciBpbm5lciB0cmVlcyBtb3VudGVkIGFyb3VuZCB0aG9zZVxuLy8gcmFuZ2VzLCBpZiBhbnkuXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IHBvcywgbW91bnQsIGZyYWcgfSBvZiBtb3VudHMpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChmcmFnLmZyb20sIHN0YXJ0UG9zKSwgdG8gPSBNYXRoLm1pbihmcmFnLnRvLCBlbmRQb3MpO1xuICAgICAgICBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gZmluZENvdmVyQ2hhbmdlcyhyYW5nZXMsIG92ZXJsYXksIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBmcm9tOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChwb3MsIGVuZCwgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gcG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZCB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hhbmdlc1tpXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZFBvcyB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBJdGVyTW9kZSwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgTm9kZVdlYWtNYXAsIFBhcnNlciwgVHJlZSwgVHJlZUJ1ZmZlciwgVHJlZUN1cnNvciwgVHJlZUZyYWdtZW50LCBwYXJzZU1peGVkIH07XG4iLCAiaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxubGV0IG5leHRUYWdJRCA9IDA7XG4vKipcbkhpZ2hsaWdodGluZyB0YWdzIGFyZSBtYXJrZXJzIHRoYXQgZGVub3RlIGEgaGlnaGxpZ2h0aW5nIGNhdGVnb3J5LlxuVGhleSBhcmUgW2Fzc29jaWF0ZWRdKCNoaWdobGlnaHQuc3R5bGVUYWdzKSB3aXRoIHBhcnRzIG9mIGEgc3ludGF4XG50cmVlIGJ5IGEgbGFuZ3VhZ2UgbW9kZSwgYW5kIHRoZW4gbWFwcGVkIHRvIGFuIGFjdHVhbCBDU1Mgc3R5bGUgYnlcbmEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS5cblxuQmVjYXVzZSBzeW50YXggdHJlZSBub2RlIHR5cGVzIGFuZCBoaWdobGlnaHQgc3R5bGVzIGhhdmUgdG8gYmVcbmFibGUgdG8gdGFsayB0aGUgc2FtZSBsYW5ndWFnZSwgQ29kZU1pcnJvciB1c2VzIGEgbW9zdGx5IF9jbG9zZWRfXG5bdm9jYWJ1bGFyeV0oI2hpZ2hsaWdodC50YWdzKSBvZiBzeW50YXggdGFncyAoYXMgb3Bwb3NlZCB0b1xudHJhZGl0aW9uYWwgb3BlbiBzdHJpbmctYmFzZWQgc3lzdGVtcywgd2hpY2ggbWFrZSBpdCBoYXJkIGZvclxuaGlnaGxpZ2h0aW5nIHRoZW1lcyB0byBjb3ZlciBhbGwgdGhlIHRva2VucyBwcm9kdWNlZCBieSB0aGVcbnZhcmlvdXMgbGFuZ3VhZ2VzKS5cblxuSXQgX2lzXyBwb3NzaWJsZSB0byBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIHlvdXIgb3duXG5oaWdobGlnaHRpbmcgdGFncyBmb3Igc3lzdGVtLWludGVybmFsIHVzZSAod2hlcmUgeW91IGNvbnRyb2wgYm90aFxudGhlIGxhbmd1YWdlIHBhY2thZ2UgYW5kIHRoZSBoaWdobGlnaHRlciksIGJ1dCBzdWNoIHRhZ3Mgd2lsbCBub3RcbmJlIHBpY2tlZCB1cCBieSByZWd1bGFyIGhpZ2hsaWdodGVycyAodGhvdWdoIHlvdSBjYW4gZGVyaXZlIHRoZW1cbmZyb20gc3RhbmRhcmQgdGFncyB0byBhbGxvdyBoaWdobGlnaHRlcnMgdG8gZmFsbCBiYWNrIHRvIHRob3NlKS5cbiovXG5jbGFzcyBUYWcge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG9wdGlvbmFsIG5hbWUgb2YgdGhlIGJhc2UgdGFnIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiB0aGlzIHRhZyBhbmQgYWxsIGl0cyBwYXJlbnQgdGFncywgc3RhcnRpbmcgd2l0aFxuICAgIHRoaXMgb25lIGl0c2VsZiBhbmQgc29ydGVkIGluIG9yZGVyIG9mIGRlY3JlYXNpbmcgc3BlY2lmaWNpdHkuXG4gICAgKi9cbiAgICBzZXQsIFxuICAgIC8qKlxuICAgIFRoZSBiYXNlIHVubW9kaWZpZWQgdGFnIHRoYXQgdGhpcyBvbmUgaXMgYmFzZWQgb24sIGlmIGl0J3NcbiAgICBtb2RpZmllZCBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJhc2UsIFxuICAgIC8qKlxuICAgIFRoZSBtb2RpZmllcnMgYXBwbGllZCB0byB0aGlzLmJhc2UgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RpZmllZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IG1vZGlmaWVkO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBuZXh0VGFnSUQrKztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCB7IG5hbWUgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IG1vZCBvZiB0aGlzLm1vZGlmaWVkKVxuICAgICAgICAgICAgaWYgKG1vZC5uYW1lKVxuICAgICAgICAgICAgICAgIG5hbWUgPSBgJHttb2QubmFtZX0oJHtuYW1lfSlgO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShuYW1lT3JQYXJlbnQsIHBhcmVudCkge1xuICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBuYW1lT3JQYXJlbnQgPT0gXCJzdHJpbmdcIiA/IG5hbWVPclBhcmVudCA6IFwiP1wiO1xuICAgICAgICBpZiAobmFtZU9yUGFyZW50IGluc3RhbmNlb2YgVGFnKVxuICAgICAgICAgICAgcGFyZW50ID0gbmFtZU9yUGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhuYW1lLCBbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHRhZyBfbW9kaWZpZXJfLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgdGFnLFxuICAgIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgPT0gbTEodDEpYCkgYW5kIGFwcGx5aW5nIG11bHRpcGxlIG1vZGlmaWVycyB3aWxsLCByZWdhcmRsZXNzIG9yXG4gICAgb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgXG4gICAgV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIHNtYWxsZXIgc2V0IG9mIG1vZGlmaWVycyBpcyByZWdpc3RlcmVkIGFzIGEgcGFyZW50LCBzbyB0aGF0IGZvclxuICAgIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lTW9kaWZpZXIobmFtZSkge1xuICAgICAgICBsZXQgbW9kID0gbmV3IE1vZGlmaWVyKG5hbWUpO1xuICAgICAgICByZXR1cm4gKHRhZykgPT4ge1xuICAgICAgICAgICAgaWYgKHRhZy5tb2RpZmllZC5pbmRleE9mKG1vZCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyLmdldCh0YWcuYmFzZSB8fCB0YWcsIHRhZy5tb2RpZmllZC5jb25jYXQobW9kKS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmxldCBuZXh0TW9kaWZpZXJJRCA9IDA7XG5jbGFzcyBNb2RpZmllciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmlkID0gbmV4dE1vZGlmaWVySUQrKztcbiAgICB9XG4gICAgc3RhdGljIGdldChiYXNlLCBtb2RzKSB7XG4gICAgICAgIGlmICghbW9kcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IGV4aXN0cyA9IG1vZHNbMF0uaW5zdGFuY2VzLmZpbmQodCA9PiB0LmJhc2UgPT0gYmFzZSAmJiBzYW1lQXJyYXkobW9kcywgdC5tb2RpZmllZCkpO1xuICAgICAgICBpZiAoZXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0cztcbiAgICAgICAgbGV0IHNldCA9IFtdLCB0YWcgPSBuZXcgVGFnKGJhc2UubmFtZSwgc2V0LCBiYXNlLCBtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgbSBvZiBtb2RzKVxuICAgICAgICAgICAgbS5pbnN0YW5jZXMucHVzaCh0YWcpO1xuICAgICAgICBsZXQgY29uZmlncyA9IHBvd2VyU2V0KG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgb2YgYmFzZS5zZXQpXG4gICAgICAgICAgICBpZiAoIXBhcmVudC5tb2RpZmllZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKE1vZGlmaWVyLmdldChwYXJlbnQsIGNvbmZpZykpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHgsIGkpID0+IHggPT0gYltpXSk7XG59XG5mdW5jdGlvbiBwb3dlclNldChhcnJheSkge1xuICAgIGxldCBzZXRzID0gW1tdXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBlID0gc2V0cy5sZW5ndGg7IGogPCBlOyBqKyspIHtcbiAgICAgICAgICAgIHNldHMucHVzaChzZXRzW2pdLmNvbmNhdChhcnJheVtpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xufVxuLyoqXG5UaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYWRkIGEgc2V0IG9mIHRhZ3MgdG8gYSBsYW5ndWFnZSBzeW50YXhcbnZpYSBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbltgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLkxSUGFyc2VyLmNvbmZpZ3VyZSkuXG5cblRoZSBhcmd1bWVudCBvYmplY3QgbWFwcyBub2RlIHNlbGVjdG9ycyB0byBbaGlnaGxpZ2h0aW5nXG50YWdzXSgjaGlnaGxpZ2h0LlRhZykgb3IgYXJyYXlzIG9mIHRhZ3MuXG5cbk5vZGUgc2VsZWN0b3JzIG1heSBob2xkIG9uZSBvciBtb3JlIChzcGFjZS1zZXBhcmF0ZWQpIG5vZGUgcGF0aHMuXG5TdWNoIGEgcGF0aCBjYW4gYmUgYSBbbm9kZSBuYW1lXSgjY29tbW9uLk5vZGVUeXBlLm5hbWUpLCBvclxubXVsdGlwbGUgbm9kZSBuYW1lcyAob3IgYCpgIHdpbGRjYXJkcykgc2VwYXJhdGVkIGJ5IHNsYXNoXG5jaGFyYWN0ZXJzLCBhcyBpbiBgXCJCbG9jay9EZWNsYXJhdGlvbi9WYXJpYWJsZU5hbWVcImAuIFN1Y2ggYSBwYXRoXG5tYXRjaGVzIHRoZSBmaW5hbCBub2RlIGJ1dCBvbmx5IGlmIGl0cyBkaXJlY3QgcGFyZW50IG5vZGVzIGFyZSB0aGVcbm90aGVyIG5vZGVzIG1lbnRpb25lZC4gQSBgKmAgaW4gc3VjaCBhIHBhdGggbWF0Y2hlcyBhbnkgcGFyZW50LFxuYnV0IG9ubHkgYSBzaW5nbGUgbGV2ZWxcdTIwMTR3aWxkY2FyZHMgdGhhdCBtYXRjaCBtdWx0aXBsZSBwYXJlbnRzXG5hcmVuJ3Qgc3VwcG9ydGVkLCBib3RoIGZvciBlZmZpY2llbmN5IHJlYXNvbnMgYW5kIGJlY2F1c2UgTGV6ZXJcbnRyZWVzIG1ha2UgaXQgcmF0aGVyIGhhcmQgdG8gcmVhc29uIGFib3V0IHdoYXQgdGhleSB3b3VsZCBtYXRjaC4pXG5cbkEgcGF0aCBjYW4gYmUgZW5kZWQgd2l0aCBgLy4uLmAgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdGFnIGFzc2lnbmVkXG50byB0aGUgbm9kZSBzaG91bGQgYWxzbyBhcHBseSB0byBhbGwgY2hpbGQgbm9kZXMsIGV2ZW4gaWYgdGhleVxubWF0Y2ggdGhlaXIgb3duIHN0eWxlIChieSBkZWZhdWx0LCBvbmx5IHRoZSBpbm5lcm1vc3Qgc3R5bGUgaXNcbnVzZWQpLlxuXG5XaGVuIGEgcGF0aCBlbmRzIGluIGAhYCwgYXMgaW4gYEF0dHJpYnV0ZSFgLCBubyBmdXJ0aGVyIG1hdGNoaW5nXG5oYXBwZW5zIGZvciB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCBhbmQgdGhlIGVudGlyZSBub2RlIGdldHMgdGhlXG5naXZlbiBzdHlsZS5cblxuSW4gdGhpcyBub3RhdGlvbiwgbm9kZSBuYW1lcyB0aGF0IGNvbnRhaW4gYC9gLCBgIWAsIGAqYCwgb3IgYC4uLmBcbm11c3QgYmUgcXVvdGVkIGFzIEpTT04gc3RyaW5ncy5cblxuRm9yIGV4YW1wbGU6XG5cbmBgYGphdmFzY3JpcHRcbnBhcnNlci5jb25maWd1cmUoe3Byb3BzOiBbXG4gIHN0eWxlVGFncyh7XG4gICAgLy8gU3R5bGUgTnVtYmVyIGFuZCBCaWdOdW1iZXIgbm9kZXNcbiAgICBcIk51bWJlciBCaWdOdW1iZXJcIjogdGFncy5udW1iZXIsXG4gICAgLy8gU3R5bGUgRXNjYXBlIG5vZGVzIHdob3NlIHBhcmVudCBpcyBTdHJpbmdcbiAgICBcIlN0cmluZy9Fc2NhcGVcIjogdGFncy5lc2NhcGUsXG4gICAgLy8gU3R5bGUgYW55dGhpbmcgaW5zaWRlIEF0dHJpYnV0ZXMgbm9kZXNcbiAgICBcIkF0dHJpYnV0ZXMhXCI6IHRhZ3MubWV0YSxcbiAgICAvLyBBZGQgYSBzdHlsZSB0byBhbGwgY29udGVudCBpbnNpZGUgSXRhbGljIG5vZGVzXG4gICAgXCJJdGFsaWMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4gICAgLy8gU3R5bGUgSW52YWxpZFN0cmluZyBub2RlcyBhcyBib3RoIGBzdHJpbmdgIGFuZCBgaW52YWxpZGBcbiAgICBcIkludmFsaWRTdHJpbmdcIjogW3RhZ3Muc3RyaW5nLCB0YWdzLmludmFsaWRdLFxuICAgIC8vIFN0eWxlIHRoZSBub2RlIG5hbWVkIFwiL1wiIGFzIHB1bmN0dWF0aW9uXG4gICAgJ1wiL1wiJzogdGFncy5wdW5jdHVhdGlvblxuICB9KVxuXX0pXG5gYGBcbiovXG5mdW5jdGlvbiBzdHlsZVRhZ3Moc3BlYykge1xuICAgIGxldCBieU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdGFncyA9IHNwZWNbcHJvcF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZXMgPSBbXSwgbW9kZSA9IDIgLyogTW9kZS5Ob3JtYWwgKi8sIHJlc3QgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCA9PSBcIi4uLlwiICYmIHBvcyA+IDAgJiYgcG9zICsgMyA9PSBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDEgLyogTW9kZS5Jbmhlcml0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gXCJcIiA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydFtwb3MrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGggJiYgbmV4dCA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogTW9kZS5PcGFxdWUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFydC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IHBpZWNlcy5sZW5ndGggLSAxLCBpbm5lciA9IHBpZWNlc1tsYXN0XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IG5ldyBSdWxlKHRhZ3MsIG1vZGUsIGxhc3QgPiAwID8gcGllY2VzLnNsaWNlKDAsIGxhc3QpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgYnlOYW1lW2lubmVyXSA9IHJ1bGUuc29ydChieU5hbWVbaW5uZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVOb2RlUHJvcC5hZGQoYnlOYW1lKTtcbn1cbmNvbnN0IHJ1bGVOb2RlUHJvcCA9IG5ldyBOb2RlUHJvcCh7XG4gICAgY29tYmluZShhLCBiKSB7XG4gICAgICAgIGxldCBjdXIsIHJvb3QsIHRha2U7XG4gICAgICAgIHdoaWxlIChhIHx8IGIpIHtcbiAgICAgICAgICAgIGlmICghYSB8fCBiICYmIGEuZGVwdGggPj0gYi5kZXB0aCkge1xuICAgICAgICAgICAgICAgIHRha2UgPSBiO1xuICAgICAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWtlID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1ciAmJiBjdXIubW9kZSA9PSB0YWtlLm1vZGUgJiYgIXRha2UuY29udGV4dCAmJiAhY3VyLmNvbnRleHQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY29weSA9IG5ldyBSdWxlKHRha2UudGFncywgdGFrZS5tb2RlLCB0YWtlLmNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGN1cilcbiAgICAgICAgICAgICAgICBjdXIubmV4dCA9IGNvcHk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcm9vdCA9IGNvcHk7XG4gICAgICAgICAgICBjdXIgPSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbn0pO1xuY2xhc3MgUnVsZSB7XG4gICAgY29uc3RydWN0b3IodGFncywgbW9kZSwgY29udGV4dCwgbmV4dCkge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbiAgICBnZXQgb3BhcXVlKCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDAgLyogTW9kZS5PcGFxdWUgKi87IH1cbiAgICBnZXQgaW5oZXJpdCgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLzsgfVxuICAgIHNvcnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlciB8fCBvdGhlci5kZXB0aCA8IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG90aGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIubmV4dCA9IHRoaXMuc29ydChvdGhlci5uZXh0KTtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQubGVuZ3RoIDogMDsgfVxufVxuUnVsZS5lbXB0eSA9IG5ldyBSdWxlKFtdLCAyIC8qIE1vZGUuTm9ybWFsICovLCBudWxsKTtcbi8qKlxuRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG50YWcvY2xhc3MgcGFpcnMuIENsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIG1vcmUgc3BlY2lmaWMgdGFncyB3aWxsXG50YWtlIHByZWNlZGVuY2UuXG4qL1xuZnVuY3Rpb24gdGFnSGlnaGxpZ2h0ZXIodGFncywgb3B0aW9ucykge1xuICAgIGxldCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHN0eWxlIG9mIHRhZ3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLnRhZykpXG4gICAgICAgICAgICBtYXBbc3R5bGUudGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2Ygc3R5bGUudGFnKVxuICAgICAgICAgICAgICAgIG1hcFt0YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgfVxuICAgIGxldCB7IHNjb3BlLCBhbGwgPSBudWxsIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiAodGFncykgPT4ge1xuICAgICAgICAgICAgbGV0IGNscyA9IGFsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHRhZy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZ0NsYXNzID0gbWFwW3N1Yi5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gY2xzID8gY2xzICsgXCIgXCIgKyB0YWdDbGFzcyA6IHRhZ0NsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9LFxuICAgICAgICBzY29wZVxuICAgIH07XG59XG5mdW5jdGlvbiBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgdGFncykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgdmFsdWUgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG5baGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLiBPZnRlbiwgdGhlIGhpZ2hlci1sZXZlbFxuW2BoaWdobGlnaHRDb2RlYF0oI2hpZ2hsaWdodC5oaWdobGlnaHRDb2RlKSBmdW5jdGlvbiBpcyBlYXNpZXIgdG9cbnVzZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCBcbi8qKlxuQXNzaWduIHN0eWxpbmcgdG8gYSByZWdpb24gb2YgdGhlIHRleHQuIFdpbGwgYmUgY2FsbGVkLCBpbiBvcmRlclxub2YgcG9zaXRpb24sIGZvciBhbnkgcmFuZ2VzIHdoZXJlIG1vcmUgdGhhbiB6ZXJvIGNsYXNzZXMgYXBwbHkuXG5gY2xhc3Nlc2AgaXMgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxuKi9cbnB1dFN0eWxlLCBcbi8qKlxuVGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0byBoaWdobGlnaHQuXG4qL1xuZnJvbSA9IDAsIFxuLyoqXG5UaGUgZW5kIG9mIHRoZSByYW5nZS5cbiovXG50byA9IHRyZWUubGVuZ3RoKSB7XG4gICAgbGV0IGJ1aWxkZXIgPSBuZXcgSGlnaGxpZ2h0QnVpbGRlcihmcm9tLCBBcnJheS5pc0FycmF5KGhpZ2hsaWdodGVyKSA/IGhpZ2hsaWdodGVyIDogW2hpZ2hsaWdodGVyXSwgcHV0U3R5bGUpO1xuICAgIGJ1aWxkZXIuaGlnaGxpZ2h0UmFuZ2UodHJlZS5jdXJzb3IoKSwgZnJvbSwgdG8sIFwiXCIsIGJ1aWxkZXIuaGlnaGxpZ2h0ZXJzKTtcbiAgICBidWlsZGVyLmZsdXNoKHRvKTtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiB0cmVlIHdpdGggdGhlIGdpdmVuIGhpZ2hsaWdodGVyLCBjYWxsaW5nXG5gcHV0VGV4dGAgZm9yIGV2ZXJ5IHBpZWNlIG9mIHRleHQsIGVpdGhlciB3aXRoIGEgc2V0IG9mIGNsYXNzZXMgb3JcbndpdGggdGhlIGVtcHR5IHN0cmluZyB3aGVuIHVuc3R5bGVkLCBhbmQgYHB1dEJyZWFrYCBmb3IgZXZlcnkgbGluZVxuYnJlYWsuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0Q29kZShjb2RlLCB0cmVlLCBoaWdobGlnaHRlciwgcHV0VGV4dCwgcHV0QnJlYWssIGZyb20gPSAwLCB0byA9IGNvZGUubGVuZ3RoKSB7XG4gICAgbGV0IHBvcyA9IGZyb207XG4gICAgZnVuY3Rpb24gd3JpdGVUbyhwLCBjbGFzc2VzKSB7XG4gICAgICAgIGlmIChwIDw9IHBvcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgdGV4dCA9IGNvZGUuc2xpY2UocG9zLCBwKSwgaSA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IHRleHQuaW5kZXhPZihcIlxcblwiLCBpKTtcbiAgICAgICAgICAgIGxldCB1cHRvID0gbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrO1xuICAgICAgICAgICAgaWYgKHVwdG8gPiBpKVxuICAgICAgICAgICAgICAgIHB1dFRleHQodGV4dC5zbGljZShpLCB1cHRvKSwgY2xhc3Nlcyk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHB1dEJyZWFrKCk7XG4gICAgICAgICAgICBpID0gbmV4dEJyZWFrICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBwO1xuICAgIH1cbiAgICBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCAoZnJvbSwgdG8sIGNsYXNzZXMpID0+IHtcbiAgICAgICAgd3JpdGVUbyhmcm9tLCBcIlwiKTtcbiAgICAgICAgd3JpdGVUbyh0bywgY2xhc3Nlcyk7XG4gICAgfSwgZnJvbSwgdG8pO1xuICAgIHdyaXRlVG8odG8sIFwiXCIpO1xufVxuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYXQsIGhpZ2hsaWdodGVycywgc3Bhbikge1xuICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXJzID0gaGlnaGxpZ2h0ZXJzO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLmNsYXNzID0gXCJcIjtcbiAgICB9XG4gICAgc3RhcnRTcGFuKGF0LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdCA+IHRoaXMuYXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCh0bykge1xuICAgICAgICBpZiAodG8gPiB0aGlzLmF0ICYmIHRoaXMuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLnNwYW4odGhpcy5hdCwgdG8sIHRoaXMuY2xhc3MpO1xuICAgIH1cbiAgICBoaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBoaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKHR5cGUpKTtcbiAgICAgICAgbGV0IGNscyA9IGluaGVyaXRlZENsYXNzO1xuICAgICAgICBsZXQgcnVsZSA9IGdldFN0eWxlVGFncyhjdXJzb3IpIHx8IFJ1bGUuZW1wdHk7XG4gICAgICAgIGxldCB0YWdDbHMgPSBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgcnVsZS50YWdzKTtcbiAgICAgICAgaWYgKHRhZ0Nscykge1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XG4gICAgICAgICAgICBjbHMgKz0gdGFnQ2xzO1xuICAgICAgICAgICAgaWYgKHJ1bGUubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLylcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyArPSAoaW5oZXJpdGVkQ2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgdGFnQ2xzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWF4KGZyb20sIHN0YXJ0KSwgY2xzKTtcbiAgICAgICAgaWYgKHJ1bGUub3BhcXVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbW91bnRlZCA9IGN1cnNvci50cmVlICYmIGN1cnNvci50cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gY3Vyc29yLm5vZGUuZW50ZXIobW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyBzdGFydCwgMSk7XG4gICAgICAgICAgICBsZXQgaW5uZXJIaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKG1vdW50ZWQudHJlZS50eXBlKSk7XG4gICAgICAgICAgICBsZXQgaGFzQ2hpbGQgPSBjdXJzb3IuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpIDwgbW91bnRlZC5vdmVybGF5Lmxlbmd0aCA/IG1vdW50ZWQub3ZlcmxheVtpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0ID8gbmV4dC5mcm9tICsgc3RhcnQgOiBlbmQ7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyksIHJhbmdlVG8gPSBNYXRoLm1pbih0bywgbmV4dFBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlRnJvbSA8IHJhbmdlVG8gJiYgaGFzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5mcm9tIDwgcmFuZ2VUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIHJhbmdlRnJvbSwgcmFuZ2VUbywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbihyYW5nZVRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBuZXh0UG9zIHx8ICFjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dFBvcyA+IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShpbm5lci5jdXJzb3IoKSwgTWF0aC5tYXgoZnJvbSwgbmV4dC5mcm9tICsgc3RhcnQpLCBNYXRoLm1pbih0bywgcG9zKSwgXCJcIiwgaW5uZXJIaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgcG9zKSwgY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ2hpbGQpXG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgIGlmIChtb3VudGVkKVxuICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzID0gXCJcIjtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvIDw9IGZyb20pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuTWF0Y2ggYSBzeW50YXggbm9kZSdzIFtoaWdobGlnaHQgcnVsZXNdKCNoaWdobGlnaHQuc3R5bGVUYWdzKS4gSWZcbnRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJuIGl0cyBzZXQgb2YgdGFncywgYW5kIHdoZXRoZXIgaXQgaXNcbm9wYXF1ZSAodXNlcyBhIGAhYCkgb3IgYXBwbGllcyB0byBhbGwgY2hpbGQgbm9kZXMgKGAvLi4uYCkuXG4qL1xuZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKG5vZGUpIHtcbiAgICBsZXQgcnVsZSA9IG5vZGUudHlwZS5wcm9wKHJ1bGVOb2RlUHJvcCk7XG4gICAgd2hpbGUgKHJ1bGUgJiYgcnVsZS5jb250ZXh0ICYmICFub2RlLm1hdGNoQ29udGV4dChydWxlLmNvbnRleHQpKVxuICAgICAgICBydWxlID0gcnVsZS5uZXh0O1xuICAgIHJldHVybiBydWxlIHx8IG51bGw7XG59XG5jb25zdCB0ID0gVGFnLmRlZmluZTtcbmNvbnN0IGNvbW1lbnQgPSB0KCksIG5hbWUgPSB0KCksIHR5cGVOYW1lID0gdChuYW1lKSwgcHJvcGVydHlOYW1lID0gdChuYW1lKSwgbGl0ZXJhbCA9IHQoKSwgc3RyaW5nID0gdChsaXRlcmFsKSwgbnVtYmVyID0gdChsaXRlcmFsKSwgY29udGVudCA9IHQoKSwgaGVhZGluZyA9IHQoY29udGVudCksIGtleXdvcmQgPSB0KCksIG9wZXJhdG9yID0gdCgpLCBwdW5jdHVhdGlvbiA9IHQoKSwgYnJhY2tldCA9IHQocHVuY3R1YXRpb24pLCBtZXRhID0gdCgpO1xuLyoqXG5UaGUgZGVmYXVsdCBzZXQgb2YgaGlnaGxpZ2h0aW5nIFt0YWdzXSgjaGlnaGxpZ2h0LlRhZykuXG5cblRoaXMgY29sbGVjdGlvbiBpcyBoZWF2aWx5IGJpYXNlZCB0b3dhcmRzIHByb2dyYW1taW5nIGxhbmd1YWdlcyxcbmFuZCBuZWNlc3NhcmlseSBpbmNvbXBsZXRlLiBBIGZ1bGwgb250b2xvZ3kgb2Ygc3ludGFjdGljXG5jb25zdHJ1Y3RzIHdvdWxkIGZpbGwgYSBzdGFjayBvZiBib29rcywgYW5kIGJlIGltcHJhY3RpY2FsIHRvXG53cml0ZSB0aGVtZXMgZm9yLiBTbyB0cnkgdG8gbWFrZSBkbyB3aXRoIHRoaXMgc2V0LiBJZiBhbGwgZWxzZVxuZmFpbHMsIFtvcGVuIGFuXG5pc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvY29kZW1pcnJvci5uZXh0KSB0byBwcm9wb3NlIGFcbm5ldyB0YWcsIG9yIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgYSBsb2NhbCBjdXN0b20gdGFnIGZvclxueW91ciB1c2UgY2FzZS5cblxuTm90ZSB0aGF0IGl0IGlzIG5vdCBvYmxpZ2F0b3J5IHRvIGFsd2F5cyBhdHRhY2ggdGhlIG1vc3Qgc3BlY2lmaWNcbnRhZyBwb3NzaWJsZSB0byBhbiBlbGVtZW50XHUyMDE0aWYgeW91ciBncmFtbWFyIGNhbid0IGVhc2lseVxuZGlzdGluZ3Vpc2ggYSBjZXJ0YWluIHR5cGUgb2YgZWxlbWVudCAoc3VjaCBhcyBhIGxvY2FsIHZhcmlhYmxlKSxcbml0IGlzIG9rYXkgdG8gc3R5bGUgaXQgYXMgaXRzIG1vcmUgZ2VuZXJhbCB2YXJpYW50IChhIHZhcmlhYmxlKS5cblxuRm9yIHRhZ3MgdGhhdCBleHRlbmQgc29tZSBwYXJlbnQgdGFnLCB0aGUgZG9jdW1lbnRhdGlvbiBsaW5rcyB0b1xudGhlIHBhcmVudC5cbiovXG5jb25zdCB0YWdzID0ge1xuICAgIC8qKlxuICAgIEEgY29tbWVudC5cbiAgICAqL1xuICAgIGNvbW1lbnQsXG4gICAgLyoqXG4gICAgQSBsaW5lIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBsaW5lQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGJsb2NrIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBibG9ja0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBkb2NDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEFueSBraW5kIG9mIGlkZW50aWZpZXIuXG4gICAgKi9cbiAgICBuYW1lLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgdmFyaWFibGUuXG4gICAgKi9cbiAgICB2YXJpYWJsZU5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSB0eXBlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgLyoqXG4gICAgQSB0YWcgbmFtZSAoc3VidGFnIG9mIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpKS5cbiAgICAqL1xuICAgIHRhZ05hbWU6IHQodHlwZU5hbWUpLFxuICAgIC8qKlxuICAgIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSBuYW1lIChzdWJ0YWcgb2YgW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSkuXG4gICAgKi9cbiAgICBhdHRyaWJ1dGVOYW1lOiB0KHByb3BlcnR5TmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBjbGFzcy5cbiAgICAqL1xuICAgIGNsYXNzTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxhYmVsIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBsYWJlbE5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBuYW1lc3BhY2UgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIG5hbWVzcGFjZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIG1hY3JvLlxuICAgICovXG4gICAgbWFjcm9OYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbGl0ZXJhbCB2YWx1ZS5cbiAgICAqL1xuICAgIGxpdGVyYWwsXG4gICAgLyoqXG4gICAgQSBzdHJpbmcgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHN0cmluZyxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykuXG4gICAgKi9cbiAgICBkb2NTdHJpbmc6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIGNoYXJhY3RlciBsaXRlcmFsIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgY2hhcmFjdGVyOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQW4gYXR0cmlidXRlIHZhbHVlIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgYXR0cmlidXRlVmFsdWU6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIG51bWJlciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgbnVtYmVyLFxuICAgIC8qKlxuICAgIEFuIGludGVnZXIgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICAqL1xuICAgIGludGVnZXI6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGZsb2F0aW5nLXBvaW50IFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBmbG9hdDogdChudW1iZXIpLFxuICAgIC8qKlxuICAgIEEgYm9vbGVhbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgYm9vbDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHJlZ2V4cDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBbiBlc2NhcGUgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKSwgZm9yIGV4YW1wbGUgYVxuICAgIGJhY2tzbGFzaCBlc2NhcGUgaW4gYSBzdHJpbmcuXG4gICAgKi9cbiAgICBlc2NhcGU6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBjb2xvciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgY29sb3I6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBVUkwgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHVybDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAgKi9cbiAgICBrZXl3b3JkLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciB0aGUgc2VsZiBvciB0aGlzXG4gICAgb2JqZWN0LlxuICAgICovXG4gICAgc2VsZjogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgbnVsbC5cbiAgICAqL1xuICAgIG51bGw6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGRlbm90aW5nIHNvbWUgYXRvbWljIHZhbHVlLlxuICAgICovXG4gICAgYXRvbTogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCByZXByZXNlbnRzIGEgdW5pdC5cbiAgICAqL1xuICAgIHVuaXQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBtb2RpZmllciBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgbW9kaWZpZXI6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgYWN0cyBhcyBhbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgKi9cbiAgICBjb250cm9sS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25LZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSByZWxhdGVkIHRvIGRlZmluaW5nIG9yXG4gICAgaW50ZXJmYWNpbmcgd2l0aCBtb2R1bGVzLlxuICAgICovXG4gICAgbW9kdWxlS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yLFxuICAgIC8qKlxuICAgIEFuIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlcmVmZXJlbmNlcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZXJlZk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBBcml0aG1ldGljLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYXJpdGhtZXRpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBMb2dpY2FsIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGxvZ2ljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIEJpdCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBiaXR3aXNlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbXBhcmlzb24gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29tcGFyZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCB1cGRhdGVzIGl0cyBvcGVyYW5kLlxuICAgICovXG4gICAgdXBkYXRlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVmaW5pdGlvbk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBUeXBlLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgdHlwZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb250cm9sLWZsb3cgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29udHJvbE9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBQcm9ncmFtIG9yIG1hcmt1cCBwdW5jdHVhdGlvbi5cbiAgICAqL1xuICAgIHB1bmN0dWF0aW9uLFxuICAgIC8qKlxuICAgIFtQdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKSB0aGF0IHNlcGFyYXRlc1xuICAgIHRoaW5ncy5cbiAgICAqL1xuICAgIHNlcGFyYXRvcjogdChwdW5jdHVhdGlvbiksXG4gICAgLyoqXG4gICAgQnJhY2tldC1zdHlsZSBbcHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikuXG4gICAgKi9cbiAgICBicmFja2V0LFxuICAgIC8qKlxuICAgIEFuZ2xlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGA8YCBhbmQgYD5gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIGFuZ2xlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBTcXVhcmUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYFtgIGFuZCBgXWBcbiAgICB0b2tlbnMpLlxuICAgICovXG4gICAgc3F1YXJlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBQYXJlbnRoZXNlcyAodXN1YWxseSBgKGAgYW5kIGApYCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgcGFyZW46IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQnJhY2VzICh1c3VhbGx5IGB7YCBhbmQgYH1gIHRva2VucykuIFN1YnRhZyBvZlxuICAgIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgKi9cbiAgICBicmFjZTogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBDb250ZW50LCBmb3IgZXhhbXBsZSBwbGFpbiB0ZXh0IGluIFhNTCBvciBtYXJrdXAgZG9jdW1lbnRzLlxuICAgICovXG4gICAgY29udGVudCxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGhlYWRpbmcuXG4gICAgKi9cbiAgICBoZWFkaW5nLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzE6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAyIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDMgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmczOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNCBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzQ6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA1IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNTogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDYgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc2OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgcHJvc2UgW2NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSBzZXBhcmF0b3IgKHN1Y2ggYXMgYSBob3Jpem9udGFsIHJ1bGUpLlxuICAgICovXG4gICAgY29udGVudFNlcGFyYXRvcjogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGxpc3QuXG4gICAgKi9cbiAgICBsaXN0OiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgcXVvdGUuXG4gICAgKi9cbiAgICBxdW90ZTogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgZW1waGFzaXplZC5cbiAgICAqL1xuICAgIGVtcGhhc2lzOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgc3Ryb25nLlxuICAgICovXG4gICAgc3Ryb25nOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBwYXJ0IG9mIGEgbGluay5cbiAgICAqL1xuICAgIGxpbms6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBhcyBjb2RlIG9yXG4gICAgbW9ub3NwYWNlLlxuICAgICovXG4gICAgbW9ub3NwYWNlOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBoYXMgYSBzdHJpa2UtdGhyb3VnaFxuICAgIHN0eWxlLlxuICAgICovXG4gICAgc3RyaWtldGhyb3VnaDogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBJbnNlcnRlZCB0ZXh0IGluIGEgY2hhbmdlLXRyYWNraW5nIGZvcm1hdC5cbiAgICAqL1xuICAgIGluc2VydGVkOiB0KCksXG4gICAgLyoqXG4gICAgRGVsZXRlZCB0ZXh0LlxuICAgICovXG4gICAgZGVsZXRlZDogdCgpLFxuICAgIC8qKlxuICAgIENoYW5nZWQgdGV4dC5cbiAgICAqL1xuICAgIGNoYW5nZWQ6IHQoKSxcbiAgICAvKipcbiAgICBBbiBpbnZhbGlkIG9yIHVuc3ludGFjdGljIGVsZW1lbnQuXG4gICAgKi9cbiAgICBpbnZhbGlkOiB0KCksXG4gICAgLyoqXG4gICAgTWV0YWRhdGEgb3IgbWV0YS1pbnN0cnVjdGlvbi5cbiAgICAqL1xuICAgIG1ldGEsXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhcHBsaWVzIHRvIHRoZSBlbnRpcmVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIGRvY3VtZW50TWV0YTogdChtZXRhKSxcbiAgICAvKipcbiAgICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFubm90YXRlcyBvciBhZGRzXG4gICAgYXR0cmlidXRlcyB0byBhIGdpdmVuIHN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgYW5ub3RhdGlvbjogdChtZXRhKSxcbiAgICAvKipcbiAgICBQcm9jZXNzaW5nIGluc3RydWN0aW9uIG9yIHByZXByb2Nlc3NvciBkaXJlY3RpdmUuIFN1YnRhZyBvZlxuICAgIFttZXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkuXG4gICAgKi9cbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHQobWV0YSksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhXG4gICAgZ2l2ZW4gZWxlbWVudCBpcyBiZWluZyBkZWZpbmVkLiBFeHBlY3RlZCB0byBiZSB1c2VkIHdpdGggdGhlXG4gICAgdmFyaW91cyBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRhZ3MuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJkZWZpbml0aW9uXCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXRcbiAgICBzb21ldGhpbmcgaXMgY29uc3RhbnQuIE1vc3RseSBleHBlY3RlZCB0byBiZSB1c2VkIHdpdGhcbiAgICBbdmFyaWFibGUgbmFtZXNdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpLlxuICAgICovXG4gICAgY29uc3RhbnQ6IFRhZy5kZWZpbmVNb2RpZmllcihcImNvbnN0YW50XCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHVzZWQgdG8gaW5kaWNhdGUgdGhhdFxuICAgIGEgW3ZhcmlhYmxlXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSBvciBbcHJvcGVydHlcbiAgICBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSBpcyBiZWluZyBjYWxsZWQgb3IgZGVmaW5lZFxuICAgIGFzIGEgZnVuY3Rpb24uXG4gICAgKi9cbiAgICBmdW5jdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKFwiZnVuY3Rpb25cIiksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICAgIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRvIGluZGljYXRlIHRoYXQgdGhleSBiZWxvbmcgdG9cbiAgICB0aGUgbGFuZ3VhZ2UncyBzdGFuZGFyZCBlbnZpcm9ubWVudC5cbiAgICAqL1xuICAgIHN0YW5kYXJkOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJzdGFuZGFyZFwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgaXMgbG9jYWwgdG8gc29tZSBzY29wZS5cbiAgICAqL1xuICAgIGxvY2FsOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJsb2NhbFwiKSxcbiAgICAvKipcbiAgICBBIGdlbmVyaWMgdmFyaWFudCBbbW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0XG4gICAgY2FuIGJlIHVzZWQgdG8gdGFnIGxhbmd1YWdlLXNwZWNpZmljIGFsdGVybmF0aXZlIHZhcmlhbnRzIG9mXG4gICAgc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gICAgZm9ybXMgb2YgYXQgbGVhc3QgdGhlIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpIGFuZFxuICAgIFt2YXJpYWJsZSBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSB0YWdzLCBzaW5jZSB0aG9zZVxuICAgIGNvbWUgdXAgYSBsb3QuXG4gICAgKi9cbiAgICBzcGVjaWFsOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJzcGVjaWFsXCIpXG59O1xuZm9yIChsZXQgbmFtZSBpbiB0YWdzKSB7XG4gICAgbGV0IHZhbCA9IHRhZ3NbbmFtZV07XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFRhZylcbiAgICAgICAgdmFsLm5hbWUgPSBuYW1lO1xufVxuLyoqXG5UaGlzIGlzIGEgaGlnaGxpZ2h0ZXIgdGhhdCBhZGRzIHN0YWJsZSwgcHJlZGljdGFibGUgY2xhc3NlcyB0b1xudG9rZW5zLCBmb3Igc3R5bGluZyB3aXRoIGV4dGVybmFsIENTUy5cblxuVGhlIGZvbGxvd2luZyB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcInRvay1cImBcbihmb3IgZXhhbXBsZSBgXCJ0b2stY29tbWVudFwiYCk6XG5cbiogW2BsaW5rYF0oI2hpZ2hsaWdodC50YWdzLmxpbmspXG4qIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxuKiBbYGVtcGhhc2lzYF0oI2hpZ2hsaWdodC50YWdzLmVtcGhhc2lzKVxuKiBbYHN0cm9uZ2BdKCNoaWdobGlnaHQudGFncy5zdHJvbmcpXG4qIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxuKiBbYGF0b21gXSgjaGlnaGxpZ2h0LnRhZ3MuYXRvbSlcbiogW2Bib29sYF0oI2hpZ2hsaWdodC50YWdzLmJvb2wpXG4qIFtgdXJsYF0oI2hpZ2hsaWdodC50YWdzLnVybClcbiogW2BsYWJlbE5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lKVxuKiBbYGluc2VydGVkYF0oI2hpZ2hsaWdodC50YWdzLmluc2VydGVkKVxuKiBbYGRlbGV0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZClcbiogW2BsaXRlcmFsYF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpXG4qIFtgc3RyaW5nYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbiogW2BudW1iZXJgXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKVxuKiBbYHZhcmlhYmxlTmFtZWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4qIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpXG4qIFtgbmFtZXNwYWNlYF0oI2hpZ2hsaWdodC50YWdzLm5hbWVzcGFjZSlcbiogW2BjbGFzc05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MuY2xhc3NOYW1lKVxuKiBbYG1hY3JvTmFtZWBdKCNoaWdobGlnaHQudGFncy5tYWNyb05hbWUpXG4qIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiogW2BvcGVyYXRvcmBdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcilcbiogW2Bjb21tZW50YF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpXG4qIFtgbWV0YWBdKCNoaWdobGlnaHQudGFncy5tZXRhKVxuKiBbYHB1bmN0dWF0aW9uYF0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKVxuKiBbYGludmFsaWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW52YWxpZClcblxuSW4gYWRkaXRpb24sIHRoZXNlIG1hcHBpbmdzIGFyZSBwcm92aWRlZDpcblxuKiBbYHJlZ2V4cGBdKCNoaWdobGlnaHQudGFncy5yZWdleHApLFxuICBbYGVzY2FwZWBdKCNoaWdobGlnaHQudGFncy5lc2NhcGUpLCBhbmRcbiAgW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2Aoc3RyaW5nKWBdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4gIGFyZSBtYXBwZWQgdG8gYFwidG9rLXN0cmluZzJcImBcbiogW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUyXCJgXG4qIFtgbG9jYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubG9jYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHByb3BlcnR5TmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuICB0byBgXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qL1xuY29uc3QgY2xhc3NIaWdobGlnaHRlciA9IHRhZ0hpZ2hsaWdodGVyKFtcbiAgICB7IHRhZzogdGFncy5saW5rLCBjbGFzczogXCJ0b2stbGlua1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZywgY2xhc3M6IFwidG9rLWhlYWRpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLCBjbGFzczogXCJ0b2stZW1waGFzaXNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZywgY2xhc3M6IFwidG9rLXN0cm9uZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCwgY2xhc3M6IFwidG9rLWtleXdvcmRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmF0b20sIGNsYXNzOiBcInRvay1hdG9tXCIgfSxcbiAgICB7IHRhZzogdGFncy5ib29sLCBjbGFzczogXCJ0b2stYm9vbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudXJsLCBjbGFzczogXCJ0b2stdXJsXCIgfSxcbiAgICB7IHRhZzogdGFncy5sYWJlbE5hbWUsIGNsYXNzOiBcInRvay1sYWJlbE5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmluc2VydGVkLCBjbGFzczogXCJ0b2staW5zZXJ0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlbGV0ZWQsIGNsYXNzOiBcInRvay1kZWxldGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5saXRlcmFsLCBjbGFzczogXCJ0b2stbGl0ZXJhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaW5nLCBjbGFzczogXCJ0b2stc3RyaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5udW1iZXIsIGNsYXNzOiBcInRvay1udW1iZXJcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSwgY2xhc3M6IFwidG9rLXN0cmluZzJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnZhcmlhYmxlTmFtZSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnR5cGVOYW1lLCBjbGFzczogXCJ0b2stdHlwZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm5hbWVzcGFjZSwgY2xhc3M6IFwidG9rLW5hbWVzcGFjZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLCBjbGFzczogXCJ0b2stY2xhc3NOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5tYWNyb05hbWUsIGNsYXNzOiBcInRvay1tYWNyb05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnByb3BlcnR5TmFtZSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mub3BlcmF0b3IsIGNsYXNzOiBcInRvay1vcGVyYXRvclwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCwgY2xhc3M6IFwidG9rLWNvbW1lbnRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1ldGEsIGNsYXNzOiBcInRvay1tZXRhXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLCBjbGFzczogXCJ0b2staW52YWxpZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHVuY3R1YXRpb24sIGNsYXNzOiBcInRvay1wdW5jdHVhdGlvblwiIH1cbl0pO1xuXG5leHBvcnQgeyBUYWcsIGNsYXNzSGlnaGxpZ2h0ZXIsIGdldFN0eWxlVGFncywgaGlnaGxpZ2h0Q29kZSwgaGlnaGxpZ2h0VHJlZSwgc3R5bGVUYWdzLCB0YWdIaWdobGlnaHRlciwgdGFncyB9O1xuIiwgImltcG9ydCB7IE5vZGVQcm9wLCBJdGVyTW9kZSwgVHJlZSwgVHJlZUZyYWdtZW50LCBQYXJzZXIsIE5vZGVUeXBlLCBOb2RlU2V0IH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgRmFjZXQsIEVkaXRvclN0YXRlLCBjb3VudENvbHVtbiwgY29tYmluZUNvbmZpZywgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUHJlYyB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IFZpZXdQbHVnaW4sIGxvZ0V4Y2VwdGlvbiwgRWRpdG9yVmlldywgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwgZ3V0dGVyLCBHdXR0ZXJNYXJrZXIsIERpcmVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgdGFncywgdGFnSGlnaGxpZ2h0ZXIsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuXG52YXIgX2E7XG4vKipcbk5vZGUgcHJvcCBzdG9yZWQgaW4gYSBwYXJzZXIncyB0b3Agc3ludGF4IG5vZGUgdG8gcHJvdmlkZSB0aGVcbmZhY2V0IHRoYXQgc3RvcmVzIGxhbmd1YWdlLXNwZWNpZmljIGRhdGEgZm9yIHRoYXQgbGFuZ3VhZ2UuXG4qL1xuY29uc3QgbGFuZ3VhZ2VEYXRhUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRvIGRlZmluZSBhIGZhY2V0ICh0byBiZSBhZGRlZCB0byB0aGUgdG9wIHN5bnRheFxubm9kZShzKSBmb3IgYSBsYW5ndWFnZSB2aWFcbltgbGFuZ3VhZ2VEYXRhUHJvcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkpLCB0aGF0IHdpbGwgYmVcbnVzZWQgdG8gYXNzb2NpYXRlIGxhbmd1YWdlIGRhdGEgd2l0aCB0aGUgbGFuZ3VhZ2UuIFlvdVxucHJvYmFibHkgb25seSBuZWVkIHRoaXMgd2hlbiBzdWJjbGFzc2luZ1xuW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLlxuKi9cbmZ1bmN0aW9uIGRlZmluZUxhbmd1YWdlRmFjZXQoYmFzZURhdGEpIHtcbiAgICByZXR1cm4gRmFjZXQuZGVmaW5lKHtcbiAgICAgICAgY29tYmluZTogYmFzZURhdGEgPyB2YWx1ZXMgPT4gdmFsdWVzLmNvbmNhdChiYXNlRGF0YSkgOiB1bmRlZmluZWRcbiAgICB9KTtcbn1cbi8qKlxuU3ludGF4IG5vZGUgcHJvcCB1c2VkIHRvIHJlZ2lzdGVyIHN1Ymxhbmd1YWdlcy4gU2hvdWxkIGJlIGFkZGVkIHRvXG50aGUgdG9wIGxldmVsIG5vZGUgdHlwZSBmb3IgdGhlIGxhbmd1YWdlLlxuKi9cbmNvbnN0IHN1Ymxhbmd1YWdlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuQSBsYW5ndWFnZSBvYmplY3QgbWFuYWdlcyBwYXJzaW5nIGFuZCBwZXItbGFuZ3VhZ2VcblttZXRhZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuIFBhcnNlIGRhdGEgaXNcbm1hbmFnZWQgYXMgYSBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQpIHRyZWUuIFRoZSBjbGFzc1xuY2FuIGJlIHVzZWQgZGlyZWN0bHksIHZpYSB0aGUgW2BMUkxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MUkxhbmd1YWdlKVxuc3ViY2xhc3MgZm9yIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC8pIExSIHBhcnNlcnMsIG9yXG52aWEgdGhlIFtgU3RyZWFtTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbUxhbmd1YWdlKSBzdWJjbGFzc1xuZm9yIHN0cmVhbSBwYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBsYW5ndWFnZSBvYmplY3QuIElmIHlvdSBuZWVkIHRvIGludm9rZSB0aGlzXG4gICAgZGlyZWN0bHksIGZpcnN0IGRlZmluZSBhIGRhdGEgZmFjZXQgd2l0aFxuICAgIFtgZGVmaW5lTGFuZ3VhZ2VGYWNldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmaW5lTGFuZ3VhZ2VGYWNldCksIGFuZCB0aGVuXG4gICAgY29uZmlndXJlIHlvdXIgcGFyc2VyIHRvIFthdHRhY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkgaXRcbiAgICB0byB0aGUgbGFuZ3VhZ2UncyBvdXRlciBzeW50YXggbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBbbGFuZ3VhZ2UgZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgZmFjZXRcbiAgICB1c2VkIGZvciB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZGF0YSwgcGFyc2VyLCBleHRyYUV4dGVuc2lvbnMgPSBbXSwgXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBuYW1lLlxuICAgICovXG4gICAgbmFtZSA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIGRlZmluZSBFZGl0b3JTdGF0ZS50cmVlIGFzIGEgZGVidWdnaW5nIGhlbHBlcixcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgRWRpdG9yU3RhdGUgcGFja2FnZSBhY3R1YWxseSBrbm93aW5nIGFib3V0XG4gICAgICAgIC8vIGxhbmd1YWdlcyBhbmQgbGV6ZXIgdHJlZXMuXG4gICAgICAgIGlmICghRWRpdG9yU3RhdGUucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwidHJlZVwiKSlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZGl0b3JTdGF0ZS5wcm90b3R5cGUsIFwidHJlZVwiLCB7IGdldCgpIHsgcmV0dXJuIHN5bnRheFRyZWUodGhpcyk7IH0gfSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtcbiAgICAgICAgICAgIGxhbmd1YWdlLm9mKHRoaXMpLFxuICAgICAgICAgICAgRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhLm9mKChzdGF0ZSwgcG9zLCBzaWRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKSwgZGF0YSA9IHRvcC50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBzdGF0ZS5mYWNldChkYXRhKSwgc3ViID0gdG9wLnR5cGUucHJvcChzdWJsYW5ndWFnZVByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyTm9kZSA9IHRvcC5yZXNvbHZlKHBvcyAtIHRvcC5mcm9tLCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3VibGFuZyBvZiBzdWIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VibGFuZy50ZXN0KGlubmVyTm9kZSwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBzdGF0ZS5mYWNldChzdWJsYW5nLmZhY2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VibGFuZy50eXBlID09IFwicmVwbGFjZVwiID8gZGF0YSA6IGRhdGEuY29uY2F0KGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0uY29uY2F0KGV4dHJhRXh0ZW5zaW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBpcyBhY3RpdmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaXNBY3RpdmVBdChzdGF0ZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKS50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCByZWdpb25zIHRoYXQgd2VyZSBwYXJzZWQgdXNpbmcgdGhpcyBsYW5ndWFnZS5cbiAgICBUaGUgcmV0dXJuZWQgcmVnaW9ucyB3aWxsIF9pbmNsdWRlXyBhbnkgbmVzdGVkIGxhbmd1YWdlcyByb290ZWRcbiAgICBpbiB0aGlzIGxhbmd1YWdlLCB3aGVuIHRob3NlIGV4aXN0LlxuICAgICovXG4gICAgZmluZFJlZ2lvbnMoc3RhdGUpIHtcbiAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgIGlmICgobGFuZyA9PT0gbnVsbCB8fCBsYW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYW5nLmRhdGEpID09IHRoaXMuZGF0YSlcbiAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiAwLCB0bzogc3RhdGUuZG9jLmxlbmd0aCB9XTtcbiAgICAgICAgaWYgKCFsYW5nIHx8ICFsYW5nLmFsbG93c05lc3RpbmcpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAodHJlZSwgZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vdW50ID0gdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgaWYgKG1vdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50LnRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tOiByLmZyb20gKyBmcm9tLCB0bzogci50byArIGZyb20gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogZnJvbSwgdG86IGZyb20gKyB0cmVlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiBzaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShjaCwgdHJlZS5wb3NpdGlvbnNbaV0gKyBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXhwbG9yZShzeW50YXhUcmVlKHN0YXRlKSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgYWxsb3dzIG5lc3RlZCBsYW5ndWFnZXMuIFRoZVxuICAgIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0cnVlLlxuICAgICovXG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0cnVlOyB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkxhbmd1YWdlLnNldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuZnVuY3Rpb24gdG9wTm9kZUF0KHN0YXRlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgdG9wTGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKSwgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnRvcE5vZGU7XG4gICAgaWYgKCF0b3BMYW5nIHx8IHRvcExhbmcuYWxsb3dzTmVzdGluZykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdHJlZTsgbm9kZTsgbm9kZSA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycyB8IEl0ZXJNb2RlLkVudGVyQnJhY2tldGVkKSlcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuaXNUb3ApXG4gICAgICAgICAgICAgICAgdHJlZSA9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0cmVlO1xufVxuLyoqXG5BIHN1YmNsYXNzIG9mIFtgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBmb3IgdXNlIHdpdGggTGV6ZXJcbltMUiBwYXJzZXJzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2xyLkxSUGFyc2VyKVxucGFyc2Vycy5cbiovXG5jbGFzcyBMUkxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHBhcnNlciwgbmFtZSkge1xuICAgICAgICBzdXBlcihkYXRhLCBwYXJzZXIsIFtdLCBuYW1lKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIGxhbmd1YWdlIGZyb20gYSBwYXJzZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBkZWZpbmVMYW5ndWFnZUZhY2V0KHNwZWMubGFuZ3VhZ2VEYXRhKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKGRhdGEsIHNwZWMucGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBwcm9wczogW2xhbmd1YWdlRGF0YVByb3AuYWRkKHR5cGUgPT4gdHlwZS5pc1RvcCA/IGRhdGEgOiB1bmRlZmluZWQpXVxuICAgICAgICB9KSwgc3BlYy5uYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgbGFuZ3VhZ2Ugd2l0aCBhIHJlY29uZmlndXJlZFxuICAgIHZlcnNpb24gb2YgaXRzIHBhcnNlciBhbmQgb3B0aW9uYWxseSBhIG5ldyBuYW1lLlxuICAgICovXG4gICAgY29uZmlndXJlKG9wdGlvbnMsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKHRoaXMuZGF0YSwgdGhpcy5wYXJzZXIuY29uZmlndXJlKG9wdGlvbnMpLCBuYW1lIHx8IHRoaXMubmFtZSk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdGhpcy5wYXJzZXIuaGFzV3JhcHBlcnMoKTsgfVxufVxuLyoqXG5HZXQgdGhlIHN5bnRheCB0cmVlIGZvciBhIHN0YXRlLCB3aGljaCBpcyB0aGUgY3VycmVudCAocG9zc2libHlcbmluY29tcGxldGUpIHBhcnNlIHRyZWUgb2YgdGhlIGFjdGl2ZVxuW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSwgb3IgdGhlIGVtcHR5IHRyZWUgaWYgdGhlcmUgaXMgbm9cbmxhbmd1YWdlIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlKHN0YXRlKSB7XG4gICAgbGV0IGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmllbGQgPyBmaWVsZC50cmVlIDogVHJlZS5lbXB0eTtcbn1cbi8qKlxuVHJ5IHRvIGdldCBhIHBhcnNlIHRyZWUgdGhhdCBzcGFucyBhdCBsZWFzdCB1cCB0byBgdXB0b2AuIFRoZVxubWV0aG9kIHdpbGwgZG8gYXQgbW9zdCBgdGltZW91dGAgbWlsbGlzZWNvbmRzIG9mIHdvcmsgdG8gcGFyc2VcbnVwIHRvIHRoYXQgcG9pbnQgaWYgdGhlIHRyZWUgaXNuJ3QgYWxyZWFkeSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZW5zdXJlU3ludGF4VHJlZShzdGF0ZSwgdXB0bywgdGltZW91dCA9IDUwKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBwYXJzZSA9IChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0O1xuICAgIGlmICghcGFyc2UpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvbGRWaWVwb3J0ID0gcGFyc2Uudmlld3BvcnQ7XG4gICAgcGFyc2UudXBkYXRlVmlld3BvcnQoeyBmcm9tOiAwLCB0bzogdXB0byB9KTtcbiAgICBsZXQgcmVzdWx0ID0gcGFyc2UuaXNEb25lKHVwdG8pIHx8IHBhcnNlLndvcmsodGltZW91dCwgdXB0bykgPyBwYXJzZS50cmVlIDogbnVsbDtcbiAgICBwYXJzZS51cGRhdGVWaWV3cG9ydChvbGRWaWVwb3J0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5RdWVyaWVzIHdoZXRoZXIgdGhlcmUgaXMgYSBmdWxsIHN5bnRheCB0cmVlIGF2YWlsYWJsZSB1cCB0byB0aGVcbmdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLiBJZiB0aGVyZSBpc24ndCwgdGhlIGJhY2tncm91bmQgcGFyc2VcbnByb2Nlc3MgX21pZ2h0XyBzdGlsbCBiZSB3b3JraW5nIGFuZCB1cGRhdGUgdGhlIHRyZWUgZnVydGhlciwgYnV0XG50aGVyZSBpcyBubyBndWFyYW50ZWUgb2YgdGhhdFx1MjAxNHRoZSBwYXJzZXIgd2lsbCBbc3RvcFxud29ya2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhQYXJzZXJSdW5uaW5nKSB3aGVuIGl0IGhhcyBzcGVudCBhXG5jZXJ0YWluIGFtb3VudCBvZiB0aW1lIG9yIGhhcyBtb3ZlZCBiZXlvbmQgdGhlIHZpc2libGUgdmlld3BvcnQuXG5BbHdheXMgcmV0dXJucyBmYWxzZSBpZiBubyBsYW5ndWFnZSBoYXMgYmVlbiBlbmFibGVkLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFRyZWVBdmFpbGFibGUoc3RhdGUsIHVwdG8gPSBzdGF0ZS5kb2MubGVuZ3RoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRleHQuaXNEb25lKHVwdG8pKSB8fCBmYWxzZTtcbn1cbi8qKlxuTW92ZSBwYXJzaW5nIGZvcndhcmQsIGFuZCB1cGRhdGUgdGhlIGVkaXRvciBzdGF0ZSBhZnRlcndhcmRzIHRvXG5yZWZsZWN0IHRoZSBuZXcgdHJlZS4gV2lsbCB3b3JrIGZvciBhdCBtb3N0IGB0aW1lb3V0YFxubWlsbGlzZWNvbmRzLiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcnNlciBtYW5hZ2VkIGdldCB0byB0aGUgZ2l2ZW5cbnBvc2l0aW9uIGluIHRoYXQgdGltZS5cbiovXG5mdW5jdGlvbiBmb3JjZVBhcnNpbmcodmlldywgdXB0byA9IHZpZXcudmlld3BvcnQudG8sIHRpbWVvdXQgPSAxMDApIHtcbiAgICBsZXQgc3VjY2VzcyA9IGVuc3VyZVN5bnRheFRyZWUodmlldy5zdGF0ZSwgdXB0bywgdGltZW91dCk7XG4gICAgaWYgKHN1Y2Nlc3MgIT0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7fSk7XG4gICAgcmV0dXJuICEhc3VjY2Vzcztcbn1cbi8qKlxuVGVsbHMgeW91IHdoZXRoZXIgdGhlIGxhbmd1YWdlIHBhcnNlciBpcyBwbGFubmluZyB0byBkbyBtb3JlXG5wYXJzaW5nIHdvcmsgKGluIGEgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgIHBzZXVkby10aHJlYWQpIG9yIGhhc1xuc3RvcHBlZCBydW5uaW5nLCBlaXRoZXIgYmVjYXVzZSBpdCBwYXJzZWQgdGhlIGVudGlyZSBkb2N1bWVudCxcbmJlY2F1c2UgaXQgc3BlbnQgdG9vIG11Y2ggdGltZSBhbmQgd2FzIGN1dCBvZmYsIG9yIGJlY2F1c2UgdGhlcmVcbmlzIG5vIGxhbmd1YWdlIHBhcnNlciBlbmFibGVkLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFBhcnNlclJ1bm5pbmcodmlldykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBhcnNlV29ya2VyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzV29ya2luZygpKSB8fCBmYWxzZTtcbn1cbi8qKlxuTGV6ZXItc3R5bGVcbltgSW5wdXRgXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2NvbW1vbi5JbnB1dClcbm9iamVjdCBmb3IgYSBbYFRleHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQpIG9iamVjdC5cbiovXG5jbGFzcyBEb2NJbnB1dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGlucHV0IG9iamVjdCBmb3IgdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5kb2MubGVuZ3RoOyB9XG4gICAgc3luY1RvKHBvcykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHRoaXMuY3Vyc29yLm5leHQocG9zIC0gdGhpcy5jdXJzb3JQb3MpLnZhbHVlO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHBvcyArIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBjaHVuayhwb3MpIHtcbiAgICAgICAgdGhpcy5zeW5jVG8ocG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICAgIH1cbiAgICBnZXQgbGluZUNodW5rcygpIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZWFkKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzdHJpbmdTdGFydCA9IHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAoZnJvbSA8IHN0cmluZ1N0YXJ0IHx8IHRvID49IHRoaXMuY3Vyc29yUG9zKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20gLSBzdHJpbmdTdGFydCwgdG8gLSBzdHJpbmdTdGFydCk7XG4gICAgfVxufVxubGV0IGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcbi8qKlxuQSBwYXJzZSBjb250ZXh0IHByb3ZpZGVkIHRvIHBhcnNlcnMgd29ya2luZyBvbiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4qL1xuY2xhc3MgUGFyc2VDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUcmVlIGZyYWdtZW50cyB0aGF0IGNhbiBiZSByZXVzZWQgYnkgaW5jcmVtZW50YWwgcmUtcGFyc2VzLlxuICAgICovXG4gICAgZnJhZ21lbnRzID0gW10sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlTGVuLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igdmlld3BvcnQgKG9yIHNvbWUgb3ZlcmFwcHJveGltYXRpb25cbiAgICB0aGVyZW9mKS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBmb3Igb3Bwb3J0dW5pc3RpY2FsbHkgYXZvaWRpbmdcbiAgICB3b3JrIChpbiB3aGljaCBjYXNlXG4gICAgW2Bza2lwVW50aWxJblZpZXdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlBhcnNlQ29udGV4dC5za2lwVW50aWxJblZpZXcpXG4gICAgc2hvdWxkIGJlIGNhbGxlZCB0byBtYWtlIHN1cmUgdGhlIHBhcnNlciBpcyByZXN0YXJ0ZWQgd2hlbiB0aGVcbiAgICBza2lwcGVkIHJlZ2lvbiBiZWNvbWVzIHZpc2libGUpLlxuICAgICovXG4gICAgdmlld3BvcnQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2tpcHBlZCwgXG4gICAgLyoqXG4gICAgVGhpcyBpcyB3aGVyZSBza2lwcGluZyBwYXJzZXJzIGNhbiByZWdpc3RlciBhIHByb21pc2UgdGhhdCxcbiAgICB3aGVuIHJlc29sdmVkLCB3aWxsIHNjaGVkdWxlIGEgbmV3IHBhcnNlLiBJdCBpcyBjbGVhcmVkIHdoZW5cbiAgICB0aGUgcGFyc2Ugd29ya2VyIHBpY2tzIHVwIHRoZSBwcm9taXNlLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjaGVkdWxlT24pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMudHJlZUxlbiA9IHRyZWVMZW47XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdGhpcy5za2lwcGVkID0gc2tpcHBlZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU9uID0gc2NoZWR1bGVPbjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZW1wU2tpcHBlZCA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyc2VyLCBzdGF0ZSwgdmlld3BvcnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHQocGFyc2VyLCBzdGF0ZSwgW10sIFRyZWUuZW1wdHksIDAsIHZpZXdwb3J0LCBbXSwgbnVsbCk7XG4gICAgfVxuICAgIHN0YXJ0UGFyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5zdGFydFBhcnNlKG5ldyBEb2NJbnB1dCh0aGlzLnN0YXRlLmRvYyksIHRoaXMuZnJhZ21lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB3b3JrKHVudGlsLCB1cHRvKSB7XG4gICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgdXB0byA+PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICB1cHRvID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy50cmVlICE9IFRyZWUuZW1wdHkgJiYgdGhpcy5pc0RvbmUodXB0byAhPT0gbnVsbCAmJiB1cHRvICE9PSB2b2lkIDAgPyB1cHRvIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aENvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1bnRpbCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgdW50aWw7XG4gICAgICAgICAgICAgICAgdW50aWwgPSAoKSA9PiBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICBpZiAodXB0byAhPSBudWxsICYmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gdXB0bykgJiZcbiAgICAgICAgICAgICAgICB1cHRvIDwgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHVwdG8pO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSB0aGlzLndpdGhvdXRUZW1wU2tpcHBlZChUcmVlRnJhZ21lbnQuYWRkVHJlZShkb25lLCB0aGlzLmZyYWdtZW50cywgdGhpcy5wYXJzZS5zdG9wcGVkQXQgIT0gbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVMZW4gPSAoX2EgPSB0aGlzLnBhcnNlLnN0b3BwZWRBdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWUgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJlZUxlbiA8ICh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMuc3RhcnRQYXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVudGlsKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdGFrZVRyZWUoKSB7XG4gICAgICAgIGxldCBwb3MsIHRyZWU7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlICYmIChwb3MgPSB0aGlzLnBhcnNlLnBhcnNlZFBvcykgPj0gdGhpcy50cmVlTGVuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHBvcylcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICAgICAgdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7IHdoaWxlICghKHRyZWUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKSkpIHsgfSB9KTtcbiAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IHBvcztcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKHRoaXMudHJlZSwgdGhpcy5mcmFnbWVudHMsIHRydWUpKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhDb250ZXh0KGYpIHtcbiAgICAgICAgbGV0IHByZXYgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgY3VycmVudENvbnRleHQgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gcHJldjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aXRob3V0VGVtcFNraXBwZWQoZnJhZ21lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHI7IHIgPSB0aGlzLnRlbXBTa2lwcGVkLnBvcCgpOylcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIHIuZnJvbSwgci50byk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hhbmdlcyhjaGFuZ2VzLCBuZXdTdGF0ZSkge1xuICAgICAgICBsZXQgeyBmcmFnbWVudHMsIHRyZWUsIHRyZWVMZW4sIHZpZXdwb3J0LCBza2lwcGVkIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgIGlmICghY2hhbmdlcy5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gcmFuZ2VzLnB1c2goeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0pKTtcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IFRyZWVGcmFnbWVudC5hcHBseUNoYW5nZXMoZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICAgICAgdHJlZSA9IFRyZWUuZW1wdHk7XG4gICAgICAgICAgICB0cmVlTGVuID0gMDtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0geyBmcm9tOiBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvOiBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC50bywgMSkgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5za2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Moci5mcm9tLCAxKSwgdG8gPSBjaGFuZ2VzLm1hcFBvcyhyLnRvLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHQodGhpcy5wYXJzZXIsIG5ld1N0YXRlLCBmcmFnbWVudHMsIHRyZWUsIHRyZWVMZW4sIHZpZXdwb3J0LCBza2lwcGVkLCB0aGlzLnNjaGVkdWxlT24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVwZGF0ZVZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0LmZyb20gPT0gdmlld3BvcnQuZnJvbSAmJiB0aGlzLnZpZXdwb3J0LnRvID09IHZpZXdwb3J0LnRvKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIGxldCBzdGFydExlbiA9IHRoaXMuc2tpcHBlZC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5za2lwcGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5za2lwcGVkW2ldO1xuICAgICAgICAgICAgaWYgKGZyb20gPCB2aWV3cG9ydC50byAmJiB0byA+IHZpZXdwb3J0LmZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyh0aGlzLmZyYWdtZW50cywgZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcHBlZC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5za2lwcGVkLmxlbmd0aCA+PSBzdGFydExlbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE5vdGlmeSB0aGUgcGFyc2Ugc2NoZWR1bGVyIHRoYXQgdGhlIGdpdmVuIHJlZ2lvbiB3YXMgc2tpcHBlZFxuICAgIGJlY2F1c2UgaXQgd2Fzbid0IGluIHZpZXcsIGFuZCB0aGUgcGFyc2Ugc2hvdWxkIGJlIHJlc3RhcnRlZFxuICAgIHdoZW4gaXQgY29tZXMgaW50byB2aWV3LlxuICAgICovXG4gICAgc2tpcFVudGlsSW5WaWV3KGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuc2tpcHBlZC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSBwYXJzZXIgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBwbGFjZWhvbGRlciB3aGVuXG4gICAgYXN5bmNocm9ub3VzbHkgbG9hZGluZyBhIG5lc3RlZCBwYXJzZXIuIEl0J2xsIHNraXAgaXRzIGlucHV0IGFuZFxuICAgIG1hcmsgaXQgYXMgbm90LXJlYWxseS1wYXJzZWQsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcGFyc2VcbiAgICBpdCBhZ2Fpbi5cbiAgICBcbiAgICBXaGVuIGB1bnRpbGAgaXMgZ2l2ZW4sIGEgcmVwYXJzZSB3aWxsIGJlIHNjaGVkdWxlZCB3aGVuIHRoYXRcbiAgICBwcm9taXNlIHJlc29sdmVzLlxuICAgICovXG4gICAgc3RhdGljIGdldFNraXBwaW5nUGFyc2VyKHVudGlsKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbMF0uZnJvbSwgdG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFBvczogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeCA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnRlbXBTa2lwcGVkLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVudGlsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gY3guc2NoZWR1bGVPbiA/IFByb21pc2UuYWxsKFtjeC5zY2hlZHVsZU9uLCB1bnRpbF0pIDogdW50aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgdG8gLSBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZEF0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdG9wQXQoKSB7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaXNEb25lKHVwdG8pIHtcbiAgICAgICAgdXB0byA9IE1hdGgubWluKHVwdG8sIHRoaXMuc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGxldCBmcmFncyA9IHRoaXMuZnJhZ21lbnRzO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlTGVuID49IHVwdG8gJiYgZnJhZ3MubGVuZ3RoICYmIGZyYWdzWzBdLmZyb20gPT0gMCAmJiBmcmFnc1swXS50byA+PSB1cHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IHBhcnNlLCBvciBgbnVsbGAgaWYgbm8gZWRpdG9yXG4gICAgcGFyc2UgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KCkgeyByZXR1cm4gY3VycmVudENvbnRleHQ7IH1cbn1cbmZ1bmN0aW9uIGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIFRyZWVGcmFnbWVudC5hcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBbeyBmcm9tQTogZnJvbSwgdG9BOiB0bywgZnJvbUI6IGZyb20sIHRvQjogdG8gfV0pO1xufVxuY2xhc3MgTGFuZ3VhZ2VTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gQSBtdXRhYmxlIHBhcnNlIHN0YXRlIHRoYXQgaXMgdXNlZCB0byBwcmVzZXJ2ZSB3b3JrIGRvbmUgZHVyaW5nXG4gICAgLy8gdGhlIGxpZmV0aW1lIG9mIGEgc3RhdGUgd2hlbiBtb3ZpbmcgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRyZWUgPSBjb250ZXh0LnRyZWU7XG4gICAgfVxuICAgIGFwcGx5KHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiB0aGlzLnRyZWUgPT0gdGhpcy5jb250ZXh0LnRyZWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IG5ld0N4ID0gdGhpcy5jb250ZXh0LmNoYW5nZXModHIuY2hhbmdlcywgdHIuc3RhdGUpO1xuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgcGFyc2Ugd2Fzbid0IGRvbmUsIGdvIGZvcndhcmQgb25seSB1cCB0byBpdHNcbiAgICAgICAgLy8gZW5kIHBvc2l0aW9uIG9yIHRoZSBlbmQgb2YgdGhlIHZpZXdwb3J0LCB0byBhdm9pZCBzbG93aW5nIGRvd25cbiAgICAgICAgLy8gc3RhdGUgdXBkYXRlcyB3aXRoIHBhcnNlIHdvcmsgYmV5b25kIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgbGV0IHVwdG8gPSB0aGlzLmNvbnRleHQudHJlZUxlbiA9PSB0ci5zdGFydFN0YXRlLmRvYy5sZW5ndGggPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogTWF0aC5tYXgodHIuY2hhbmdlcy5tYXBQb3ModGhpcy5jb250ZXh0LnRyZWVMZW4pLCBuZXdDeC52aWV3cG9ydC50byk7XG4gICAgICAgIGlmICghbmV3Q3gud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB1cHRvKSlcbiAgICAgICAgICAgIG5ld0N4LnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShuZXdDeCk7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2cFRvID0gTWF0aC5taW4oMzAwMCAvKiBXb3JrLkluaXRWaWV3cG9ydCAqLywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGxldCBwYXJzZVN0YXRlID0gUGFyc2VDb250ZXh0LmNyZWF0ZShzdGF0ZS5mYWNldChsYW5ndWFnZSkucGFyc2VyLCBzdGF0ZSwgeyBmcm9tOiAwLCB0bzogdnBUbyB9KTtcbiAgICAgICAgaWYgKCFwYXJzZVN0YXRlLndvcmsoMjAgLyogV29yay5BcHBseSAqLywgdnBUbykpXG4gICAgICAgICAgICBwYXJzZVN0YXRlLnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShwYXJzZVN0YXRlKTtcbiAgICB9XG59XG5MYW5ndWFnZS5zdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlOiBMYW5ndWFnZVN0YXRlLmluaXQsXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZS5pcyhMYW5ndWFnZS5zZXRTdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgIGlmICh0ci5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB0ci5zdGF0ZS5mYWNldChsYW5ndWFnZSkpXG4gICAgICAgICAgICByZXR1cm4gTGFuZ3VhZ2VTdGF0ZS5pbml0KHRyLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRyKTtcbiAgICB9XG59KTtcbmxldCByZXF1ZXN0SWRsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjaygpLCA1MDAgLyogV29yay5NYXhQYXVzZSAqLyk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn07XG5pZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXF1ZXN0SWRsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICBsZXQgaWRsZSA9IC0xLCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZGxlID0gcmVxdWVzdElkbGVDYWxsYmFjayhjYWxsYmFjaywgeyB0aW1lb3V0OiA1MDAgLyogV29yay5NYXhQYXVzZSAqLyAtIDEwMCAvKiBXb3JrLk1pblBhdXNlICovIH0pO1xuICAgICAgICB9LCAxMDAgLyogV29yay5NaW5QYXVzZSAqLyk7XG4gICAgICAgIHJldHVybiAoKSA9PiBpZGxlIDwgMCA/IGNsZWFyVGltZW91dCh0aW1lb3V0KSA6IGNhbmNlbElkbGVDYWxsYmFjayhpZGxlKTtcbiAgICB9O1xuY29uc3QgaXNJbnB1dFBlbmRpbmcgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgKChfYSA9IG5hdmlnYXRvci5zY2hlZHVsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNJbnB1dFBlbmRpbmcpXG4gICAgPyAoKSA9PiBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZygpIDogbnVsbDtcbmNvbnN0IHBhcnNlV29ya2VyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIFBhcnNlV29ya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMud29ya2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCA9IDA7XG4gICAgICAgIC8vIEVuZCBvZiB0aGUgY3VycmVudCB0aW1lIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtFbmQgPSAtMTtcbiAgICAgICAgLy8gTWlsbGlzZWNvbmRzIG9mIGJ1ZGdldCBsZWZ0IGZvciB0aGlzIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAtMTtcbiAgICAgICAgdGhpcy53b3JrID0gdGhpcy53b3JrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGN4ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKS5jb250ZXh0O1xuICAgICAgICBpZiAoY3gudXBkYXRlVmlld3BvcnQodXBkYXRlLnZpZXcudmlld3BvcnQpIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA+IGN4LnRyZWVMZW4pXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5oYXNGb2N1cylcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ICs9IDUwIC8qIFdvcmsuQ2hhbmdlQm9udXMgKi87XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGN4KTtcbiAgICB9XG4gICAgc2NoZWR1bGVXb3JrKCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKTtcbiAgICAgICAgaWYgKGZpZWxkLnRyZWUgIT0gZmllbGQuY29udGV4dC50cmVlIHx8ICFmaWVsZC5jb250ZXh0LmlzRG9uZShzdGF0ZS5kb2MubGVuZ3RoKSlcbiAgICAgICAgICAgIHRoaXMud29ya2luZyA9IHJlcXVlc3RJZGxlKHRoaXMud29yayk7XG4gICAgfVxuICAgIHdvcmsoZGVhZGxpbmUpIHtcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rRW5kIDwgbm93ICYmICh0aGlzLmNodW5rRW5kIDwgMCB8fCB0aGlzLnZpZXcuaGFzRm9jdXMpKSB7IC8vIFN0YXJ0IGEgbmV3IGNodW5rXG4gICAgICAgICAgICB0aGlzLmNodW5rRW5kID0gbm93ICsgMzAwMDAgLyogV29yay5DaHVua1RpbWUgKi87XG4gICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gMzAwMCAvKiBXb3JrLkNodW5rQnVkZ2V0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0IDw9IDApXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vIG1vcmUgYnVkZ2V0XG4gICAgICAgIGxldCB7IHN0YXRlLCB2aWV3cG9ydDogeyB0bzogdnBUbyB9IH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSA9PSBmaWVsZC5jb250ZXh0LnRyZWUgJiYgZmllbGQuY29udGV4dC5pc0RvbmUodnBUbyArIDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyBNYXRoLm1pbih0aGlzLmNodW5rQnVkZ2V0LCAxMDAgLyogV29yay5TbGljZSAqLywgZGVhZGxpbmUgJiYgIWlzSW5wdXRQZW5kaW5nID8gTWF0aC5tYXgoMjUgLyogV29yay5NaW5TbGljZSAqLywgZGVhZGxpbmUudGltZVJlbWFpbmluZygpIC0gNSkgOiAxZTkpO1xuICAgICAgICBsZXQgdmlld3BvcnRGaXJzdCA9IGZpZWxkLmNvbnRleHQudHJlZUxlbiA8IHZwVG8gJiYgc3RhdGUuZG9jLmxlbmd0aCA+IHZwVG8gKyAxMDAwO1xuICAgICAgICBsZXQgZG9uZSA9IGZpZWxkLmNvbnRleHQud29yaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNJbnB1dFBlbmRpbmcgJiYgaXNJbnB1dFBlbmRpbmcoKSB8fCBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgfSwgdnBUbyArICh2aWV3cG9ydEZpcnN0ID8gMCA6IDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKTtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCAtPSBEYXRlLm5vdygpIC0gbm93O1xuICAgICAgICBpZiAoZG9uZSB8fCB0aGlzLmNodW5rQnVkZ2V0IDw9IDApIHtcbiAgICAgICAgICAgIGZpZWxkLmNvbnRleHQudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IExhbmd1YWdlLnNldFN0YXRlLm9mKG5ldyBMYW5ndWFnZVN0YXRlKGZpZWxkLmNvbnRleHQpKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0J1ZGdldCA+IDAgJiYgIShkb25lICYmICF2aWV3cG9ydEZpcnN0KSlcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGZpZWxkLmNvbnRleHQpO1xuICAgIH1cbiAgICBjaGVja0FzeW5jU2NoZWR1bGUoY3gpIHtcbiAgICAgICAgaWYgKGN4LnNjaGVkdWxlT24pIHtcbiAgICAgICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCsrO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPblxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVXb3JrKCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMud29ya1NjaGVkdWxlZC0tKTtcbiAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXG4gICAgICAgICAgICB0aGlzLndvcmtpbmcoKTtcbiAgICB9XG4gICAgaXNXb3JraW5nKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy53b3JraW5nIHx8IHRoaXMud29ya1NjaGVkdWxlZCA+IDApO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7IGZvY3VzKCkgeyB0aGlzLnNjaGVkdWxlV29yaygpOyB9IH1cbn0pO1xuLyoqXG5UaGUgZmFjZXQgdXNlZCB0byBhc3NvY2lhdGUgYSBsYW5ndWFnZSB3aXRoIGFuIGVkaXRvciBzdGF0ZS4gVXNlZFxuYnkgYExhbmd1YWdlYCBvYmplY3QncyBgZXh0ZW5zaW9uYCBwcm9wZXJ0eSAoc28geW91IGRvbid0IG5lZWQgdG9cbm1hbnVhbGx5IHdyYXAgeW91ciBsYW5ndWFnZXMgaW4gdGhpcykuIENhbiBiZSB1c2VkIHRvIGFjY2VzcyB0aGVcbmN1cnJlbnQgbGFuZ3VhZ2Ugb24gYSBzdGF0ZS5cbiovXG5jb25zdCBsYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobGFuZ3VhZ2VzKSB7IHJldHVybiBsYW5ndWFnZXMubGVuZ3RoID8gbGFuZ3VhZ2VzWzBdIDogbnVsbDsgfSxcbiAgICBlbmFibGVzOiBsYW5ndWFnZSA9PiBbXG4gICAgICAgIExhbmd1YWdlLnN0YXRlLFxuICAgICAgICBwYXJzZVdvcmtlcixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5jb21wdXRlKFtsYW5ndWFnZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGxhbmcgJiYgbGFuZy5uYW1lID8geyBcImRhdGEtbGFuZ3VhZ2VcIjogbGFuZy5uYW1lIH0gOiB7fTtcbiAgICAgICAgfSlcbiAgICBdXG59KTtcbi8qKlxuVGhpcyBjbGFzcyBidW5kbGVzIGEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSB3aXRoIGFuXG5vcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBMYW5ndWFnZSBwYWNrYWdlcyBhcmVcbmVuY291cmFnZWQgdG8gZXhwb3J0IGEgZnVuY3Rpb24gdGhhdCBvcHRpb25hbGx5IHRha2VzIGFcbmNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZCByZXR1cm5zIGEgYExhbmd1YWdlU3VwcG9ydGAgaW5zdGFuY2UsIGFzXG50aGUgbWFpbiB3YXkgZm9yIGNsaWVudCBjb2RlIHRvIHVzZSB0aGUgcGFja2FnZS5cbiovXG5jbGFzcyBMYW5ndWFnZVN1cHBvcnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIHN1cHBvcnQgb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxhbmd1YWdlIG9iamVjdC5cbiAgICAqL1xuICAgIGxhbmd1YWdlLCBcbiAgICAvKipcbiAgICBBbiBvcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBXaGVuIG5lc3RpbmcgYVxuICAgIGxhbmd1YWdlIGluIGFub3RoZXIgbGFuZ3VhZ2UsIHRoZSBvdXRlciBsYW5ndWFnZSBpcyBlbmNvdXJhZ2VkXG4gICAgdG8gaW5jbHVkZSB0aGUgc3VwcG9ydGluZyBleHRlbnNpb25zIGZvciBpdHMgaW5uZXIgbGFuZ3VhZ2VzXG4gICAgaW4gaXRzIG93biBzZXQgb2Ygc3VwcG9ydCBleHRlbnNpb25zLlxuICAgICovXG4gICAgc3VwcG9ydCA9IFtdKSB7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbbGFuZ3VhZ2UsIHN1cHBvcnRdO1xuICAgIH1cbn1cbi8qKlxuTGFuZ3VhZ2UgZGVzY3JpcHRpb25zIGFyZSB1c2VkIHRvIHN0b3JlIG1ldGFkYXRhIGFib3V0IGxhbmd1YWdlc1xuYW5kIHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhlbS4gVGhlaXIgbWFpbiByb2xlIGlzIGZpbmRpbmcgdGhlXG5hcHByb3ByaWF0ZSBsYW5ndWFnZSBmb3IgYSBmaWxlbmFtZSBvciBkeW5hbWljYWxseSBsb2FkaW5nIG5lc3RlZFxucGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZURlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQWx0ZXJuYXRpdmUgbmFtZXMgZm9yIHRoZSBtb2RlIChsb3dlcmNhc2VkLCBpbmNsdWRlcyBgdGhpcy5uYW1lYCkuXG4gICAgKi9cbiAgICBhbGlhcywgXG4gICAgLyoqXG4gICAgRmlsZSBleHRlbnNpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZXh0ZW5zaW9ucywgXG4gICAgLyoqXG4gICAgT3B0aW9uYWwgZmlsZW5hbWUgcGF0dGVybiB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpc1xuICAgIGxhbmd1YWdlLlxuICAgICovXG4gICAgZmlsZW5hbWUsIGxvYWRGdW5jLCBcbiAgICAvKipcbiAgICBJZiB0aGUgbGFuZ3VhZ2UgaGFzIGJlZW4gbG9hZGVkLCB0aGlzIHdpbGwgaG9sZCBpdHMgdmFsdWUuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmxvYWRGdW5jID0gbG9hZEZ1bmM7XG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXJ0IGxvYWRpbmcgdGhlIHRoZSBsYW5ndWFnZS4gV2lsbCByZXR1cm4gYSBwcm9taXNlIHRoYXRcbiAgICByZXNvbHZlcyB0byBhIFtgTGFuZ3VhZ2VTdXBwb3J0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZVN1cHBvcnQpXG4gICAgb2JqZWN0IHdoZW4gdGhlIGxhbmd1YWdlIHN1Y2Nlc3NmdWxseSBsb2Fkcy5cbiAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmcgfHwgKHRoaXMubG9hZGluZyA9IHRoaXMubG9hZEZ1bmMoKS50aGVuKHN1cHBvcnQgPT4gdGhpcy5zdXBwb3J0ID0gc3VwcG9ydCwgZXJyID0+IHsgdGhpcy5sb2FkaW5nID0gbnVsbDsgdGhyb3cgZXJyOyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIGRlc2NyaXB0aW9uLlxuICAgICovXG4gICAgc3RhdGljIG9mKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgbG9hZCwgc3VwcG9ydCB9ID0gc3BlYztcbiAgICAgICAgaWYgKCFsb2FkKSB7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdXN0IHBhc3MgZWl0aGVyICdsb2FkJyBvciAnc3VwcG9ydCcgdG8gTGFuZ3VhZ2VEZXNjcmlwdGlvbi5vZlwiKTtcbiAgICAgICAgICAgIGxvYWQgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoc3VwcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZURlc2NyaXB0aW9uKHNwZWMubmFtZSwgKHNwZWMuYWxpYXMgfHwgW10pLmNvbmNhdChzcGVjLm5hbWUpLm1hcChzID0+IHMudG9Mb3dlckNhc2UoKSksIHNwZWMuZXh0ZW5zaW9ucyB8fCBbXSwgc3BlYy5maWxlbmFtZSwgbG9hZCwgc3VwcG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2UgaW4gdGhlIGdpdmVuIGFycmF5IG9mIGRlc2NyaXB0aW9ucyB0aGF0XG4gICAgbWF0Y2hlcyB0aGUgZmlsZW5hbWUuIFdpbGwgZmlyc3QgbWF0Y2hcbiAgICBbYGZpbGVuYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmZpbGVuYW1lKSBwYXR0ZXJucyxcbiAgICBhbmQgdGhlbiBbZXh0ZW5zaW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpLFxuICAgIGFuZCByZXR1cm4gdGhlIGZpcnN0IGxhbmd1YWdlIHRoYXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaEZpbGVuYW1lKGRlc2NzLCBmaWxlbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuZmlsZW5hbWUgJiYgZC5maWxlbmFtZS50ZXN0KGZpbGVuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgbGV0IGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhmaWxlbmFtZSk7XG4gICAgICAgIGlmIChleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGlmIChkLmV4dGVuc2lvbnMuaW5kZXhPZihleHRbMV0pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lIG9yIGFsaWFzIG1hdGNoZXMgdGhlIHRoZSBnaXZlblxuICAgIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmVseSkuIElmIGBmdXp6eWAgaXMgdHJ1ZSwgYW5kIG5vIGRpcmVjdFxuICAgIG1hdGNocyBpcyBmb3VuZCwgdGhpcydsbCBhbHNvIHNlYXJjaCBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lXG4gICAgb3IgYWxpYXMgb2NjdXJzIGluIHRoZSBzdHJpbmcgKGZvciBuYW1lcyBzaG9ydGVyIHRoYW4gdGhyZWVcbiAgICBjaGFyYWN0ZXJzLCBvbmx5IHdoZW4gc3Vycm91bmRlZCBieSBub24td29yZCBjaGFyYWN0ZXJzKS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaExhbmd1YWdlTmFtZShkZXNjcywgbmFtZSwgZnV6enkgPSB0cnVlKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5hbGlhcy5zb21lKGEgPT4gYSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgaWYgKGZ1enp5KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhIG9mIGQuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gbmFtZS5pbmRleE9mKGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiAoYS5sZW5ndGggPiAyIHx8ICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgLSAxXSkgJiYgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCArIGEubGVuZ3RoXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuRmFjZXQgdGhhdCBkZWZpbmVzIGEgd2F5IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZVxuYXBwcm9wcmlhdGUgaW5kZW50YXRpb24gZGVwdGgsIGFzIGEgY29sdW1uIG51bWJlciAoc2VlXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSksIGF0IHRoZSBzdGFydCBvZiBhIGdpdmVuXG5saW5lLiBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgaW5kaWNhdGVzIG5vIGluZGVudGF0aW9uIGNhbiBiZVxuZGV0ZXJtaW5lZCwgYW5kIHRoZSBsaW5lIHNob3VsZCBpbmhlcml0IHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgb25lXG5hYm92ZSBpdC4gQSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgZGVmZXJzIHRvIHRoZSBuZXh0IGluZGVudFxuc2VydmljZS5cbiovXG5jb25zdCBpbmRlbnRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5GYWNldCBmb3Igb3ZlcnJpZGluZyB0aGUgdW5pdCBieSB3aGljaCBpbmRlbnRhdGlvbiBoYXBwZW5zLiBTaG91bGRcbmJlIGEgc3RyaW5nIGNvbnNpc3RpbmcgZW50aXJlbHkgb2YgdGhlIHNhbWUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG5XaGVuIG5vdCBzZXQsIHRoaXMgZGVmYXVsdHMgdG8gMiBzcGFjZXMuXG4qL1xuY29uc3QgaW5kZW50VW5pdCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBcIiAgXCI7XG4gICAgICAgIGxldCB1bml0ID0gdmFsdWVzWzBdO1xuICAgICAgICBpZiAoIXVuaXQgfHwgL1xcUy8udGVzdCh1bml0KSB8fCBBcnJheS5mcm9tKHVuaXQpLnNvbWUoZSA9PiBlICE9IHVuaXRbMF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRlbnQgdW5pdDogXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbMF0pKTtcbiAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxufSk7XG4vKipcblJldHVybiB0aGUgX2NvbHVtbiB3aWR0aF8gb2YgYW4gaW5kZW50IHVuaXQgaW4gdGhlIHN0YXRlLlxuRGV0ZXJtaW5lZCBieSB0aGUgW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KVxuZmFjZXQsIGFuZCBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIHdoZW4gdGhhdFxuY29udGFpbnMgdGFicy5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRVbml0KHN0YXRlKSB7XG4gICAgbGV0IHVuaXQgPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICByZXR1cm4gdW5pdC5jaGFyQ29kZUF0KDApID09IDkgPyBzdGF0ZS50YWJTaXplICogdW5pdC5sZW5ndGggOiB1bml0Lmxlbmd0aDtcbn1cbi8qKlxuQ3JlYXRlIGFuIGluZGVudGF0aW9uIHN0cmluZyB0aGF0IGNvdmVycyBjb2x1bW5zIDAgdG8gYGNvbHNgLlxuV2lsbCB1c2UgdGFicyBmb3IgYXMgbXVjaCBvZiB0aGUgY29sdW1ucyBhcyBwb3NzaWJsZSB3aGVuIHRoZVxuW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBmYWNldCBjb250YWluc1xudGFicy5cbiovXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RhdGUsIGNvbHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIiwgdHMgPSBzdGF0ZS50YWJTaXplLCBjaCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpWzBdO1xuICAgIGlmIChjaCA9PSBcIlxcdFwiKSB7XG4gICAgICAgIHdoaWxlIChjb2xzID49IHRzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGNvbHMgLT0gdHM7XG4gICAgICAgIH1cbiAgICAgICAgY2ggPSBcIiBcIjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyBpKyspXG4gICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5HZXQgdGhlIGluZGVudGF0aW9uLCBhcyBhIGNvbHVtbiBudW1iZXIsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbldpbGwgZmlyc3QgY29uc3VsdCBhbnkgW2luZGVudCBzZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKVxudGhhdCBhcmUgcmVnaXN0ZXJlZCwgYW5kIGlmIG5vbmUgb2YgdGhvc2UgcmV0dXJuIGFuIGluZGVudGF0aW9uLFxudGhpcyB3aWxsIGNoZWNrIHRoZSBzeW50YXggdHJlZSBmb3IgdGhlIFtpbmRlbnQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnROb2RlUHJvcCkgYW5kIHVzZSB0aGF0IGlmIGZvdW5kLiBSZXR1cm5zIGFcbm51bWJlciB3aGVuIGFuIGluZGVudGF0aW9uIGNvdWxkIGJlIGRldGVybWluZWQsIGFuZCBudWxsXG5vdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgcG9zKSB7XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBFZGl0b3JTdGF0ZSlcbiAgICAgICAgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2YgY29udGV4dC5zdGF0ZS5mYWNldChpbmRlbnRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShjb250ZXh0LCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSk7XG4gICAgcmV0dXJuIHRyZWUubGVuZ3RoID49IHBvcyA/IHN5bnRheEluZGVudGF0aW9uKGNvbnRleHQsIHRyZWUsIHBvcykgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYSBjaGFuZ2Ugc2V0IHRoYXQgYXV0by1pbmRlbnRzIGFsbCBsaW5lcyB0b3VjaGVkIGJ5IHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcmFuZ2UuXG4qL1xuZnVuY3Rpb24gaW5kZW50UmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHVwZGF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB1cGRhdGVkW3N0YXJ0XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTE7IH0gfSk7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QobGluZS50ZXh0KSlcbiAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgIGxldCBjdXIgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgIGlmIChjdXIgIT0gbm9ybSkge1xuICAgICAgICAgICAgdXBkYXRlZFtsaW5lLmZyb21dID0gaW5kZW50O1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xufVxuLyoqXG5JbmRlbnRhdGlvbiBjb250ZXh0cyBhcmUgdXNlZCB3aGVuIGNhbGxpbmcgW2luZGVudGF0aW9uXG5zZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKS4gVGhleSBwcm92aWRlIGhlbHBlciB1dGlsaXRpZXNcbnVzZWZ1bCBpbiBpbmRlbnRhdGlvbiBsb2dpYywgYW5kIGNhbiBzZWxlY3RpdmVseSBvdmVycmlkZSB0aGVcbmluZGVudGF0aW9uIHJlcG9ydGVkIGZvciBzb21lIGxpbmVzLlxuKi9cbmNsYXNzIEluZGVudENvbnRleHQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbmRlbnQgY29udGV4dC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVuaXQgPSBnZXRJbmRlbnRVbml0KHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCB0YWtpbmdcbiAgICBbc2ltdWxhdGVkIGxpbmVcbiAgICBicmVha3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgaW50byBhY2NvdW50LiBJZiB0aGVyZSBpcyBzdWNoIGEgYnJlYWsgYXQgYHBvc2AsIHRoZSBgYmlhc2BcbiAgICBhcmd1bWVudCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhcnQgb2YgdGhlIGxpbmUgbGluZSBiZWZvcmUgb3JcbiAgICBhZnRlciB0aGUgYnJlYWsgaXMgdXNlZC5cbiAgICAqL1xuICAgIGxpbmVBdChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCB7IHNpbXVsYXRlQnJlYWssIHNpbXVsYXRlRG91YmxlQnJlYWsgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHNpbXVsYXRlQnJlYWsgIT0gbnVsbCAmJiBzaW11bGF0ZUJyZWFrID49IGxpbmUuZnJvbSAmJiBzaW11bGF0ZUJyZWFrIDw9IGxpbmUudG8pIHtcbiAgICAgICAgICAgIGlmIChzaW11bGF0ZURvdWJsZUJyZWFrICYmIHNpbXVsYXRlQnJlYWsgPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IFwiXCIsIGZyb206IHBvcyB9O1xuICAgICAgICAgICAgZWxzZSBpZiAoYmlhcyA8IDAgPyBzaW11bGF0ZUJyZWFrIDwgcG9zIDogc2ltdWxhdGVCcmVhayA8PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBzaW11bGF0ZUJyZWFrIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKDAsIHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBsaW5lLmZyb20gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGBwb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgdGV4dEFmdGVyUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrICYmIHBvcyA9PSB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShwb3MgLSBmcm9tLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgcG9zICsgMTAwIC0gZnJvbSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjb2x1bW4gZm9yIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGNvbHVtbihwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHBvcyAtIGZyb20pO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbiA/IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uKGZyb20pIDogLTE7XG4gICAgICAgIGlmIChvdmVycmlkZSA+IC0xKVxuICAgICAgICAgICAgcmVzdWx0ICs9IG92ZXJyaWRlIC0gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBwb3NpdGlvbiAodGFraW5nIHRhYnMgaW50byBhY2NvdW50KSBvZiB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbiBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgY291bnRDb2x1bW4obGluZSwgcG9zID0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50Q29sdW1uKGxpbmUsIHRoaXMuc3RhdGUudGFiU2l6ZSwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgaW5kZW50YXRpb24gY29sdW1uIG9mIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICAqL1xuICAgIGxpbmVJbmRlbnQocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbjtcbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcnJpZGVuID0gb3ZlcnJpZGUoZnJvbSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVuID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkluZGVudENvbnRleHQuY29uc3RydWN0b3Jeb3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgIGZvciB0aGlzIGNvbnRleHQsIGlmIGFueS5cbiAgICAqL1xuICAgIGdldCBzaW11bGF0ZWRCcmVhaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG5BIHN5bnRheCB0cmVlIG5vZGUgcHJvcCB1c2VkIHRvIGFzc29jaWF0ZSBpbmRlbnRhdGlvbiBzdHJhdGVnaWVzXG53aXRoIG5vZGUgdHlwZXMuIFN1Y2ggYSBzdHJhdGVneSBpcyBhIGZ1bmN0aW9uIGZyb20gYW4gaW5kZW50YXRpb25cbmNvbnRleHQgdG8gYSBjb2x1bW4gbnVtYmVyIChzZWUgYWxzb1xuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpIG9yIG51bGwsIHdoZXJlIG51bGxcbmluZGljYXRlcyB0aGF0IG5vIGRlZmluaXRpdmUgaW5kZW50YXRpb24gY2FuIGJlIGRldGVybWluZWQuXG4qL1xuY29uc3QgaW5kZW50Tm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vLyBDb21wdXRlIHRoZSBpbmRlbnRhdGlvbiBmb3IgYSBnaXZlbiBwb3NpdGlvbiBmcm9tIHRoZSBzeW50YXggdHJlZS5cbmZ1bmN0aW9uIHN5bnRheEluZGVudGF0aW9uKGN4LCBhc3QsIHBvcykge1xuICAgIGxldCBzdGFjayA9IGFzdC5yZXNvbHZlU3RhY2socG9zKTtcbiAgICBsZXQgaW5uZXIgPSBhc3QucmVzb2x2ZUlubmVyKHBvcywgLTEpLnJlc29sdmUocG9zLCAwKS5lbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpO1xuICAgIGlmIChpbm5lciAhPSBzdGFjay5ub2RlKSB7XG4gICAgICAgIGxldCBhZGQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gaW5uZXI7IGN1ciAmJiAhKGN1ci5mcm9tIDwgc3RhY2subm9kZS5mcm9tIHx8IGN1ci50byA+IHN0YWNrLm5vZGUudG8gfHxcbiAgICAgICAgICAgIGN1ci5mcm9tID09IHN0YWNrLm5vZGUuZnJvbSAmJiBjdXIudHlwZSA9PSBzdGFjay5ub2RlLnR5cGUpOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgYWRkLnB1c2goY3VyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFkZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIHN0YWNrID0geyBub2RlOiBhZGRbaV0sIG5leHQ6IHN0YWNrIH07XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnRGb3Ioc3RhY2ssIGN4LCBwb3MpO1xufVxuZnVuY3Rpb24gaW5kZW50Rm9yKHN0YWNrLCBjeCwgcG9zKSB7XG4gICAgZm9yIChsZXQgY3VyID0gc3RhY2s7IGN1cjsgY3VyID0gY3VyLm5leHQpIHtcbiAgICAgICAgbGV0IHN0cmF0ZWd5ID0gaW5kZW50U3RyYXRlZ3koY3VyLm5vZGUpO1xuICAgICAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgICAgICByZXR1cm4gc3RyYXRlZ3koVHJlZUluZGVudENvbnRleHQuY3JlYXRlKGN4LCBwb3MsIGN1cikpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlnbm9yZUNsb3NlZChjeCkge1xuICAgIHJldHVybiBjeC5wb3MgPT0gY3gub3B0aW9ucy5zaW11bGF0ZUJyZWFrICYmIGN4Lm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhaztcbn1cbmZ1bmN0aW9uIGluZGVudFN0cmF0ZWd5KHRyZWUpIHtcbiAgICBsZXQgc3RyYXRlZ3kgPSB0cmVlLnR5cGUucHJvcChpbmRlbnROb2RlUHJvcCk7XG4gICAgaWYgKHN0cmF0ZWd5KVxuICAgICAgICByZXR1cm4gc3RyYXRlZ3k7XG4gICAgbGV0IGZpcnN0ID0gdHJlZS5maXJzdENoaWxkLCBjbG9zZTtcbiAgICBpZiAoZmlyc3QgJiYgKGNsb3NlID0gZmlyc3QudHlwZS5wcm9wKE5vZGVQcm9wLmNsb3NlZEJ5KSkpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0cmVlLmxhc3RDaGlsZCwgY2xvc2VkID0gbGFzdCAmJiBjbG9zZS5pbmRleE9mKGxhc3QubmFtZSkgPiAtMTtcbiAgICAgICAgcmV0dXJuIGN4ID0+IGRlbGltaXRlZFN0cmF0ZWd5KGN4LCB0cnVlLCAxLCB1bmRlZmluZWQsIGNsb3NlZCAmJiAhaWdub3JlQ2xvc2VkKGN4KSA/IGxhc3QuZnJvbSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlLnBhcmVudCA9PSBudWxsID8gdG9wSW5kZW50IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRvcEluZGVudCgpIHsgcmV0dXJuIDA7IH1cbi8qKlxuT2JqZWN0cyBvZiB0aGlzIHR5cGUgcHJvdmlkZSBjb250ZXh0IGluZm9ybWF0aW9uIGFuZCBoZWxwZXJcbm1ldGhvZHMgdG8gaW5kZW50YXRpb24gZnVuY3Rpb25zIHJlZ2lzdGVyZWQgb24gc3ludGF4IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVJbmRlbnRDb250ZXh0IGV4dGVuZHMgSW5kZW50Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIGluZGVudGF0aW9uIGlzIGJlaW5nIGNvbXB1dGVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoYmFzZS5zdGF0ZSwgYmFzZS5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzeW50YXggdHJlZSBub2RlIHRvIHdoaWNoIHRoZSBpbmRlbnRhdGlvbiBzdHJhdGVneVxuICAgIGFwcGxpZXMuXG4gICAgKi9cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5ub2RlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGJhc2UsIHBvcywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVJbmRlbnRDb250ZXh0KGJhc2UsIHBvcywgY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgdGhpcy5wb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgZ2V0IHRleHRBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dEFmdGVyUG9zKHRoaXMucG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBhdCB0aGUgcmVmZXJlbmNlIGxpbmUgZm9yIGB0aGlzLm5vZGVgLCB3aGljaFxuICAgIGlzIHRoZSBsaW5lIG9uIHdoaWNoIGl0IHN0YXJ0cywgdW5sZXNzIHRoZXJlIGlzIGEgbm9kZSB0aGF0IGlzXG4gICAgX25vdF8gYSBwYXJlbnQgb2YgdGhpcyBub2RlIGNvdmVyaW5nIHRoZSBzdGFydCBvZiB0aGF0IGxpbmUuIElmXG4gICAgc28sIHRoZSBsaW5lIGF0IHRoZSBzdGFydCBvZiB0aGF0IG5vZGUgaXMgdHJpZWQsIGFnYWluIHNraXBwaW5nXG4gICAgb24gaWYgaXQgaXMgY292ZXJlZCBieSBhbm90aGVyIHN1Y2ggbm9kZS5cbiAgICAqL1xuICAgIGdldCBiYXNlSW5kZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlSW5kZW50Rm9yKHRoaXMubm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgaW5kZW50YXRpb24gZm9yIHRoZSByZWZlcmVuY2UgbGluZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIChzZWUgW2BiYXNlSW5kZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5UcmVlSW5kZW50Q29udGV4dC5iYXNlSW5kZW50KSkuXG4gICAgKi9cbiAgICBiYXNlSW5kZW50Rm9yKG5vZGUpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQobm9kZS5mcm9tKTtcbiAgICAgICAgLy8gU2tpcCBsaW5lIHN0YXJ0cyB0aGF0IGFyZSBjb3ZlcmVkIGJ5IGEgc2libGluZyAob3IgY291c2luLCBldGMpXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhdEJyZWFrID0gbm9kZS5yZXNvbHZlKGxpbmUuZnJvbSk7XG4gICAgICAgICAgICB3aGlsZSAoYXRCcmVhay5wYXJlbnQgJiYgYXRCcmVhay5wYXJlbnQuZnJvbSA9PSBhdEJyZWFrLmZyb20pXG4gICAgICAgICAgICAgICAgYXRCcmVhayA9IGF0QnJlYWsucGFyZW50O1xuICAgICAgICAgICAgaWYgKGlzUGFyZW50KGF0QnJlYWssIG5vZGUpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChhdEJyZWFrLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbmRlbnQobGluZS5mcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbG9va2luZyBmb3IgaW5kZW50YXRpb25zIGluIHRoZSBub2RlJ3MgcGFyZW50IG5vZGVzLFxuICAgIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGF0LlxuICAgICovXG4gICAgY29udGludWUoKSB7XG4gICAgICAgIHJldHVybiBpbmRlbnRGb3IodGhpcy5jb250ZXh0Lm5leHQsIHRoaXMuYmFzZSwgdGhpcy5wb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUGFyZW50KHBhcmVudCwgb2YpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBvZjsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICBpZiAocGFyZW50ID09IGN1cilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIENoZWNrIHdoZXRoZXIgYSBkZWxpbWl0ZWQgbm9kZSBpcyBhbGlnbmVkIChtZWFuaW5nIHRoZXJlIGFyZVxuLy8gbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgb3BlbmluZyBkZWxpbWl0ZXIpLiBBbmRcbi8vIGlmIHNvLCByZXR1cm4gdGhlIG9wZW5pbmcgdG9rZW4uXG5mdW5jdGlvbiBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIHtcbiAgICBsZXQgdHJlZSA9IGNvbnRleHQubm9kZTtcbiAgICBsZXQgb3BlblRva2VuID0gdHJlZS5jaGlsZEFmdGVyKHRyZWUuZnJvbSksIGxhc3QgPSB0cmVlLmxhc3RDaGlsZDtcbiAgICBpZiAoIW9wZW5Ub2tlbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHNpbSA9IGNvbnRleHQub3B0aW9ucy5zaW11bGF0ZUJyZWFrO1xuICAgIGxldCBvcGVuTGluZSA9IGNvbnRleHQuc3RhdGUuZG9jLmxpbmVBdChvcGVuVG9rZW4uZnJvbSk7XG4gICAgbGV0IGxpbmVFbmQgPSBzaW0gPT0gbnVsbCB8fCBzaW0gPD0gb3BlbkxpbmUuZnJvbSA/IG9wZW5MaW5lLnRvIDogTWF0aC5taW4ob3BlbkxpbmUudG8sIHNpbSk7XG4gICAgZm9yIChsZXQgcG9zID0gb3BlblRva2VuLnRvOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSB0cmVlLmNoaWxkQWZ0ZXIocG9zKTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQgPT0gbGFzdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIW5leHQudHlwZS5pc1NraXBwZWQpIHtcbiAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPj0gbGluZUVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBzcGFjZSA9IC9eICovLmV4ZWMob3BlbkxpbmUudGV4dC5zbGljZShvcGVuVG9rZW4udG8gLSBvcGVuTGluZS5mcm9tKSlbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogb3BlblRva2VuLmZyb20sIHRvOiBvcGVuVG9rZW4udG8gKyBzcGFjZSB9O1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IG5leHQudG87XG4gICAgfVxufVxuLyoqXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSBmb3IgZGVsaW1pdGVkICh1c3VhbGx5IGJyYWNrZXRlZCkgbm9kZXMuXG5XaWxsLCBieSBkZWZhdWx0LCBpbmRlbnQgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBwYXJlbnQncyBiYXNlXG5pbmRlbnQgdW5sZXNzIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgY2xvc2luZyB0b2tlbi4gV2hlbiBgYWxpZ25gXG5pcyB0cnVlIGFuZCB0aGVyZSBhcmUgbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIG5vZGUncyBvcGVuaW5nXG5saW5lLCB0aGUgY29udGVudCBvZiB0aGUgbm9kZSB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgZW5kIG9mIHRoZVxub3BlbmluZyBub2RlLCBsaWtlIHRoaXM6XG5cbiAgICBmb28oYmFyLFxuICAgICAgICBiYXopXG4qL1xuZnVuY3Rpb24gZGVsaW1pdGVkSW5kZW50KHsgY2xvc2luZywgYWxpZ24gPSB0cnVlLCB1bml0cyA9IDEgfSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nKTtcbn1cbmZ1bmN0aW9uIGRlbGltaXRlZFN0cmF0ZWd5KGNvbnRleHQsIGFsaWduLCB1bml0cywgY2xvc2luZywgY2xvc2VkQXQpIHtcbiAgICBsZXQgYWZ0ZXIgPSBjb250ZXh0LnRleHRBZnRlciwgc3BhY2UgPSBhZnRlci5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG4gICAgbGV0IGNsb3NlZCA9IGNsb3NpbmcgJiYgYWZ0ZXIuc2xpY2Uoc3BhY2UsIHNwYWNlICsgY2xvc2luZy5sZW5ndGgpID09IGNsb3NpbmcgfHwgY2xvc2VkQXQgPT0gY29udGV4dC5wb3MgKyBzcGFjZTtcbiAgICBsZXQgYWxpZ25lZCA9IGFsaWduID8gYnJhY2tldGVkQWxpZ25lZChjb250ZXh0KSA6IG51bGw7XG4gICAgaWYgKGFsaWduZWQpXG4gICAgICAgIHJldHVybiBjbG9zZWQgPyBjb250ZXh0LmNvbHVtbihhbGlnbmVkLmZyb20pIDogY29udGV4dC5jb2x1bW4oYWxpZ25lZC50byk7XG4gICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0ICogdW5pdHMpO1xufVxuLyoqXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0IGFsaWducyBhIG5vZGUncyBjb250ZW50IHRvIGl0cyBiYXNlXG5pbmRlbnRhdGlvbi5cbiovXG5jb25zdCBmbGF0SW5kZW50ID0gKGNvbnRleHQpID0+IGNvbnRleHQuYmFzZUluZGVudDtcbi8qKlxuQ3JlYXRlcyBhbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0LCBieSBkZWZhdWx0LCBpbmRlbnRzXG5jb250aW51ZWQgbGluZXMgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBub2RlJ3MgYmFzZSBpbmRlbnRhdGlvbi5cbllvdSBjYW4gcHJvdmlkZSBgZXhjZXB0YCB0byBwcmV2ZW50IGluZGVudGF0aW9uIG9mIGxpbmVzIHRoYXRcbm1hdGNoIGEgcGF0dGVybiAoZm9yIGV4YW1wbGUgYC9eZWxzZVxcYi9gIGluIGBpZmAvYGVsc2VgXG5jb25zdHJ1Y3RzKSwgYW5kIHlvdSBjYW4gY2hhbmdlIHRoZSBhbW91bnQgb2YgdW5pdHMgdXNlZCB3aXRoIHRoZVxuYHVuaXRzYCBvcHRpb24uXG4qL1xuZnVuY3Rpb24gY29udGludWVkSW5kZW50KHsgZXhjZXB0LCB1bml0cyA9IDEgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCBtYXRjaEV4Y2VwdCA9IGV4Y2VwdCAmJiBleGNlcHQudGVzdChjb250ZXh0LnRleHRBZnRlcik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAobWF0Y2hFeGNlcHQgPyAwIDogdW5pdHMgKiBjb250ZXh0LnVuaXQpO1xuICAgIH07XG59XG5jb25zdCBEb250SW5kZW50QmV5b25kID0gMjAwO1xuLyoqXG5FbmFibGVzIHJlaW5kZW50YXRpb24gb24gaW5wdXQuIFdoZW4gYSBsYW5ndWFnZSBkZWZpbmVzIGFuXG5gaW5kZW50T25JbnB1dGAgZmllbGQgaW4gaXRzIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCksIHdoaWNoIG11c3QgaG9sZCBhIHJlZ3VsYXJcbmV4cHJlc3Npb24sIHRoZSBsaW5lIGF0IHRoZSBjdXJzb3Igd2lsbCBiZSByZWluZGVudGVkIHdoZW5ldmVyIG5ld1xudGV4dCBpcyB0eXBlZCBhbmQgdGhlIGlucHV0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHVwIHRvIHRoZVxuY3Vyc29yIG1hdGNoZXMgdGhhdCByZWdleHAuXG5cblRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlaW5kZW50cywgaXQgaXMgcmVjb21tZW5kZWQgdG8gc3RhcnQgdGhlXG5yZWdleHAgd2l0aCBgXmAgKHVzdWFsbHkgZm9sbG93ZWQgYnkgYFxccypgKSwgYW5kIGVuZCBpdCB3aXRoIGAkYC5cbkZvciBleGFtcGxlLCBgL15cXHMqXFx9JC9gIHdpbGwgcmVpbmRlbnQgd2hlbiBhIGNsb3NpbmcgYnJhY2UgaXNcbmFkZGVkIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUuXG4qL1xuZnVuY3Rpb24gaW5kZW50T25JbnB1dCgpIHtcbiAgICByZXR1cm4gRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIub2YodHIgPT4ge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgfHwgIXRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSAmJiAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC5jb21wbGV0ZVwiKSlcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IHJ1bGVzID0gdHIuc3RhcnRTdGF0ZS5sYW5ndWFnZURhdGFBdChcImluZGVudE9uSW5wdXRcIiwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgaWYgKCFydWxlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBkb2MgPSB0ci5uZXdEb2MsIHsgaGVhZCB9ID0gdHIubmV3U2VsZWN0aW9uLm1haW4sIGxpbmUgPSBkb2MubGluZUF0KGhlYWQpO1xuICAgICAgICBpZiAoaGVhZCA+IGxpbmUuZnJvbSArIERvbnRJbmRlbnRCZXlvbmQpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBkb2Muc2xpY2VTdHJpbmcobGluZS5mcm9tLCBoZWFkKTtcbiAgICAgICAgaWYgKCFydWxlcy5zb21lKHIgPT4gci50ZXN0KGxpbmVTdGFydCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGxhc3QgPSAtMSwgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3QpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsYXN0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKHN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgICAgICBpZiAoY3VyICE9IG5vcm0pXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmxlbmd0aCA/IFt0ciwgeyBjaGFuZ2VzLCBzZXF1ZW50aWFsOiB0cnVlIH1dIDogdHI7XG4gICAgfSk7XG59XG5cbi8qKlxuQSBmYWNldCB0aGF0IHJlZ2lzdGVycyBhIGNvZGUgZm9sZGluZyBzZXJ2aWNlLiBXaGVuIGNhbGxlZCB3aXRoXG50aGUgZXh0ZW50IG9mIGEgbGluZSwgc3VjaCBhIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmb2xkYWJsZVxucmFuZ2UgdGhhdCBzdGFydHMgb24gdGhhdCBsaW5lIChidXQgY29udGludWVzIGJleW9uZCBpdCksIGlmIG9uZVxuY2FuIGJlIGZvdW5kLlxuKi9cbmNvbnN0IGZvbGRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5UaGlzIG5vZGUgcHJvcCBpcyB1c2VkIHRvIGFzc29jaWF0ZSBmb2xkaW5nIGluZm9ybWF0aW9uIHdpdGhcbnN5bnRheCBub2RlIHR5cGVzLiBHaXZlbiBhIHN5bnRheCBub2RlLCBpdCBzaG91bGQgY2hlY2sgd2hldGhlclxudGhhdCB0cmVlIGlzIGZvbGRhYmxlIGFuZCByZXR1cm4gdGhlIHJhbmdlIHRoYXQgY2FuIGJlIGNvbGxhcHNlZFxud2hlbiBpdCBpcy5cbiovXG5jb25zdCBmb2xkTm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbltGb2xkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgZnVuY3Rpb24gdGhhdCBmb2xkcyBldmVyeXRoaW5nIGJ1dFxudGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBjaGlsZCBvZiBhIHN5bnRheCBub2RlLiBVc2VmdWwgZm9yIG5vZGVzXG50aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCBkZWxpbWl0ZXJzLlxuKi9cbmZ1bmN0aW9uIGZvbGRJbnNpZGUobm9kZSkge1xuICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZCwgbGFzdCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC50byA8IGxhc3QuZnJvbSA/IHsgZnJvbTogZmlyc3QudG8sIHRvOiBsYXN0LnR5cGUuaXNFcnJvciA/IG5vZGUudG8gOiBsYXN0LmZyb20gfSA6IG51bGw7XG59XG5mdW5jdGlvbiBzeW50YXhGb2xkaW5nKHN0YXRlLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKTtcbiAgICBpZiAodHJlZS5sZW5ndGggPCBlbmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzdGFjayA9IHRyZWUucmVzb2x2ZVN0YWNrKGVuZCwgMSk7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBmb3IgKGxldCBpdGVyID0gc3RhY2s7IGl0ZXI7IGl0ZXIgPSBpdGVyLm5leHQpIHtcbiAgICAgICAgbGV0IGN1ciA9IGl0ZXIubm9kZTtcbiAgICAgICAgaWYgKGN1ci50byA8PSBlbmQgfHwgY3VyLmZyb20gPiBlbmQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGZvdW5kICYmIGN1ci5mcm9tIDwgc3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IHByb3AgPSBjdXIudHlwZS5wcm9wKGZvbGROb2RlUHJvcCk7XG4gICAgICAgIGlmIChwcm9wICYmIChjdXIudG8gPCB0cmVlLmxlbmd0aCAtIDUwIHx8IHRyZWUubGVuZ3RoID09IHN0YXRlLmRvYy5sZW5ndGggfHwgIWlzVW5maW5pc2hlZChjdXIpKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcChjdXIsIHN0YXRlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5mcm9tIDw9IGVuZCAmJiB2YWx1ZS5mcm9tID49IHN0YXJ0ICYmIHZhbHVlLnRvID4gZW5kKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gaXNVbmZpbmlzaGVkKG5vZGUpIHtcbiAgICBsZXQgY2ggPSBub2RlLmxhc3RDaGlsZDtcbiAgICByZXR1cm4gY2ggJiYgY2gudG8gPT0gbm9kZS50byAmJiBjaC50eXBlLmlzRXJyb3I7XG59XG4vKipcbkNoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIGxpbmUgaXMgZm9sZGFibGUuIEZpcnN0IGFza3MgYW55IGZvbGRcbnNlcnZpY2VzIHJlZ2lzdGVyZWQgdGhyb3VnaFxuW2Bmb2xkU2VydmljZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZFNlcnZpY2UpLCBhbmQgaWYgbm9uZSBvZiB0aGVtIHJldHVyblxuYSByZXN1bHQsIHRyaWVzIHRvIHF1ZXJ5IHRoZSBbZm9sZCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgb2Ygc3ludGF4IG5vZGVzIHRoYXQgY292ZXIgdGhlIGVuZFxub2YgdGhlIGxpbmUuXG4qL1xuZnVuY3Rpb24gZm9sZGFibGUoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCkge1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2Ygc3RhdGUuZmFjZXQoZm9sZFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN5bnRheEZvbGRpbmcoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG59XG5mdW5jdGlvbiBtYXBSYW5nZShyYW5nZSwgbWFwcGluZykge1xuICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBQb3MocmFuZ2UuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBQb3MocmFuZ2UudG8sIC0xKTtcbiAgICByZXR1cm4gZnJvbSA+PSB0byA/IHVuZGVmaW5lZCA6IHsgZnJvbSwgdG8gfTtcbn1cbi8qKlxuU3RhdGUgZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gZm9sZCB0aGVcbmdpdmVuIHJhbmdlLiAoWW91IHByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIGluIGV4Y2VwdGlvbmFsXG5jaXJjdW1zdGFuY2VzXHUyMDE0dXN1YWxseSB5b3UnbGwganVzdCB3YW50IHRvIGxldFxuW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpIGFuZCB0aGUgW2ZvbGRcbmd1dHRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkR3V0dGVyKSBjcmVhdGUgdGhlIHRyYW5zYWN0aW9ucy4pXG4qL1xuY29uc3QgZm9sZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6IG1hcFJhbmdlIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCB1bmZvbGRzIHRoZSBnaXZlbiByYW5nZSAoaWYgaXQgd2FzIGZvbGRlZCkuXG4qL1xuY29uc3QgdW5mb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVzKHZpZXcpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgaWYgKGxpbmVzLnNvbWUobCA9PiBsLmZyb20gPD0gaGVhZCAmJiBsLnRvID49IGhlYWQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxpbmVzLnB1c2godmlldy5saW5lQmxvY2tBdChoZWFkKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cbi8qKlxuVGhlIHN0YXRlIGZpZWxkIHRoYXQgc3RvcmVzIHRoZSBmb2xkZWQgcmFuZ2VzIChhcyBhIFtkZWNvcmF0aW9uXG5zZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uU2V0KSkuIENhbiBiZSBwYXNzZWQgdG9cbltgRWRpdG9yU3RhdGUudG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIGFuZFxuW2Bmcm9tSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeZnJvbUpTT04pIHRvIHNlcmlhbGl6ZSB0aGUgZm9sZFxuc3RhdGUuXG4qL1xuY29uc3QgZm9sZFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfSxcbiAgICB1cGRhdGUoZm9sZGVkLCB0cikge1xuICAgICAgICBpZiAodHIuaXNVc2VyRXZlbnQoXCJkZWxldGVcIikpXG4gICAgICAgICAgICB0ci5jaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BKSA9PiBmb2xkZWQgPSBjbGVhclRvdWNoZWRGb2xkcyhmb2xkZWQsIGZyb21BLCB0b0EpKTtcbiAgICAgICAgZm9sZGVkID0gZm9sZGVkLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZS5pcyhmb2xkRWZmZWN0KSAmJiAhZm9sZEV4aXN0cyhmb2xkZWQsIGUudmFsdWUuZnJvbSwgZS52YWx1ZS50bykpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBwcmVwYXJlUGxhY2Vob2xkZXIgfSA9IHRyLnN0YXRlLmZhY2V0KGZvbGRDb25maWcpO1xuICAgICAgICAgICAgICAgIGxldCB3aWRnZXQgPSAhcHJlcGFyZVBsYWNlaG9sZGVyID8gZm9sZFdpZGdldCA6XG4gICAgICAgICAgICAgICAgICAgIERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFByZXBhcmVkRm9sZFdpZGdldChwcmVwYXJlUGxhY2Vob2xkZXIodHIuc3RhdGUsIGUudmFsdWUpKSB9KTtcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgYWRkOiBbd2lkZ2V0LnJhbmdlKGUudmFsdWUuZnJvbSwgZS52YWx1ZS50byldIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5pcyh1bmZvbGRFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGZpbHRlcjogKGZyb20sIHRvKSA9PiBlLnZhbHVlLmZyb20gIT0gZnJvbSB8fCBlLnZhbHVlLnRvICE9IHRvLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcm9tOiBlLnZhbHVlLmZyb20sIGZpbHRlclRvOiBlLnZhbHVlLnRvIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGZvbGRlZCByYW5nZXMgdGhhdCBjb3ZlciB0aGUgc2VsZWN0aW9uIGhlYWRcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIGZvbGRlZCA9IGNsZWFyVG91Y2hlZEZvbGRzKGZvbGRlZCwgdHIuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIHJldHVybiBmb2xkZWQ7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKSxcbiAgICB0b0pTT04oZm9sZGVkLCBzdGF0ZSkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvbGRlZC5iZXR3ZWVuKDAsIHN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyByYW5nZXMucHVzaChmcm9tLCB0byk7IH0pO1xuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH0sXG4gICAgZnJvbUpTT04odmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggJSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZhbHVlW2krK10sIHRvID0gdmFsdWVbaSsrXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiB0byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIGZvciBmb2xkIHN0YXRlXCIpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goZm9sZFdpZGdldC5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChyYW5nZXMsIHRydWUpO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gY2xlYXJUb3VjaGVkRm9sZHMoZm9sZGVkLCBmcm9tLCB0byA9IGZyb20pIHtcbiAgICBsZXQgdG91Y2hlZCA9IGZhbHNlO1xuICAgIGZvbGRlZC5iZXR3ZWVuKGZyb20sIHRvLCAoYSwgYikgPT4geyBpZiAoYSA8IHRvICYmIGIgPiBmcm9tKVxuICAgICAgICB0b3VjaGVkID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuICF0b3VjaGVkID8gZm9sZGVkIDogZm9sZGVkLnVwZGF0ZSh7XG4gICAgICAgIGZpbHRlckZyb206IGZyb20sXG4gICAgICAgIGZpbHRlclRvOiB0byxcbiAgICAgICAgZmlsdGVyOiAoYSwgYikgPT4gYSA+PSB0byB8fCBiIDw9IGZyb21cbiAgICB9KTtcbn1cbi8qKlxuR2V0IGEgW3JhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldCkgY29udGFpbmluZyB0aGUgZm9sZGVkIHJhbmdlc1xuaW4gdGhlIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZvbGRlZFJhbmdlcyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fCBSYW5nZVNldC5lbXB0eTtcbn1cbmZ1bmN0aW9uIGZpbmRGb2xkKHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIChfYSA9IHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmV0d2Vlbihmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGlmICghZm91bmQgfHwgZm91bmQuZnJvbSA+IGZyb20pXG4gICAgICAgICAgICBmb3VuZCA9IHsgZnJvbSwgdG8gfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBmb2xkRXhpc3RzKGZvbGRlZCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb2xkZWQuYmV0d2Vlbihmcm9tLCBmcm9tLCAoYSwgYikgPT4geyBpZiAoYSA9PSBmcm9tICYmIGIgPT0gdG8pXG4gICAgICAgIGZvdW5kID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gbWF5YmVFbmFibGUoc3RhdGUsIG90aGVyKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpID8gb3RoZXIgOiBvdGhlci5jb25jYXQoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGNvZGVGb2xkaW5nKCkpKTtcbn1cbi8qKlxuRm9sZCB0aGUgbGluZXMgdGhhdCBhcmUgc2VsZWN0ZWQsIGlmIHBvc3NpYmxlLlxuKi9cbmNvbnN0IGZvbGRDb2RlID0gdmlldyA9PiB7XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIFtmb2xkRWZmZWN0Lm9mKHJhbmdlKSwgYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlKV0pIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuVW5mb2xkIGZvbGRlZCByYW5nZXMgb24gc2VsZWN0ZWQgbGluZXMuXG4qL1xuY29uc3QgdW5mb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGlmICghdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgIHJldHVybiBlZmZlY3RzLmxlbmd0aCA+IDA7XG59O1xuZnVuY3Rpb24gYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlLCBmb2xkID0gdHJ1ZSkge1xuICAgIGxldCBsaW5lRnJvbSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKS5udW1iZXIsIGxpbmVUbyA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50bykubnVtYmVyO1xuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKGZvbGQgPyBcIkZvbGRlZCBsaW5lc1wiIDogXCJVbmZvbGRlZCBsaW5lc1wiKX0gJHtsaW5lRnJvbX0gJHt2aWV3LnN0YXRlLnBocmFzZShcInRvXCIpfSAke2xpbmVUb30uYCk7XG59XG4vKipcbkZvbGQgYWxsIHRvcC1sZXZlbCBmb2xkYWJsZSByYW5nZXMuIE5vdGUgdGhhdCwgaW4gbW9zdCBjYXNlcyxcbmZvbGRpbmcgaW5mb3JtYXRpb24gd2lsbCBkZXBlbmQgb24gdGhlIFtzeW50YXhcbnRyZWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4VHJlZSksIGFuZCBmb2xkaW5nIGV2ZXJ5dGhpbmcgbWF5IG5vdCB3b3JrXG5yZWxpYWJseSB3aGVuIHRoZSBkb2N1bWVudCBoYXNuJ3QgYmVlbiBmdWxseSBwYXJzZWQgKGVpdGhlclxuYmVjYXVzZSB0aGUgZWRpdG9yIHN0YXRlIHdhcyBvbmx5IGp1c3QgaW5pdGlhbGl6ZWQsIG9yIGJlY2F1c2UgdGhlXG5kb2N1bWVudCBpcyBzbyBiaWcgdGhhdCB0aGUgcGFyc2VyIGRlY2lkZWQgbm90IHRvIHBhcnNlIGl0XG5lbnRpcmVseSkuXG4qL1xuY29uc3QgZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgc3RhdGUuZG9jLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyksIHJhbmdlID0gZm9sZGFibGUoc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKHJhbmdlKSk7XG4gICAgICAgIHBvcyA9IChyYW5nZSA/IHZpZXcubGluZUJsb2NrQXQocmFuZ2UudG8pIDogbGluZSkudG8gKyAxO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBlZmZlY3RzKSB9KTtcbiAgICByZXR1cm4gISFlZmZlY3RzLmxlbmd0aDtcbn07XG4vKipcblVuZm9sZCBhbGwgZm9sZGVkIGNvZGUuXG4qL1xuY29uc3QgdW5mb2xkQWxsID0gdmlldyA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5zaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmaWVsZC5iZXR3ZWVuKDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoeyBmcm9tLCB0byB9KSk7IH0pO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8vIEZpbmQgdGhlIGZvbGRhYmxlIHJlZ2lvbiBjb250YWluaW5nIHRoZSBnaXZlbiBsaW5lLCBpZiBvbmUgZXhpc3RzXG5mdW5jdGlvbiBmb2xkYWJsZUNvbnRhaW5lcih2aWV3LCBsaW5lQmxvY2spIHtcbiAgICAvLyBMb29rIGJhY2t3YXJkcyB0aHJvdWdoIGxpbmUgYmxvY2tzIHVudGlsIHdlIGZpbmQgYSBmb2xkYWJsZSByZWdpb24gdGhhdFxuICAgIC8vIGludGVyc2VjdHMgd2l0aCB0aGUgbGluZVxuICAgIGZvciAobGV0IGxpbmUgPSBsaW5lQmxvY2s7Oykge1xuICAgICAgICBsZXQgZm9sZGFibGVSZWdpb24gPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGFibGVSZWdpb24gJiYgZm9sZGFibGVSZWdpb24udG8gPiBsaW5lQmxvY2suZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBmb2xkYWJsZVJlZ2lvbjtcbiAgICAgICAgaWYgKCFsaW5lLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGluZSA9IHZpZXcubGluZUJsb2NrQXQobGluZS5mcm9tIC0gMSk7XG4gICAgfVxufVxuLyoqXG5Ub2dnbGUgZm9sZGluZyBhdCBjdXJzb3JzLiBVbmZvbGRzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGZvbGRcbnN0YXJ0aW5nIGluIHRoYXQgbGluZSwgdHJpZXMgdG8gZmluZCBhIGZvbGRhYmxlIHJhbmdlIGFyb3VuZCBpdFxub3RoZXJ3aXNlLlxuKi9cbmNvbnN0IHRvZ2dsZUZvbGQgPSAodmlldykgPT4ge1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkZWQsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm9sZFJhbmdlID0gZm9sZGFibGVDb250YWluZXIodmlldywgbGluZSk7XG4gICAgICAgICAgICBpZiAoZm9sZFJhbmdlKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKGZvbGRSYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkUmFuZ2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGggPiAwKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLyoqXG5EZWZhdWx0IGZvbGQtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIEN0cmwtU2hpZnQtWyAoQ21kLUFsdC1bIG9uIG1hY09TKTogW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpLlxuIC0gQ3RybC1TaGlmdC1dIChDbWQtQWx0LV0gb24gbWFjT1MpOiBbYHVuZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnVuZm9sZENvZGUpLlxuIC0gQ3RybC1BbHQtWzogW2Bmb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQWxsKS5cbiAtIEN0cmwtQWx0LV06IFtgdW5mb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRBbGwpLlxuKi9cbmNvbnN0IGZvbGRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1bXCIsIG1hYzogXCJDbWQtQWx0LVtcIiwgcnVuOiBmb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtXVwiLCBtYWM6IFwiQ21kLUFsdC1dXCIsIHJ1bjogdW5mb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LVtcIiwgcnVuOiBmb2xkQWxsIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtXVwiLCBydW46IHVuZm9sZEFsbCB9XG5dO1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBwbGFjZWhvbGRlckRPTTogbnVsbCxcbiAgICBwcmVwYXJlUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgcGxhY2Vob2xkZXJUZXh0OiBcIlx1MjAyNlwiXG59O1xuY29uc3QgZm9sZENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiBjb21iaW5lQ29uZmlnKHZhbHVlcywgZGVmYXVsdENvbmZpZyk7IH1cbn0pO1xuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyBjb2RlIGZvbGRpbmcuXG4qL1xuZnVuY3Rpb24gY29kZUZvbGRpbmcoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtmb2xkU3RhdGUsIGJhc2VUaGVtZSQxXTtcbiAgICBpZiAoY29uZmlnKVxuICAgICAgICByZXN1bHQucHVzaChmb2xkQ29uZmlnLm9mKGNvbmZpZykpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3aWRnZXRUb0RPTSh2aWV3LCBwcmVwYXJlZCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoZm9sZENvbmZpZyk7XG4gICAgbGV0IG9uY2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHZpZXcucG9zQXRET00oZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgaWYgKGNvbmYucGxhY2Vob2xkZXJET00pXG4gICAgICAgIHJldHVybiBjb25mLnBsYWNlaG9sZGVyRE9NKHZpZXcsIG9uY2xpY2ssIHByZXBhcmVkKTtcbiAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBjb25mLnBsYWNlaG9sZGVyVGV4dDtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc3RhdGUucGhyYXNlKFwiZm9sZGVkIGNvZGVcIikpO1xuICAgIGVsZW1lbnQudGl0bGUgPSBzdGF0ZS5waHJhc2UoXCJ1bmZvbGRcIik7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImNtLWZvbGRQbGFjZWhvbGRlclwiO1xuICAgIGVsZW1lbnQub25jbGljayA9IG9uY2xpY2s7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5jb25zdCBmb2xkV2lkZ2V0ID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgICAgICB0b0RPTSh2aWV3KSB7IHJldHVybiB3aWRnZXRUb0RPTSh2aWV3LCBudWxsKTsgfVxuICAgIH0gfSk7XG5jbGFzcyBQcmVwYXJlZEZvbGRXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLnZhbHVlID09IG90aGVyLnZhbHVlOyB9XG4gICAgdG9ET00odmlldykgeyByZXR1cm4gd2lkZ2V0VG9ET00odmlldywgdGhpcy52YWx1ZSk7IH1cbn1cbmNvbnN0IGZvbGRHdXR0ZXJEZWZhdWx0cyA9IHtcbiAgICBvcGVuVGV4dDogXCJcdTIzMDRcIixcbiAgICBjbG9zZWRUZXh0OiBcIlx1MjAzQVwiLFxuICAgIG1hcmtlckRPTTogbnVsbCxcbiAgICBkb21FdmVudEhhbmRsZXJzOiB7fSxcbiAgICBmb2xkaW5nQ2hhbmdlZDogKCkgPT4gZmFsc2Vcbn07XG5jbGFzcyBGb2xkTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIG9wZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNvbmZpZyA9PSBvdGhlci5jb25maWcgJiYgdGhpcy5vcGVuID09IG90aGVyLm9wZW47IH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXJrZXJET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWFya2VyRE9NKHRoaXMub3Blbik7XG4gICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLm9wZW4gPyB0aGlzLmNvbmZpZy5vcGVuVGV4dCA6IHRoaXMuY29uZmlnLmNsb3NlZFRleHQ7XG4gICAgICAgIHNwYW4udGl0bGUgPSB2aWV3LnN0YXRlLnBocmFzZSh0aGlzLm9wZW4gPyBcIkZvbGQgbGluZVwiIDogXCJVbmZvbGQgbGluZVwiKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIGEgZm9sZCBndXR0ZXIsIHdoaWNoIHNob3dzIGFcbmZvbGQgc3RhdHVzIGluZGljYXRvciBiZWZvcmUgZm9sZGFibGUgbGluZXMgKHdoaWNoIGNhbiBiZSBjbGlja2VkXG50byBmb2xkIG9yIHVuZm9sZCB0aGUgbGluZSkuXG4qL1xuZnVuY3Rpb24gZm9sZEd1dHRlcihjb25maWcgPSB7fSkge1xuICAgIGxldCBmdWxsQ29uZmlnID0geyAuLi5mb2xkR3V0dGVyRGVmYXVsdHMsIC4uLmNvbmZpZyB9O1xuICAgIGxldCBjYW5Gb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgdHJ1ZSksIGNhblVuZm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcbiAgICBsZXQgbWFya2VycyA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdmlldy52aWV3cG9ydC5mcm9tO1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsYW5ndWFnZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSB8fFxuICAgICAgICAgICAgICAgIHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpICE9IHVwZGF0ZS5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgIHN5bnRheFRyZWUodXBkYXRlLnN0YXJ0U3RhdGUpICE9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSB8fFxuICAgICAgICAgICAgICAgIGZ1bGxDb25maWcuZm9sZGluZ0NoYW5nZWQodXBkYXRlKSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh1cGRhdGUudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRNYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgbGluZSBvZiB2aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKSA/IGNhblVuZm9sZFxuICAgICAgICAgICAgICAgICAgICA6IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5Gb2xkIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobWFyaylcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQobGluZS5mcm9tLCBsaW5lLmZyb20sIG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgeyBkb21FdmVudEhhbmRsZXJzIH0gPSBmdWxsQ29uZmlnO1xuICAgIHJldHVybiBbXG4gICAgICAgIG1hcmtlcnMsXG4gICAgICAgIGd1dHRlcih7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1mb2xkR3V0dGVyXCIsXG4gICAgICAgICAgICBtYXJrZXJzKHZpZXcpIHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKG1hcmtlcnMpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya2VycykgfHwgUmFuZ2VTZXQuZW1wdHk7IH0sXG4gICAgICAgICAgICBpbml0aWFsU3BhY2VyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tRXZlbnRIYW5kbGVyczoge1xuICAgICAgICAgICAgICAgIC4uLmRvbUV2ZW50SGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgY2xpY2s6ICh2aWV3LCBsaW5lLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRIYW5kbGVycy5jbGljayAmJiBkb21FdmVudEhhbmRsZXJzLmNsaWNrKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZm9sZEVmZmVjdC5vZihyYW5nZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgY29kZUZvbGRpbmcoKVxuICAgIF07XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZm9sZFBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZWVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIi4yZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjAgMXB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZm9sZEd1dHRlciBzcGFuXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfVxufSk7XG5cbi8qKlxuQSBoaWdobGlnaHQgc3R5bGUgYXNzb2NpYXRlcyBDU1Mgc3R5bGVzIHdpdGggaGlnaGxpZ2h0aW5nXG5bdGFnc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNoaWdobGlnaHQuVGFnKS5cbiovXG5jbGFzcyBIaWdobGlnaHRTdHlsZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHRhZyBzdHlsZXMgdXNlZCB0byBjcmVhdGUgdGhpcyBoaWdobGlnaHQgc3R5bGUuXG4gICAgKi9cbiAgICBzcGVjcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgIGxldCBtb2RTcGVjO1xuICAgICAgICBmdW5jdGlvbiBkZWYoc3BlYykge1xuICAgICAgICAgICAgbGV0IGNscyA9IFN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbiAgICAgICAgICAgIChtb2RTcGVjIHx8IChtb2RTcGVjID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpW1wiLlwiICsgY2xzXSA9IHNwZWM7XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbCA9IHR5cGVvZiBvcHRpb25zLmFsbCA9PSBcInN0cmluZ1wiID8gb3B0aW9ucy5hbGwgOiBvcHRpb25zLmFsbCA/IGRlZihvcHRpb25zLmFsbCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNjb3BlT3B0ID0gb3B0aW9ucy5zY29wZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlT3B0IGluc3RhbmNlb2YgTGFuZ3VhZ2UgPyAodHlwZSkgPT4gdHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHNjb3BlT3B0LmRhdGFcbiAgICAgICAgICAgIDogc2NvcGVPcHQgPyAodHlwZSkgPT4gdHlwZSA9PSBzY29wZU9wdCA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHRhZ0hpZ2hsaWdodGVyKHNwZWNzLm1hcChzdHlsZSA9PiAoe1xuICAgICAgICAgICAgdGFnOiBzdHlsZS50YWcsXG4gICAgICAgICAgICBjbGFzczogc3R5bGUuY2xhc3MgfHwgZGVmKE9iamVjdC5hc3NpZ24oe30sIHN0eWxlLCB7IHRhZzogbnVsbCB9KSlcbiAgICAgICAgfSkpLCB7XG4gICAgICAgICAgICBhbGwsXG4gICAgICAgIH0pLnN0eWxlO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZFNwZWMgPyBuZXcgU3R5bGVNb2R1bGUobW9kU3BlYykgOiBudWxsO1xuICAgICAgICB0aGlzLnRoZW1lVHlwZSA9IG9wdGlvbnMudGhlbWVUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBoaWdobGlnaHRlciBzdHlsZSB0aGF0IGFzc29jaWF0ZXMgdGhlIGdpdmVuIHN0eWxlcyB0b1xuICAgIHRoZSBnaXZlbiB0YWdzLiBUaGUgc3BlY3MgbXVzdCBiZSBvYmplY3RzIHRoYXQgaG9sZCBhIHN0eWxlIHRhZ1xuICAgIG9yIGFycmF5IG9mIHRhZ3MgaW4gdGhlaXIgYHRhZ2AgcHJvcGVydHksIGFuZCBlaXRoZXIgYSBzaW5nbGVcbiAgICBgY2xhc3NgIHByb3BlcnR5IHByb3ZpZGluZyBhIHN0YXRpYyBDU1MgY2xhc3MgKGZvciBoaWdobGlnaHRlclxuICAgIHRoYXQgcmVseSBvbiBleHRlcm5hbCBzdHlsaW5nKSwgb3IgYVxuICAgIFtgc3R5bGUtbW9kYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pLXN0eWxlXG4gICAgc2V0IG9mIENTUyBwcm9wZXJ0aWVzICh3aGljaCBkZWZpbmUgdGhlIHN0eWxpbmcgZm9yIHRob3NlIHRhZ3MpLlxuICAgIFxuICAgIFRoZSBDU1MgcnVsZXMgY3JlYXRlZCBmb3IgYSBoaWdobGlnaHRlciB3aWxsIGJlIGVtaXR0ZWQgaW4gdGhlXG4gICAgb3JkZXIgb2YgdGhlIHNwZWMncyBwcm9wZXJ0aWVzLiBUaGF0IG1lYW5zIHRoYXQgZm9yIGVsZW1lbnRzIHRoYXRcbiAgICBoYXZlIG11bHRpcGxlIHRhZ3MgYXNzb2NpYXRlZCB3aXRoIHRoZW0sIHN0eWxlcyBkZWZpbmVkIGZ1cnRoZXJcbiAgICBkb3duIGluIHRoZSBsaXN0IHdpbGwgaGF2ZSBhIGhpZ2hlciBDU1MgcHJlY2VkZW5jZSB0aGFuIHN0eWxlc1xuICAgIGRlZmluZWQgZWFybGllci5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaWdobGlnaHRTdHlsZShzcGVjcywgb3B0aW9ucyB8fCB7fSk7XG4gICAgfVxufVxuY29uc3QgaGlnaGxpZ2h0ZXJGYWNldCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGZhbGxiYWNrSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gdmFsdWVzLmxlbmd0aCA/IFt2YWx1ZXNbMF1dIDogbnVsbDsgfVxufSk7XG5mdW5jdGlvbiBnZXRIaWdobGlnaHRlcnMoc3RhdGUpIHtcbiAgICBsZXQgbWFpbiA9IHN0YXRlLmZhY2V0KGhpZ2hsaWdodGVyRmFjZXQpO1xuICAgIHJldHVybiBtYWluLmxlbmd0aCA/IG1haW4gOiBzdGF0ZS5mYWNldChmYWxsYmFja0hpZ2hsaWdodGVyKTtcbn1cbi8qKlxuV3JhcCBhIGhpZ2hsaWdodGVyIGluIGFuIGVkaXRvciBleHRlbnNpb24gdGhhdCB1c2VzIGl0IHRvIGFwcGx5XG5zeW50YXggaGlnaGxpZ2h0aW5nIHRvIHRoZSBlZGl0b3IgY29udGVudC5cblxuV2hlbiBtdWx0aXBsZSAobm9uLWZhbGxiYWNrKSBzdHlsZXMgYXJlIHByb3ZpZGVkLCB0aGUgc3R5bGluZ1xuYXBwbGllZCBpcyB0aGUgdW5pb24gb2YgdGhlIGNsYXNzZXMgdGhleSBlbWl0LlxuKi9cbmZ1bmN0aW9uIHN5bnRheEhpZ2hsaWdodGluZyhoaWdobGlnaHRlciwgb3B0aW9ucykge1xuICAgIGxldCBleHQgPSBbdHJlZUhpZ2hsaWdodGVyXSwgdGhlbWVUeXBlO1xuICAgIGlmIChoaWdobGlnaHRlciBpbnN0YW5jZW9mIEhpZ2hsaWdodFN0eWxlKSB7XG4gICAgICAgIGlmIChoaWdobGlnaHRlci5tb2R1bGUpXG4gICAgICAgICAgICBleHQucHVzaChFZGl0b3JWaWV3LnN0eWxlTW9kdWxlLm9mKGhpZ2hsaWdodGVyLm1vZHVsZSkpO1xuICAgICAgICB0aGVtZVR5cGUgPSBoaWdobGlnaHRlci50aGVtZVR5cGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2spXG4gICAgICAgIGV4dC5wdXNoKGZhbGxiYWNrSGlnaGxpZ2h0ZXIub2YoaGlnaGxpZ2h0ZXIpKTtcbiAgICBlbHNlIGlmICh0aGVtZVR5cGUpXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodGVyRmFjZXQuY29tcHV0ZU4oW0VkaXRvclZpZXcuZGFya1RoZW1lXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZhY2V0KEVkaXRvclZpZXcuZGFya1RoZW1lKSA9PSAodGhlbWVUeXBlID09IFwiZGFya1wiKSA/IFtoaWdobGlnaHRlcl0gOiBbXTtcbiAgICAgICAgfSkpO1xuICAgIGVsc2VcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5vZihoaWdobGlnaHRlcikpO1xuICAgIHJldHVybiBleHQ7XG59XG4vKipcblJldHVybnMgdGhlIENTUyBjbGFzc2VzIChpZiBhbnkpIHRoYXQgdGhlIGhpZ2hsaWdodGVycyBhY3RpdmUgaW5cbnRoZSBzdGF0ZSB3b3VsZCBhc3NpZ24gdG8gdGhlIGdpdmVuIHN0eWxlXG5bdGFnc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNoaWdobGlnaHQuVGFnKSBhbmRcbihvcHRpb25hbCkgbGFuZ3VhZ2VcbltzY29wZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5IaWdobGlnaHRTdHlsZV5kZWZpbmVeb3B0aW9ucy5zY29wZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0aW5nRm9yKHN0YXRlLCB0YWdzLCBzY29wZSkge1xuICAgIGxldCBoaWdobGlnaHRlcnMgPSBnZXRIaWdobGlnaHRlcnMoc3RhdGUpO1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmIChoaWdobGlnaHRlcnMpXG4gICAgICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICAgICAgaWYgKCFoaWdobGlnaHRlci5zY29wZSB8fCBzY29wZSAmJiBoaWdobGlnaHRlci5zY29wZShzY29wZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xzID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyBjbHMgOiBjbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgVHJlZUhpZ2hsaWdodGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMubWFya0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy50cmVlID0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKHZpZXcsIGdldEhpZ2hsaWdodGVycyh2aWV3LnN0YXRlKSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGVkVG8gPSB2aWV3LnZpZXdwb3J0LnRvO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpLCBoaWdobGlnaHRlcnMgPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXRlKTtcbiAgICAgICAgbGV0IHN0eWxlQ2hhbmdlID0gaGlnaGxpZ2h0ZXJzICE9IGdldEhpZ2hsaWdodGVycyh1cGRhdGUuc3RhcnRTdGF0ZSk7XG4gICAgICAgIGxldCB7IHZpZXdwb3J0IH0gPSB1cGRhdGUudmlldywgZGVjb3JhdGVkVG9NYXBwZWQgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5kZWNvcmF0ZWRUbywgMSk7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA8IHZpZXdwb3J0LnRvICYmICFzdHlsZUNoYW5nZSAmJiB0cmVlLnR5cGUgPT0gdGhpcy50cmVlLnR5cGUgJiYgZGVjb3JhdGVkVG9NYXBwZWQgPj0gdmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlZFRvID0gZGVjb3JhdGVkVG9NYXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBzdHlsZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh1cGRhdGUudmlldywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGVkVG8gPSB2aWV3cG9ydC50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZERlY28odmlldywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGlmICghaGlnaGxpZ2h0ZXJzIHx8ICF0aGlzLnRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodFRyZWUodGhpcy50cmVlLCBoaWdobGlnaHRlcnMsIChmcm9tLCB0bywgc3R5bGUpID0+IHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgdGhpcy5tYXJrQ2FjaGVbc3R5bGVdIHx8ICh0aGlzLm1hcmtDYWNoZVtzdHlsZV0gPSBEZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogc3R5bGUgfSkpKTtcbiAgICAgICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59XG5jb25zdCB0cmVlSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoKC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhUcmVlSGlnaGxpZ2h0ZXIsIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KSk7XG4vKipcbkEgZGVmYXVsdCBoaWdobGlnaHQgc3R5bGUgKHdvcmtzIHdlbGwgd2l0aCBsaWdodCB0aGVtZXMpLlxuKi9cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRTdHlsZSA9IC8qQF9fUFVSRV9fKi9IaWdobGlnaHRTdHlsZS5kZWZpbmUoW1xuICAgIHsgdGFnOiB0YWdzLm1ldGEsXG4gICAgICAgIGNvbG9yOiBcIiM0MDQ3NDBcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpbmssXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsXG4gICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpa2V0aHJvdWdoLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJsaW5lLXRocm91Z2hcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsXG4gICAgICAgIGNvbG9yOiBcIiM3MDhcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIHRhZ3MudXJsLCB0YWdzLmNvbnRlbnRTZXBhcmF0b3IsIHRhZ3MubGFiZWxOYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzIxOVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLmxpdGVyYWwsIHRhZ3MuaW5zZXJ0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjMTY0XCIgfSxcbiAgICB7IHRhZzogW3RhZ3Muc3RyaW5nLCB0YWdzLmRlbGV0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjYTExXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLFxuICAgICAgICBjb2xvcjogXCIjZTQwXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMwMGZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMzMGFcIiB9LFxuICAgIHsgdGFnOiBbdGFncy50eXBlTmFtZSwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogXCIjMDg1XCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsXG4gICAgICAgIGNvbG9yOiBcIiMxNjdcIiB9LFxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIHRhZ3MubWFjcm9OYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzI1NlwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBjXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LFxuICAgICAgICBjb2xvcjogXCIjOTQwXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLFxuICAgICAgICBjb2xvcjogXCIjZjAwXCIgfVxuXSk7XG5cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLW1hdGNoaW5nQnJhY2tldFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMzI4YzgyNTJcIiB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1ub25tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2JiNTU1NTQ0XCIgfVxufSk7XG5jb25zdCBEZWZhdWx0U2NhbkRpc3QgPSAxMDAwMCwgRGVmYXVsdEJyYWNrZXRzID0gXCIoKVtde31cIjtcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ0NvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhZnRlckN1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJyYWNrZXRzOiBEZWZhdWx0QnJhY2tldHMsXG4gICAgICAgICAgICBtYXhTY2FuRGlzdGFuY2U6IERlZmF1bHRTY2FuRGlzdCxcbiAgICAgICAgICAgIHJlbmRlck1hdGNoOiBkZWZhdWx0UmVuZGVyTWF0Y2hcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBtYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbWF0Y2hpbmdCcmFja2V0XCIgfSksIG5vbm1hdGNoaW5nTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1ub25tYXRjaGluZ0JyYWNrZXRcIiB9KTtcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNYXRjaChtYXRjaCkge1xuICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgIGxldCBtYXJrID0gbWF0Y2gubWF0Y2hlZCA/IG1hdGNoaW5nTWFyayA6IG5vbm1hdGNoaW5nTWFyaztcbiAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guc3RhcnQuZnJvbSwgbWF0Y2guc3RhcnQudG8pKTtcbiAgICBpZiAobWF0Y2guZW5kKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guZW5kLmZyb20sIG1hdGNoLmVuZC50bykpO1xuICAgIHJldHVybiBkZWNvcmF0aW9ucztcbn1cbmNvbnN0IGJyYWNrZXRNYXRjaGluZ1N0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBEZWNvcmF0aW9uLm5vbmU7IH0sXG4gICAgdXBkYXRlKGRlY28sIHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiAhdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGRlY287XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoYnJhY2tldE1hdGNoaW5nQ29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdHIuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIC0xLCBjb25maWcpXG4gICAgICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPiAwICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgLSAxLCAxLCBjb25maWcpKVxuICAgICAgICAgICAgICAgIHx8IChjb25maWcuYWZ0ZXJDdXJzb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIDEsIGNvbmZpZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYW5nZS5oZWFkIDwgdHIuc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEsIGNvbmZpZykpKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucy5jb25jYXQoY29uZmlnLnJlbmRlck1hdGNoKG1hdGNoLCB0ci5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvcmF0aW9ucywgdHJ1ZSk7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKVxufSk7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdVbmlxdWUgPSBbXG4gICAgYnJhY2tldE1hdGNoaW5nU3RhdGUsXG4gICAgYmFzZVRoZW1lXG5dO1xuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBicmFja2V0IG1hdGNoaW5nLiBXaGVuZXZlciB0aGVcbmN1cnNvciBpcyBuZXh0IHRvIGEgYnJhY2tldCwgdGhhdCBicmFja2V0IGFuZCB0aGUgb25lIGl0IG1hdGNoZXNcbmFyZSBoaWdobGlnaHRlZC4gT3IsIHdoZW4gbm8gbWF0Y2hpbmcgYnJhY2tldCBpcyBmb3VuZCwgYW5vdGhlclxuaGlnaGxpZ2h0aW5nIHN0eWxlIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhpcy5cbiovXG5mdW5jdGlvbiBicmFja2V0TWF0Y2hpbmcoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW2JyYWNrZXRNYXRjaGluZ0NvbmZpZy5vZihjb25maWcpLCBicmFja2V0TWF0Y2hpbmdVbmlxdWVdO1xufVxuLyoqXG5XaGVuIGxhcmdlciBzeW50YXggbm9kZXMsIHN1Y2ggYXMgSFRNTCB0YWdzLCBhcmUgbWFya2VkIGFzXG5vcGVuaW5nL2Nsb3NpbmcsIGl0IGNhbiBiZSBhIGJpdCBtZXNzeSB0byB0cmVhdCB0aGUgd2hvbGUgbm9kZSBhc1xuYSBtYXRjaGFibGUgYnJhY2tldC4gVGhpcyBub2RlIHByb3AgYWxsb3dzIHlvdSB0byBkZWZpbmUsIGZvciBzdWNoXG5hIG5vZGUsIGEgXHUyMDE4aGFuZGxlXHUyMDE5XHUyMDE0dGhlIHBhcnQgb2YgdGhlIG5vZGUgdGhhdCBpcyBoaWdobGlnaHRlZCwgYW5kXG50aGF0IHRoZSBjdXJzb3IgbXVzdCBiZSBvbiB0byBhY3RpdmF0ZSBoaWdobGlnaHRpbmcgaW4gdGhlIGZpcnN0XG5wbGFjZS5cbiovXG5jb25zdCBicmFja2V0TWF0Y2hpbmdIYW5kbGUgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG5mdW5jdGlvbiBtYXRjaGluZ05vZGVzKG5vZGUsIGRpciwgYnJhY2tldHMpIHtcbiAgICBsZXQgYnlQcm9wID0gbm9kZS5wcm9wKGRpciA8IDAgPyBOb2RlUHJvcC5vcGVuZWRCeSA6IE5vZGVQcm9wLmNsb3NlZEJ5KTtcbiAgICBpZiAoYnlQcm9wKVxuICAgICAgICByZXR1cm4gYnlQcm9wO1xuICAgIGlmIChub2RlLm5hbWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gYnJhY2tldHMuaW5kZXhPZihub2RlLm5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSAmJiBpbmRleCAlIDIgPT0gKGRpciA8IDAgPyAxIDogMCkpXG4gICAgICAgICAgICByZXR1cm4gW2JyYWNrZXRzW2luZGV4ICsgZGlyXV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZEhhbmRsZShub2RlKSB7XG4gICAgbGV0IGhhc0hhbmRsZSA9IG5vZGUudHlwZS5wcm9wKGJyYWNrZXRNYXRjaGluZ0hhbmRsZSk7XG4gICAgcmV0dXJuIGhhc0hhbmRsZSA/IGhhc0hhbmRsZShub2RlLm5vZGUpIDogbm9kZTtcbn1cbi8qKlxuRmluZCB0aGUgbWF0Y2hpbmcgYnJhY2tldCBmb3IgdGhlIHRva2VuIGF0IGBwb3NgLCBzY2FubmluZ1xuZGlyZWN0aW9uIGBkaXJgLiBPbmx5IHRoZSBgYnJhY2tldHNgIGFuZCBgbWF4U2NhbkRpc3RhbmNlYFxucHJvcGVydGllcyBhcmUgdXNlZCBmcm9tIGBjb25maWdgLCBpZiBnaXZlbi4gUmV0dXJucyBudWxsIGlmIG5vXG5icmFja2V0IHdhcyBmb3VuZCBhdCBgcG9zYCwgb3IgYSBtYXRjaCByZXN1bHQgb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjb25maWcgPSB7fSkge1xuICAgIGxldCBtYXhTY2FuRGlzdGFuY2UgPSBjb25maWcubWF4U2NhbkRpc3RhbmNlIHx8IERlZmF1bHRTY2FuRGlzdCwgYnJhY2tldHMgPSBjb25maWcuYnJhY2tldHMgfHwgRGVmYXVsdEJyYWNrZXRzO1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSksIG5vZGUgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIGRpcik7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyOyBjdXIgPSBjdXIucGFyZW50KSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hpbmdOb2RlcyhjdXIudHlwZSwgZGlyLCBicmFja2V0cyk7XG4gICAgICAgIGlmIChtYXRjaGVzICYmIGN1ci5mcm9tIDwgY3VyLnRvKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlID0gZmluZEhhbmRsZShjdXIpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZSAmJiAoZGlyID4gMCA/IHBvcyA+PSBoYW5kbGUuZnJvbSAmJiBwb3MgPCBoYW5kbGUudG8gOiBwb3MgPiBoYW5kbGUuZnJvbSAmJiBwb3MgPD0gaGFuZGxlLnRvKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hNYXJrZWRCcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIGN1ciwgaGFuZGxlLCBtYXRjaGVzLCBicmFja2V0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoUGxhaW5CcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIHRyZWUsIG5vZGUudHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cyk7XG59XG5mdW5jdGlvbiBtYXRjaE1hcmtlZEJyYWNrZXRzKF9zdGF0ZSwgX3BvcywgZGlyLCB0b2tlbiwgaGFuZGxlLCBtYXRjaGluZywgYnJhY2tldHMpIHtcbiAgICBsZXQgcGFyZW50ID0gdG9rZW4ucGFyZW50LCBmaXJzdFRva2VuID0geyBmcm9tOiBoYW5kbGUuZnJvbSwgdG86IGhhbmRsZS50byB9O1xuICAgIGxldCBkZXB0aCA9IDAsIGN1cnNvciA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jdXJzb3IoKTtcbiAgICBpZiAoY3Vyc29yICYmIChkaXIgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHRva2VuLmZyb20pIDogY3Vyc29yLmNoaWxkQWZ0ZXIodG9rZW4udG8pKSlcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGRpciA8IDAgPyBjdXJzb3IudG8gPD0gdG9rZW4uZnJvbSA6IGN1cnNvci5mcm9tID49IHRva2VuLnRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDAgJiYgbWF0Y2hpbmcuaW5kZXhPZihjdXJzb3IudHlwZS5uYW1lKSA+IC0xICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRIYW5kbGUgPSBmaW5kSGFuZGxlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBlbmQ6IGVuZEhhbmRsZSA/IHsgZnJvbTogZW5kSGFuZGxlLmZyb20sIHRvOiBlbmRIYW5kbGUudG8gfSA6IHVuZGVmaW5lZCwgbWF0Y2hlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCBkaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCAtZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmRIYW5kbGUgPSBmaW5kSGFuZGxlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmaXJzdFRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kSGFuZGxlICYmIGVuZEhhbmRsZS5mcm9tIDwgZW5kSGFuZGxlLnRvID8geyBmcm9tOiBlbmRIYW5kbGUuZnJvbSwgdG86IGVuZEhhbmRsZS50byB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaXIgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH07XG59XG5mdW5jdGlvbiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCB0b2tlblR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpIHtcbiAgICBsZXQgc3RhcnRDaCA9IGRpciA8IDAgPyBzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpIDogc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKTtcbiAgICBsZXQgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2Yoc3RhcnRDaCk7XG4gICAgaWYgKGJyYWNrZXQgPCAwIHx8IChicmFja2V0ICUgMiA9PSAwKSAhPSAoZGlyID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzdGFydFRva2VuID0geyBmcm9tOiBkaXIgPCAwID8gcG9zIC0gMSA6IHBvcywgdG86IGRpciA+IDAgPyBwb3MgKyAxIDogcG9zIH07XG4gICAgbGV0IGl0ZXIgPSBzdGF0ZS5kb2MuaXRlclJhbmdlKHBvcywgZGlyID4gMCA/IHN0YXRlLmRvYy5sZW5ndGggOiAwKSwgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGRpc3RhbmNlID0gMDsgIShpdGVyLm5leHQoKSkuZG9uZSAmJiBkaXN0YW5jZSA8PSBtYXhTY2FuRGlzdGFuY2U7KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gaXRlci52YWx1ZTtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IGJhc2VQb3MgPSBwb3MgKyBkaXN0YW5jZSAqIGRpcjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZGlyID4gMCA/IDAgOiB0ZXh0Lmxlbmd0aCAtIDEsIGVuZCA9IGRpciA+IDAgPyB0ZXh0Lmxlbmd0aCA6IC0xOyBwb3MgIT0gZW5kOyBwb3MgKz0gZGlyKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBicmFja2V0cy5pbmRleE9mKHRleHRbcG9zXSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwIHx8IHRyZWUucmVzb2x2ZUlubmVyKGJhc2VQb3MgKyBwb3MsIDEpLnR5cGUgIT0gdG9rZW5UeXBlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKChmb3VuZCAlIDIgPT0gMCkgPT0gKGRpciA+IDApKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID09IDEpIHsgLy8gQ2xvc2luZ1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydFRva2VuLCBlbmQ6IHsgZnJvbTogYmFzZVBvcyArIHBvcywgdG86IGJhc2VQb3MgKyBwb3MgKyAxIH0sIG1hdGNoZWQ6IChmb3VuZCA+PiAxKSA9PSAoYnJhY2tldCA+PiAxKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRleHQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gaXRlci5kb25lID8geyBzdGFydDogc3RhcnRUb2tlbiwgbWF0Y2hlZDogZmFsc2UgfSA6IG51bGw7XG59XG5cbi8vIENvdW50cyB0aGUgY29sdW1uIG9mZnNldCBpbiBhIHN0cmluZywgdGFraW5nIHRhYnMgaW50byBhY2NvdW50LlxuLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbmZ1bmN0aW9uIGNvdW50Q29sKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4ID0gMCwgc3RhcnRWYWx1ZSA9IDApIHtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RyaW5nLnNlYXJjaCgvW15cXHNcXHUwMGEwXS8pO1xuICAgICAgICBpZiAoZW5kID09IC0xKVxuICAgICAgICAgICAgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgbGV0IG4gPSBzdGFydFZhbHVlO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpXG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuKys7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5FbmNhcHN1bGF0ZXMgYSBzaW5nbGUgbGluZSBvZiBpbnB1dC4gR2l2ZW4gdG8gc3RyZWFtIHN5bnRheCBjb2RlLFxud2hpY2ggdXNlcyBpdCB0byB0b2tlbml6ZSB0aGUgY29udGVudC5cbiovXG5jbGFzcyBTdHJpbmdTdHJlYW0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN0cmVhbS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsaW5lLlxuICAgICovXG4gICAgc3RyaW5nLCB0YWJTaXplLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBpbmRlbnQgdW5pdCBzaXplLlxuICAgICovXG4gICAgaW5kZW50VW5pdCwgb3ZlcnJpZGVJbmRlbnQpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemU7XG4gICAgICAgIHRoaXMuaW5kZW50VW5pdCA9IGluZGVudFVuaXQ7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVJbmRlbnQgPSBvdmVycmlkZUluZGVudDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBsaW5lLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBlb2woKSB7IHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBzb2woKSB7IHJldHVybiB0aGlzLnBvcyA9PSAwOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBuZXh0IGNvZGUgdW5pdCBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgb3IgdW5kZWZpbmVkXG4gICAgaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHBlZWsoKSB7IHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZDsgfVxuICAgIC8qKlxuICAgIFJlYWQgdGhlIG5leHQgY29kZSB1bml0IGFuZCBhZHZhbmNlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPCB0aGlzLnN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgbmV4dCBjaGFyYWN0ZXIgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nLCByZWd1bGFyXG4gICAgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlLiBDb25zdW1lIGFuZCByZXR1cm4gaXQgaWYgaXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIGVhdChtYXRjaCkge1xuICAgICAgICBsZXQgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgb2s7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIG9rID0gY2ggPT0gbWF0Y2g7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9rID0gY2ggJiYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpO1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbWF0Y2hpbmcgY2hhcmFjdGVycyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzdHJpbmcsXG4gICAgcmVndWxhciBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUgZnVuY3Rpb24uIFJldHVybiB0cnVlIGlmIGFueVxuICAgIGNoYXJhY3RlcnMgd2VyZSBjb25zdW1lZC5cbiAgICAqL1xuICAgIGVhdFdoaWxlKG1hdGNoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN1bWUgd2hpdGVzcGFjZSBhaGVhZCBvZiBgdGhpcy5wb3NgLiBSZXR1cm4gdHJ1ZSBpZiBhbnkgd2FzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBlYXRTcGFjZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKVxuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHNraXBUb0VuZCgpIHsgdGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIGRpcmVjdGx5IGJlZm9yZSB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpZiBmb3VuZCBvbiB0aGVcbiAgICBjdXJyZW50IGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG8oY2gpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBmb3VuZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYmFjayBgbmAgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIGJhY2tVcChuKSB7IHRoaXMucG9zIC09IG47IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgY29sdW1uKCkge1xuICAgICAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbCh0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgaW5kZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3ZlcnJpZGVJbmRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvdW50Q29sKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgaW5wdXQgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICh3aGljaCBzaG91bGQgc3RhcnQgd2l0aCBhIGBeYCkuIFJldHVybiB0cnVlIG9yIHRoZSByZWdleHAgbWF0Y2hcbiAgICBpZiBpdCBtYXRjaGVzLlxuICAgIFxuICAgIFVubGVzcyBgY29uc3VtZWAgaXMgc2V0IHRvIGBmYWxzZWAsIHRoaXMgd2lsbCBtb3ZlIGB0aGlzLnBvc2BcbiAgICBwYXN0IHRoZSBtYXRjaGVkIHRleHQuXG4gICAgXG4gICAgV2hlbiBtYXRjaGluZyBhIHN0cmluZyBgY2FzZUluc2Vuc2l0aXZlYCBjYW4gYmUgc2V0IHRvIHRydWUgdG9cbiAgICBtYWtlIHRoZSBtYXRjaCBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICovXG4gICAgbWF0Y2gocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgY2FzZWQgPSAoc3RyKSA9PiBjYXNlSW5zZW5zaXRpdmUgPyBzdHIudG9Mb3dlckNhc2UoKSA6IHN0cjtcbiAgICAgICAgICAgIGxldCBzdWJzdHIgPSB0aGlzLnN0cmluZy5zdWJzdHIodGhpcy5wb3MsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChjYXNlZChzdWJzdHIpID09IGNhc2VkKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAqL1xuICAgIGN1cnJlbnQoKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyk7IH1cbn1cblxuZnVuY3Rpb24gZnVsbFBhcnNlcihzcGVjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogc3BlYy5uYW1lIHx8IFwiXCIsXG4gICAgICAgIHRva2VuOiBzcGVjLnRva2VuLFxuICAgICAgICBibGFua0xpbmU6IHNwZWMuYmxhbmtMaW5lIHx8ICgoKSA9PiB7IH0pLFxuICAgICAgICBzdGFydFN0YXRlOiBzcGVjLnN0YXJ0U3RhdGUgfHwgKCgpID0+IHRydWUpLFxuICAgICAgICBjb3B5U3RhdGU6IHNwZWMuY29weVN0YXRlIHx8IGRlZmF1bHRDb3B5U3RhdGUsXG4gICAgICAgIGluZGVudDogc3BlYy5pbmRlbnQgfHwgKCgpID0+IG51bGwpLFxuICAgICAgICBsYW5ndWFnZURhdGE6IHNwZWMubGFuZ3VhZ2VEYXRhIHx8IHt9LFxuICAgICAgICB0b2tlblRhYmxlOiBzcGVjLnRva2VuVGFibGUgfHwgbm9Ub2tlbnMsXG4gICAgICAgIG1lcmdlVG9rZW5zOiBzcGVjLm1lcmdlVG9rZW5zICE9PSBmYWxzZVxuICAgIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29weVN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgbGV0IG5ld1N0YXRlID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBzdGF0ZSkge1xuICAgICAgICBsZXQgdmFsID0gc3RhdGVbcHJvcF07XG4gICAgICAgIG5ld1N0YXRlW3Byb3BdID0gKHZhbCBpbnN0YW5jZW9mIEFycmF5ID8gdmFsLnNsaWNlKCkgOiB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3RhdGU7XG59XG5jb25zdCBJbmRlbnRlZEZyb20gPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8qKlxuQSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGNsYXNzIGJhc2VkIG9uIGEgQ29kZU1pcnJvclxuNS1zdHlsZSBbc3RyZWFtaW5nIHBhcnNlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1QYXJzZXIpLlxuKi9cbmNsYXNzIFN0cmVhbUxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQocGFyc2VyLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIGxldCBwID0gZnVsbFBhcnNlcihwYXJzZXIpLCBzZWxmO1xuICAgICAgICBsZXQgaW1wbCA9IG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlKHNlbGYsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKGRhdGEsIGltcGwsIFtdLCBwYXJzZXIubmFtZSk7XG4gICAgICAgIHRoaXMudG9wTm9kZSA9IGRvY0lEKGRhdGEsIHRoaXMpO1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIgPSBwO1xuICAgICAgICB0aGlzLnN0YXRlQWZ0ZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnRva2VuVGFibGUgPSBwYXJzZXIudG9rZW5UYWJsZSA/IG5ldyBUb2tlblRhYmxlKHAudG9rZW5UYWJsZSkgOiBkZWZhdWx0VG9rZW5UYWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RyZWFtIGxhbmd1YWdlLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7IHJldHVybiBuZXcgU3RyZWFtTGFuZ3VhZ2Uoc3BlYyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEluZGVudChjeCkge1xuICAgICAgICBsZXQgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHsgb3ZlcnJpZGVJbmRlbnRhdGlvbiB9ID0gY3gub3B0aW9ucztcbiAgICAgICAgaWYgKG92ZXJyaWRlSW5kZW50YXRpb24pIHtcbiAgICAgICAgICAgIGZyb20gPSBJbmRlbnRlZEZyb20uZ2V0KGN4LnN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmcm9tICE9IG51bGwgJiYgZnJvbSA8IGN4LnBvcyAtIDFlNClcbiAgICAgICAgICAgICAgICBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGZpbmRTdGF0ZSh0aGlzLCBjeC5ub2RlLnRyZWUsIGN4Lm5vZGUuZnJvbSwgY3gubm9kZS5mcm9tLCBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBjeC5wb3MpLCBzdGF0ZVBvcywgc3RhdGU7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gc3RhcnQucG9zICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShjeC51bml0KTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gY3gubm9kZS5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjeC5wb3MgLSBzdGF0ZVBvcyA+IDEwMDAwIC8qIEMuTWF4SW5kZW50U2NhbkRpc3QgKi8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHN0YXRlUG9zIDwgY3gucG9zKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGN4LnN0YXRlLmRvYy5saW5lQXQoc3RhdGVQb3MpLCBlbmQgPSBNYXRoLm1pbihjeC5wb3MsIGxpbmUudG8pO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudGF0aW9uID0gb3ZlcnJpZGVJbmRlbnRhdGlvbiA/IG92ZXJyaWRlSW5kZW50YXRpb24obGluZS5mcm9tKSA6IC0xO1xuICAgICAgICAgICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUudGV4dCwgY3guc3RhdGUudGFiU2l6ZSwgY3gudW5pdCwgaW5kZW50YXRpb24gPCAwID8gdW5kZWZpbmVkIDogaW5kZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJlYW0ucG9zIDwgZW5kIC0gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICByZWFkVG9rZW4odGhpcy5zdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHN0YXRlLCBjeC51bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT0gY3gucG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZSA9IGN4LmxpbmVBdChjeC5wb3MpO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbiAmJiBmcm9tID09IG51bGwpXG4gICAgICAgICAgICBJbmRlbnRlZEZyb20uc2V0KGN4LnN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1QYXJzZXIuaW5kZW50KHN0YXRlLCAvXlxccyooLiopLy5leGVjKGxpbmUudGV4dClbMV0sIGN4KTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuZnVuY3Rpb24gZmluZFN0YXRlKGxhbmcsIHRyZWUsIG9mZiwgc3RhcnRQb3MsIGJlZm9yZSkge1xuICAgIGxldCBzdGF0ZSA9IG9mZiA+PSBzdGFydFBvcyAmJiBvZmYgKyB0cmVlLmxlbmd0aCA8PSBiZWZvcmUgJiYgdHJlZS5wcm9wKGxhbmcuc3RhdGVBZnRlcik7XG4gICAgaWYgKHN0YXRlKVxuICAgICAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHN0YXRlKSwgcG9zOiBvZmYgKyB0cmVlLmxlbmd0aCB9O1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIHBvcyA9IG9mZiArIHRyZWUucG9zaXRpb25zW2ldO1xuICAgICAgICBsZXQgZm91bmQgPSBjaGlsZCBpbnN0YW5jZW9mIFRyZWUgJiYgcG9zIDwgYmVmb3JlICYmIGZpbmRTdGF0ZShsYW5nLCBjaGlsZCwgcG9zLCBzdGFydFBvcywgYmVmb3JlKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGN1dFRyZWUobGFuZywgdHJlZSwgZnJvbSwgdG8sIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgJiYgZnJvbSA8PSAwICYmIHRvID49IHRyZWUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICBpZiAoIWluc2lkZSAmJiBmcm9tID09IDAgJiYgdHJlZS50eXBlID09IGxhbmcudG9wTm9kZSlcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgcG9zID0gdHJlZS5wb3NpdGlvbnNbaV0sIGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgaW5uZXI7XG4gICAgICAgIGlmIChwb3MgPCB0byAmJiBjaGlsZCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgIGlmICghKGlubmVyID0gY3V0VHJlZShsYW5nLCBjaGlsZCwgZnJvbSAtIHBvcywgdG8gLSBwb3MsIGluc2lkZSkpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmV0dXJuICFpbnNpZGUgPyBpbm5lclxuICAgICAgICAgICAgICAgIDogbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLnNsaWNlKDAsIGkpLmNvbmNhdChpbm5lciksIHRyZWUucG9zaXRpb25zLnNsaWNlKDAsIGkgKyAxKSwgcG9zICsgaW5uZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgc3RhcnRQb3MsIGVuZFBvcywgZWRpdG9yU3RhdGUpIHtcbiAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cykge1xuICAgICAgICBsZXQgZnJvbSA9IGYuZnJvbSArIChmLm9wZW5TdGFydCA/IDI1IDogMCksIHRvID0gZi50byAtIChmLm9wZW5FbmQgPyAyNSA6IDApO1xuICAgICAgICBsZXQgZm91bmQgPSBmcm9tIDw9IHN0YXJ0UG9zICYmIHRvID4gc3RhcnRQb3MgJiYgZmluZFN0YXRlKGxhbmcsIGYudHJlZSwgMCAtIGYub2Zmc2V0LCBzdGFydFBvcywgdG8pLCB0cmVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgZm91bmQucG9zIDw9IGVuZFBvcyAmJiAodHJlZSA9IGN1dFRyZWUobGFuZywgZi50cmVlLCBzdGFydFBvcyArIGYub2Zmc2V0LCBmb3VuZC5wb3MgKyBmLm9mZnNldCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBmb3VuZC5zdGF0ZSwgdHJlZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShlZGl0b3JTdGF0ZSA/IGdldEluZGVudFVuaXQoZWRpdG9yU3RhdGUpIDogNCksIHRyZWU6IFRyZWUuZW1wdHkgfTtcbn1cbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihsYW5nLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMudG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKSwgZnJvbSA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICBsZXQgeyBzdGF0ZSwgdHJlZSB9ID0gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBmcm9tLCB0aGlzLnRvLCBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuc3RhdGUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gdGhpcy5jaHVua1N0YXJ0ID0gZnJvbSArIHRyZWUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2godHJlZS5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godHJlZS5wb3NpdGlvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zIDwgY29udGV4dC52aWV3cG9ydC5mcm9tIC0gMTAwMDAwIC8qIEMuTWF4RGlzdGFuY2VCZWZvcmVWaWV3cG9ydCAqLyAmJlxuICAgICAgICAgICAgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gY29udGV4dC52aWV3cG9ydC5mcm9tICYmIHIudG8gPj0gY29udGV4dC52aWV3cG9ydC5mcm9tKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBjb250ZXh0LnZpZXdwb3J0LmZyb20pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBjb250ZXh0LnZpZXdwb3J0LmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKTtcbiAgICAgICAgbGV0IHBhcnNlRW5kID0gdGhpcy5zdG9wcGVkQXQgPT0gbnVsbCA/IHRoaXMudG8gOiBNYXRoLm1pbih0aGlzLnRvLCB0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwYXJzZUVuZCwgdGhpcy5jaHVua1N0YXJ0ICsgNTEyIC8qIEMuQ2h1bmtTaXplICovKTtcbiAgICAgICAgaWYgKGNvbnRleHQpXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNvbnRleHQudmlld3BvcnQudG8pO1xuICAgICAgICB3aGlsZSAodGhpcy5wYXJzZWRQb3MgPCBlbmQpXG4gICAgICAgICAgICB0aGlzLnBhcnNlTGluZShjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IHRoaXMucGFyc2VkUG9zKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuaygpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRQb3MgPj0gcGFyc2VFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgdGhpcy5wYXJzZWRQb3MgPj0gY29udGV4dC52aWV3cG9ydC50bykge1xuICAgICAgICAgICAgY29udGV4dC5za2lwVW50aWxJblZpZXcodGhpcy5wYXJzZWRQb3MsIHBhcnNlRW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgIH1cbiAgICBsaW5lQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsocG9zKTtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0LmxpbmVDaHVua3MpIHtcbiAgICAgICAgICAgIGxldCBlb2wgPSBjaHVuay5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgaWYgKGVvbCA+IC0xKVxuICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc2xpY2UoMCwgZW9sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaHVuayA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBjaHVuayA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyArIGNodW5rLmxlbmd0aCA8PSB0aGlzLnRvID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCB0aGlzLnRvIC0gcG9zKTtcbiAgICB9XG4gICAgbmV4dExpbmUoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy5wYXJzZWRQb3MsIGxpbmUgPSB0aGlzLmxpbmVBZnRlcihmcm9tKSwgZW5kID0gZnJvbSArIGxpbmUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDs7KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VFbmQgPSB0aGlzLnJhbmdlc1tpbmRleF0udG87XG4gICAgICAgICAgICBpZiAocmFuZ2VFbmQgPj0gZW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgcmFuZ2VFbmQgLSAoZW5kIC0gbGluZS5sZW5ndGgpKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHJhbmdlU3RhcnQgPSB0aGlzLnJhbmdlc1tpbmRleF0uZnJvbTtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHRoaXMubGluZUFmdGVyKHJhbmdlU3RhcnQpO1xuICAgICAgICAgICAgbGluZSArPSBhZnRlcjtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlU3RhcnQgKyBhZnRlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZSwgZW5kIH07XG4gICAgfVxuICAgIHNraXBHYXBzVG8ocG9zLCBvZmZzZXQsIHNpZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8sIG9mZlBvcyA9IHBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChzaWRlID4gMCA/IGVuZCA+IG9mZlBvcyA6IGVuZCA+PSBvZmZQb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF0uZnJvbTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzdGFydCAtIGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBtb3ZlUmFuZ2VJbmRleCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8gPCB0aGlzLnBhcnNlZFBvcylcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCsrO1xuICAgIH1cbiAgICBlbWl0VG9rZW4oaWQsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHNpemUgPSA0O1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKGZyb20sIG9mZnNldCwgMSk7XG4gICAgICAgICAgICBmcm9tICs9IG9mZnNldDtcbiAgICAgICAgICAgIGxldCBsZW4wID0gdGhpcy5jaHVuay5sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8odG8sIG9mZnNldCwgLTEpO1xuICAgICAgICAgICAgdG8gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNodW5rLmxlbmd0aCAtIGxlbjA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDQ7XG4gICAgICAgIGlmICh0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLm1lcmdlVG9rZW5zICYmIHNpemUgPT0gNCAmJiBsYXN0ID49IDAgJiZcbiAgICAgICAgICAgIHRoaXMuY2h1bmtbbGFzdF0gPT0gaWQgJiYgdGhpcy5jaHVua1tsYXN0ICsgMl0gPT0gZnJvbSlcbiAgICAgICAgICAgIHRoaXMuY2h1bmtbbGFzdCArIDJdID0gdG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuY2h1bmsucHVzaChpZCwgZnJvbSwgdG8sIHNpemUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBwYXJzZUxpbmUoY29udGV4dCkge1xuICAgICAgICBsZXQgeyBsaW5lLCBlbmQgfSA9IHRoaXMubmV4dExpbmUoKSwgb2Zmc2V0ID0gMCwgeyBzdHJlYW1QYXJzZXIgfSA9IHRoaXMubGFuZztcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZSwgY29udGV4dCA/IGNvbnRleHQuc3RhdGUudGFiU2l6ZSA6IDQsIGNvbnRleHQgPyBnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpIDogMik7XG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgIHN0cmVhbVBhcnNlci5ibGFua0xpbmUodGhpcy5zdGF0ZSwgc3RyZWFtLmluZGVudFVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSByZWFkVG9rZW4oc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5lbWl0VG9rZW4odGhpcy5sYW5nLnRva2VuVGFibGUucmVzb2x2ZSh0b2tlbiksIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnN0YXJ0LCB0aGlzLnBhcnNlZFBvcyArIHN0cmVhbS5wb3MsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5zdGFydCA+IDEwMDAwIC8qIEMuTWF4TGluZUxlbmd0aCAqLylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBlbmQ7XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zIDwgdGhpcy50bylcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zKys7XG4gICAgfVxuICAgIGZpbmlzaENodW5rKCkge1xuICAgICAgICBsZXQgdHJlZSA9IFRyZWUuYnVpbGQoe1xuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLmNodW5rLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuY2h1bmtTdGFydCxcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5wYXJzZWRQb3MgLSB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IDAsXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IDUxMiAvKiBDLkNodW5rU2l6ZSAqLyxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5jaHVua1JldXNlZFxuICAgICAgICB9KTtcbiAgICAgICAgdHJlZSA9IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbiwgdHJlZS5wb3NpdGlvbnMsIHRyZWUubGVuZ3RoLCBbW3RoaXMubGFuZy5zdGF0ZUFmdGVyLCB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZSh0aGlzLnN0YXRlKV1dKTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCAtIHRoaXMucmFuZ2VzWzBdLmZyb20pO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IHRoaXMucGFyc2VkUG9zO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLmxhbmcudG9wTm9kZSwgdGhpcy5jaHVua3MsIHRoaXMuY2h1bmtQb3MsIHRoaXMucGFyc2VkUG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSkuYmFsYW5jZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWRUb2tlbih0b2tlbiwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gcGFyc2VyIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIik7XG59XG5jb25zdCBub1Rva2VucyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgdHlwZUFycmF5ID0gW05vZGVUeXBlLm5vbmVdO1xuY29uc3Qgbm9kZVNldCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVNldCh0eXBlQXJyYXkpO1xuY29uc3Qgd2FybmVkID0gW107XG4vLyBDYWNoZSBvZiBub2RlIHR5cGVzIGJ5IG5hbWUgYW5kIHRhZ3NcbmNvbnN0IGJ5VGFnID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZWZhdWx0VGFibGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvciAobGV0IFtsZWdhY3lOYW1lLCBuYW1lXSBvZiBbXG4gICAgW1widmFyaWFibGVcIiwgXCJ2YXJpYWJsZU5hbWVcIl0sXG4gICAgW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCJdLFxuICAgIFtcInN0cmluZy0yXCIsIFwic3RyaW5nLnNwZWNpYWxcIl0sXG4gICAgW1wiZGVmXCIsIFwidmFyaWFibGVOYW1lLmRlZmluaXRpb25cIl0sXG4gICAgW1widGFnXCIsIFwidGFnTmFtZVwiXSxcbiAgICBbXCJhdHRyaWJ1dGVcIiwgXCJhdHRyaWJ1dGVOYW1lXCJdLFxuICAgIFtcInR5cGVcIiwgXCJ0eXBlTmFtZVwiXSxcbiAgICBbXCJidWlsdGluXCIsIFwidmFyaWFibGVOYW1lLnN0YW5kYXJkXCJdLFxuICAgIFtcInF1YWxpZmllclwiLCBcIm1vZGlmaWVyXCJdLFxuICAgIFtcImVycm9yXCIsIFwiaW52YWxpZFwiXSxcbiAgICBbXCJoZWFkZXJcIiwgXCJoZWFkaW5nXCJdLFxuICAgIFtcInByb3BlcnR5XCIsIFwicHJvcGVydHlOYW1lXCJdXG5dKVxuICAgIGRlZmF1bHRUYWJsZVtsZWdhY3lOYW1lXSA9IC8qQF9fUFVSRV9fKi9jcmVhdGVUb2tlblR5cGUobm9Ub2tlbnMsIG5hbWUpO1xuY2xhc3MgVG9rZW5UYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZXh0cmEpIHtcbiAgICAgICAgdGhpcy5leHRyYSA9IGV4dHJhO1xuICAgICAgICB0aGlzLnRhYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBkZWZhdWx0VGFibGUpO1xuICAgIH1cbiAgICByZXNvbHZlKHRhZykge1xuICAgICAgICByZXR1cm4gIXRhZyA/IDAgOiB0aGlzLnRhYmxlW3RhZ10gfHwgKHRoaXMudGFibGVbdGFnXSA9IGNyZWF0ZVRva2VuVHlwZSh0aGlzLmV4dHJhLCB0YWcpKTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0VG9rZW5UYWJsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVG9rZW5UYWJsZShub1Rva2Vucyk7XG5mdW5jdGlvbiB3YXJuRm9yUGFydChwYXJ0LCBtc2cpIHtcbiAgICBpZiAod2FybmVkLmluZGV4T2YocGFydCkgPiAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHdhcm5lZC5wdXNoKHBhcnQpO1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5UeXBlKGV4dHJhLCB0YWdTdHIpIHtcbiAgICBsZXQgdGFncyQxID0gW107XG4gICAgZm9yIChsZXQgbmFtZSBvZiB0YWdTdHIuc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIG5hbWUuc3BsaXQoXCIuXCIpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoZXh0cmFbcGFydF0gfHwgdGFnc1twYXJ0XSk7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFVua25vd24gaGlnaGxpZ2h0aW5nIHRhZyAke3BhcnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBNb2RpZmllciAke3BhcnR9IHVzZWQgYXQgc3RhcnQgb2YgdGFnYCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLm1hcCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVGFnICR7cGFydH0gdXNlZCBhcyBtb2RpZmllcmApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0YWcgb2YgZm91bmQpXG4gICAgICAgICAgICB0YWdzJDEucHVzaCh0YWcpO1xuICAgIH1cbiAgICBpZiAoIXRhZ3MkMS5sZW5ndGgpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGxldCBuYW1lID0gdGFnU3RyLnJlcGxhY2UoLyAvZywgXCJfXCIpLCBrZXkgPSBuYW1lICsgXCIgXCIgKyB0YWdzJDEubWFwKHQgPT4gdC5pZCk7XG4gICAgbGV0IGtub3duID0gYnlUYWdba2V5XTtcbiAgICBpZiAoa25vd24pXG4gICAgICAgIHJldHVybiBrbm93bi5pZDtcbiAgICBsZXQgdHlwZSA9IGJ5VGFnW2tleV0gPSBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogdHlwZUFycmF5Lmxlbmd0aCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IFtzdHlsZVRhZ3MoeyBbbmFtZV06IHRhZ3MkMSB9KV1cbiAgICB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZS5pZDtcbn1cbmZ1bmN0aW9uIGRvY0lEKGRhdGEsIGxhbmcpIHtcbiAgICBsZXQgdHlwZSA9IE5vZGVUeXBlLmRlZmluZSh7IGlkOiB0eXBlQXJyYXkubGVuZ3RoLCBuYW1lOiBcIkRvY3VtZW50XCIsIHByb3BzOiBbXG4gICAgICAgICAgICBsYW5ndWFnZURhdGFQcm9wLmFkZCgoKSA9PiBkYXRhKSxcbiAgICAgICAgICAgIGluZGVudE5vZGVQcm9wLmFkZCgoKSA9PiBjeCA9PiBsYW5nLmdldEluZGVudChjeCkpXG4gICAgICAgIF0sIHRvcDogdHJ1ZSB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JMaW5lKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5sZW5ndGggPD0gNDA5NiAmJiAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY1xcdWZiNTAtXFx1ZmRmZl0vLnRlc3QobGluZSk7XG59XG5mdW5jdGlvbiB0ZXh0SGFzUlRMKHRleHQpIHtcbiAgICBmb3IgKGxldCBpID0gdGV4dC5pdGVyKCk7ICFpLm5leHQoKS5kb25lOylcbiAgICAgICAgaWYgKGJ1aWxkRm9yTGluZShpLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoYW5nZUFkZHNSVEwoY2hhbmdlKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgY2hhbmdlLml0ZXJDaGFuZ2VzKChmQSwgdEEsIGZCLCB0QiwgaW5zKSA9PiB7XG4gICAgICAgIGlmICghYWRkZWQgJiYgdGV4dEhhc1JUTChpbnMpKVxuICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBhZGRlZDtcbn1cbmNvbnN0IGFsd2F5c0lzb2xhdGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geCkgfSk7XG4vKipcbk1ha2Ugc3VyZSBub2Rlc1xuW21hcmtlZF0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbW9uLk5vZGVQcm9wXmlzb2xhdGUpXG5hcyBpc29sYXRpbmcgZm9yIGJpZGlyZWN0aW9uYWwgdGV4dCBhcmUgcmVuZGVyZWQgaW4gYSB3YXkgdGhhdFxuaXNvbGF0ZXMgdGhlbSBmcm9tIHRoZSBzdXJyb3VuZGluZyB0ZXh0LlxuKi9cbmZ1bmN0aW9uIGJpZGlJc29sYXRlcyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgZXh0ZW5zaW9ucyA9IFtpc29sYXRlTWFya3NdO1xuICAgIGlmIChvcHRpb25zLmFsd2F5c0lzb2xhdGUpXG4gICAgICAgIGV4dGVuc2lvbnMucHVzaChhbHdheXNJc29sYXRlLm9mKHRydWUpKTtcbiAgICByZXR1cm4gZXh0ZW5zaW9ucztcbn1cbmNvbnN0IGlzb2xhdGVNYXJrcyA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmFsd2F5cyA9IHZpZXcuc3RhdGUuZmFjZXQoYWx3YXlzSXNvbGF0ZSkgfHxcbiAgICAgICAgICAgIHZpZXcudGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSIHx8XG4gICAgICAgICAgICB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmhhc1JUTCA9ICF0aGlzLmFsd2F5cyAmJiB0ZXh0SGFzUlRMKHZpZXcuc3RhdGUuZG9jKTtcbiAgICAgICAgdGhpcy50cmVlID0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYWx3YXlzIHx8IHRoaXMuaGFzUlRMID8gYnVpbGREZWNvKHZpZXcsIHRoaXMudHJlZSwgdGhpcy5hbHdheXMpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBhbHdheXMgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWx3YXlzSXNvbGF0ZSkgfHxcbiAgICAgICAgICAgIHVwZGF0ZS52aWV3LnRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiB8fFxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLmZhY2V0KEVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIWFsd2F5cyAmJiAhdGhpcy5oYXNSVEwgJiYgY2hhbmdlQWRkc1JUTCh1cGRhdGUuY2hhbmdlcykpXG4gICAgICAgICAgICB0aGlzLmhhc1JUTCA9IHRydWU7XG4gICAgICAgIGlmICghYWx3YXlzICYmICF0aGlzLmhhc1JUTClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChhbHdheXMgIT0gdGhpcy5hbHdheXMgfHwgdHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuYWx3YXlzID0gYWx3YXlzO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGJ1aWxkRGVjbyh1cGRhdGUudmlldywgdHJlZSwgYWx3YXlzKTtcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4ge1xuICAgICAgICBmdW5jdGlvbiBhY2Nlc3Modmlldykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVjb3JhdGlvbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW0VkaXRvclZpZXcub3V0ZXJEZWNvcmF0aW9ucy5vZihhY2Nlc3MpLFxuICAgICAgICAgICAgUHJlYy5sb3dlc3QoRWRpdG9yVmlldy5iaWRpSXNvbGF0ZWRSYW5nZXMub2YoYWNjZXNzKSldO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gYnVpbGREZWNvKHZpZXcsIHRyZWUsIGFsd2F5cykge1xuICAgIGxldCBkZWNvID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgIGxldCByYW5nZXMgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKCFhbHdheXMpXG4gICAgICAgIHJhbmdlcyA9IGNsaXBSVExMaW5lcyhyYW5nZXMsIHZpZXcuc3RhdGUuZG9jKTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIHRyZWUuaXRlcmF0ZSh7XG4gICAgICAgICAgICBlbnRlcjogbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlzbyA9IG5vZGUudHlwZS5wcm9wKE5vZGVQcm9wLmlzb2xhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChpc28pXG4gICAgICAgICAgICAgICAgICAgIGRlY28uYWRkKG5vZGUuZnJvbSwgbm9kZS50bywgbWFya3NbaXNvXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbSwgdG9cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvLmZpbmlzaCgpO1xufVxuZnVuY3Rpb24gY2xpcFJUTExpbmVzKHJhbmdlcywgZG9jKSB7XG4gICAgbGV0IGN1ciA9IGRvYy5pdGVyKCksIHBvcyA9IDAsIHJlc3VsdCA9IFtdLCBsYXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3QudG8gPiBmcm9tKSB7XG4gICAgICAgICAgICBmcm9tID0gbGFzdC50bztcbiAgICAgICAgICAgIGlmIChmcm9tID49IHRvKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgKyBjdXIudmFsdWUubGVuZ3RoIDwgZnJvbSkge1xuICAgICAgICAgICAgY3VyLm5leHQoZnJvbSAtIChwb3MgKyBjdXIudmFsdWUubGVuZ3RoKSk7XG4gICAgICAgICAgICBwb3MgPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHBvcywgZW5kID0gcG9zICsgY3VyLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghY3VyLmxpbmVCcmVhayAmJiBidWlsZEZvckxpbmUoY3VyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QudG8gPiBzdGFydCAtIDEwKVxuICAgICAgICAgICAgICAgICAgICBsYXN0LnRvID0gTWF0aC5taW4odG8sIGVuZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYXN0ID0geyBmcm9tOiBzdGFydCwgdG86IE1hdGgubWluKHRvLCBlbmQpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA+PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICAgIGN1ci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG1hcmtzID0ge1xuICAgIHJ0bDogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcInJ0bFwiIH0sIGJpZGlJc29sYXRlOiBEaXJlY3Rpb24uUlRMIH0pLFxuICAgIGx0cjogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcImx0clwiIH0sIGJpZGlJc29sYXRlOiBEaXJlY3Rpb24uTFRSIH0pLFxuICAgIGF1dG86IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1pc29cIiwgaW5jbHVzaXZlOiB0cnVlLCBhdHRyaWJ1dGVzOiB7IGRpcjogXCJhdXRvXCIgfSwgYmlkaUlzb2xhdGU6IG51bGwgfSlcbn07XG5cbmV4cG9ydCB7IERvY0lucHV0LCBIaWdobGlnaHRTdHlsZSwgSW5kZW50Q29udGV4dCwgTFJMYW5ndWFnZSwgTGFuZ3VhZ2UsIExhbmd1YWdlRGVzY3JpcHRpb24sIExhbmd1YWdlU3VwcG9ydCwgUGFyc2VDb250ZXh0LCBTdHJlYW1MYW5ndWFnZSwgU3RyaW5nU3RyZWFtLCBUcmVlSW5kZW50Q29udGV4dCwgYmlkaUlzb2xhdGVzLCBicmFja2V0TWF0Y2hpbmcsIGJyYWNrZXRNYXRjaGluZ0hhbmRsZSwgY29kZUZvbGRpbmcsIGNvbnRpbnVlZEluZGVudCwgZGVmYXVsdEhpZ2hsaWdodFN0eWxlLCBkZWZpbmVMYW5ndWFnZUZhY2V0LCBkZWxpbWl0ZWRJbmRlbnQsIGVuc3VyZVN5bnRheFRyZWUsIGZsYXRJbmRlbnQsIGZvbGRBbGwsIGZvbGRDb2RlLCBmb2xkRWZmZWN0LCBmb2xkR3V0dGVyLCBmb2xkSW5zaWRlLCBmb2xkS2V5bWFwLCBmb2xkTm9kZVByb3AsIGZvbGRTZXJ2aWNlLCBmb2xkU3RhdGUsIGZvbGRhYmxlLCBmb2xkZWRSYW5nZXMsIGZvcmNlUGFyc2luZywgZ2V0SW5kZW50VW5pdCwgZ2V0SW5kZW50YXRpb24sIGhpZ2hsaWdodGluZ0ZvciwgaW5kZW50Tm9kZVByb3AsIGluZGVudE9uSW5wdXQsIGluZGVudFJhbmdlLCBpbmRlbnRTZXJ2aWNlLCBpbmRlbnRTdHJpbmcsIGluZGVudFVuaXQsIGxhbmd1YWdlLCBsYW5ndWFnZURhdGFQcm9wLCBtYXRjaEJyYWNrZXRzLCBzdWJsYW5ndWFnZVByb3AsIHN5bnRheEhpZ2hsaWdodGluZywgc3ludGF4UGFyc2VyUnVubmluZywgc3ludGF4VHJlZSwgc3ludGF4VHJlZUF2YWlsYWJsZSwgdG9nZ2xlRm9sZCwgdW5mb2xkQWxsLCB1bmZvbGRDb2RlLCB1bmZvbGRFZmZlY3QgfTtcbiIsICJpbXBvcnQgeyBBbm5vdGF0aW9uLCBTdGF0ZUVmZmVjdCwgRWRpdG9yU2VsZWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgZnJvbUNvZGVQb2ludCwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFByZWMsIFRleHQsIFRyYW5zYWN0aW9uLCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBSYW5nZVNldCwgQ2hhckNhdGVnb3J5IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRGlyZWN0aW9uLCBsb2dFeGNlcHRpb24sIHNob3dUb29sdGlwLCBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBnZXRUb29sdGlwLCBEZWNvcmF0aW9uLCBXaWRnZXRUeXBlLCBrZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHN5bnRheFRyZWUsIGluZGVudFVuaXQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5cbi8qKlxuQW4gaW5zdGFuY2Ugb2YgdGhpcyBpcyBwYXNzZWQgdG8gY29tcGxldGlvbiBzb3VyY2UgZnVuY3Rpb25zLlxuKi9cbmNsYXNzIENvbXBsZXRpb25Db250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgY29tcGxldGlvbiBjb250ZXh0LiAoTW9zdGx5IHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgIGNvbXBsZXRpb24gc291cmNlc1x1MjAxNGluIHRoZSBlZGl0b3IsIHRoZSBleHRlbnNpb24gd2lsbCBjcmVhdGVcbiAgICB0aGVzZSBmb3IgeW91LilcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUgdGhhdCB0aGUgY29tcGxldGlvbiBoYXBwZW5zIGluLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgY29tcGxldGlvbiBpcyBoYXBwZW5pbmcuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIGNvbXBsZXRpb24gd2FzIGFjdGl2YXRlZCBleHBsaWNpdGx5LCBvclxuICAgIGltcGxpY2l0bHkgYnkgdHlwaW5nLiBUaGUgdXN1YWwgd2F5IHRvIHJlc3BvbmQgdG8gdGhpcyBpcyB0b1xuICAgIG9ubHkgcmV0dXJuIGNvbXBsZXRpb25zIHdoZW4gZWl0aGVyIHRoZXJlIGlzIHBhcnQgb2YgYVxuICAgIGNvbXBsZXRhYmxlIGVudGl0eSBiZWZvcmUgdGhlIGN1cnNvciwgb3IgYGV4cGxpY2l0YCBpcyB0cnVlLlxuICAgICovXG4gICAgZXhwbGljaXQsIFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igdmlldy4gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgY29udGV4dCB3YXMgY3JlYXRlZFxuICAgIGluIGEgc2l0dWF0aW9uIHdoZXJlIHRoZXJlIGlzIG5vIHN1Y2ggdmlldyBhdmFpbGFibGUsIHN1Y2ggYXNcbiAgICBpbiBzeW5jaHJvbm91cyB1cGRhdGVzIHZpYVxuICAgIFtgQ29tcGxldGlvblJlc3VsdC51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uUmVzdWx0LnVwZGF0ZSlcbiAgICBvciB3aGVuIGNhbGxlZCBieSB0ZXN0IGNvZGUuXG4gICAgKi9cbiAgICB2aWV3KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hYm9ydE9uRG9jQ2hhbmdlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50LCBjb250ZW50LCBhbmQgKGlmIHRoZXJlIGlzIGEgdG9rZW4pIHR5cGUgb2YgdGhlXG4gICAgdG9rZW4gYmVmb3JlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICB0b2tlbkJlZm9yZSh0eXBlcykge1xuICAgICAgICBsZXQgdG9rZW4gPSBzeW50YXhUcmVlKHRoaXMuc3RhdGUpLnJlc29sdmVJbm5lcih0aGlzLnBvcywgLTEpO1xuICAgICAgICB3aGlsZSAodG9rZW4gJiYgdHlwZXMuaW5kZXhPZih0b2tlbi5uYW1lKSA8IDApXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuID8geyBmcm9tOiB0b2tlbi5mcm9tLCB0bzogdGhpcy5wb3MsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnN0YXRlLnNsaWNlRG9jKHRva2VuLmZyb20sIHRoaXMucG9zKSxcbiAgICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUgfSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWF0Y2ggb2YgdGhlIGdpdmVuIGV4cHJlc3Npb24gZGlyZWN0bHkgYmVmb3JlIHRoZVxuICAgIGN1cnNvci5cbiAgICAqL1xuICAgIG1hdGNoQmVmb3JlKGV4cHIpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIHRoaXMucG9zIC0gMjUwKTtcbiAgICAgICAgbGV0IHN0ciA9IGxpbmUudGV4dC5zbGljZShzdGFydCAtIGxpbmUuZnJvbSwgdGhpcy5wb3MgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgZm91bmQgPSBzdHIuc2VhcmNoKGVuc3VyZUFuY2hvcihleHByLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHsgZnJvbTogc3RhcnQgKyBmb3VuZCwgdG86IHRoaXMucG9zLCB0ZXh0OiBzdHIuc2xpY2UoZm91bmQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFlpZWxkcyB0cnVlIHdoZW4gdGhlIHF1ZXJ5IGhhcyBiZWVuIGFib3J0ZWQuIENhbiBiZSB1c2VmdWwgaW5cbiAgICBhc3luY2hyb25vdXMgcXVlcmllcyB0byBhdm9pZCBkb2luZyB3b3JrIHRoYXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICovXG4gICAgZ2V0IGFib3J0ZWQoKSB7IHJldHVybiB0aGlzLmFib3J0TGlzdGVuZXJzID09IG51bGw7IH1cbiAgICAvKipcbiAgICBBbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGFib3J0IGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgdGhlIHF1ZXJ5IGlzXG4gICAgW2Fib3J0ZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Db250ZXh0LmFib3J0ZWQpLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHJ1bm5pbmcgcXVlcmllcyB3aWxsIG5vdCBiZSBhYm9ydGVkIGZvciByZWd1bGFyXG4gICAgdHlwaW5nIG9yIGJhY2tzcGFjaW5nLCBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZXkgYXJlIGxpa2VseSB0b1xuICAgIHJldHVybiBhIHJlc3VsdCB3aXRoIGFcbiAgICBbYHZhbGlkRm9yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvblJlc3VsdC52YWxpZEZvcikgZmllbGQgdGhhdFxuICAgIGFsbG93cyB0aGUgcmVzdWx0IHRvIGJlIHVzZWQgYWZ0ZXIgYWxsLiBQYXNzaW5nIGBvbkRvY0NoYW5nZTpcbiAgICB0cnVlYCB3aWxsIGNhdXNlIHRoaXMgcXVlcnkgdG8gYmUgYWJvcnRlZCBmb3IgYW55IGRvY3VtZW50XG4gICAgY2hhbmdlLlxuICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZSA9PSBcImFib3J0XCIgJiYgdGhpcy5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub25Eb2NDaGFuZ2UpXG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydE9uRG9jQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU2V0KGNoYXJzKSB7XG4gICAgbGV0IGZsYXQgPSBPYmplY3Qua2V5cyhjaGFycykuam9pbihcIlwiKTtcbiAgICBsZXQgd29yZHMgPSAvXFx3Ly50ZXN0KGZsYXQpO1xuICAgIGlmICh3b3JkcylcbiAgICAgICAgZmxhdCA9IGZsYXQucmVwbGFjZSgvXFx3L2csIFwiXCIpO1xuICAgIHJldHVybiBgWyR7d29yZHMgPyBcIlxcXFx3XCIgOiBcIlwifSR7ZmxhdC5yZXBsYWNlKC9bXlxcd1xcc10vZywgXCJcXFxcJCZcIil9XWA7XG59XG5mdW5jdGlvbiBwcmVmaXhNYXRjaChvcHRpb25zKSB7XG4gICAgbGV0IGZpcnN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmVzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgeyBsYWJlbCB9IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgZmlyc3RbbGFiZWxbMF1dID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3RbbGFiZWxbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNvdXJjZSA9IHRvU2V0KGZpcnN0KSArIHRvU2V0KHJlc3QpICsgXCIqJFwiO1xuICAgIHJldHVybiBbbmV3IFJlZ0V4cChcIl5cIiArIHNvdXJjZSksIG5ldyBSZWdFeHAoc291cmNlKV07XG59XG4vKipcbkdpdmVuIGEgYSBmaXhlZCBhcnJheSBvZiBvcHRpb25zLCByZXR1cm4gYW4gYXV0b2NvbXBsZXRlciB0aGF0XG5jb21wbGV0ZXMgdGhlbS5cbiovXG5mdW5jdGlvbiBjb21wbGV0ZUZyb21MaXN0KGxpc3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGxpc3QubWFwKG8gPT4gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IHsgbGFiZWw6IG8gfSA6IG8pO1xuICAgIGxldCBbdmFsaWRGb3IsIG1hdGNoXSA9IG9wdGlvbnMuZXZlcnkobyA9PiAvXlxcdyskLy50ZXN0KG8ubGFiZWwpKSA/IFsvXFx3KiQvLCAvXFx3KyQvXSA6IHByZWZpeE1hdGNoKG9wdGlvbnMpO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuIHx8IGNvbnRleHQuZXhwbGljaXQgPyB7IGZyb206IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zLCBvcHRpb25zLCB2YWxpZEZvciB9IDogbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgb25seSBmaXJlIHdoZW4gdGhlXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXG4qL1xuZnVuY3Rpb24gaWZJbihub2Rlcywgc291cmNlKSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZShjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgbm90IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZk5vdEluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgIH07XG59XG5jbGFzcyBPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBsZXRpb24sIHNvdXJjZSwgbWF0Y2gsIHNjb3JlKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbiA9IGNvbXBsZXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjdXIoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb207IH1cbi8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gcmVnZXhwIGhhcyBhICQgYXQgaXRzIGVuZCBhbmQsIGlmIGBzdGFydGAgaXNcbi8vIHRydWUsIGEgXiBhdCBpdHMgc3RhcnQuXG5mdW5jdGlvbiBlbnN1cmVBbmNob3IoZXhwciwgc3RhcnQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgc291cmNlIH0gPSBleHByO1xuICAgIGxldCBhZGRTdGFydCA9IHN0YXJ0ICYmIHNvdXJjZVswXSAhPSBcIl5cIiwgYWRkRW5kID0gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPSBcIiRcIjtcbiAgICBpZiAoIWFkZFN0YXJ0ICYmICFhZGRFbmQpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke2FkZFN0YXJ0ID8gXCJeXCIgOiBcIlwifSg/OiR7c291cmNlfSkke2FkZEVuZCA/IFwiJFwiIDogXCJcIn1gLCAoX2EgPSBleHByLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoZXhwci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSk7XG59XG4vKipcblRoaXMgYW5ub3RhdGlvbiBpcyBhZGRlZCB0byB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgcHJvZHVjZWQgYnlcbnBpY2tpbmcgYSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IHBpY2tlZENvbXBsZXRpb24gPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggaW5zZXJ0cyBhXG5jb21wbGV0aW9uJ3MgdGV4dCBpbiB0aGUgbWFpbiBzZWxlY3Rpb24gcmFuZ2UsIGFuZCBhbnkgb3RoZXJcbnNlbGVjdGlvbiByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSB0ZXh0IGluIGZyb250IG9mIGl0LlxuKi9cbmZ1bmN0aW9uIGluc2VydENvbXBsZXRpb25UZXh0KHN0YXRlLCB0ZXh0LCBmcm9tLCB0bykge1xuICAgIGxldCB7IG1haW4gfSA9IHN0YXRlLnNlbGVjdGlvbiwgZnJvbU9mZiA9IGZyb20gLSBtYWluLmZyb20sIHRvT2ZmID0gdG8gLSBtYWluLmZyb207XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBpZiAocmFuZ2UgIT0gbWFpbiAmJiBmcm9tICE9IHRvICYmXG4gICAgICAgICAgICAgICAgc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSArIGZyb21PZmYsIHJhbmdlLmZyb20gKyB0b09mZikgIT0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGF0ZS50b1RleHQodGV4dCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSArIGZyb21PZmYsIHRvOiB0byA9PSBtYWluLmZyb20gPyByYW5nZS50byA6IHJhbmdlLmZyb20gKyB0b09mZiwgaW5zZXJ0OiBsaW5lcyB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBmcm9tT2ZmICsgbGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIlxuICAgIH07XG59XG5jb25zdCBTb3VyY2VDYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gYXNTb3VyY2Uoc291cmNlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IGtub3duID0gU291cmNlQ2FjaGUuZ2V0KHNvdXJjZSk7XG4gICAgaWYgKCFrbm93bilcbiAgICAgICAgU291cmNlQ2FjaGUuc2V0KHNvdXJjZSwga25vd24gPSBjb21wbGV0ZUZyb21MaXN0KHNvdXJjZSkpO1xuICAgIHJldHVybiBrbm93bjtcbn1cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNsb3NlQ29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcblxuLy8gQSBwYXR0ZXJuIG1hdGNoZXIgZm9yIGZ1enp5IGNvbXBsZXRpb24gbWF0Y2hpbmcuIENyZWF0ZSBhbiBpbnN0YW5jZVxuLy8gb25jZSBmb3IgYSBwYXR0ZXJuLCBhbmQgdGhlbiB1c2UgdGhhdCB0byBtYXRjaCBhbnkgbnVtYmVyIG9mXG4vLyBjb21wbGV0aW9ucy5cbmNsYXNzIEZ1enp5TWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICAgIHRoaXMuZm9sZGVkID0gW107XG4gICAgICAgIC8vIEJ1ZmZlcnMgcmV1c2VkIGJ5IGNhbGxzIHRvIGBtYXRjaGAgdG8gdHJhY2sgbWF0Y2hlZCBjaGFyYWN0ZXJcbiAgICAgICAgLy8gcG9zaXRpb25zLlxuICAgICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBbXTtcbiAgICAgICAgdGhpcy5ieVdvcmQgPSBbXTtcbiAgICAgICAgdGhpcy5zY29yZSA9IDA7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhdHRlcm4ubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSBjb2RlUG9pbnRBdChwYXR0ZXJuLCBwKSwgc2l6ZSA9IGNvZGVQb2ludFNpemUoY2hhcik7XG4gICAgICAgICAgICB0aGlzLmNoYXJzLnB1c2goY2hhcik7XG4gICAgICAgICAgICBsZXQgcGFydCA9IHBhdHRlcm4uc2xpY2UocCwgcCArIHNpemUpLCB1cHBlciA9IHBhcnQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZm9sZGVkLnB1c2goY29kZVBvaW50QXQodXBwZXIgPT0gcGFydCA/IHBhcnQudG9Mb3dlckNhc2UoKSA6IHVwcGVyLCAwKSk7XG4gICAgICAgICAgICBwICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3RyYWwgPSBwYXR0ZXJuLmxlbmd0aCAhPSB0aGlzLmNoYXJzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0KHNjb3JlLCBtYXRjaGVkKSB7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gbWF0Y2hlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIE1hdGNoZXMgYSBnaXZlbiB3b3JkIChjb21wbGV0aW9uKSBhZ2FpbnN0IHRoZSBwYXR0ZXJuIChpbnB1dCkuXG4gICAgLy8gV2lsbCByZXR1cm4gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGVyZSB3YXMgYSBtYXRjaCBhbmQsXG4gICAgLy8gb24gc3VjY2Vzcywgc2V0IGB0aGlzLnNjb3JlYCB0byB0aGUgc2NvcmUsIGB0aGlzLm1hdGNoZWRgIHRvIGFuXG4gICAgLy8gYXJyYXkgb2YgYGZyb20sIHRvYCBwYWlycyBpbmRpY2F0aW5nIHRoZSBtYXRjaGVkIHBhcnRzIG9mIGB3b3JkYC5cbiAgICAvL1xuICAgIC8vIFRoZSBzY29yZSBpcyBhIG51bWJlciB0aGF0IGlzIG1vcmUgbmVnYXRpdmUgdGhlIHdvcnNlIHRoZSBtYXRjaFxuICAgIC8vIGlzLiBTZWUgYFBlbmFsdHlgIGFib3ZlLlxuICAgIG1hdGNoKHdvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0dGVybi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLywgW10pO1xuICAgICAgICBpZiAod29yZC5sZW5ndGggPCB0aGlzLnBhdHRlcm4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IGNoYXJzLCBmb2xkZWQsIGFueSwgcHJlY2lzZSwgYnlXb3JkIH0gPSB0aGlzO1xuICAgICAgICAvLyBGb3Igc2luZ2xlLWNoYXJhY3RlciBxdWVyaWVzLCBvbmx5IG1hdGNoIHdoZW4gdGhleSBvY2N1ciByaWdodFxuICAgICAgICAvLyBhdCB0aGUgc3RhcnRcbiAgICAgICAgaWYgKGNoYXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBjb2RlUG9pbnRBdCh3b3JkLCAwKSwgZmlyc3RTaXplID0gY29kZVBvaW50U2l6ZShmaXJzdCk7XG4gICAgICAgICAgICBsZXQgc2NvcmUgPSBmaXJzdFNpemUgPT0gd29yZC5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi87XG4gICAgICAgICAgICBpZiAoZmlyc3QgPT0gY2hhcnNbMF0pIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0ID09IGZvbGRlZFswXSlcbiAgICAgICAgICAgICAgICBzY29yZSArPSAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi87XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoc2NvcmUsIFswLCBmaXJzdFNpemVdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlyZWN0ID0gd29yZC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgICAgIGlmIChkaXJlY3QgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCh3b3JkLmxlbmd0aCA9PSB0aGlzLnBhdHRlcm4ubGVuZ3RoID8gMCA6IC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovLCBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aF0pO1xuICAgICAgICBsZXQgbGVuID0gY2hhcnMubGVuZ3RoLCBhbnlUbyA9IDA7XG4gICAgICAgIGlmIChkaXJlY3QgPCAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApOyBpIDwgZSAmJiBhbnlUbyA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FueVRvXSB8fCBuZXh0ID09IGZvbGRlZFthbnlUb10pXG4gICAgICAgICAgICAgICAgICAgIGFueVthbnlUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbWF0Y2gsIGV4aXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChhbnlUbyA8IGxlbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRyYWNrcyB0aGUgZXh0ZW50IG9mIHRoZSBwcmVjaXNlIChub24tZm9sZGVkLCBub3RcbiAgICAgICAgLy8gbmVjZXNzYXJpbHkgYWRqYWNlbnQpIG1hdGNoXG4gICAgICAgIGxldCBwcmVjaXNlVG8gPSAwO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGVyZSBpcyBhIG1hdGNoIHRoYXQgaGl0cyBvbmx5IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAvLyBhcHBlYXIgdG8gYmUgc3RhcnRpbmcgd29yZHMuIGBieVdvcmRGb2xkZWRgIGlzIHNldCB0byB0cnVlIHdoZW5cbiAgICAgICAgLy8gYSBjYXNlIGZvbGRlZCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gc3VjaCBhIG1hdGNoXG4gICAgICAgIGxldCBieVdvcmRUbyA9IDAsIGJ5V29yZEZvbGRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBhIHBhcnRpYWwgYWRqYWNlbnQgbWF0Y2gsIHRoZXNlIHRyYWNrIGl0cyBzdGF0ZVxuICAgICAgICBsZXQgYWRqYWNlbnRUbyA9IDAsIGFkamFjZW50U3RhcnQgPSAtMSwgYWRqYWNlbnRFbmQgPSAtMTtcbiAgICAgICAgbGV0IGhhc0xvd2VyID0gL1thLXpdLy50ZXN0KHdvcmQpLCB3b3JkQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICAvLyBHbyBvdmVyIHRoZSBvcHRpb24ncyB0ZXh0LCBzY2FubmluZyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgbWF0Y2hlc1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApLCBwcmV2VHlwZSA9IDAgLyogVHAuTm9uV29yZCAqLzsgaSA8IGUgJiYgYnlXb3JkVG8gPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzZVRvIDwgbGVuICYmIG5leHQgPT0gY2hhcnNbcHJlY2lzZVRvXSlcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzZVtwcmVjaXNlVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FkamFjZW50VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FkamFjZW50VG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRFbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoLCB0eXBlID0gbmV4dCA8IDB4ZmZcbiAgICAgICAgICAgICAgICA/IChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcgfHwgbmV4dCA+PSA5NyAmJiBuZXh0IDw9IDEyMiA/IDIgLyogVHAuTG93ZXIgKi8gOiBuZXh0ID49IDY1ICYmIG5leHQgPD0gOTAgPyAxIC8qIFRwLlVwcGVyICovIDogMCAvKiBUcC5Ob25Xb3JkICovKVxuICAgICAgICAgICAgICAgIDogKChjaCA9IGZyb21Db2RlUG9pbnQobmV4dCkpICE9IGNoLnRvTG93ZXJDYXNlKCkgPyAxIC8qIFRwLlVwcGVyICovIDogY2ggIT0gY2gudG9VcHBlckNhc2UoKSA/IDIgLyogVHAuTG93ZXIgKi8gOiAwIC8qIFRwLk5vbldvcmQgKi8pO1xuICAgICAgICAgICAgaWYgKCFpIHx8IHR5cGUgPT0gMSAvKiBUcC5VcHBlciAqLyAmJiBoYXNMb3dlciB8fCBwcmV2VHlwZSA9PSAwIC8qIFRwLk5vbldvcmQgKi8gJiYgdHlwZSAhPSAwIC8qIFRwLk5vbldvcmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNbYnlXb3JkVG9dID09IG5leHQgfHwgKGZvbGRlZFtieVdvcmRUb10gPT0gbmV4dCAmJiAoYnlXb3JkRm9sZGVkID0gdHJ1ZSkpKVxuICAgICAgICAgICAgICAgICAgICBieVdvcmRbYnlXb3JkVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ5V29yZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdvcmRBZGphY2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4gJiYgYnlXb3JkWzBdID09IDAgJiYgd29yZEFkamFjZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogUGVuYWx0eS5CeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIDogMCksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbiAmJiBhZGphY2VudFN0YXJ0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIC0gd29yZC5sZW5ndGggKyAoYWRqYWNlbnRFbmQgPT0gd29yZC5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8pLCBbMCwgYWRqYWNlbnRFbmRdKTtcbiAgICAgICAgaWYgKGRpcmVjdCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyAtIHdvcmQubGVuZ3RoLCBbZGlyZWN0LCBkaXJlY3QgKyB0aGlzLnBhdHRlcm4ubGVuZ3RoXSk7XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gKyAtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gLSB3b3JkLmxlbmd0aCwgW2FkamFjZW50U3RhcnQsIGFkamFjZW50RW5kXSk7XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBQZW5hbHR5LkJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiAwKSArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyArXG4gICAgICAgICAgICAgICAgKHdvcmRBZGphY2VudCA/IDAgOiAtMTEwMCAvKiBQZW5hbHR5LkdhcCAqLyksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIHJldHVybiBjaGFycy5sZW5ndGggPT0gMiA/IG51bGxcbiAgICAgICAgICAgIDogdGhpcy5yZXN1bHQoKGFueVswXSA/IC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyA6IDApICsgLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovICsgLTExMDAgLyogUGVuYWx0eS5HYXAgKi8sIGFueSwgd29yZCk7XG4gICAgfVxuICAgIHJlc3VsdChzY29yZSwgcG9zaXRpb25zLCB3b3JkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB0byA9IHBvcyArICh0aGlzLmFzdHJhbCA/IGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQod29yZCwgcG9zKSkgOiAxKTtcbiAgICAgICAgICAgIGlmIChpICYmIHJlc3VsdFtpIC0gMV0gPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpIC0gMV0gPSB0bztcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmV0KHNjb3JlIC0gd29yZC5sZW5ndGgsIHJlc3VsdCk7XG4gICAgfVxufVxuY2xhc3MgU3RyaWN0TWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zY29yZSA9IDA7XG4gICAgICAgIHRoaXMuZm9sZGVkID0gcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBtYXRjaCh3b3JkKSB7XG4gICAgICAgIGlmICh3b3JkLmxlbmd0aCA8IHRoaXMucGF0dGVybi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHN0YXJ0ID0gd29yZC5zbGljZSgwLCB0aGlzLnBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgbGV0IG1hdGNoID0gc3RhcnQgPT0gdGhpcy5wYXR0ZXJuID8gMCA6IHN0YXJ0LnRvTG93ZXJDYXNlKCkgPT0gdGhpcy5mb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiBudWxsO1xuICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBbMCwgc3RhcnQubGVuZ3RoXTtcbiAgICAgICAgdGhpcy5zY29yZSA9IG1hdGNoICsgKHdvcmQubGVuZ3RoID09IHRoaXMucGF0dGVybi5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNvbnN0IGNvbXBsZXRpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWN0aXZhdGVPblR5cGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGFjdGl2YXRlT25Db21wbGV0aW9uOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgICAgIGFjdGl2YXRlT25UeXBpbmdEZWxheTogMTAwLFxuICAgICAgICAgICAgc2VsZWN0T25PcGVuOiB0cnVlLFxuICAgICAgICAgICAgb3ZlcnJpZGU6IG51bGwsXG4gICAgICAgICAgICBjbG9zZU9uQmx1cjogdHJ1ZSxcbiAgICAgICAgICAgIG1heFJlbmRlcmVkT3B0aW9uczogMTAwLFxuICAgICAgICAgICAgZGVmYXVsdEtleW1hcDogdHJ1ZSxcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKCkgPT4gXCJcIixcbiAgICAgICAgICAgIG9wdGlvbkNsYXNzOiAoKSA9PiBcIlwiLFxuICAgICAgICAgICAgYWJvdmVDdXJzb3I6IGZhbHNlLFxuICAgICAgICAgICAgaWNvbnM6IHRydWUsXG4gICAgICAgICAgICBhZGRUb09wdGlvbnM6IFtdLFxuICAgICAgICAgICAgcG9zaXRpb25JbmZvOiBkZWZhdWx0UG9zaXRpb25JbmZvLFxuICAgICAgICAgICAgZmlsdGVyU3RyaWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbXBhcmVDb21wbGV0aW9uczogKGEsIGIpID0+IChhLnNvcnRUZXh0IHx8IGEubGFiZWwpLmxvY2FsZUNvbXBhcmUoYi5zb3J0VGV4dCB8fCBiLmxhYmVsKSxcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGVsYXk6IDc1LFxuICAgICAgICAgICAgdXBkYXRlU3luY1RpbWU6IDEwMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBpY29uczogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogKGEsIGIpID0+IGEuY29uY2F0KGIpLFxuICAgICAgICAgICAgZmlsdGVyU3RyaWN0OiAoYSwgYikgPT4gYSB8fCBiLFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGpvaW5DbGFzcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyBiID8gYSArIFwiIFwiICsgYiA6IGEgOiBiO1xufVxuZnVuY3Rpb24gZGVmYXVsdFBvc2l0aW9uSW5mbyh2aWV3LCBsaXN0LCBvcHRpb24sIGluZm8sIHNwYWNlLCB0b29sdGlwKSB7XG4gICAgbGV0IHJ0bCA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uUlRMLCBsZWZ0ID0gcnRsLCBuYXJyb3cgPSBmYWxzZTtcbiAgICBsZXQgc2lkZSA9IFwidG9wXCIsIG9mZnNldCwgbWF4V2lkdGg7XG4gICAgbGV0IHNwYWNlTGVmdCA9IGxpc3QubGVmdCAtIHNwYWNlLmxlZnQsIHNwYWNlUmlnaHQgPSBzcGFjZS5yaWdodCAtIGxpc3QucmlnaHQ7XG4gICAgbGV0IGluZm9XaWR0aCA9IGluZm8ucmlnaHQgLSBpbmZvLmxlZnQsIGluZm9IZWlnaHQgPSBpbmZvLmJvdHRvbSAtIGluZm8udG9wO1xuICAgIGlmIChsZWZ0ICYmIHNwYWNlTGVmdCA8IE1hdGgubWluKGluZm9XaWR0aCwgc3BhY2VSaWdodCkpXG4gICAgICAgIGxlZnQgPSBmYWxzZTtcbiAgICBlbHNlIGlmICghbGVmdCAmJiBzcGFjZVJpZ2h0IDwgTWF0aC5taW4oaW5mb1dpZHRoLCBzcGFjZUxlZnQpKVxuICAgICAgICBsZWZ0ID0gdHJ1ZTtcbiAgICBpZiAoaW5mb1dpZHRoIDw9IChsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCkpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoc3BhY2UudG9wLCBNYXRoLm1pbihvcHRpb24udG9wLCBzcGFjZS5ib3R0b20gLSBpbmZvSGVpZ2h0KSkgLSBsaXN0LnRvcDtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgbGVmdCA/IHNwYWNlTGVmdCA6IHNwYWNlUmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmFycm93ID0gdHJ1ZTtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgKHJ0bCA/IGxpc3QucmlnaHQgOiBzcGFjZS5yaWdodCAtIGxpc3QubGVmdCkgLSAzMCAvKiBJbmZvLk1hcmdpbiAqLyk7XG4gICAgICAgIGxldCBzcGFjZUJlbG93ID0gc3BhY2UuYm90dG9tIC0gbGlzdC5ib3R0b207XG4gICAgICAgIGlmIChzcGFjZUJlbG93ID49IGluZm9IZWlnaHQgfHwgc3BhY2VCZWxvdyA+IGxpc3QudG9wKSB7IC8vIEJlbG93IHRoZSBjb21wbGV0aW9uXG4gICAgICAgICAgICBvZmZzZXQgPSBvcHRpb24uYm90dG9tIC0gbGlzdC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIEFib3ZlIGl0XG4gICAgICAgICAgICBzaWRlID0gXCJib3R0b21cIjtcbiAgICAgICAgICAgIG9mZnNldCA9IGxpc3QuYm90dG9tIC0gb3B0aW9uLnRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2NhbGVZID0gKGxpc3QuYm90dG9tIC0gbGlzdC50b3ApIC8gdG9vbHRpcC5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHNjYWxlWCA9IChsaXN0LnJpZ2h0IC0gbGlzdC5sZWZ0KSAvIHRvb2x0aXAub2Zmc2V0V2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6IGAke3NpZGV9OiAke29mZnNldCAvIHNjYWxlWX1weDsgbWF4LXdpZHRoOiAke21heFdpZHRoIC8gc2NhbGVYfXB4YCxcbiAgICAgICAgY2xhc3M6IFwiY20tY29tcGxldGlvbkluZm8tXCIgKyAobmFycm93ID8gKHJ0bCA/IFwibGVmdC1uYXJyb3dcIiA6IFwicmlnaHQtbmFycm93XCIpIDogbGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG9wdGlvbkNvbnRlbnQoY29uZmlnKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBjb25maWcuYWRkVG9PcHRpb25zLnNsaWNlKCk7XG4gICAgaWYgKGNvbmZpZy5pY29ucylcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25JY29uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZCguLi5jb21wbGV0aW9uLnR5cGUuc3BsaXQoL1xccysvZykubWFwKGNscyA9PiBcImNtLWNvbXBsZXRpb25JY29uLVwiICsgY2xzKSk7XG4gICAgICAgICAgICAgICAgaWNvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IDIwXG4gICAgICAgIH0pO1xuICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uLCBfcywgX3YsIG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGxhYmVsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkxhYmVsXCI7XG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBjb21wbGV0aW9uLmRpc3BsYXlMYWJlbCB8fCBjb21wbGV0aW9uLmxhYmVsLCBvZmYgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaC5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBtYXRjaFtqKytdLCB0byA9IG1hdGNoW2orK107XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBvZmYpXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZiwgZnJvbSkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKGZyb20sIHRvKSkpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjtcbiAgICAgICAgICAgICAgICBvZmYgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmYgPCBsYWJlbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogNTBcbiAgICB9LCB7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRpb24uZGV0YWlsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGFpbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZGV0YWlsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkRldGFpbFwiO1xuICAgICAgICAgICAgZGV0YWlsRWx0LnRleHRDb250ZW50ID0gY29tcGxldGlvbi5kZXRhaWw7XG4gICAgICAgICAgICByZXR1cm4gZGV0YWlsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogODBcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudC5zb3J0KChhLCBiKSA9PiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbikubWFwKGEgPT4gYS5yZW5kZXIpO1xufVxuZnVuY3Rpb24gcmFuZ2VBcm91bmRTZWxlY3RlZCh0b3RhbCwgc2VsZWN0ZWQsIG1heCkge1xuICAgIGlmICh0b3RhbCA8PSBtYXgpXG4gICAgICAgIHJldHVybiB7IGZyb206IDAsIHRvOiB0b3RhbCB9O1xuICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgIHNlbGVjdGVkID0gMDtcbiAgICBpZiAoc2VsZWN0ZWQgPD0gKHRvdGFsID4+IDEpKSB7XG4gICAgICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKHNlbGVjdGVkIC8gbWF4KTtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2ZmICogbWF4LCB0bzogKG9mZiArIDEpICogbWF4IH07XG4gICAgfVxuICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKCh0b3RhbCAtIHNlbGVjdGVkKSAvIG1heCk7XG4gICAgcmV0dXJuIHsgZnJvbTogdG90YWwgLSAob2ZmICsgMSkgKiBtYXgsIHRvOiB0b3RhbCAtIG9mZiAqIG1heCB9O1xufVxuY2xhc3MgQ29tcGxldGlvblRvb2x0aXAge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlRmllbGQgPSBzdGF0ZUZpZWxkO1xuICAgICAgICB0aGlzLmFwcGx5Q29tcGxldGlvbiA9IGFwcGx5Q29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhY2VJbmZvUmVxID0ge1xuICAgICAgICAgICAgcmVhZDogKCkgPT4gdGhpcy5tZWFzdXJlSW5mbygpLFxuICAgICAgICAgICAgd3JpdGU6IChwb3MpID0+IHRoaXMucGxhY2VJbmZvKHBvcyksXG4gICAgICAgICAgICBrZXk6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zcGFjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudENsYXNzID0gXCJcIjtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkIH0gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMub3B0aW9uQ29udGVudCA9IG9wdGlvbkNvbnRlbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25DbGFzcyA9IGNvbmZpZy5vcHRpb25DbGFzcztcbiAgICAgICAgdGhpcy50b29sdGlwQ2xhc3MgPSBjb25maWcudG9vbHRpcENsYXNzO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIGNvbmZpZy5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3Modmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCkub3BlbjtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSA9IGUudGFyZ2V0LCBtYXRjaDsgZG9tICYmIGRvbSAhPSB0aGlzLmRvbTsgZG9tID0gZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiTElcIiAmJiAobWF0Y2ggPSAvLShcXGQrKSQvLmV4ZWMoZG9tLmlkKSkgJiYgK21hdGNoWzFdIDwgb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uc1srbWF0Y2hbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIChlKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvb2x0aXAgJiYgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jbG9zZU9uQmx1ciAmJlxuICAgICAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2hvd09wdGlvbnMob3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICB9XG4gICAgbW91bnQoKSB7IHRoaXMudXBkYXRlU2VsKCk7IH1cbiAgICBzaG93T3B0aW9ucyhvcHRpb25zLCBpZCkge1xuICAgICAgICBpZiAodGhpcy5saXN0KVxuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHRoaXMucmFuZ2UpKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm9SZXEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjU3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICAgICAgbGV0IHByZXZTdGF0ZSA9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCk7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcENsYXNzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChjU3RhdGUgIT0gcHJldlN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCBzZWxlY3RlZCwgZGlzYWJsZWQgfSA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUub3BlbiB8fCBwcmV2U3RhdGUub3Blbi5vcHRpb25zICE9IG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIHVwZGF0ZS5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd09wdGlvbnMob3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsKCk7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgIT0gKChfYSA9IHByZXZTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzYWJsZWQpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZFwiLCAhIWRpc2FibGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVUb29sdGlwQ2xhc3Moc3RhdGUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMudG9vbHRpcENsYXNzKHN0YXRlKTtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmN1cnJlbnRDbGFzcykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLmN1cnJlbnRDbGFzcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNscy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbCgpIHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpLCBvcGVuID0gY1N0YXRlLm9wZW47XG4gICAgICAgIGlmIChvcGVuLnNlbGVjdGVkID4gLTEgJiYgb3Blbi5zZWxlY3RlZCA8IHRoaXMucmFuZ2UuZnJvbSB8fCBvcGVuLnNlbGVjdGVkID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wZW4ub3B0aW9ucy5sZW5ndGgsIG9wZW4uc2VsZWN0ZWQsIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcGVuLm9wdGlvbnMsIGNTdGF0ZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1NlbCA9IHRoaXMudXBkYXRlU2VsZWN0ZWRPcHRpb24ob3Blbi5zZWxlY3RlZCk7XG4gICAgICAgIGlmIChuZXdTZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUluZm8oKTtcbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24gfSA9IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXTtcbiAgICAgICAgICAgIGxldCB7IGluZm8gfSA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGluZm9SZXN1bHQgPSB0eXBlb2YgaW5mbyA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGluZm8pIDogaW5mbyhjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmICghaW5mb1Jlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoXCJ0aGVuXCIgaW4gaW5mb1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgIGluZm9SZXN1bHQudGhlbihvYmogPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqICYmIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQsIGZhbHNlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEluZm9QYW5lKG9iaiwgY29tcGxldGlvbik7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlLCBcImNvbXBsZXRpb24gaW5mb1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEluZm9QYW5lKGluZm9SZXN1bHQsIGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgICAgIG5ld1NlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIHRoaXMuaW5mby5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSW5mb1BhbmUoY29udGVudCwgY29tcGxldGlvbikge1xuICAgICAgICB0aGlzLmRlc3Ryb3lJbmZvKCk7XG4gICAgICAgIGxldCB3cmFwID0gdGhpcy5pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm9cIjtcbiAgICAgICAgd3JhcC5pZCA9IFwiY20tY29tcGxldGlvbkluZm8tXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGNvbnRlbnQubm9kZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgZG9tLCBkZXN0cm95IH0gPSBjb250ZW50O1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IGRlc3Ryb3kgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh3cmFwKTtcbiAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgbGV0IHNldCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IG9wdCA9IHRoaXMubGlzdC5maXJzdENoaWxkLCBpID0gdGhpcy5yYW5nZS5mcm9tOyBvcHQ7IG9wdCA9IG9wdC5uZXh0U2libGluZywgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3B0Lm5vZGVOYW1lICE9IFwiTElcIiB8fCAhb3B0LmlkKSB7XG4gICAgICAgICAgICAgICAgaS0tOyAvLyBBIHNlY3Rpb24gaGVhZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IG9wdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0KVxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcodGhpcy5saXN0LCBzZXQpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBtZWFzdXJlSW5mbygpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbYXJpYS1zZWxlY3RlZF1cIik7XG4gICAgICAgIGlmICghc2VsIHx8ICF0aGlzLmluZm8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxpc3RSZWN0ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBpbmZvUmVjdCA9IHRoaXMuaW5mby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNlbFJlY3QgPSBzZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzcGFjZSA9IHRoaXMuc3BhY2U7XG4gICAgICAgIGlmICghc3BhY2UpIHtcbiAgICAgICAgICAgIGxldCBkb2NFbHQgPSB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHNwYWNlID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiBkb2NFbHQuY2xpZW50V2lkdGgsIGJvdHRvbTogZG9jRWx0LmNsaWVudEhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxSZWN0LnRvcCA+IE1hdGgubWluKHNwYWNlLmJvdHRvbSwgbGlzdFJlY3QuYm90dG9tKSAtIDEwIHx8XG4gICAgICAgICAgICBzZWxSZWN0LmJvdHRvbSA8IE1hdGgubWF4KHNwYWNlLnRvcCwgbGlzdFJlY3QudG9wKSArIDEwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykucG9zaXRpb25JbmZvKHRoaXMudmlldywgbGlzdFJlY3QsIHNlbFJlY3QsIGluZm9SZWN0LCBzcGFjZSwgdGhpcy5kb20pO1xuICAgIH1cbiAgICBwbGFjZUluZm8ocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUuY3NzVGV4dCA9IHBvcy5zdHlsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvIFwiICsgKHBvcy5jbGFzcyB8fCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6IC0xZTZweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB1bC5pZCA9IGlkO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkNvbXBsZXRpb25zXCIpKTtcbiAgICAgICAgdWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgZm9jdXMgY2hhbmdlIHdoZW4gY2xpY2tpbmcgdGhlIHNjcm9sbGJhclxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09IHVsKVxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjdXJTZWN0aW9uID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlLmZyb207IGkgPCByYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBjb21wbGV0aW9uLCBtYXRjaCB9ID0gb3B0aW9uc1tpXSwgeyBzZWN0aW9uIH0gPSBjb21wbGV0aW9uO1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyBzZWN0aW9uIDogc2VjdGlvbi5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lICE9IGN1clNlY3Rpb24gJiYgKGkgPiByYW5nZS5mcm9tIHx8IHJhbmdlLmZyb20gPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyU2VjdGlvbiA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VjdGlvbiAhPSBcInN0cmluZ1wiICYmIHNlY3Rpb24uaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bC5hcHBlbmRDaGlsZChzZWN0aW9uLmhlYWRlcihzZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGVhZGVyID0gdWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNvbXBsZXRpb24tc2VjdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIudGV4dENvbnRlbnQgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGkgPSB1bC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgICAgICAgbGkuaWQgPSBpZCArIFwiLVwiICsgaTtcbiAgICAgICAgICAgIGxpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIik7XG4gICAgICAgICAgICBsZXQgY2xzID0gdGhpcy5vcHRpb25DbGFzcyhjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgbGkuY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHRoaXMub3B0aW9uQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gc291cmNlKGNvbXBsZXRpb24sIHRoaXMudmlldy5zdGF0ZSwgdGhpcy52aWV3LCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGxpLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZS5mcm9tKVxuICAgICAgICAgICAgdWwuY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcFwiKTtcbiAgICAgICAgaWYgKHJhbmdlLnRvIDwgb3B0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tXCIpO1xuICAgICAgICByZXR1cm4gdWw7XG4gICAgfVxuICAgIGRlc3Ryb3lJbmZvKCkge1xuICAgICAgICBpZiAodGhpcy5pbmZvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvRGVzdHJveSlcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9EZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluZm8ucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLmluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUluZm8oKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wbGV0aW9uVG9vbHRpcChzdGF0ZUZpZWxkLCBhcHBseUNvbXBsZXRpb24pIHtcbiAgICByZXR1cm4gKHZpZXcpID0+IG5ldyBDb21wbGV0aW9uVG9vbHRpcCh2aWV3LCBzdGF0ZUZpZWxkLCBhcHBseUNvbXBsZXRpb24pO1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY29udGFpbmVyLCBlbGVtZW50KSB7XG4gICAgbGV0IHBhcmVudCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc2VsZiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHNjYWxlWSA9IHBhcmVudC5oZWlnaHQgLyBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgIGlmIChzZWxmLnRvcCA8IHBhcmVudC50b3ApXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgLT0gKHBhcmVudC50b3AgLSBzZWxmLnRvcCkgLyBzY2FsZVk7XG4gICAgZWxzZSBpZiAoc2VsZi5ib3R0b20gPiBwYXJlbnQuYm90dG9tKVxuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wICs9IChzZWxmLmJvdHRvbSAtIHBhcmVudC5ib3R0b20pIC8gc2NhbGVZO1xufVxuXG4vLyBVc2VkIHRvIHBpY2sgYSBwcmVmZXJyZWQgb3B0aW9uIHdoZW4gdHdvIG9wdGlvbnMgd2l0aCB0aGUgc2FtZVxuLy8gbGFiZWwgb2NjdXIgaW4gdGhlIHJlc3VsdC5cbmZ1bmN0aW9uIHNjb3JlKG9wdGlvbikge1xuICAgIHJldHVybiAob3B0aW9uLmJvb3N0IHx8IDApICogMTAwICsgKG9wdGlvbi5hcHBseSA/IDEwIDogMCkgKyAob3B0aW9uLmluZm8gPyA1IDogMCkgK1xuICAgICAgICAob3B0aW9uLnR5cGUgPyAxIDogMCk7XG59XG5mdW5jdGlvbiBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXTtcbiAgICBsZXQgc2VjdGlvbnMgPSBudWxsLCBkeW5hbWljU2VjdGlvblNjb3JlID0gbnVsbDtcbiAgICBsZXQgYWRkT3B0aW9uID0gKG9wdGlvbikgPT4ge1xuICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICAgICAgbGV0IHsgc2VjdGlvbiB9ID0gb3B0aW9uLmNvbXBsZXRpb247XG4gICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXNlY3Rpb25zKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyBzZWN0aW9uIDogc2VjdGlvbi5uYW1lO1xuICAgICAgICAgICAgaWYgKCFzZWN0aW9ucy5zb21lKHMgPT4gcy5uYW1lID09IG5hbWUpKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2godHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHsgbmFtZSB9IDogc2VjdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBjb25mID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgZm9yIChsZXQgYSBvZiBhY3RpdmUpXG4gICAgICAgIGlmIChhLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICBsZXQgZ2V0TWF0Y2ggPSBhLnJlc3VsdC5nZXRNYXRjaDtcbiAgICAgICAgICAgIGlmIChhLnJlc3VsdC5maWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIGEucmVzdWx0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW9uKG5ldyBPcHRpb24ob3B0aW9uLCBhLnNvdXJjZSwgZ2V0TWF0Y2ggPyBnZXRNYXRjaChvcHRpb24pIDogW10sIDFlOSAtIG9wdGlvbnMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSBzdGF0ZS5zbGljZURvYyhhLmZyb20sIGEudG8pLCBtYXRjaDtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlciA9IGNvbmYuZmlsdGVyU3RyaWN0ID8gbmV3IFN0cmljdE1hdGNoZXIocGF0dGVybikgOiBuZXcgRnV6enlNYXRjaGVyKHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPSBtYXRjaGVyLm1hdGNoKG9wdGlvbi5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaGVkID0gIW9wdGlvbi5kaXNwbGF5TGFiZWwgPyBtYXRjaC5tYXRjaGVkIDogZ2V0TWF0Y2ggPyBnZXRNYXRjaChvcHRpb24sIG1hdGNoLm1hdGNoZWQpIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2NvcmUgPSBtYXRjaC5zY29yZSArIChvcHRpb24uYm9vc3QgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPcHRpb24obmV3IE9wdGlvbihvcHRpb24sIGEuc291cmNlLCBtYXRjaGVkLCBzY29yZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24uc2VjdGlvbiA9PSBcIm9iamVjdFwiICYmIG9wdGlvbi5zZWN0aW9uLnJhbmsgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHsgbmFtZSB9ID0gb3B0aW9uLnNlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkeW5hbWljU2VjdGlvblNjb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2VjdGlvblNjb3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2VjdGlvblNjb3JlW25hbWVdID0gTWF0aC5tYXgoc2NvcmUsIGR5bmFtaWNTZWN0aW9uU2NvcmVbbmFtZV0gfHwgLTFlOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGlmIChzZWN0aW9ucykge1xuICAgICAgICBsZXQgc2VjdGlvbk9yZGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcG9zID0gMDtcbiAgICAgICAgbGV0IGNtcCA9IChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGEucmFuayA9PT0gXCJkeW5hbWljXCIgJiYgYi5yYW5rID09PSBcImR5bmFtaWNcIiA/IGR5bmFtaWNTZWN0aW9uU2NvcmVbYi5uYW1lXSAtIGR5bmFtaWNTZWN0aW9uU2NvcmVbYS5uYW1lXSA6IDApIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBhLnJhbmsgPT0gXCJudW1iZXJcIiA/IGEucmFuayA6IDFlOSkgLSAodHlwZW9mIGIucmFuayA9PSBcIm51bWJlclwiID8gYi5yYW5rIDogMWU5KSB8fFxuICAgICAgICAgICAgICAgIChhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IDEpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBzIG9mIHNlY3Rpb25zLnNvcnQoY21wKSkge1xuICAgICAgICAgICAgcG9zIC09IDFlNTtcbiAgICAgICAgICAgIHNlY3Rpb25PcmRlcltzLm5hbWVdID0gcG9zO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBsZXQgeyBzZWN0aW9uIH0gPSBvcHRpb24uY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uKVxuICAgICAgICAgICAgICAgIG9wdGlvbi5zY29yZSArPSBzZWN0aW9uT3JkZXJbdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXSwgcHJldiA9IG51bGw7XG4gICAgbGV0IGNvbXBhcmUgPSBjb25mLmNvbXBhcmVDb21wbGV0aW9ucztcbiAgICBmb3IgKGxldCBvcHQgb2Ygb3B0aW9ucy5zb3J0KChhLCBiKSA9PiAoYi5zY29yZSAtIGEuc2NvcmUpIHx8IGNvbXBhcmUoYS5jb21wbGV0aW9uLCBiLmNvbXBsZXRpb24pKSkge1xuICAgICAgICBsZXQgY3VyID0gb3B0LmNvbXBsZXRpb247XG4gICAgICAgIGlmICghcHJldiB8fCBwcmV2LmxhYmVsICE9IGN1ci5sYWJlbCB8fCBwcmV2LmRldGFpbCAhPSBjdXIuZGV0YWlsIHx8XG4gICAgICAgICAgICAocHJldi50eXBlICE9IG51bGwgJiYgY3VyLnR5cGUgIT0gbnVsbCAmJiBwcmV2LnR5cGUgIT0gY3VyLnR5cGUpIHx8XG4gICAgICAgICAgICBwcmV2LmFwcGx5ICE9IGN1ci5hcHBseSB8fCBwcmV2LmJvb3N0ICE9IGN1ci5ib29zdClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9wdCk7XG4gICAgICAgIGVsc2UgaWYgKHNjb3JlKG9wdC5jb21wbGV0aW9uKSA+IHNjb3JlKHByZXYpKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IG9wdDtcbiAgICAgICAgcHJldiA9IG9wdC5jb21wbGV0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgQ29tcGxldGlvbkRpYWxvZyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXR0cnMsIHRvb2x0aXAsIHRpbWVzdGFtcCwgc2VsZWN0ZWQsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy50b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBzZXRTZWxlY3RlZChzZWxlY3RlZCwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkID09IHRoaXMuc2VsZWN0ZWQgfHwgc2VsZWN0ZWQgPj0gdGhpcy5vcHRpb25zLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwgdGhpcy50b29sdGlwLCB0aGlzLnRpbWVzdGFtcCwgc2VsZWN0ZWQsIHRoaXMuZGlzYWJsZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGQoYWN0aXZlLCBzdGF0ZSwgaWQsIHByZXYsIGNvbmYsIGRpZFNldEFjdGl2ZSkge1xuICAgICAgICBpZiAocHJldiAmJiAhZGlkU2V0QWN0aXZlICYmIGFjdGl2ZS5zb21lKHMgPT4gcy5pc1BlbmRpbmcpKVxuICAgICAgICAgICAgcmV0dXJuIHByZXYuc2V0RGlzYWJsZWQoKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBwcmV2ICYmIGFjdGl2ZS5zb21lKGEgPT4gYS5pc1BlbmRpbmcpID8gcHJldi5zZXREaXNhYmxlZCgpIDogbnVsbDtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuc2VsZWN0T25PcGVuID8gMCA6IC0xO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2LnNlbGVjdGVkICE9IHNlbGVjdGVkICYmIHByZXYuc2VsZWN0ZWQgIT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZFZhbHVlID0gcHJldi5vcHRpb25zW3ByZXYuc2VsZWN0ZWRdLmNvbXBsZXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbaV0uY29tcGxldGlvbiA9PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyhvcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwge1xuICAgICAgICAgICAgcG9zOiBhY3RpdmUucmVkdWNlKChhLCBiKSA9PiBiLmhhc1Jlc3VsdCgpID8gTWF0aC5taW4oYSwgYi5mcm9tKSA6IGEsIDFlOCksXG4gICAgICAgICAgICBjcmVhdGU6IGNyZWF0ZVRvb2x0aXAsXG4gICAgICAgICAgICBhYm92ZTogY29uZi5hYm92ZUN1cnNvcixcbiAgICAgICAgfSwgcHJldiA/IHByZXYudGltZXN0YW1wIDogRGF0ZS5ub3coKSwgc2VsZWN0ZWQsIGZhbHNlKTtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgdGhpcy5hdHRycywgeyAuLi50aGlzLnRvb2x0aXAsIHBvczogY2hhbmdlcy5tYXBQb3ModGhpcy50b29sdGlwLnBvcykgfSwgdGhpcy50aW1lc3RhbXAsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuZGlzYWJsZWQpO1xuICAgIH1cbiAgICBzZXREaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgdGhpcy5hdHRycywgdGhpcy50b29sdGlwLCB0aGlzLnRpbWVzdGFtcCwgdGhpcy5zZWxlY3RlZCwgdHJ1ZSk7XG4gICAgfVxufVxuY2xhc3MgQ29tcGxldGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmUsIGlkLCBvcGVuKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIHN0YXRpYyBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uU3RhdGUobm9uZSwgXCJjbS1hYy1cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDJlNikudG9TdHJpbmcoMzYpLCBudWxsKTtcbiAgICB9XG4gICAgdXBkYXRlKHRyKSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgY29uZiA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgICAgICBsZXQgc291cmNlcyA9IGNvbmYub3ZlcnJpZGUgfHxcbiAgICAgICAgICAgIHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiYXV0b2NvbXBsZXRlXCIsIGN1cihzdGF0ZSkpLm1hcChhc1NvdXJjZSk7XG4gICAgICAgIGxldCBhY3RpdmUgPSBzb3VyY2VzLm1hcChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5hY3RpdmUuZmluZChzID0+IHMuc291cmNlID09IHNvdXJjZSkgfHxcbiAgICAgICAgICAgICAgICBuZXcgQWN0aXZlU291cmNlKHNvdXJjZSwgdGhpcy5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgPyAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gOiAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggPT0gdGhpcy5hY3RpdmUubGVuZ3RoICYmIGFjdGl2ZS5ldmVyeSgoYSwgaSkgPT4gYSA9PSB0aGlzLmFjdGl2ZVtpXSkpXG4gICAgICAgICAgICBhY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLm9wZW4sIGRpZFNldCA9IHRyLmVmZmVjdHMuc29tZShlID0+IGUuaXMoc2V0QWN0aXZlRWZmZWN0KSk7XG4gICAgICAgIGlmIChvcGVuICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICBvcGVuID0gb3Blbi5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24gfHwgYWN0aXZlLnNvbWUoYSA9PiBhLmhhc1Jlc3VsdCgpICYmIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGEuZnJvbSwgYS50bykpIHx8XG4gICAgICAgICAgICAhc2FtZVJlc3VsdHMoYWN0aXZlLCB0aGlzLmFjdGl2ZSkgfHwgZGlkU2V0KVxuICAgICAgICAgICAgb3BlbiA9IENvbXBsZXRpb25EaWFsb2cuYnVpbGQoYWN0aXZlLCBzdGF0ZSwgdGhpcy5pZCwgb3BlbiwgY29uZiwgZGlkU2V0KTtcbiAgICAgICAgZWxzZSBpZiAob3BlbiAmJiBvcGVuLmRpc2FibGVkICYmICFhY3RpdmUuc29tZShhID0+IGEuaXNQZW5kaW5nKSlcbiAgICAgICAgICAgIG9wZW4gPSBudWxsO1xuICAgICAgICBpZiAoIW9wZW4gJiYgYWN0aXZlLmV2ZXJ5KGEgPT4gIWEuaXNQZW5kaW5nKSAmJiBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkpKVxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLm1hcChhID0+IGEuaGFzUmVzdWx0KCkgPyBuZXcgQWN0aXZlU291cmNlKGEuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IGEpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VsZWN0ZWRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIG9wZW4gPSBvcGVuICYmIG9wZW4uc2V0U2VsZWN0ZWQoZWZmZWN0LnZhbHVlLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZSA9PSB0aGlzLmFjdGl2ZSAmJiBvcGVuID09IHRoaXMub3BlbiA/IHRoaXMgOiBuZXcgQ29tcGxldGlvblN0YXRlKGFjdGl2ZSwgdGhpcy5pZCwgb3Blbik7XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLnRvb2x0aXAgOiBudWxsOyB9XG4gICAgZ2V0IGF0dHJzKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLmF0dHJzIDogdGhpcy5hY3RpdmUubGVuZ3RoID8gYmFzZUF0dHJzIDogbm9BdHRyczsgfVxufVxuZnVuY3Rpb24gc2FtZVJlc3VsdHMoYSwgYikge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgd2hpbGUgKGlBIDwgYS5sZW5ndGggJiYgIWFbaUFdLmhhc1Jlc3VsdCgpKVxuICAgICAgICAgICAgaUErKztcbiAgICAgICAgd2hpbGUgKGlCIDwgYi5sZW5ndGggJiYgIWJbaUJdLmhhc1Jlc3VsdCgpKVxuICAgICAgICAgICAgaUIrKztcbiAgICAgICAgbGV0IGVuZEEgPSBpQSA9PSBhLmxlbmd0aCwgZW5kQiA9IGlCID09IGIubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kQSB8fCBlbmRCKVxuICAgICAgICAgICAgcmV0dXJuIGVuZEEgPT0gZW5kQjtcbiAgICAgICAgaWYgKGFbaUErK10ucmVzdWx0ICE9IGJbaUIrK10ucmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IGJhc2VBdHRycyA9IHtcbiAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiXG59O1xuY29uc3Qgbm9BdHRycyA9IHt9O1xuZnVuY3Rpb24gbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCkge1xuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCIsXG4gICAgICAgIFwiYXJpYS1oYXNwb3B1cFwiOiBcImxpc3Rib3hcIixcbiAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IGlkXG4gICAgfTtcbiAgICBpZiAoc2VsZWN0ZWQgPiAtMSlcbiAgICAgICAgcmVzdWx0W1wiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCJdID0gaWQgKyBcIi1cIiArIHNlbGVjdGVkO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBub25lID0gW107XG5mdW5jdGlvbiBnZXRVcGRhdGVUeXBlKHRyLCBjb25mKSB7XG4gICAgaWYgKHRyLmlzVXNlckV2ZW50KFwiaW5wdXQuY29tcGxldGVcIikpIHtcbiAgICAgICAgbGV0IGNvbXBsZXRpb24gPSB0ci5hbm5vdGF0aW9uKHBpY2tlZENvbXBsZXRpb24pO1xuICAgICAgICBpZiAoY29tcGxldGlvbiAmJiBjb25mLmFjdGl2YXRlT25Db21wbGV0aW9uKGNvbXBsZXRpb24pKVxuICAgICAgICAgICAgcmV0dXJuIDQgLyogVXBkYXRlVHlwZS5BY3RpdmF0ZSAqLyB8IDggLyogVXBkYXRlVHlwZS5SZXNldCAqLztcbiAgICB9XG4gICAgbGV0IHR5cGluZyA9IHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKTtcbiAgICByZXR1cm4gdHlwaW5nICYmIGNvbmYuYWN0aXZhdGVPblR5cGluZyA/IDQgLyogVXBkYXRlVHlwZS5BY3RpdmF0ZSAqLyB8IDEgLyogVXBkYXRlVHlwZS5UeXBpbmcgKi9cbiAgICAgICAgOiB0eXBpbmcgPyAxIC8qIFVwZGF0ZVR5cGUuVHlwaW5nICovXG4gICAgICAgICAgICA6IHRyLmlzVXNlckV2ZW50KFwiZGVsZXRlLmJhY2t3YXJkXCIpID8gMiAvKiBVcGRhdGVUeXBlLkJhY2tzcGFjaW5nICovXG4gICAgICAgICAgICAgICAgOiB0ci5zZWxlY3Rpb24gPyA4IC8qIFVwZGF0ZVR5cGUuUmVzZXQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiB0ci5kb2NDaGFuZ2VkID8gMTYgLyogVXBkYXRlVHlwZS5SZXNldElmVG91Y2hpbmcgKi8gOiAwIC8qIFVwZGF0ZVR5cGUuTm9uZSAqLztcbn1cbmNsYXNzIEFjdGl2ZVNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBzdGF0ZSwgZXhwbGljaXQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XG4gICAgfVxuICAgIGhhc1Jlc3VsdCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzUGVuZGluZygpIHsgcmV0dXJuIHRoaXMuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovOyB9XG4gICAgdXBkYXRlKHRyLCBjb25mKSB7XG4gICAgICAgIGxldCB0eXBlID0gZ2V0VXBkYXRlVHlwZSh0ciwgY29uZiksIHZhbHVlID0gdGhpcztcbiAgICAgICAgaWYgKCh0eXBlICYgOCAvKiBVcGRhdGVUeXBlLlJlc2V0ICovKSB8fCAodHlwZSAmIDE2IC8qIFVwZGF0ZVR5cGUuUmVzZXRJZlRvdWNoaW5nICovKSAmJiB0aGlzLnRvdWNoZXModHIpKVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIGlmICgodHlwZSAmIDQgLyogVXBkYXRlVHlwZS5BY3RpdmF0ZSAqLykgJiYgdmFsdWUuc3RhdGUgPT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLylcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGVGb3IodHIsIHR5cGUpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzdGFydENvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhjbG9zZUNvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZUVmZmVjdCkpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGVmZmVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zb3VyY2UgPT0gdmFsdWUuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB1cGRhdGVGb3IodHIsIHR5cGUpIHsgcmV0dXJuIHRoaXMubWFwKHRyLmNoYW5nZXMpOyB9XG4gICAgbWFwKGNoYW5nZXMpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB0b3VjaGVzKHRyKSB7XG4gICAgICAgIHJldHVybiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShjdXIodHIuc3RhdGUpKTtcbiAgICB9XG59XG5jbGFzcyBBY3RpdmVSZXN1bHQgZXh0ZW5kcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZXhwbGljaXQsIGxpbWl0LCByZXN1bHQsIGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSwgMyAvKiBTdGF0ZS5SZXN1bHQgKi8sIGV4cGxpY2l0KTtcbiAgICAgICAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgdXBkYXRlRm9yKHRyLCB0eXBlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCEodHlwZSAmIDMgLyogVXBkYXRlVHlwZS5TaW1wbGVJbnRlcmFjdGlvbiAqLykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgaWYgKHJlc3VsdC5tYXAgJiYgIXRyLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKHJlc3VsdCwgdHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBmcm9tID0gdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tKSwgdG8gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxKTtcbiAgICAgICAgbGV0IHBvcyA9IGN1cih0ci5zdGF0ZSk7XG4gICAgICAgIGlmIChwb3MgPiB0byB8fCAhcmVzdWx0IHx8XG4gICAgICAgICAgICAodHlwZSAmIDIgLyogVXBkYXRlVHlwZS5CYWNrc3BhY2luZyAqLykgJiYgKGN1cih0ci5zdGFydFN0YXRlKSA9PSB0aGlzLmZyb20gfHwgcG9zIDwgdGhpcy5saW1pdCkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgdHlwZSAmIDQgLyogVXBkYXRlVHlwZS5BY3RpdmF0ZSAqLyA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICBsZXQgbGltaXQgPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmxpbWl0KTtcbiAgICAgICAgaWYgKGNoZWNrVmFsaWQocmVzdWx0LnZhbGlkRm9yLCB0ci5zdGF0ZSwgZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIHRoaXMuZXhwbGljaXQsIGxpbWl0LCByZXN1bHQsIGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHJlc3VsdC51cGRhdGUgJiZcbiAgICAgICAgICAgIChyZXN1bHQgPSByZXN1bHQudXBkYXRlKHJlc3VsdCwgZnJvbSwgdG8sIG5ldyBDb21wbGV0aW9uQ29udGV4dCh0ci5zdGF0ZSwgcG9zLCBmYWxzZSkpKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0LCBsaW1pdCwgcmVzdWx0LCByZXN1bHQuZnJvbSwgKF9hID0gcmVzdWx0LnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXIodHIuc3RhdGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgdGhpcy5leHBsaWNpdCk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChtYXBwaW5nLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlc3VsdC5tYXAgPyB0aGlzLnJlc3VsdC5tYXAodGhpcy5yZXN1bHQsIG1hcHBpbmcpIDogdGhpcy5yZXN1bHQ7XG4gICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdCwgbWFwcGluZy5tYXBQb3ModGhpcy5saW1pdCksIHRoaXMucmVzdWx0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmZyb20pLCBtYXBwaW5nLm1hcFBvcyh0aGlzLnRvLCAxKSk7XG4gICAgfVxuICAgIHRvdWNoZXModHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tWYWxpZCh2YWxpZEZvciwgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgaWYgKCF2YWxpZEZvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIHJldHVybiB0eXBlb2YgdmFsaWRGb3IgPT0gXCJmdW5jdGlvblwiID8gdmFsaWRGb3IodGV4dCwgZnJvbSwgdG8sIHN0YXRlKSA6IGVuc3VyZUFuY2hvcih2YWxpZEZvciwgdHJ1ZSkudGVzdCh0ZXh0KTtcbn1cbmNvbnN0IHNldEFjdGl2ZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChzb3VyY2VzLCBtYXBwaW5nKSB7IHJldHVybiBzb3VyY2VzLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKTsgfVxufSk7XG5jb25zdCBzZXRTZWxlY3RlZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNvbXBsZXRpb25TdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gQ29tcGxldGlvblN0YXRlLnN0YXJ0KCk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikgeyByZXR1cm4gdmFsdWUudXBkYXRlKHRyKTsgfSxcbiAgICBwcm92aWRlOiBmID0+IFtcbiAgICAgICAgc2hvd1Rvb2x0aXAuZnJvbShmLCB2YWwgPT4gdmFsLnRvb2x0aXApLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmZyb20oZiwgc3RhdGUgPT4gc3RhdGUuYXR0cnMpXG4gICAgXVxufSk7XG5mdW5jdGlvbiBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uKSB7XG4gICAgY29uc3QgYXBwbHkgPSBvcHRpb24uY29tcGxldGlvbi5hcHBseSB8fCBvcHRpb24uY29tcGxldGlvbi5sYWJlbDtcbiAgICBsZXQgcmVzdWx0ID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gb3B0aW9uLnNvdXJjZSk7XG4gICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgQWN0aXZlUmVzdWx0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYXBwbHkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAuLi5pbnNlcnRDb21wbGV0aW9uVGV4dCh2aWV3LnN0YXRlLCBhcHBseSwgcmVzdWx0LmZyb20sIHJlc3VsdC50byksXG4gICAgICAgICAgICBhbm5vdGF0aW9uczogcGlja2VkQ29tcGxldGlvbi5vZihvcHRpb24uY29tcGxldGlvbilcbiAgICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgICBhcHBseSh2aWV3LCBvcHRpb24uY29tcGxldGlvbiwgcmVzdWx0LmZyb20sIHJlc3VsdC50byk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBjcmVhdGVUb29sdGlwID0gLypAX19QVVJFX18qL2NvbXBsZXRpb25Ub29sdGlwKGNvbXBsZXRpb25TdGF0ZSwgYXBwbHlDb21wbGV0aW9uKTtcblxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IG1vdmVzIHRoZSBjb21wbGV0aW9uIHNlbGVjdGlvbiBmb3J3YXJkIG9yXG5iYWNrd2FyZCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuKi9cbmZ1bmN0aW9uIG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZvcndhcmQsIGJ5ID0gXCJvcHRpb25cIikge1xuICAgIHJldHVybiAodmlldykgPT4ge1xuICAgICAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IGNTdGF0ZS5vcGVuLmRpc2FibGVkIHx8XG4gICAgICAgICAgICBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5pbnRlcmFjdGlvbkRlbGF5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RlcCA9IDEsIHRvb2x0aXA7XG4gICAgICAgIGlmIChieSA9PSBcInBhZ2VcIiAmJiAodG9vbHRpcCA9IGdldFRvb2x0aXAodmlldywgY1N0YXRlLm9wZW4udG9vbHRpcCkpKVxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IodG9vbHRpcC5kb20ub2Zmc2V0SGVpZ2h0IC9cbiAgICAgICAgICAgICAgICB0b29sdGlwLmRvbS5xdWVyeVNlbGVjdG9yKFwibGlcIikub2Zmc2V0SGVpZ2h0KSAtIDEpO1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IGNTdGF0ZS5vcGVuLm9wdGlvbnM7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IGNTdGF0ZS5vcGVuLnNlbGVjdGVkID4gLTEgPyBjU3RhdGUub3Blbi5zZWxlY3RlZCArIHN0ZXAgKiAoZm9yd2FyZCA/IDEgOiAtMSkgOiBmb3J3YXJkID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGJ5ID09IFwicGFnZVwiID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkID49IGxlbmd0aClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyBsZW5ndGggLSAxIDogMDtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlbGVjdGVkRWZmZWN0Lm9mKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQWNjZXB0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24uXG4qL1xuY29uc3QgYWNjZXB0Q29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgfHwgIWNTdGF0ZSB8fCAhY1N0YXRlLm9wZW4gfHwgY1N0YXRlLm9wZW4uc2VsZWN0ZWQgPCAwIHx8IGNTdGF0ZS5vcGVuLmRpc2FibGVkIHx8XG4gICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmludGVyYWN0aW9uRGVsYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYXBwbHlDb21wbGV0aW9uKHZpZXcsIGNTdGF0ZS5vcGVuLm9wdGlvbnNbY1N0YXRlLm9wZW4uc2VsZWN0ZWRdKTtcbn07XG4vKipcbkV4cGxpY2l0bHkgc3RhcnQgYXV0b2NvbXBsZXRpb24uXG4qL1xuY29uc3Qgc3RhcnRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YodHJ1ZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgY3VycmVudGx5IGFjdGl2ZSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGNsb3NlQ29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNsYXNzIFJ1bm5pbmdRdWVyeSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgLy8gTm90ZSB0aGF0ICd1bmRlZmluZWQnIG1lYW5zICdub3QgZG9uZSB5ZXQnLCB3aGVyZWFzICdudWxsJyBtZWFuc1xuICAgICAgICAvLyAncXVlcnkgcmV0dXJuZWQgbnVsbCcuXG4gICAgICAgIHRoaXMuZG9uZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jb25zdCBNYXhVcGRhdGVDb3VudCA9IDUwLCBNaW5BYm9ydFRpbWUgPSAxMDAwO1xuY29uc3QgY29tcGxldGlvblBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTE7XG4gICAgICAgIHRoaXMucnVubmluZyA9IFtdO1xuICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi87XG4gICAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkuYWN0aXZlKVxuICAgICAgICAgICAgaWYgKGFjdGl2ZS5pc1BlbmRpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpO1xuICAgICAgICBsZXQgY29uZiA9IHVwZGF0ZS5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuc2VsZWN0aW9uU2V0ICYmICF1cGRhdGUuZG9jQ2hhbmdlZCAmJiB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpID09IGNTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGRvZXNSZXNldCA9IHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGdldFVwZGF0ZVR5cGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlICYgOCAvKiBVcGRhdGVUeXBlLlJlc2V0ICovKSB8fCAodHIuc2VsZWN0aW9uIHx8IHRyLmRvY0NoYW5nZWQpICYmICEodHlwZSAmIDMgLyogVXBkYXRlVHlwZS5TaW1wbGVJbnRlcmFjdGlvbiAqLyk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKGRvZXNSZXNldCB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5LmNvbnRleHQuYWJvcnRPbkRvY0NoYW5nZSAmJiB1cGRhdGUuZG9jQ2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoICsgdXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiBNYXhVcGRhdGVDb3VudCAmJiBEYXRlLm5vdygpIC0gcXVlcnkudGltZSA+IE1pbkFib3J0VGltZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeS51cGRhdGVzLnB1c2goLi4udXBkYXRlLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VVcGRhdGUgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVXBkYXRlKTtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5lZmZlY3RzLnNvbWUoZSA9PiBlLmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpKSlcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy5wZW5kaW5nU3RhcnQgPyA1MCA6IGNvbmYuYWN0aXZhdGVPblR5cGluZ0RlbGF5O1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5pc1BlbmRpbmcgJiYgIXRoaXMucnVubmluZy5zb21lKHEgPT4gcS5hY3RpdmUuc291cmNlID09IGEuc291cmNlKSlcbiAgICAgICAgICAgID8gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0VXBkYXRlKCksIGRlbGF5KSA6IC0xO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgIT0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi8pXG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAyIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbXBvc2luZyA9PSAyIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZCAqLyAmJiB0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgY1N0YXRlID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGNTdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUuaXNQZW5kaW5nICYmICF0aGlzLnJ1bm5pbmcuc29tZShyID0+IHIuYWN0aXZlLnNvdXJjZSA9PSBhY3RpdmUuc291cmNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ydW5uaW5nLmxlbmd0aCAmJiBjU3RhdGUub3BlbiAmJiBjU3RhdGUub3Blbi5kaXNhYmxlZClcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWNjZXB0KCksIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS51cGRhdGVTeW5jVGltZSk7XG4gICAgfVxuICAgIHN0YXJ0UXVlcnkoYWN0aXZlKSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIHBvcyA9IGN1cihzdGF0ZSk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IENvbXBsZXRpb25Db250ZXh0KHN0YXRlLCBwb3MsIGFjdGl2ZS5leHBsaWNpdCwgdGhpcy52aWV3KTtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSBuZXcgUnVubmluZ1F1ZXJ5KGFjdGl2ZSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMucnVubmluZy5wdXNoKHBlbmRpbmcpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoYWN0aXZlLnNvdXJjZShjb250ZXh0KSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKCFwZW5kaW5nLmNvbnRleHQuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmcuZG9uZSA9IHJlc3VsdCB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVBY2NlcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZUFjY2VwdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5ldmVyeShxID0+IHEuZG9uZSAhPT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2NlcHQoKSwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLnVwZGF0ZVN5bmNUaW1lKTtcbiAgICB9XG4gICAgLy8gRm9yIGVhY2ggZmluaXNoZWQgcXVlcnkgaW4gdGhpcy5ydW5uaW5nLCB0cnkgdG8gY3JlYXRlIGEgcmVzdWx0XG4gICAgLy8gb3IsIGlmIGFwcHJvcHJpYXRlLCByZXN0YXJ0IHRoZSBxdWVyeS5cbiAgICBhY2NlcHQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlQWNjZXB0KTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKSwgY1N0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gY3VyKHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoID8gcXVlcnkudXBkYXRlc1swXS5zdGFydFN0YXRlIDogdGhpcy52aWV3LnN0YXRlKTtcbiAgICAgICAgICAgICAgICBsZXQgbGltaXQgPSBNYXRoLm1pbihwb3MsIHF1ZXJ5LmRvbmUuZnJvbSArIChxdWVyeS5hY3RpdmUuZXhwbGljaXQgPyAwIDogMSkpO1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlUmVzdWx0KHF1ZXJ5LmFjdGl2ZS5zb3VyY2UsIHF1ZXJ5LmFjdGl2ZS5leHBsaWNpdCwgbGltaXQsIHF1ZXJ5LmRvbmUsIHF1ZXJ5LmRvbmUuZnJvbSwgKF9hID0gcXVlcnkuZG9uZS50bykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcG9zKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgdGhlIHRyYW5zYWN0aW9ucyB0aGF0IGhhcHBlbmVkIHNpbmNlIHRoZSBzdGFydCBvZlxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IGFuZCBzZWUgaWYgdGhhdCBwcmVzZXJ2ZXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUuaGFzUmVzdWx0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gY1N0YXRlLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gcXVlcnkuYWN0aXZlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBmYWlsZWQuIFNob3VsZCBjbGVhciB0aGUgcGVuZGluZyBzdGF0dXMgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzbid0IGJlZW4gcmUtc2V0IGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTb3VyY2UocXVlcnkuYWN0aXZlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhY3RpdmUuaXNQZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhcmVkIGJ5IHN1YnNlcXVlbnQgdHJhbnNhY3Rpb25zLiBSZXN0YXJ0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkLmxlbmd0aCB8fCBjU3RhdGUub3BlbiAmJiBjU3RhdGUub3Blbi5kaXNhYmxlZClcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldEFjdGl2ZUVmZmVjdC5vZih1cGRhdGVkKSB9KTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICBibHVyKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY2xvc2VPbkJsdXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlhbG9nID0gc3RhdGUub3BlbiAmJiBnZXRUb29sdGlwKHRoaXMudmlldywgc3RhdGUub3Blbi50b29sdGlwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpYWxvZyB8fCAhZGlhbG9nLmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSksIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25zdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMSAvKiBDb21wb3NpdGlvblN0YXRlLlN0YXJ0ZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvc2l0aW9uZW5kKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID09IDMgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkQW5kTW92ZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZmlyZXMgY29tcG9zaXRpb25lbmQgZXZlbnRzIHN5bmNocm9ub3VzbHksIHBvc3NpYmx5XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBpbnNpZGUgYW4gdXBkYXRlLCBzbyBkaXNwYXRjaCBhc3luY2hyb25vdXNseSB0byBhdm9pZCByZWVudHJhbmN5XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YoZmFsc2UpIH0pLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5jb25zdCB3aW5kb3dzID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBjb21taXRDaGFyYWN0ZXJzID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICBrZXlkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghZmllbGQgfHwgIWZpZWxkLm9wZW4gfHwgZmllbGQub3Blbi5kaXNhYmxlZCB8fCBmaWVsZC5vcGVuLnNlbGVjdGVkIDwgMCB8fFxuICAgICAgICAgICAgZXZlbnQua2V5Lmxlbmd0aCA+IDEgfHwgZXZlbnQuY3RybEtleSAmJiAhKHdpbmRvd3MgJiYgZXZlbnQuYWx0S2V5KSB8fCBldmVudC5tZXRhS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgb3B0aW9uID0gZmllbGQub3Blbi5vcHRpb25zW2ZpZWxkLm9wZW4uc2VsZWN0ZWRdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmllbGQuYWN0aXZlLmZpbmQoYSA9PiBhLnNvdXJjZSA9PSBvcHRpb24uc291cmNlKTtcbiAgICAgICAgbGV0IGNvbW1pdENoYXJzID0gb3B0aW9uLmNvbXBsZXRpb24uY29tbWl0Q2hhcmFjdGVycyB8fCByZXN1bHQucmVzdWx0LmNvbW1pdENoYXJhY3RlcnM7XG4gICAgICAgIGlmIChjb21taXRDaGFycyAmJiBjb21taXRDaGFycy5pbmRleE9mKGV2ZW50LmtleSkgPiAtMSlcbiAgICAgICAgICAgIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb24pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSkpO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXRvb2x0aXAuY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjoge1xuICAgICAgICBcIiYgPiB1bFwiOiB7XG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlbiBhdXRvXCIsXG4gICAgICAgICAgICBtYXhXaWR0aF9mYWxsYmFjazogXCI3MDBweFwiLFxuICAgICAgICAgICAgbWF4V2lkdGg6IFwibWluKDcwMHB4LCA5NXZ3KVwiLFxuICAgICAgICAgICAgbWluV2lkdGg6IFwiMjUwcHhcIixcbiAgICAgICAgICAgIG1heEhlaWdodDogXCIxMGVtXCIsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgICAgbGlzdFN0eWxlOiBcIm5vbmVcIixcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBcIiYgPiBsaSwgJiA+IGNvbXBsZXRpb24tc2VjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogXCIxcHggM3B4XCIsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogMS4yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImID4gbGlcIjoge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IFwiZWxsaXBzaXNcIixcbiAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImID4gY29tcGxldGlvbi1zZWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImxpc3QtaXRlbVwiLFxuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgc2lsdmVyXCIsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IFwiMC41ZW1cIixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMTdjXCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUtZGlzYWJsZWQgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3NzdcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMzQ3XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZCB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzQ0NFwiLFxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wOmJlZm9yZSwgLmNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZUJvdHRvbTphZnRlclwiOiB7XG4gICAgICAgIGNvbnRlbnQ6ICdcIlx1MDBCN1x1MDBCN1x1MDBCN1wiJyxcbiAgICAgICAgb3BhY2l0eTogMC41LFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC5jbS1jb21wbGV0aW9uSW5mb1wiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiM3B4IDlweFwiLFxuICAgICAgICB3aWR0aDogXCJtYXgtY29udGVudFwiLFxuICAgICAgICBtYXhXaWR0aDogYCR7NDAwIC8qIEluZm8uV2lkdGggKi99cHhgLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZS1saW5lXCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnRcIjogeyByaWdodDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodFwiOiB7IGxlZnQ6IFwiMTAwJVwiIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdC1uYXJyb3dcIjogeyByaWdodDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tcmlnaHQtbmFycm93XCI6IHsgbGVmdDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwMjJcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmMjJcIiB9LFxuICAgIFwiLmNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiBcIjEuMTVlbVwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBtYXJnaW46IFwiMCAtMC43cHggLS43ZW1cIixcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjRweCBkb3R0ZWQgIzg4OFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkRldGFpbFwiOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiMC41ZW1cIixcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvblwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjkwJVwiLFxuICAgICAgICB3aWR0aDogXCIuOGVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBcIi42ZW1cIixcbiAgICAgICAgb3BhY2l0eTogXCIwLjZcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWZ1bmN0aW9uLCAuY20tY29tcGxldGlvbkljb24tbWV0aG9kXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHUwMTkyJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNsYXNzXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHUyNUNCJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWludGVyZmFjZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1MjVDQydcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi12YXJpYWJsZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1RDgzNVx1REM2NSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jb25zdGFudFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1RDgzNVx1REMzNidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10eXBlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHVEODM1XHVEQzYxJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWVudW1cIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdTIyMkEnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tcHJvcGVydHlcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdTI1QTEnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24ta2V5d29yZFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1RDgzRFx1REQxMVxcdUZFMEUnXCIgfSAvLyBEaXNhYmxlIGVtb2ppIHJlbmRlcmluZ1xuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tbmFtZXNwYWNlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHUyNUEyJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXRleHRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidhYmMnXCIsIGZvbnRTaXplOiBcIjUwJVwiLCB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiIH1cbiAgICB9XG59KTtcblxuY2xhc3MgRmllbGRQb3Mge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBsaW5lLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG5jbGFzcyBGaWVsZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tLCAtMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgIGxldCB0byA9IGNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICByZXR1cm4gZnJvbSA9PSBudWxsIHx8IHRvID09IG51bGwgPyBudWxsIDogbmV3IEZpZWxkUmFuZ2UodGhpcy5maWVsZCwgZnJvbSwgdG8pO1xuICAgIH1cbn1cbmNsYXNzIFNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVzLCBmaWVsZFBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgICAgIHRoaXMuZmllbGRQb3NpdGlvbnMgPSBmaWVsZFBvc2l0aW9ucztcbiAgICB9XG4gICAgaW5zdGFudGlhdGUoc3RhdGUsIHBvcykge1xuICAgICAgICBsZXQgdGV4dCA9IFtdLCBsaW5lU3RhcnQgPSBbcG9zXTtcbiAgICAgICAgbGV0IGxpbmVPYmogPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJhc2VJbmRlbnQgPSAvXlxccyovLmV4ZWMobGluZU9iai50ZXh0KVswXTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLmxpbmVzKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gYmFzZUluZGVudCwgdGFicyA9IC9eXFx0Ki8uZXhlYyhsaW5lKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJzOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQucHVzaChwb3MgKyBpbmRlbnQubGVuZ3RoIC0gdGFicyk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGluZGVudCArIGxpbmUuc2xpY2UodGFicyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0LnB1c2gobGluZSk7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLmZpZWxkUG9zaXRpb25zLm1hcChwb3MgPT4gbmV3IEZpZWxkUmFuZ2UocG9zLmZpZWxkLCBsaW5lU3RhcnRbcG9zLmxpbmVdICsgcG9zLmZyb20sIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MudG8pKTtcbiAgICAgICAgcmV0dXJuIHsgdGV4dCwgcmFuZ2VzIH07XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh0ZW1wbGF0ZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBsaW5lcyA9IFtdLCBwb3NpdGlvbnMgPSBbXSwgbTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZW1wbGF0ZS5zcGxpdCgvXFxyXFxuP3xcXG4vKSkge1xuICAgICAgICAgICAgd2hpbGUgKG0gPSAvWyMkXVxceyg/OihcXGQrKSg/OjooW157fV0qKSk/fCgoPzpcXFxcW3t9XXxbXnt9XSkqKSlcXH0vLmV4ZWMobGluZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VxID0gbVsxXSA/ICttWzFdIDogbnVsbCwgcmF3TmFtZSA9IG1bMl0gfHwgbVszXSB8fCBcIlwiLCBmb3VuZCA9IC0xO1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gcmF3TmFtZS5yZXBsYWNlKC9cXFxcW3t9XS9nLCBtID0+IG1bMV0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXEgIT0gbnVsbCA/IGZpZWxkc1tpXS5zZXEgPT0gc2VxIDogbmFtZSA/IGZpZWxkc1tpXS5uYW1lID09IG5hbWUgOiBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZmllbGRzLmxlbmd0aCAmJiAoc2VxID09IG51bGwgfHwgKGZpZWxkc1tpXS5zZXEgIT0gbnVsbCAmJiBmaWVsZHNbaV0uc2VxIDwgc2VxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5zcGxpY2UoaSwgMCwgeyBzZXEsIG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MuZmllbGQgPj0gZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZpZWxkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MubGluZSA9PSBsaW5lcy5sZW5ndGggJiYgcG9zLmZyb20gPiBtLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc25pcCA9IG1bMl0gPyAzICsgKG1bMV0gfHwgXCJcIikubGVuZ3RoIDogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5mcm9tIC09IHNuaXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MudG8gLT0gc25pcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBGaWVsZFBvcyhmb3VuZCwgbGluZXMubGVuZ3RoLCBtLmluZGV4LCBtLmluZGV4ICsgbmFtZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBtLmluZGV4KSArIHJhd05hbWUgKyBsaW5lLnNsaWNlKG0uaW5kZXggKyBtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9cXFxcKFt7fV0pL2csIChfLCBicmFjZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zLmxpbmUgPT0gbGluZXMubGVuZ3RoICYmIHBvcy5mcm9tID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5mcm9tLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MudG8tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBicmFjZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNuaXBwZXQobGluZXMsIHBvc2l0aW9ucyk7XG4gICAgfVxufVxubGV0IGZpZWxkTWFya2VyID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKCkge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zbmlwcGV0RmllbGRQb3NpdGlvblwiO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH0gfSk7XG5sZXQgZmllbGRSYW5nZSA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zbmlwcGV0RmllbGRcIiB9KTtcbmNsYXNzIEFjdGl2ZVNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlcywgYWN0aXZlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5kZWNvID0gRGVjb3JhdGlvbi5zZXQocmFuZ2VzLm1hcChyID0+IChyLmZyb20gPT0gci50byA/IGZpZWxkTWFya2VyIDogZmllbGRSYW5nZSkucmFuZ2Uoci5mcm9tLCByLnRvKSksIHRydWUpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSByLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghbWFwcGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCB0aGlzLmFjdGl2ZSk7XG4gICAgfVxuICAgIHNlbGVjdGlvbkluc2lkZUZpZWxkKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLnJhbmdlcy5ldmVyeShyYW5nZSA9PiB0aGlzLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSB0aGlzLmFjdGl2ZSAmJiByLmZyb20gPD0gcmFuZ2UuZnJvbSAmJiByLnRvID49IHJhbmdlLnRvKSk7XG4gICAgfVxufVxuY29uc3Qgc2V0QWN0aXZlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBjaGFuZ2VzKSB7IHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5tYXAoY2hhbmdlcyk7IH1cbn0pO1xuY29uc3QgbW92ZVRvRmllbGQgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzbmlwcGV0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRBY3RpdmUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKG1vdmVUb0ZpZWxkKSAmJiB2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQodmFsdWUucmFuZ2VzLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5zZWxlY3Rpb24gJiYgIXZhbHVlLnNlbGVjdGlvbkluc2lkZUZpZWxkKHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYsIHZhbCA9PiB2YWwgPyB2YWwuZGVjbyA6IERlY29yYXRpb24ubm9uZSlcbn0pO1xuZnVuY3Rpb24gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCBmaWVsZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5maWx0ZXIociA9PiByLmZpZWxkID09IGZpZWxkKS5tYXAociA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xufVxuLyoqXG5Db252ZXJ0IGEgc25pcHBldCB0ZW1wbGF0ZSB0byBhIGZ1bmN0aW9uIHRoYXQgY2FuXG5bYXBwbHldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb24uYXBwbHkpIGl0LiBTbmlwcGV0cyBhcmUgd3JpdHRlblxudXNpbmcgc3ludGF4IGxpa2UgdGhpczpcblxuICAgIFwiZm9yIChsZXQgJHtpbmRleH0gPSAwOyAke2luZGV4fSA8ICR7ZW5kfTsgJHtpbmRleH0rKykge1xcblxcdCR7fVxcbn1cIlxuXG5FYWNoIGAke31gIHBsYWNlaG9sZGVyICh5b3UgbWF5IGFsc28gdXNlIGAje31gKSBpbmRpY2F0ZXMgYSBmaWVsZFxudGhhdCB0aGUgdXNlciBjYW4gZmlsbCBpbi4gSXRzIG5hbWUsIGlmIGFueSwgd2lsbCBiZSB0aGUgZGVmYXVsdFxuY29udGVudCBmb3IgdGhlIGZpZWxkLlxuXG5XaGVuIHRoZSBzbmlwcGV0IGlzIGFjdGl2YXRlZCBieSBjYWxsaW5nIHRoZSByZXR1cm5lZCBmdW5jdGlvbixcbnRoZSBjb2RlIGlzIGluc2VydGVkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gTmV3bGluZXMgaW4gdGhlXG50ZW1wbGF0ZSBhcmUgaW5kZW50ZWQgYnkgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBzdGFydCBsaW5lLCBwbHVzXG5vbmUgW2luZGVudCB1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIHBlciB0YWIgY2hhcmFjdGVyIGFmdGVyXG50aGUgbmV3bGluZS5cblxuT24gYWN0aXZhdGlvbiwgKGFsbCBpbnN0YW5jZXMgb2YpIHRoZSBmaXJzdCBmaWVsZCBhcmUgc2VsZWN0ZWQuXG5UaGUgdXNlciBjYW4gbW92ZSBiZXR3ZWVuIGZpZWxkcyB3aXRoIFRhYiBhbmQgU2hpZnQtVGFiIGFzIGxvbmcgYXNcbnRoZSBmaWVsZHMgYXJlIGFjdGl2ZS4gTW92aW5nIHRvIHRoZSBsYXN0IGZpZWxkIG9yIG1vdmluZyB0aGVcbmN1cnNvciBvdXQgb2YgdGhlIGN1cnJlbnQgZmllbGQgZGVhY3RpdmF0ZXMgdGhlIGZpZWxkcy5cblxuVGhlIG9yZGVyIG9mIGZpZWxkcyBkZWZhdWx0cyB0byB0ZXh0dWFsIG9yZGVyLCBidXQgeW91IGNhbiBhZGRcbm51bWJlcnMgdG8gcGxhY2Vob2xkZXJzIChgJHsxfWAgb3IgYCR7MTpkZWZhdWx0VGV4dH1gKSB0byBwcm92aWRlXG5hIGN1c3RvbSBvcmRlci5cblxuVG8gaW5jbHVkZSBhIGxpdGVyYWwgYHtgIG9yIGB9YCBpbiB5b3VyIHRlbXBsYXRlLCBwdXQgYSBiYWNrc2xhc2hcbmluIGZyb250IG9mIGl0LiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBhbmQgdGhlIGJyYWNlIHdpbGwgbm90IGJlXG5pbnRlcnByZXRlZCBhcyBpbmRpY2F0aW5nIGEgcGxhY2Vob2xkZXIuXG4qL1xuZnVuY3Rpb24gc25pcHBldCh0ZW1wbGF0ZSkge1xuICAgIGxldCBzbmlwcGV0ID0gU25pcHBldC5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIChlZGl0b3IsIGNvbXBsZXRpb24sIGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGxldCB7IHRleHQsIHJhbmdlcyB9ID0gc25pcHBldC5pbnN0YW50aWF0ZShlZGl0b3Iuc3RhdGUsIGZyb20pO1xuICAgICAgICBsZXQgeyBtYWluIH0gPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgc3BlYyA9IHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbSwgdG86IHRvID09IG1haW4uZnJvbSA/IG1haW4udG8gOiB0bywgaW5zZXJ0OiBUZXh0Lm9mKHRleHQpIH0sXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBjb21wbGV0aW9uID8gW3BpY2tlZENvbXBsZXRpb24ub2YoY29tcGxldGlvbiksIFRyYW5zYWN0aW9uLnVzZXJFdmVudC5vZihcImlucHV0LmNvbXBsZXRlXCIpXSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMuc2VsZWN0aW9uID0gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCAwKTtcbiAgICAgICAgaWYgKHJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA+IDApKSB7XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCAwKTtcbiAgICAgICAgICAgIGxldCBlZmZlY3RzID0gc3BlYy5lZmZlY3RzID0gW3NldEFjdGl2ZS5vZihhY3RpdmUpXTtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtzbmlwcGV0U3RhdGUsIGFkZFNuaXBwZXRLZXltYXAsIHNuaXBwZXRQb2ludGVySGFuZGxlciwgYmFzZVRoZW1lXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaChlZGl0b3Iuc3RhdGUudXBkYXRlKHNwZWMpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZUZpZWxkKGRpcikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IGRpciA8IDAgJiYgYWN0aXZlLmFjdGl2ZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbmV4dCA9IGFjdGl2ZS5hY3RpdmUgKyBkaXIsIGxhc3QgPSBkaXIgPiAwICYmICFhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IG5leHQgKyBkaXIpO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBuZXh0KSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihsYXN0ID8gbnVsbCA6IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG5leHQpKSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQSBjb21tYW5kIHRoYXQgY2xlYXJzIHRoZSBhY3RpdmUgc25pcHBldCwgaWYgYW55LlxuKi9cbmNvbnN0IGNsZWFyU25pcHBldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghYWN0aXZlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgZWZmZWN0czogc2V0QWN0aXZlLm9mKG51bGwpIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdG8gdGhlIG5leHQgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IG5leHRTbmlwcGV0RmllbGQgPSAvKkBfX1BVUkVfXyovbW92ZUZpZWxkKDEpO1xuLyoqXG5Nb3ZlIHRvIHRoZSBwcmV2aW91cyBzbmlwcGV0IGZpZWxkLCBpZiBhdmFpbGFibGUuXG4qL1xuY29uc3QgcHJldlNuaXBwZXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9tb3ZlRmllbGQoLTEpO1xuLyoqXG5DaGVjayBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgc25pcHBldCB3aXRoIGEgbmV4dCBmaWVsZCBmb3JcbmBuZXh0U25pcHBldEZpZWxkYCB0byBtb3ZlIHRvLlxuKi9cbmZ1bmN0aW9uIGhhc05leHRTbmlwcGV0RmllbGQoc3RhdGUpIHtcbiAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuICEhKGFjdGl2ZSAmJiBhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IGFjdGl2ZS5hY3RpdmUgKyAxKSk7XG59XG4vKipcblJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgc25pcHBldCBhbmQgYSBwcmV2aW91cyBmaWVsZFxuZm9yIGBwcmV2U25pcHBldEZpZWxkYCB0byBtb3ZlIHRvLlxuKi9cbmZ1bmN0aW9uIGhhc1ByZXZTbmlwcGV0RmllbGQoc3RhdGUpIHtcbiAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuICEhKGFjdGl2ZSAmJiBhY3RpdmUuYWN0aXZlID4gMCk7XG59XG5jb25zdCBkZWZhdWx0U25pcHBldEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJUYWJcIiwgcnVuOiBuZXh0U25pcHBldEZpZWxkLCBzaGlmdDogcHJldlNuaXBwZXRGaWVsZCB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsZWFyU25pcHBldCB9XG5dO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHRoZSBrZXkgYmluZGluZ3MgdXNlZCBieVxuc25pcHBldHMuIFRoZSBkZWZhdWx0IGJpbmRzIFRhYiB0b1xuW2BuZXh0U25pcHBldEZpZWxkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubmV4dFNuaXBwZXRGaWVsZCksIFNoaWZ0LVRhYiB0b1xuW2BwcmV2U25pcHBldEZpZWxkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUucHJldlNuaXBwZXRGaWVsZCksIGFuZCBFc2NhcGVcbnRvIFtgY2xlYXJTbmlwcGV0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xlYXJTbmlwcGV0KS5cbiovXG5jb25zdCBzbmlwcGV0S2V5bWFwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShtYXBzKSB7IHJldHVybiBtYXBzLmxlbmd0aCA/IG1hcHNbMF0gOiBkZWZhdWx0U25pcHBldEtleW1hcDsgfVxufSk7XG5jb25zdCBhZGRTbmlwcGV0S2V5bWFwID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyova2V5bWFwLmNvbXB1dGUoW3NuaXBwZXRLZXltYXBdLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChzbmlwcGV0S2V5bWFwKSkpO1xuLyoqXG5DcmVhdGUgYSBjb21wbGV0aW9uIGZyb20gYSBzbmlwcGV0LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZVxucHJvcGVydGllcyBmcm9tIGBjb21wbGV0aW9uYCwgcGx1cyBhbiBgYXBwbHlgIGZ1bmN0aW9uIHRoYXRcbmFwcGxpZXMgdGhlIHNuaXBwZXQuXG4qL1xuZnVuY3Rpb24gc25pcHBldENvbXBsZXRpb24odGVtcGxhdGUsIGNvbXBsZXRpb24pIHtcbiAgICByZXR1cm4geyAuLi5jb21wbGV0aW9uLCBhcHBseTogc25pcHBldCh0ZW1wbGF0ZSkgfTtcbn1cbmNvbnN0IHNuaXBwZXRQb2ludGVySGFuZGxlciA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIG1vdXNlZG93bihldmVudCwgdmlldykge1xuICAgICAgICBsZXQgYWN0aXZlID0gdmlldy5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSwgcG9zO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCAocG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBtYXRjaCA9IGFjdGl2ZS5yYW5nZXMuZmluZChyID0+IHIuZnJvbSA8PSBwb3MgJiYgci50byA+PSBwb3MpO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmZpZWxkID09IGFjdGl2ZS5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YoYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA+IG1hdGNoLmZpZWxkKVxuICAgICAgICAgICAgICAgID8gbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbWF0Y2guZmllbGQpIDogbnVsbCksXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHdvcmRSRSh3b3JkQ2hhcnMpIHtcbiAgICBsZXQgZXNjYXBlZCA9IHdvcmRDaGFycy5yZXBsYWNlKC9bXFxdXFwtXFxcXF0vZywgXCJcXFxcJCZcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fJHtlc2NhcGVkfV0rYCwgXCJ1Z1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBbXFx3JHtlc2NhcGVkfV1gLCBcImdcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwUkUocmUsIGYpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChmKHJlLnNvdXJjZSksIHJlLnVuaWNvZGUgPyBcInVcIiA6IFwiXCIpO1xufVxuY29uc3Qgd29yZENhY2hlcyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gd29yZENhY2hlKHdvcmRDaGFycykge1xuICAgIHJldHVybiB3b3JkQ2FjaGVzW3dvcmRDaGFyc10gfHwgKHdvcmRDYWNoZXNbd29yZENoYXJzXSA9IG5ldyBXZWFrTWFwKTtcbn1cbmZ1bmN0aW9uIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpIHtcbiAgICBmb3IgKGxldCBsaW5lcyA9IGRvYy5pdGVyTGluZXMoKSwgcG9zID0gMDsgIWxpbmVzLm5leHQoKS5kb25lOykge1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gbGluZXMsIG07XG4gICAgICAgIHdvcmRSRS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobSA9IHdvcmRSRS5leGVjKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFzZWVuW21bMF1dICYmIHBvcyArIG0uaW5kZXggIT0gaWdub3JlQXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6IFwidGV4dFwiLCBsYWJlbDogbVswXSB9KTtcbiAgICAgICAgICAgICAgICBzZWVuW21bMF1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+PSAyMDAwIC8qIEMuTWF4TGlzdCAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcyArPSB2YWx1ZS5sZW5ndGggKyAxO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RXb3Jkcyhkb2MsIGNhY2hlLCB3b3JkUkUsIHRvLCBpZ25vcmVBdCkge1xuICAgIGxldCBiaWcgPSBkb2MubGVuZ3RoID49IDEwMDAgLyogQy5NaW5DYWNoZUxlbiAqLztcbiAgICBsZXQgY2FjaGVkID0gYmlnICYmIGNhY2hlLmdldChkb2MpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZG9jLmNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaC5sZW5ndGggPj0gMTAwMCAvKiBDLk1pbkNhY2hlTGVuICovKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjb2xsZWN0V29yZHMoY2gsIGNhY2hlLCB3b3JkUkUsIHRvIC0gcG9zLCBpZ25vcmVBdCAtIHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuW2MubGFiZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2MubGFiZWxdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVXb3JkcyhjaCwgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0IC0gcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBjaC5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdG9yZVdvcmRzKGRvYywgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0KTtcbiAgICB9XG4gICAgaWYgKGJpZyAmJiByZXN1bHQubGVuZ3RoIDwgMjAwMCAvKiBDLk1heExpc3QgKi8pXG4gICAgICAgIGNhY2hlLnNldChkb2MsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuQSBjb21wbGV0aW9uIHNvdXJjZSB0aGF0IHdpbGwgc2NhbiB0aGUgZG9jdW1lbnQgZm9yIHdvcmRzICh1c2luZyBhXG5bY2hhcmFjdGVyIGNhdGVnb3JpemVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikpLCBhbmRcbnJldHVybiB0aG9zZSBhcyBjb21wbGV0aW9ucy5cbiovXG5jb25zdCBjb21wbGV0ZUFueVdvcmQgPSBjb250ZXh0ID0+IHtcbiAgICBsZXQgd29yZENoYXJzID0gY29udGV4dC5zdGF0ZS5sYW5ndWFnZURhdGFBdChcIndvcmRDaGFyc1wiLCBjb250ZXh0LnBvcykuam9pbihcIlwiKTtcbiAgICBsZXQgcmUgPSB3b3JkUkUod29yZENoYXJzKTtcbiAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hcFJFKHJlLCBzID0+IHMgKyBcIiRcIikpO1xuICAgIGlmICghdG9rZW4gJiYgIWNvbnRleHQuZXhwbGljaXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmcm9tID0gdG9rZW4gPyB0b2tlbi5mcm9tIDogY29udGV4dC5wb3M7XG4gICAgbGV0IG9wdGlvbnMgPSBjb2xsZWN0V29yZHMoY29udGV4dC5zdGF0ZS5kb2MsIHdvcmRDYWNoZSh3b3JkQ2hhcnMpLCByZSwgNTAwMDAgLyogQy5SYW5nZSAqLywgZnJvbSk7XG4gICAgcmV0dXJuIHsgZnJvbSwgb3B0aW9ucywgdmFsaWRGb3I6IG1hcFJFKHJlLCBzID0+IFwiXlwiICsgcykgfTtcbn07XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIiddLFxuICAgIGJlZm9yZTogXCIpXX06Oz5cIixcbiAgICBzdHJpbmdQcmVmaXhlczogW11cbn07XG5jb25zdCBjbG9zZUJyYWNrZXRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IG1hcHBlZCA9IG1hcHBpbmcubWFwUG9zKHZhbHVlLCAtMSwgTWFwTW9kZS5UcmFja0FmdGVyKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZCA9PSBudWxsID8gdW5kZWZpbmVkIDogbWFwcGVkO1xuICAgIH1cbn0pO1xuY29uc3QgY2xvc2VkQnJhY2tldCA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbn07XG5jbG9zZWRCcmFja2V0LnN0YXJ0U2lkZSA9IDE7XG5jbG9zZWRCcmFja2V0LmVuZFNpZGUgPSAtMTtcbmNvbnN0IGJyYWNrZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gUmFuZ2VTZXQuZW1wdHk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0ci5zdGF0ZS5kb2MubGluZUF0KHRyLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGUoeyBmaWx0ZXI6IGZyb20gPT4gZnJvbSA+PSBsaW5lLmZyb20gJiYgZnJvbSA8PSBsaW5lLnRvIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhjbG9zZUJyYWNrZXRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlKHsgYWRkOiBbY2xvc2VkQnJhY2tldC5yYW5nZShlZmZlY3QudmFsdWUsIGVmZmVjdC52YWx1ZSArIDEpXSB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn0pO1xuLyoqXG5FeHRlbnNpb24gdG8gZW5hYmxlIGJyYWNrZXQtY2xvc2luZyBiZWhhdmlvci4gV2hlbiBhIGNsb3NlYWJsZVxuYnJhY2tldCBpcyB0eXBlZCwgaXRzIGNsb3NpbmcgYnJhY2tldCBpcyBpbW1lZGlhdGVseSBpbnNlcnRlZFxuYWZ0ZXIgdGhlIGN1cnNvci4gV2hlbiBjbG9zaW5nIGEgYnJhY2tldCBkaXJlY3RseSBpbiBmcm9udCBvZiBhXG5jbG9zaW5nIGJyYWNrZXQgaW5zZXJ0ZWQgYnkgdGhlIGV4dGVuc2lvbiwgdGhlIGN1cnNvciBtb3ZlcyBvdmVyXG50aGF0IGJyYWNrZXQuXG4qL1xuZnVuY3Rpb24gY2xvc2VCcmFja2V0cygpIHtcbiAgICByZXR1cm4gW2lucHV0SGFuZGxlciwgYnJhY2tldFN0YXRlXTtcbn1cbmNvbnN0IGRlZmluZWRDbG9zaW5nID0gXCIoKVtde308Plx1MDBBQlx1MDBCQlx1MDBCQlx1MDBBQlx1RkYzQlx1RkYzRFx1RkY1Qlx1RkY1RFwiO1xuZnVuY3Rpb24gY2xvc2luZyhjaCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVmaW5lZENsb3NpbmcubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIGlmIChkZWZpbmVkQ2xvc2luZy5jaGFyQ29kZUF0KGkpID09IGNoKVxuICAgICAgICAgICAgcmV0dXJuIGRlZmluZWRDbG9zaW5nLmNoYXJBdChpICsgMSk7XG4gICAgcmV0dXJuIGZyb21Db2RlUG9pbnQoY2ggPCAxMjggPyBjaCA6IGNoICsgMSk7XG59XG5mdW5jdGlvbiBjb25maWcoc3RhdGUsIHBvcykge1xuICAgIHJldHVybiBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImNsb3NlQnJhY2tldHNcIiwgcG9zKVswXSB8fCBkZWZhdWx0cztcbn1cbmNvbnN0IGFuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgJiYgLypAX19QVVJFX18qLy9BbmRyb2lkXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgaW5wdXRIYW5kbGVyID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuaW5wdXRIYW5kbGVyLm9mKCh2aWV3LCBmcm9tLCB0bywgaW5zZXJ0KSA9PiB7XG4gICAgaWYgKChhbmRyb2lkID8gdmlldy5jb21wb3NpbmcgOiB2aWV3LmNvbXBvc2l0aW9uU3RhcnRlZCkgfHwgdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChpbnNlcnQubGVuZ3RoID4gMiB8fCBpbnNlcnQubGVuZ3RoID09IDIgJiYgY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdChpbnNlcnQsIDApKSA9PSAxIHx8XG4gICAgICAgIGZyb20gIT0gc2VsLmZyb20gfHwgdG8gIT0gc2VsLnRvKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHRyID0gaW5zZXJ0QnJhY2tldCh2aWV3LnN0YXRlLCBpbnNlcnQpO1xuICAgIGlmICghdHIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5Db21tYW5kIHRoYXQgaW1wbGVtZW50cyBkZWxldGluZyBhIHBhaXIgb2YgbWF0Y2hpbmcgYnJhY2tldHMgd2hlblxudGhlIGN1cnNvciBpcyBiZXR3ZWVuIHRoZW0uXG4qL1xuY29uc3QgZGVsZXRlQnJhY2tldFBhaXIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjb25mID0gY29uZmlnKHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICBsZXQgdG9rZW5zID0gY29uZi5icmFja2V0cyB8fCBkZWZhdWx0cy5icmFja2V0cztcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gcHJldkNoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PSBiZWZvcmUgJiYgbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKSA9PSBjbG9zaW5nKGNvZGVQb2ludEF0KHRva2VuLCAwKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuaGVhZCAtIHRva2VuLmxlbmd0aCwgdG86IHJhbmdlLmhlYWQgKyB0b2tlbi5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgLSB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIGlmICghZG9udClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJkZWxldGUuYmFja3dhcmRcIiB9KSk7XG4gICAgcmV0dXJuICFkb250O1xufTtcbi8qKlxuQ2xvc2UtYnJhY2tldHMgcmVsYXRlZCBrZXkgYmluZGluZ3MuIEJpbmRzIEJhY2tzcGFjZSB0b1xuW2BkZWxldGVCcmFja2V0UGFpcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmRlbGV0ZUJyYWNrZXRQYWlyKS5cbiovXG5jb25zdCBjbG9zZUJyYWNrZXRzS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUJyYWNrZXRQYWlyIH1cbl07XG4vKipcbkltcGxlbWVudHMgdGhlIGV4dGVuc2lvbidzIGJlaGF2aW9yIG9uIHRleHQgaW5zZXJ0aW9uLiBJZiB0aGVcbmdpdmVuIHN0cmluZyBjb3VudHMgYXMgYSBicmFja2V0IGluIHRoZSBsYW5ndWFnZSBhcm91bmQgdGhlXG5zZWxlY3Rpb24sIGFuZCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGl0IHJlcXVpcmVzIGN1c3RvbVxuYmVoYXZpb3IgKGluc2VydGluZyBhIGNsb3NpbmcgdmVyc2lvbiBvciBza2lwcGluZyBwYXN0IGFcbnByZXZpb3VzbHktY2xvc2VkIGJyYWNrZXQpLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0cmFuc2FjdGlvblxucmVwcmVzZW50aW5nIHRoYXQgY3VzdG9tIGJlaGF2aW9yLiAoWW91IG9ubHkgbmVlZCB0aGlzIGlmIHlvdSB3YW50XG50byBwcm9ncmFtbWF0aWNhbGx5IGluc2VydCBicmFja2V0c1x1MjAxNHRoZVxuW2BjbG9zZUJyYWNrZXRzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VCcmFja2V0cykgZXh0ZW5zaW9uIHdpbGxcbnRha2UgY2FyZSBvZiBydW5uaW5nIHRoaXMgZm9yIHVzZXIgaW5wdXQuKVxuKi9cbmZ1bmN0aW9uIGluc2VydEJyYWNrZXQoc3RhdGUsIGJyYWNrZXQpIHtcbiAgICBsZXQgY29uZiA9IGNvbmZpZyhzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgbGV0IHRva2VucyA9IGNvbmYuYnJhY2tldHMgfHwgZGVmYXVsdHMuYnJhY2tldHM7XG4gICAgZm9yIChsZXQgdG9rIG9mIHRva2Vucykge1xuICAgICAgICBsZXQgY2xvc2VkID0gY2xvc2luZyhjb2RlUG9pbnRBdCh0b2ssIDApKTtcbiAgICAgICAgaWYgKGJyYWNrZXQgPT0gdG9rKVxuICAgICAgICAgICAgcmV0dXJuIGNsb3NlZCA9PSB0b2sgPyBoYW5kbGVTYW1lKHN0YXRlLCB0b2ssIHRva2Vucy5pbmRleE9mKHRvayArIHRvayArIHRvaykgPiAtMSwgY29uZilcbiAgICAgICAgICAgICAgICA6IGhhbmRsZU9wZW4oc3RhdGUsIHRvaywgY2xvc2VkLCBjb25mLmJlZm9yZSB8fCBkZWZhdWx0cy5iZWZvcmUpO1xuICAgICAgICBpZiAoYnJhY2tldCA9PSBjbG9zZWQgJiYgY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5mcm9tKSlcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDbG9zZShzdGF0ZSwgdG9rLCBjbG9zZWQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgc3RhdGUuZmllbGQoYnJhY2tldFN0YXRlKS5iZXR3ZWVuKDAsIHN0YXRlLmRvYy5sZW5ndGgsIGZyb20gPT4ge1xuICAgICAgICBpZiAoZnJvbSA9PSBwb3MpXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gbmV4dENoYXIoZG9jLCBwb3MpIHtcbiAgICBsZXQgbmV4dCA9IGRvYy5zbGljZVN0cmluZyhwb3MsIHBvcyArIDIpO1xuICAgIHJldHVybiBuZXh0LnNsaWNlKDAsIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQobmV4dCwgMCkpKTtcbn1cbmZ1bmN0aW9uIHByZXZDaGFyKGRvYywgcG9zKSB7XG4gICAgbGV0IHByZXYgPSBkb2Muc2xpY2VTdHJpbmcocG9zIC0gMiwgcG9zKTtcbiAgICByZXR1cm4gY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdChwcmV2LCAwKSkgPT0gcHJldi5sZW5ndGggPyBwcmV2IDogcHJldi5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9wZW4oc3RhdGUsIG9wZW4sIGNsb3NlLCBjbG9zZUJlZm9yZSkge1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW3sgaW5zZXJ0OiBvcGVuLCBmcm9tOiByYW5nZS5mcm9tIH0sIHsgaW5zZXJ0OiBjbG9zZSwgZnJvbTogcmFuZ2UudG8gfV0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLnRvICsgb3Blbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yICsgb3Blbi5sZW5ndGgsIHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCkgfTtcbiAgICAgICAgbGV0IG5leHQgPSBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpO1xuICAgICAgICBpZiAoIW5leHQgfHwgL1xccy8udGVzdChuZXh0KSB8fCBjbG9zZUJlZm9yZS5pbmRleE9mKG5leHQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogb3BlbiArIGNsb3NlLCBmcm9tOiByYW5nZS5oZWFkIH0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSB9O1xuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvbnQgPyBudWxsIDogc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC50eXBlXCJcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNsb3NlKHN0YXRlLCBfb3BlbiwgY2xvc2UpIHtcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5ICYmIG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCkgPT0gY2xvc2UpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmhlYWQsIHRvOiByYW5nZS5oZWFkICsgY2xvc2UubGVuZ3RoLCBpbnNlcnQ6IGNsb3NlIH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCArIGNsb3NlLmxlbmd0aCkgfTtcbiAgICAgICAgcmV0dXJuIGRvbnQgPSB7IHJhbmdlIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvbnQgPyBudWxsIDogc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC50eXBlXCJcbiAgICB9KTtcbn1cbi8vIEhhbmRsZXMgY2FzZXMgd2hlcmUgdGhlIG9wZW4gYW5kIGNsb3NlIHRva2VuIGFyZSB0aGUgc2FtZSwgYW5kXG4vLyBwb3NzaWJseSB0cmlwbGUgcXVvdGVzIChhcyBpbiBgXCJcIlwiYWJjXCJcIlwiYC1zdHlsZSBxdW90aW5nKS5cbmZ1bmN0aW9uIGhhbmRsZVNhbWUoc3RhdGUsIHRva2VuLCBhbGxvd1RyaXBsZSwgY29uZmlnKSB7XG4gICAgbGV0IHN0cmluZ1ByZWZpeGVzID0gY29uZmlnLnN0cmluZ1ByZWZpeGVzIHx8IGRlZmF1bHRzLnN0cmluZ1ByZWZpeGVzO1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW3sgaW5zZXJ0OiB0b2tlbiwgZnJvbTogcmFuZ2UuZnJvbSB9LCB7IGluc2VydDogdG9rZW4sIGZyb206IHJhbmdlLnRvIH1dLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IgKyB0b2tlbi5sZW5ndGgsIHJhbmdlLmhlYWQgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIGxldCBwb3MgPSByYW5nZS5oZWFkLCBuZXh0ID0gbmV4dENoYXIoc3RhdGUuZG9jLCBwb3MpLCBzdGFydDtcbiAgICAgICAgaWYgKG5leHQgPT0gdG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChub2RlU3RhcnQoc3RhdGUsIHBvcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHBvcykpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNUcmlwbGUgPSBhbGxvd1RyaXBsZSAmJiBzdGF0ZS5zbGljZURvYyhwb3MsIHBvcyArIHRva2VuLmxlbmd0aCAqIDMpID09IHRva2VuICsgdG9rZW4gKyB0b2tlbjtcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9IGlzVHJpcGxlID8gdG9rZW4gKyB0b2tlbiArIHRva2VuIDogdG9rZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiBwb3MsIHRvOiBwb3MgKyBjb250ZW50Lmxlbmd0aCwgaW5zZXJ0OiBjb250ZW50IH0sXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIGNvbnRlbnQubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG93VHJpcGxlICYmIHN0YXRlLnNsaWNlRG9jKHBvcyAtIDIgKiB0b2tlbi5sZW5ndGgsIHBvcykgPT0gdG9rZW4gKyB0b2tlbiAmJlxuICAgICAgICAgICAgKHN0YXJ0ID0gY2FuU3RhcnRTdHJpbmdBdChzdGF0ZSwgcG9zIC0gMiAqIHRva2VuLmxlbmd0aCwgc3RyaW5nUHJlZml4ZXMpKSA+IC0xICYmXG4gICAgICAgICAgICBub2RlU3RhcnQoc3RhdGUsIHN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4gKyB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcykobmV4dCkgIT0gQ2hhckNhdGVnb3J5LldvcmQpIHtcbiAgICAgICAgICAgIGlmIChjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MsIHN0cmluZ1ByZWZpeGVzKSA+IC0xICYmICFwcm9iYWJseUluU3RyaW5nKHN0YXRlLCBwb3MsIHRva2VuLCBzdHJpbmdQcmVmaXhlcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9kZVN0YXJ0KHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MgKyAxKTtcbiAgICByZXR1cm4gdHJlZS5wYXJlbnQgJiYgdHJlZS5mcm9tID09IHBvcztcbn1cbmZ1bmN0aW9uIHByb2JhYmx5SW5TdHJpbmcoc3RhdGUsIHBvcywgcXVvdGVUb2tlbiwgcHJlZml4ZXMpIHtcbiAgICBsZXQgbm9kZSA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MsIC0xKTtcbiAgICBsZXQgbWF4UHJlZml4ID0gcHJlZml4ZXMucmVkdWNlKChtLCBwKSA9PiBNYXRoLm1heChtLCBwLmxlbmd0aCksIDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YXRlLnNsaWNlRG9jKG5vZGUuZnJvbSwgTWF0aC5taW4obm9kZS50bywgbm9kZS5mcm9tICsgcXVvdGVUb2tlbi5sZW5ndGggKyBtYXhQcmVmaXgpKTtcbiAgICAgICAgbGV0IHF1b3RlUG9zID0gc3RhcnQuaW5kZXhPZihxdW90ZVRva2VuKTtcbiAgICAgICAgaWYgKCFxdW90ZVBvcyB8fCBxdW90ZVBvcyA+IC0xICYmIHByZWZpeGVzLmluZGV4T2Yoc3RhcnQuc2xpY2UoMCwgcXVvdGVQb3MpKSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoZmlyc3QgJiYgZmlyc3QuZnJvbSA9PSBub2RlLmZyb20gJiYgZmlyc3QudG8gLSBmaXJzdC5mcm9tID4gcXVvdGVUb2tlbi5sZW5ndGggKyBxdW90ZVBvcykge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zbGljZURvYyhmaXJzdC50byAtIHF1b3RlVG9rZW4ubGVuZ3RoLCBmaXJzdC50bykgPT0gcXVvdGVUb2tlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmlyc3QuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnRvID09IHBvcyAmJiBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2FuU3RhcnRTdHJpbmdBdChzdGF0ZSwgcG9zLCBwcmVmaXhlcykge1xuICAgIGxldCBjaGFyQ2F0ID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgaWYgKGNoYXJDYXQoc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgZm9yIChsZXQgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcyAtIHByZWZpeC5sZW5ndGg7XG4gICAgICAgIGlmIChzdGF0ZS5zbGljZURvYyhzdGFydCwgcG9zKSA9PSBwcmVmaXggJiYgY2hhckNhdChzdGF0ZS5zbGljZURvYyhzdGFydCAtIDEsIHN0YXJ0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYXV0b2NvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gYXV0b2NvbXBsZXRpb24oY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBjb21taXRDaGFyYWN0ZXJzLFxuICAgICAgICBjb21wbGV0aW9uU3RhdGUsXG4gICAgICAgIGNvbXBsZXRpb25Db25maWcub2YoY29uZmlnKSxcbiAgICAgICAgY29tcGxldGlvblBsdWdpbixcbiAgICAgICAgY29tcGxldGlvbktleW1hcEV4dCxcbiAgICAgICAgYmFzZVRoZW1lXG4gICAgXTtcbn1cbi8qKlxuQmFzaWMga2V5YmluZGluZ3MgZm9yIGF1dG9jb21wbGV0aW9uLlxuXG4gLSBDdHJsLVNwYWNlIChhbmQgQWx0LVxcYCBvciBBbHQtaSBvbiBtYWNPUyk6IFtgc3RhcnRDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc3RhcnRDb21wbGV0aW9uKVxuIC0gRXNjYXBlOiBbYGNsb3NlQ29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQ29tcGxldGlvbilcbiAtIEFycm93RG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSlgXG4gLSBBcnJvd1VwOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYChmYWxzZSlgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gUGFnZVVwOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYChmYWxzZSwgXCJwYWdlXCIpYFxuIC0gRW50ZXI6IFtgYWNjZXB0Q29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmFjY2VwdENvbXBsZXRpb24pXG4qL1xuY29uc3QgY29tcGxldGlvbktleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLVNwYWNlXCIsIHJ1bjogc3RhcnRDb21wbGV0aW9uIH0sXG4gICAgeyBtYWM6IFwiQWx0LWBcIiwgcnVuOiBzdGFydENvbXBsZXRpb24gfSxcbiAgICB7IG1hYzogXCJBbHQtaVwiLCBydW46IHN0YXJ0Q29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsb3NlQ29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlKSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UpIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZhbHNlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGFjY2VwdENvbXBsZXRpb24gfVxuXTtcbmNvbnN0IGNvbXBsZXRpb25LZXltYXBFeHQgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZU4oW2NvbXBsZXRpb25Db25maWddLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5kZWZhdWx0S2V5bWFwID8gW2NvbXBsZXRpb25LZXltYXBdIDogW10pKTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24gc3RhdHVzLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBhdmFpbGFibGUsXG50aGlzIHdpbGwgcmV0dXJuIGBcImFjdGl2ZVwiYC4gV2hlbiBjb21wbGV0aW9ucyBhcmUgcGVuZGluZyAoaW4gdGhlXG5wcm9jZXNzIG9mIGJlaW5nIHF1ZXJpZWQpLCB0aGlzIHJldHVybnMgYFwicGVuZGluZ1wiYC4gT3RoZXJ3aXNlLCBpdFxucmV0dXJucyBgbnVsbGAuXG4qL1xuZnVuY3Rpb24gY29tcGxldGlvblN0YXR1cyhzdGF0ZSkge1xuICAgIGxldCBjU3RhdGUgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuaXNQZW5kaW5nKSA/IFwicGVuZGluZ1wiXG4gICAgICAgIDogY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgPyBcImFjdGl2ZVwiIDogbnVsbDtcbn1cbmNvbnN0IGNvbXBsZXRpb25BcnJheUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwO1xuLyoqXG5SZXR1cm5zIHRoZSBhdmFpbGFibGUgY29tcGxldGlvbnMgYXMgYW4gYXJyYXkuXG4qL1xuZnVuY3Rpb24gY3VycmVudENvbXBsZXRpb25zKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIGlmICghb3BlbiB8fCBvcGVuLmRpc2FibGVkKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29tcGxldGlvbkFycmF5Q2FjaGUuZ2V0KG9wZW4ub3B0aW9ucyk7XG4gICAgaWYgKCFjb21wbGV0aW9ucylcbiAgICAgICAgY29tcGxldGlvbkFycmF5Q2FjaGUuc2V0KG9wZW4ub3B0aW9ucywgY29tcGxldGlvbnMgPSBvcGVuLm9wdGlvbnMubWFwKG8gPT4gby5jb21wbGV0aW9uKSk7XG4gICAgcmV0dXJuIGNvbXBsZXRpb25zO1xufVxuLyoqXG5SZXR1cm4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLCBpZiBhbnkuXG4qL1xuZnVuY3Rpb24gc2VsZWN0ZWRDb21wbGV0aW9uKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXS5jb21wbGV0aW9uIDogbnVsbDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBvc2l0aW9uIGluIHRoZSBhY3RpdmUgY29tcGxldGlvblxubGlzdCwgb3IgbnVsbCBpZiBubyBjb21wbGV0aW9ucyBhcmUgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIHNlbGVjdGVkQ29tcGxldGlvbkluZGV4KHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4uc2VsZWN0ZWQgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYW4gZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gY2hhbmdlXG50aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWRDb21wbGV0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHNldFNlbGVjdGVkRWZmZWN0Lm9mKGluZGV4KTtcbn1cblxuZXhwb3J0IHsgQ29tcGxldGlvbkNvbnRleHQsIGFjY2VwdENvbXBsZXRpb24sIGF1dG9jb21wbGV0aW9uLCBjbGVhclNuaXBwZXQsIGNsb3NlQnJhY2tldHMsIGNsb3NlQnJhY2tldHNLZXltYXAsIGNsb3NlQ29tcGxldGlvbiwgY29tcGxldGVBbnlXb3JkLCBjb21wbGV0ZUZyb21MaXN0LCBjb21wbGV0aW9uS2V5bWFwLCBjb21wbGV0aW9uU3RhdHVzLCBjdXJyZW50Q29tcGxldGlvbnMsIGRlbGV0ZUJyYWNrZXRQYWlyLCBoYXNOZXh0U25pcHBldEZpZWxkLCBoYXNQcmV2U25pcHBldEZpZWxkLCBpZkluLCBpZk5vdEluLCBpbnNlcnRCcmFja2V0LCBpbnNlcnRDb21wbGV0aW9uVGV4dCwgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24sIG5leHRTbmlwcGV0RmllbGQsIHBpY2tlZENvbXBsZXRpb24sIHByZXZTbmlwcGV0RmllbGQsIHNlbGVjdGVkQ29tcGxldGlvbiwgc2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgsIHNldFNlbGVjdGVkQ29tcGxldGlvbiwgc25pcHBldCwgc25pcHBldENvbXBsZXRpb24sIHNuaXBwZXRLZXltYXAsIHN0YXJ0Q29tcGxldGlvbiB9O1xuIiwgImltcG9ydCB7IE5vZGVUeXBlLCBOb2RlUHJvcCwgTm9kZVNldCwgVHJlZSwgUGFyc2VyLCBwYXJzZU1peGVkIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5pbXBvcnQgeyBzdHlsZVRhZ3MsIHRhZ3MsIFRhZyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG5jbGFzcyBDb21wb3NpdGVCbG9jayB7XG4gICAgc3RhdGljIGNyZWF0ZSh0eXBlLCB2YWx1ZSwgZnJvbSwgcGFyZW50SGFzaCwgZW5kKSB7XG4gICAgICAgIGxldCBoYXNoID0gKHBhcmVudEhhc2ggKyAocGFyZW50SGFzaCA8PCA4KSArIHR5cGUgKyAodmFsdWUgPDwgNCkpIHwgMDtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVCbG9jayh0eXBlLCB2YWx1ZSwgZnJvbSwgaGFzaCwgZW5kLCBbXSwgW10pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBcbiAgICAvLyBVc2VkIGZvciBpbmRlbnRhdGlvbiBpbiBsaXN0IGl0ZW1zLCBtYXJrdXAgY2hhcmFjdGVyIGluIGxpc3RzXG4gICAgdmFsdWUsIGZyb20sIGhhc2gsIGVuZCwgY2hpbGRyZW4sIHBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaGFzaCA9IGhhc2g7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmhhc2hQcm9wID0gW1tOb2RlUHJvcC5jb250ZXh0SGFzaCwgaGFzaF1dO1xuICAgIH1cbiAgICBhZGRDaGlsZChjaGlsZCwgcG9zKSB7XG4gICAgICAgIGlmIChjaGlsZC5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSAhPSB0aGlzLmhhc2gpXG4gICAgICAgICAgICBjaGlsZCA9IG5ldyBUcmVlKGNoaWxkLnR5cGUsIGNoaWxkLmNoaWxkcmVuLCBjaGlsZC5wb3NpdGlvbnMsIGNoaWxkLmxlbmd0aCwgdGhpcy5oYXNoUHJvcCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLnB1c2gocG9zKTtcbiAgICB9XG4gICAgdG9UcmVlKG5vZGVTZXQsIGVuZCA9IHRoaXMuZW5kKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA+PSAwKVxuICAgICAgICAgICAgZW5kID0gTWF0aC5tYXgoZW5kLCB0aGlzLnBvc2l0aW9uc1tsYXN0XSArIHRoaXMuY2hpbGRyZW5bbGFzdF0ubGVuZ3RoICsgdGhpcy5mcm9tKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKG5vZGVTZXQudHlwZXNbdGhpcy50eXBlXSwgdGhpcy5jaGlsZHJlbiwgdGhpcy5wb3NpdGlvbnMsIGVuZCAtIHRoaXMuZnJvbSkuYmFsYW5jZSh7XG4gICAgICAgICAgICBtYWtlVHJlZTogKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLmhhc2hQcm9wKVxuICAgICAgICB9KTtcbiAgICB9XG59XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIkRvY3VtZW50XCJdID0gMV0gPSBcIkRvY3VtZW50XCI7XG4gICAgVHlwZVtUeXBlW1wiQ29kZUJsb2NrXCJdID0gMl0gPSBcIkNvZGVCbG9ja1wiO1xuICAgIFR5cGVbVHlwZVtcIkZlbmNlZENvZGVcIl0gPSAzXSA9IFwiRmVuY2VkQ29kZVwiO1xuICAgIFR5cGVbVHlwZVtcIkJsb2NrcXVvdGVcIl0gPSA0XSA9IFwiQmxvY2txdW90ZVwiO1xuICAgIFR5cGVbVHlwZVtcIkhvcml6b250YWxSdWxlXCJdID0gNV0gPSBcIkhvcml6b250YWxSdWxlXCI7XG4gICAgVHlwZVtUeXBlW1wiQnVsbGV0TGlzdFwiXSA9IDZdID0gXCJCdWxsZXRMaXN0XCI7XG4gICAgVHlwZVtUeXBlW1wiT3JkZXJlZExpc3RcIl0gPSA3XSA9IFwiT3JkZXJlZExpc3RcIjtcbiAgICBUeXBlW1R5cGVbXCJMaXN0SXRlbVwiXSA9IDhdID0gXCJMaXN0SXRlbVwiO1xuICAgIFR5cGVbVHlwZVtcIkFUWEhlYWRpbmcxXCJdID0gOV0gPSBcIkFUWEhlYWRpbmcxXCI7XG4gICAgVHlwZVtUeXBlW1wiQVRYSGVhZGluZzJcIl0gPSAxMF0gPSBcIkFUWEhlYWRpbmcyXCI7XG4gICAgVHlwZVtUeXBlW1wiQVRYSGVhZGluZzNcIl0gPSAxMV0gPSBcIkFUWEhlYWRpbmczXCI7XG4gICAgVHlwZVtUeXBlW1wiQVRYSGVhZGluZzRcIl0gPSAxMl0gPSBcIkFUWEhlYWRpbmc0XCI7XG4gICAgVHlwZVtUeXBlW1wiQVRYSGVhZGluZzVcIl0gPSAxM10gPSBcIkFUWEhlYWRpbmc1XCI7XG4gICAgVHlwZVtUeXBlW1wiQVRYSGVhZGluZzZcIl0gPSAxNF0gPSBcIkFUWEhlYWRpbmc2XCI7XG4gICAgVHlwZVtUeXBlW1wiU2V0ZXh0SGVhZGluZzFcIl0gPSAxNV0gPSBcIlNldGV4dEhlYWRpbmcxXCI7XG4gICAgVHlwZVtUeXBlW1wiU2V0ZXh0SGVhZGluZzJcIl0gPSAxNl0gPSBcIlNldGV4dEhlYWRpbmcyXCI7XG4gICAgVHlwZVtUeXBlW1wiSFRNTEJsb2NrXCJdID0gMTddID0gXCJIVE1MQmxvY2tcIjtcbiAgICBUeXBlW1R5cGVbXCJMaW5rUmVmZXJlbmNlXCJdID0gMThdID0gXCJMaW5rUmVmZXJlbmNlXCI7XG4gICAgVHlwZVtUeXBlW1wiUGFyYWdyYXBoXCJdID0gMTldID0gXCJQYXJhZ3JhcGhcIjtcbiAgICBUeXBlW1R5cGVbXCJDb21tZW50QmxvY2tcIl0gPSAyMF0gPSBcIkNvbW1lbnRCbG9ja1wiO1xuICAgIFR5cGVbVHlwZVtcIlByb2Nlc3NpbmdJbnN0cnVjdGlvbkJsb2NrXCJdID0gMjFdID0gXCJQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25CbG9ja1wiO1xuICAgIC8vIElubGluZVxuICAgIFR5cGVbVHlwZVtcIkVzY2FwZVwiXSA9IDIyXSA9IFwiRXNjYXBlXCI7XG4gICAgVHlwZVtUeXBlW1wiRW50aXR5XCJdID0gMjNdID0gXCJFbnRpdHlcIjtcbiAgICBUeXBlW1R5cGVbXCJIYXJkQnJlYWtcIl0gPSAyNF0gPSBcIkhhcmRCcmVha1wiO1xuICAgIFR5cGVbVHlwZVtcIkVtcGhhc2lzXCJdID0gMjVdID0gXCJFbXBoYXNpc1wiO1xuICAgIFR5cGVbVHlwZVtcIlN0cm9uZ0VtcGhhc2lzXCJdID0gMjZdID0gXCJTdHJvbmdFbXBoYXNpc1wiO1xuICAgIFR5cGVbVHlwZVtcIkxpbmtcIl0gPSAyN10gPSBcIkxpbmtcIjtcbiAgICBUeXBlW1R5cGVbXCJJbWFnZVwiXSA9IDI4XSA9IFwiSW1hZ2VcIjtcbiAgICBUeXBlW1R5cGVbXCJJbmxpbmVDb2RlXCJdID0gMjldID0gXCJJbmxpbmVDb2RlXCI7XG4gICAgVHlwZVtUeXBlW1wiSFRNTFRhZ1wiXSA9IDMwXSA9IFwiSFRNTFRhZ1wiO1xuICAgIFR5cGVbVHlwZVtcIkNvbW1lbnRcIl0gPSAzMV0gPSBcIkNvbW1lbnRcIjtcbiAgICBUeXBlW1R5cGVbXCJQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIl0gPSAzMl0gPSBcIlByb2Nlc3NpbmdJbnN0cnVjdGlvblwiO1xuICAgIFR5cGVbVHlwZVtcIkF1dG9saW5rXCJdID0gMzNdID0gXCJBdXRvbGlua1wiO1xuICAgIC8vIFNtYWxsZXIgdG9rZW5zXG4gICAgVHlwZVtUeXBlW1wiSGVhZGVyTWFya1wiXSA9IDM0XSA9IFwiSGVhZGVyTWFya1wiO1xuICAgIFR5cGVbVHlwZVtcIlF1b3RlTWFya1wiXSA9IDM1XSA9IFwiUXVvdGVNYXJrXCI7XG4gICAgVHlwZVtUeXBlW1wiTGlzdE1hcmtcIl0gPSAzNl0gPSBcIkxpc3RNYXJrXCI7XG4gICAgVHlwZVtUeXBlW1wiTGlua01hcmtcIl0gPSAzN10gPSBcIkxpbmtNYXJrXCI7XG4gICAgVHlwZVtUeXBlW1wiRW1waGFzaXNNYXJrXCJdID0gMzhdID0gXCJFbXBoYXNpc01hcmtcIjtcbiAgICBUeXBlW1R5cGVbXCJDb2RlTWFya1wiXSA9IDM5XSA9IFwiQ29kZU1hcmtcIjtcbiAgICBUeXBlW1R5cGVbXCJDb2RlVGV4dFwiXSA9IDQwXSA9IFwiQ29kZVRleHRcIjtcbiAgICBUeXBlW1R5cGVbXCJDb2RlSW5mb1wiXSA9IDQxXSA9IFwiQ29kZUluZm9cIjtcbiAgICBUeXBlW1R5cGVbXCJMaW5rVGl0bGVcIl0gPSA0Ml0gPSBcIkxpbmtUaXRsZVwiO1xuICAgIFR5cGVbVHlwZVtcIkxpbmtMYWJlbFwiXSA9IDQzXSA9IFwiTGlua0xhYmVsXCI7XG4gICAgVHlwZVtUeXBlW1wiVVJMXCJdID0gNDRdID0gXCJVUkxcIjtcbn0pKFR5cGUgfHwgKFR5cGUgPSB7fSkpO1xuLyoqXG5EYXRhIHN0cnVjdHVyZSB1c2VkIHRvIGFjY3VtdWxhdGUgYSBibG9jaydzIGNvbnRlbnQgZHVyaW5nIFtsZWFmXG5ibG9jayBwYXJzaW5nXSgjQmxvY2tQYXJzZXIubGVhZikuXG4qL1xuY2xhc3MgTGVhZkJsb2NrIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgYmxvY2suXG4gICAgKi9cbiAgICBzdGFydCwgXG4gICAgLyoqXG4gICAgVGhlIGJsb2NrJ3MgdGV4dCBjb250ZW50LlxuICAgICovXG4gICAgY29udGVudCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGJsb2NrIHBhcnNlcnMgYWN0aXZlIGZvciB0aGlzIGJsb2NrLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcnNlcnMgPSBbXTtcbiAgICB9XG59XG4vKipcbkRhdGEgc3RydWN0dXJlIHVzZWQgZHVyaW5nIGJsb2NrLWxldmVsIHBlci1saW5lIHBhcnNpbmcuXG4qL1xuY2xhc3MgTGluZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgbGluZSdzIGZ1bGwgdGV4dC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBiYXNlIGluZGVudCBwcm92aWRlZCBieSB0aGUgY29tcG9zaXRlIGNvbnRleHRzICh0aGF0IGhhdmVcbiAgICAgICAgYmVlbiBoYW5kbGVkIHNvIGZhcikuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYmFzZUluZGVudCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RyaW5nIHBvc2l0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGJhc2UgaW5kZW50LlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhc2VQb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIG51bWJlciBvZiBjb250ZXh0cyBoYW5kbGVkIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgIEFueSBtYXJrZXJzIChpLmUuIGJsb2NrIHF1b3RlIG1hcmtlcnMpIHBhcnNlZCBmb3IgdGhlIGNvbnRleHRzLiBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIG5leHQgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIGJleW9uZCBhbnlcbiAgICAgICAgbGlzdCwgYmxvY2txdW90ZSwgb3Igb3RoZXIgY29tcG9zaXRlIGJsb2NrIG1hcmtlcnMuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjb2x1bW4gb2YgdGhlIG5leHQgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGVudCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIGNoYXJhY3RlciBhZnRlciBgcG9zYC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZm9yd2FyZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBvcyA+IHRoaXMucG9zKVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkSW5uZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3J3YXJkSW5uZXIoKSB7XG4gICAgICAgIGxldCBuZXdQb3MgPSB0aGlzLnNraXBTcGFjZSh0aGlzLmJhc2VQb3MpO1xuICAgICAgICB0aGlzLmluZGVudCA9IHRoaXMuY291bnRJbmRlbnQobmV3UG9zLCB0aGlzLnBvcywgdGhpcy5pbmRlbnQpO1xuICAgICAgICB0aGlzLnBvcyA9IG5ld1BvcztcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV3UG9zID09IHRoaXMudGV4dC5sZW5ndGggPyAtMSA6IHRoaXMudGV4dC5jaGFyQ29kZUF0KG5ld1Bvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNraXAgd2hpdGVzcGFjZSBhZnRlciB0aGUgZ2l2ZW4gcG9zaXRpb24sIHJldHVybiB0aGUgcG9zaXRpb24gb2ZcbiAgICB0aGUgbmV4dCBub24tc3BhY2UgY2hhcmFjdGVyIG9yIHRoZSBlbmQgb2YgdGhlIGxpbmUgaWYgdGhlcmUnc1xuICAgIG9ubHkgc3BhY2UgYWZ0ZXIgYGZyb21gLlxuICAgICovXG4gICAgc2tpcFNwYWNlKGZyb20pIHsgcmV0dXJuIHNraXBTcGFjZSh0aGlzLnRleHQsIGZyb20pOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNldCh0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuYmFzZUluZGVudCA9IHRoaXMuYmFzZVBvcyA9IHRoaXMucG9zID0gdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICB0aGlzLmZvcndhcmRJbm5lcigpO1xuICAgICAgICB0aGlzLmRlcHRoID0gMTtcbiAgICAgICAgd2hpbGUgKHRoaXMubWFya2Vycy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm1hcmtlcnMucG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGxpbmUncyBiYXNlIHBvc2l0aW9uIGZvcndhcmQgdG8gdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IGNvbXBvc2l0ZSBbYmxvY2tcbiAgICBwYXJzZXJzXSgjQmxvY2tQYXJzZXIucGFyc2UpIG9yIFttYXJrdXAgc2tpcHBpbmdcbiAgICBmdW5jdGlvbnNdKCNOb2RlU3BlYy5jb21wb3NpdGUpLlxuICAgICovXG4gICAgbW92ZUJhc2UodG8pIHtcbiAgICAgICAgdGhpcy5iYXNlUG9zID0gdG87XG4gICAgICAgIHRoaXMuYmFzZUluZGVudCA9IHRoaXMuY291bnRJbmRlbnQodG8sIHRoaXMucG9zLCB0aGlzLmluZGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGxpbmUncyBiYXNlIHBvc2l0aW9uIGZvcndhcmQgdG8gdGhlIGdpdmVuIF9jb2x1bW5fLlxuICAgICovXG4gICAgbW92ZUJhc2VDb2x1bW4oaW5kZW50KSB7XG4gICAgICAgIHRoaXMuYmFzZUluZGVudCA9IGluZGVudDtcbiAgICAgICAgdGhpcy5iYXNlUG9zID0gdGhpcy5maW5kQ29sdW1uKGluZGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0b3JlIGEgY29tcG9zaXRlLWJsb2NrLWxldmVsIG1hcmtlci4gU2hvdWxkIGJlIGNhbGxlZCBmcm9tXG4gICAgW21hcmt1cCBza2lwcGluZyBmdW5jdGlvbnNdKCNOb2RlU3BlYy5jb21wb3NpdGUpIHdoZW4gdGhleVxuICAgIGNvbnN1bWUgYW55IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBhZGRNYXJrZXIoZWx0KSB7XG4gICAgICAgIHRoaXMubWFya2Vycy5wdXNoKGVsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCBgdG9gLCBvcHRpb25hbGx5IHN0YXJ0aW5nIGF0IGEgZ2l2ZW5cbiAgICBwb3NpdGlvbiBhbmQgY29sdW1uLlxuICAgICovXG4gICAgY291bnRJbmRlbnQodG8sIGZyb20gPSAwLCBpbmRlbnQgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgICAgICAgIGluZGVudCArPSB0aGlzLnRleHQuY2hhckNvZGVBdChpKSA9PSA5ID8gNCAtIGluZGVudCAlIDQgOiAxO1xuICAgICAgICByZXR1cm4gaW5kZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBwb3NpdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBjb2x1bW4uXG4gICAgKi9cbiAgICBmaW5kQ29sdW1uKGdvYWwpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRlbnQgPSAwOyBpIDwgdGhpcy50ZXh0Lmxlbmd0aCAmJiBpbmRlbnQgPCBnb2FsOyBpKyspXG4gICAgICAgICAgICBpbmRlbnQgKz0gdGhpcy50ZXh0LmNoYXJDb2RlQXQoaSkgPT0gOSA/IDQgLSBpbmRlbnQgJSA0IDogMTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NydWIoKSB7XG4gICAgICAgIGlmICghdGhpcy5iYXNlSW5kZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iYXNlUG9zOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyB0aGlzLnRleHQuc2xpY2UodGhpcy5iYXNlUG9zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBza2lwRm9yTGlzdChibCwgY3gsIGxpbmUpIHtcbiAgICBpZiAobGluZS5wb3MgPT0gbGluZS50ZXh0Lmxlbmd0aCB8fFxuICAgICAgICAoYmwgIT0gY3guYmxvY2sgJiYgbGluZS5pbmRlbnQgPj0gY3guc3RhY2tbbGluZS5kZXB0aCArIDFdLnZhbHVlICsgbGluZS5iYXNlSW5kZW50KSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbmUuaW5kZW50ID49IGxpbmUuYmFzZUluZGVudCArIDQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2l6ZSA9IChibC50eXBlID09IFR5cGUuT3JkZXJlZExpc3QgPyBpc09yZGVyZWRMaXN0IDogaXNCdWxsZXRMaXN0KShsaW5lLCBjeCwgZmFsc2UpO1xuICAgIHJldHVybiBzaXplID4gMCAmJlxuICAgICAgICAoYmwudHlwZSAhPSBUeXBlLkJ1bGxldExpc3QgfHwgaXNIb3Jpem9udGFsUnVsZShsaW5lLCBjeCwgZmFsc2UpIDwgMCkgJiZcbiAgICAgICAgbGluZS50ZXh0LmNoYXJDb2RlQXQobGluZS5wb3MgKyBzaXplIC0gMSkgPT0gYmwudmFsdWU7XG59XG5jb25zdCBEZWZhdWx0U2tpcE1hcmt1cCA9IHtcbiAgICBbVHlwZS5CbG9ja3F1b3RlXShibCwgY3gsIGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubmV4dCAhPSA2MiAvKiAnPicgKi8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxpbmUubWFya2Vycy5wdXNoKGVsdChUeXBlLlF1b3RlTWFyaywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MsIGN4LmxpbmVTdGFydCArIGxpbmUucG9zICsgMSkpO1xuICAgICAgICBsaW5lLm1vdmVCYXNlKGxpbmUucG9zICsgKHNwYWNlKGxpbmUudGV4dC5jaGFyQ29kZUF0KGxpbmUucG9zICsgMSkpID8gMiA6IDEpKTtcbiAgICAgICAgYmwuZW5kID0gY3gubGluZVN0YXJ0ICsgbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBbVHlwZS5MaXN0SXRlbV0oYmwsIF9jeCwgbGluZSkge1xuICAgICAgICBpZiAobGluZS5pbmRlbnQgPCBsaW5lLmJhc2VJbmRlbnQgKyBibC52YWx1ZSAmJiBsaW5lLm5leHQgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGluZS5tb3ZlQmFzZUNvbHVtbihsaW5lLmJhc2VJbmRlbnQgKyBibC52YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgW1R5cGUuT3JkZXJlZExpc3RdOiBza2lwRm9yTGlzdCxcbiAgICBbVHlwZS5CdWxsZXRMaXN0XTogc2tpcEZvckxpc3QsXG4gICAgW1R5cGUuRG9jdW1lbnRdKCkgeyByZXR1cm4gdHJ1ZTsgfVxufTtcbmZ1bmN0aW9uIHNwYWNlKGNoKSB7IHJldHVybiBjaCA9PSAzMiB8fCBjaCA9PSA5IHx8IGNoID09IDEwIHx8IGNoID09IDEzOyB9XG5mdW5jdGlvbiBza2lwU3BhY2UobGluZSwgaSA9IDApIHtcbiAgICB3aGlsZSAoaSA8IGxpbmUubGVuZ3RoICYmIHNwYWNlKGxpbmUuY2hhckNvZGVBdChpKSkpXG4gICAgICAgIGkrKztcbiAgICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIHNraXBTcGFjZUJhY2sobGluZSwgaSwgdG8pIHtcbiAgICB3aGlsZSAoaSA+IHRvICYmIHNwYWNlKGxpbmUuY2hhckNvZGVBdChpIC0gMSkpKVxuICAgICAgICBpLS07XG4gICAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBpc0ZlbmNlZENvZGUobGluZSkge1xuICAgIGlmIChsaW5lLm5leHQgIT0gOTYgJiYgbGluZS5uZXh0ICE9IDEyNiAvKiAnYH4nICovKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IHBvcyA9IGxpbmUucG9zICsgMTtcbiAgICB3aGlsZSAocG9zIDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBsaW5lLnRleHQuY2hhckNvZGVBdChwb3MpID09IGxpbmUubmV4dClcbiAgICAgICAgcG9zKys7XG4gICAgaWYgKHBvcyA8IGxpbmUucG9zICsgMylcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGlmIChsaW5lLm5leHQgPT0gOTYpXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBsaW5lLnRleHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobGluZS50ZXh0LmNoYXJDb2RlQXQoaSkgPT0gOTYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiBwb3M7XG59XG5mdW5jdGlvbiBpc0Jsb2NrcXVvdGUobGluZSkge1xuICAgIHJldHVybiBsaW5lLm5leHQgIT0gNjIgLyogJz4nICovID8gLTEgOiBsaW5lLnRleHQuY2hhckNvZGVBdChsaW5lLnBvcyArIDEpID09IDMyID8gMiA6IDE7XG59XG5mdW5jdGlvbiBpc0hvcml6b250YWxSdWxlKGxpbmUsIGN4LCBicmVha2luZykge1xuICAgIGlmIChsaW5lLm5leHQgIT0gNDIgJiYgbGluZS5uZXh0ICE9IDQ1ICYmIGxpbmUubmV4dCAhPSA5NSAvKiAnXy0qJyAqLylcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBjb3VudCA9IDE7XG4gICAgZm9yIChsZXQgcG9zID0gbGluZS5wb3MgKyAxOyBwb3MgPCBsaW5lLnRleHQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICBsZXQgY2ggPSBsaW5lLnRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoY2ggPT0gbGluZS5uZXh0KVxuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgZWxzZSBpZiAoIXNwYWNlKGNoKSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLy8gU2V0ZXh0IGhlYWRlcnMgdGFrZSBwcmVjZWRlbmNlXG4gICAgaWYgKGJyZWFraW5nICYmIGxpbmUubmV4dCA9PSA0NSAmJiBpc1NldGV4dFVuZGVybGluZShsaW5lKSA+IC0xICYmIGxpbmUuZGVwdGggPT0gY3guc3RhY2subGVuZ3RoICYmXG4gICAgICAgIGN4LnBhcnNlci5sZWFmQmxvY2tQYXJzZXJzLmluZGV4T2YoRGVmYXVsdExlYWZCbG9ja3MuU2V0ZXh0SGVhZGluZykgPiAtMSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiBjb3VudCA8IDMgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBpbkxpc3QoY3gsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gY3guc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChjeC5zdGFja1tpXS50eXBlID09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0J1bGxldExpc3QobGluZSwgY3gsIGJyZWFraW5nKSB7XG4gICAgcmV0dXJuIChsaW5lLm5leHQgPT0gNDUgfHwgbGluZS5uZXh0ID09IDQzIHx8IGxpbmUubmV4dCA9PSA0MiAvKiAnLSsqJyAqLykgJiZcbiAgICAgICAgKGxpbmUucG9zID09IGxpbmUudGV4dC5sZW5ndGggLSAxIHx8IHNwYWNlKGxpbmUudGV4dC5jaGFyQ29kZUF0KGxpbmUucG9zICsgMSkpKSAmJlxuICAgICAgICAoIWJyZWFraW5nIHx8IGluTGlzdChjeCwgVHlwZS5CdWxsZXRMaXN0KSB8fCBsaW5lLnNraXBTcGFjZShsaW5lLnBvcyArIDIpIDwgbGluZS50ZXh0Lmxlbmd0aCkgPyAxIDogLTE7XG59XG5mdW5jdGlvbiBpc09yZGVyZWRMaXN0KGxpbmUsIGN4LCBicmVha2luZykge1xuICAgIGxldCBwb3MgPSBsaW5lLnBvcywgbmV4dCA9IGxpbmUubmV4dDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcgLyogJzAtOScgKi8pXG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChwb3MgPT0gbGluZS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbmV4dCA9IGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgfVxuICAgIGlmIChwb3MgPT0gbGluZS5wb3MgfHwgcG9zID4gbGluZS5wb3MgKyA5IHx8XG4gICAgICAgIChuZXh0ICE9IDQ2ICYmIG5leHQgIT0gNDEgLyogJy4pJyAqLykgfHxcbiAgICAgICAgKHBvcyA8IGxpbmUudGV4dC5sZW5ndGggLSAxICYmICFzcGFjZShsaW5lLnRleHQuY2hhckNvZGVBdChwb3MgKyAxKSkpIHx8XG4gICAgICAgIGJyZWFraW5nICYmICFpbkxpc3QoY3gsIFR5cGUuT3JkZXJlZExpc3QpICYmXG4gICAgICAgICAgICAobGluZS5za2lwU3BhY2UocG9zICsgMSkgPT0gbGluZS50ZXh0Lmxlbmd0aCB8fCBwb3MgPiBsaW5lLnBvcyArIDEgfHwgbGluZS5uZXh0ICE9IDQ5IC8qICcxJyAqLykpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gcG9zICsgMSAtIGxpbmUucG9zO1xufVxuZnVuY3Rpb24gaXNBdHhIZWFkaW5nKGxpbmUpIHtcbiAgICBpZiAobGluZS5uZXh0ICE9IDM1IC8qICcjJyAqLylcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBwb3MgPSBsaW5lLnBvcyArIDE7XG4gICAgd2hpbGUgKHBvcyA8IGxpbmUudGV4dC5sZW5ndGggJiYgbGluZS50ZXh0LmNoYXJDb2RlQXQocG9zKSA9PSAzNSlcbiAgICAgICAgcG9zKys7XG4gICAgaWYgKHBvcyA8IGxpbmUudGV4dC5sZW5ndGggJiYgbGluZS50ZXh0LmNoYXJDb2RlQXQocG9zKSAhPSAzMilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBzaXplID0gcG9zIC0gbGluZS5wb3M7XG4gICAgcmV0dXJuIHNpemUgPiA2ID8gLTEgOiBzaXplO1xufVxuZnVuY3Rpb24gaXNTZXRleHRVbmRlcmxpbmUobGluZSkge1xuICAgIGlmIChsaW5lLm5leHQgIT0gNDUgJiYgbGluZS5uZXh0ICE9IDYxIC8qICctPScgKi8gfHwgbGluZS5pbmRlbnQgPj0gbGluZS5iYXNlSW5kZW50ICsgNClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBwb3MgPSBsaW5lLnBvcyArIDE7XG4gICAgd2hpbGUgKHBvcyA8IGxpbmUudGV4dC5sZW5ndGggJiYgbGluZS50ZXh0LmNoYXJDb2RlQXQocG9zKSA9PSBsaW5lLm5leHQpXG4gICAgICAgIHBvcysrO1xuICAgIGxldCBlbmQgPSBwb3M7XG4gICAgd2hpbGUgKHBvcyA8IGxpbmUudGV4dC5sZW5ndGggJiYgc3BhY2UobGluZS50ZXh0LmNoYXJDb2RlQXQocG9zKSkpXG4gICAgICAgIHBvcysrO1xuICAgIHJldHVybiBwb3MgPT0gbGluZS50ZXh0Lmxlbmd0aCA/IGVuZCA6IC0xO1xufVxuY29uc3QgRW1wdHlMaW5lID0gL15bIFxcdF0qJC8sIENvbW1lbnRFbmQgPSAvLS0+LywgUHJvY2Vzc2luZ0VuZCA9IC9cXD8+LztcbmNvbnN0IEhUTUxCbG9ja1N0eWxlID0gW1xuICAgIFsvXjwoPzpzY3JpcHR8cHJlfHN0eWxlKSg/Olxcc3w+fCQpL2ksIC88XFwvKD86c2NyaXB0fHByZXxzdHlsZSk+L2ldLFxuICAgIFsvXlxccyo8IS0tLywgQ29tbWVudEVuZF0sXG4gICAgWy9eXFxzKjxcXD8vLCBQcm9jZXNzaW5nRW5kXSxcbiAgICBbL15cXHMqPCFbQS1aXS8sIC8+L10sXG4gICAgWy9eXFxzKjwhXFxbQ0RBVEFcXFsvLCAvXFxdXFxdPi9dLFxuICAgIFsvXlxccyo8XFwvPyg/OmFkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9ufGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoMXxoMnxoM3xoNHxoNXxoNnxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZXxsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbnxwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHJ8dHJhY2t8dWwpKD86XFxzfFxcLz8+fCQpL2ksIEVtcHR5TGluZV0sXG4gICAgWy9eXFxzKig/OjxcXC9bYS16XVtcXHctXSpcXHMqPnw8W2Etel1bXFx3LV0qKFxccytbYS16Ol9dW1xcdy0uXSooPzpcXHMqPVxccyooPzpbXlxcc1wiJz08PmBdK3wnW14nXSonfFwiW15cIl0qXCIpKT8pKlxccyo+KVxccyokL2ksIEVtcHR5TGluZV1cbl07XG5mdW5jdGlvbiBpc0hUTUxCbG9jayhsaW5lLCBfY3gsIGJyZWFraW5nKSB7XG4gICAgaWYgKGxpbmUubmV4dCAhPSA2MCAvKiAnPCcgKi8pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgcmVzdCA9IGxpbmUudGV4dC5zbGljZShsaW5lLnBvcyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGUgPSBIVE1MQmxvY2tTdHlsZS5sZW5ndGggLSAoYnJlYWtpbmcgPyAxIDogMCk7IGkgPCBlOyBpKyspXG4gICAgICAgIGlmIChIVE1MQmxvY2tTdHlsZVtpXVswXS50ZXN0KHJlc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZ2V0TGlzdEluZGVudChsaW5lLCBwb3MpIHtcbiAgICBsZXQgaW5kZW50QWZ0ZXIgPSBsaW5lLmNvdW50SW5kZW50KHBvcywgbGluZS5wb3MsIGxpbmUuaW5kZW50KTtcbiAgICBsZXQgaW5kZW50ZWQgPSBsaW5lLmNvdW50SW5kZW50KGxpbmUuc2tpcFNwYWNlKHBvcyksIHBvcywgaW5kZW50QWZ0ZXIpO1xuICAgIHJldHVybiBpbmRlbnRlZCA+PSBpbmRlbnRBZnRlciArIDUgPyBpbmRlbnRBZnRlciArIDEgOiBpbmRlbnRlZDtcbn1cbmZ1bmN0aW9uIGFkZENvZGVUZXh0KG1hcmtzLCBmcm9tLCB0bykge1xuICAgIGxldCBsYXN0ID0gbWFya3MubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIG1hcmtzW2xhc3RdLnRvID09IGZyb20gJiYgbWFya3NbbGFzdF0udHlwZSA9PSBUeXBlLkNvZGVUZXh0KVxuICAgICAgICBtYXJrc1tsYXN0XS50byA9IHRvO1xuICAgIGVsc2VcbiAgICAgICAgbWFya3MucHVzaChlbHQoVHlwZS5Db2RlVGV4dCwgZnJvbSwgdG8pKTtcbn1cbi8vIFJ1bGVzIGZvciBwYXJzaW5nIGJsb2Nrcy4gQSByZXR1cm4gdmFsdWUgb2YgZmFsc2UgbWVhbnMgdGhlIHJ1bGVcbi8vIGRvZXNuJ3QgYXBwbHkgaGVyZSwgdHJ1ZSBtZWFucyBpdCBkb2VzLiBXaGVuIHRydWUgaXMgcmV0dXJuZWQgYW5kXG4vLyBgcC5saW5lYCBoYXMgYmVlbiB1cGRhdGVkLCB0aGUgcnVsZSBpcyBhc3N1bWVkIHRvIGhhdmUgY29uc3VtZWQgYVxuLy8gbGVhZiBibG9jay4gT3RoZXJ3aXNlLCBpdCBpcyBhc3N1bWVkIHRvIGhhdmUgb3BlbmVkIGEgY29udGV4dC5cbmNvbnN0IERlZmF1bHRCbG9ja1BhcnNlcnMgPSB7XG4gICAgTGlua1JlZmVyZW5jZTogdW5kZWZpbmVkLFxuICAgIEluZGVudGVkQ29kZShjeCwgbGluZSkge1xuICAgICAgICBsZXQgYmFzZSA9IGxpbmUuYmFzZUluZGVudCArIDQ7XG4gICAgICAgIGlmIChsaW5lLmluZGVudCA8IGJhc2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydCA9IGxpbmUuZmluZENvbHVtbihiYXNlKTtcbiAgICAgICAgbGV0IGZyb20gPSBjeC5saW5lU3RhcnQgKyBzdGFydCwgdG8gPSBjeC5saW5lU3RhcnQgKyBsaW5lLnRleHQubGVuZ3RoO1xuICAgICAgICBsZXQgbWFya3MgPSBbXSwgcGVuZGluZ01hcmtzID0gW107XG4gICAgICAgIGFkZENvZGVUZXh0KG1hcmtzLCBmcm9tLCB0byk7XG4gICAgICAgIHdoaWxlIChjeC5uZXh0TGluZSgpICYmIGxpbmUuZGVwdGggPj0gY3guc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobGluZS5wb3MgPT0gbGluZS50ZXh0Lmxlbmd0aCkgeyAvLyBFbXB0eVxuICAgICAgICAgICAgICAgIGFkZENvZGVUZXh0KHBlbmRpbmdNYXJrcywgY3gubGluZVN0YXJ0IC0gMSwgY3gubGluZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBtIG9mIGxpbmUubWFya2VycylcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ01hcmtzLnB1c2gobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLmluZGVudCA8IGJhc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG0gb2YgcGVuZGluZ01hcmtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobS50eXBlID09IFR5cGUuQ29kZVRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29kZVRleHQobWFya3MsIG0uZnJvbSwgbS50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya3MucHVzaChtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTWFya3MgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkQ29kZVRleHQobWFya3MsIGN4LmxpbmVTdGFydCAtIDEsIGN4LmxpbmVTdGFydCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbSBvZiBsaW5lLm1hcmtlcnMpXG4gICAgICAgICAgICAgICAgICAgIG1hcmtzLnB1c2gobSk7XG4gICAgICAgICAgICAgICAgdG8gPSBjeC5saW5lU3RhcnQgKyBsaW5lLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlU3RhcnQgPSBjeC5saW5lU3RhcnQgKyBsaW5lLmZpbmRDb2x1bW4obGluZS5iYXNlSW5kZW50ICsgNCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVTdGFydCA8IHRvKVxuICAgICAgICAgICAgICAgICAgICBhZGRDb2RlVGV4dChtYXJrcywgY29kZVN0YXJ0LCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlbmRpbmdNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBlbmRpbmdNYXJrcyA9IHBlbmRpbmdNYXJrcy5maWx0ZXIobSA9PiBtLnR5cGUgIT0gVHlwZS5Db2RlVGV4dCk7XG4gICAgICAgICAgICBpZiAocGVuZGluZ01hcmtzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBsaW5lLm1hcmtlcnMgPSBwZW5kaW5nTWFya3MuY29uY2F0KGxpbmUubWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgY3guYWRkTm9kZShjeC5idWZmZXIud3JpdGVFbGVtZW50cyhtYXJrcywgLWZyb20pLmZpbmlzaChUeXBlLkNvZGVCbG9jaywgdG8gLSBmcm9tKSwgZnJvbSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgRmVuY2VkQ29kZShjeCwgbGluZSkge1xuICAgICAgICBsZXQgZmVuY2VFbmQgPSBpc0ZlbmNlZENvZGUobGluZSk7XG4gICAgICAgIGlmIChmZW5jZUVuZCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBmcm9tID0gY3gubGluZVN0YXJ0ICsgbGluZS5wb3MsIGNoID0gbGluZS5uZXh0LCBsZW4gPSBmZW5jZUVuZCAtIGxpbmUucG9zO1xuICAgICAgICBsZXQgaW5mb0Zyb20gPSBsaW5lLnNraXBTcGFjZShmZW5jZUVuZCksIGluZm9UbyA9IHNraXBTcGFjZUJhY2sobGluZS50ZXh0LCBsaW5lLnRleHQubGVuZ3RoLCBpbmZvRnJvbSk7XG4gICAgICAgIGxldCBtYXJrcyA9IFtlbHQoVHlwZS5Db2RlTWFyaywgZnJvbSwgZnJvbSArIGxlbildO1xuICAgICAgICBpZiAoaW5mb0Zyb20gPCBpbmZvVG8pXG4gICAgICAgICAgICBtYXJrcy5wdXNoKGVsdChUeXBlLkNvZGVJbmZvLCBjeC5saW5lU3RhcnQgKyBpbmZvRnJvbSwgY3gubGluZVN0YXJ0ICsgaW5mb1RvKSk7XG4gICAgICAgIGZvciAobGV0IGZpcnN0ID0gdHJ1ZSwgZW1wdHkgPSB0cnVlLCBoYXNMaW5lID0gZmFsc2U7IGN4Lm5leHRMaW5lKCkgJiYgbGluZS5kZXB0aCA+PSBjeC5zdGFjay5sZW5ndGg7IGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxldCBpID0gbGluZS5wb3M7XG4gICAgICAgICAgICBpZiAobGluZS5pbmRlbnQgLSBsaW5lLmJhc2VJbmRlbnQgPCA0KVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBsaW5lLnRleHQuY2hhckNvZGVBdChpKSA9PSBjaClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGkgLSBsaW5lLnBvcyA+PSBsZW4gJiYgbGluZS5za2lwU3BhY2UoaSkgPT0gbGluZS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG0gb2YgbGluZS5tYXJrZXJzKVxuICAgICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eSAmJiBoYXNMaW5lKVxuICAgICAgICAgICAgICAgICAgICBhZGRDb2RlVGV4dChtYXJrcywgY3gubGluZVN0YXJ0IC0gMSwgY3gubGluZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKGVsdChUeXBlLkNvZGVNYXJrLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcywgY3gubGluZVN0YXJ0ICsgaSkpO1xuICAgICAgICAgICAgICAgIGN4Lm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYXNMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZENvZGVUZXh0KG1hcmtzLCBjeC5saW5lU3RhcnQgLSAxLCBjeC5saW5lU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBtIG9mIGxpbmUubWFya2VycylcbiAgICAgICAgICAgICAgICAgICAgbWFya3MucHVzaChtKTtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dFN0YXJ0ID0gY3gubGluZVN0YXJ0ICsgbGluZS5iYXNlUG9zLCB0ZXh0RW5kID0gY3gubGluZVN0YXJ0ICsgbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGV4dFN0YXJ0IDwgdGV4dEVuZCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRDb2RlVGV4dChtYXJrcywgdGV4dFN0YXJ0LCB0ZXh0RW5kKTtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3guYWRkTm9kZShjeC5idWZmZXIud3JpdGVFbGVtZW50cyhtYXJrcywgLWZyb20pXG4gICAgICAgICAgICAuZmluaXNoKFR5cGUuRmVuY2VkQ29kZSwgY3gucHJldkxpbmVFbmQoKSAtIGZyb20pLCBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBCbG9ja3F1b3RlKGN4LCBsaW5lKSB7XG4gICAgICAgIGxldCBzaXplID0gaXNCbG9ja3F1b3RlKGxpbmUpO1xuICAgICAgICBpZiAoc2l6ZSA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN4LnN0YXJ0Q29udGV4dChUeXBlLkJsb2NrcXVvdGUsIGxpbmUucG9zKTtcbiAgICAgICAgY3guYWRkTm9kZShUeXBlLlF1b3RlTWFyaywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MsIGN4LmxpbmVTdGFydCArIGxpbmUucG9zICsgMSk7XG4gICAgICAgIGxpbmUubW92ZUJhc2UobGluZS5wb3MgKyBzaXplKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBIb3Jpem9udGFsUnVsZShjeCwgbGluZSkge1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsUnVsZShsaW5lLCBjeCwgZmFsc2UpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGZyb20gPSBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcztcbiAgICAgICAgY3gubmV4dExpbmUoKTtcbiAgICAgICAgY3guYWRkTm9kZShUeXBlLkhvcml6b250YWxSdWxlLCBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBCdWxsZXRMaXN0KGN4LCBsaW5lKSB7XG4gICAgICAgIGxldCBzaXplID0gaXNCdWxsZXRMaXN0KGxpbmUsIGN4LCBmYWxzZSk7XG4gICAgICAgIGlmIChzaXplIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGN4LmJsb2NrLnR5cGUgIT0gVHlwZS5CdWxsZXRMaXN0KVxuICAgICAgICAgICAgY3guc3RhcnRDb250ZXh0KFR5cGUuQnVsbGV0TGlzdCwgbGluZS5iYXNlUG9zLCBsaW5lLm5leHQpO1xuICAgICAgICBsZXQgbmV3QmFzZSA9IGdldExpc3RJbmRlbnQobGluZSwgbGluZS5wb3MgKyAxKTtcbiAgICAgICAgY3guc3RhcnRDb250ZXh0KFR5cGUuTGlzdEl0ZW0sIGxpbmUuYmFzZVBvcywgbmV3QmFzZSAtIGxpbmUuYmFzZUluZGVudCk7XG4gICAgICAgIGN4LmFkZE5vZGUoVHlwZS5MaXN0TWFyaywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MsIGN4LmxpbmVTdGFydCArIGxpbmUucG9zICsgc2l6ZSk7XG4gICAgICAgIGxpbmUubW92ZUJhc2VDb2x1bW4obmV3QmFzZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgT3JkZXJlZExpc3QoY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IHNpemUgPSBpc09yZGVyZWRMaXN0KGxpbmUsIGN4LCBmYWxzZSk7XG4gICAgICAgIGlmIChzaXplIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGN4LmJsb2NrLnR5cGUgIT0gVHlwZS5PcmRlcmVkTGlzdClcbiAgICAgICAgICAgIGN4LnN0YXJ0Q29udGV4dChUeXBlLk9yZGVyZWRMaXN0LCBsaW5lLmJhc2VQb3MsIGxpbmUudGV4dC5jaGFyQ29kZUF0KGxpbmUucG9zICsgc2l6ZSAtIDEpKTtcbiAgICAgICAgbGV0IG5ld0Jhc2UgPSBnZXRMaXN0SW5kZW50KGxpbmUsIGxpbmUucG9zICsgc2l6ZSk7XG4gICAgICAgIGN4LnN0YXJ0Q29udGV4dChUeXBlLkxpc3RJdGVtLCBsaW5lLmJhc2VQb3MsIG5ld0Jhc2UgLSBsaW5lLmJhc2VJbmRlbnQpO1xuICAgICAgICBjeC5hZGROb2RlKFR5cGUuTGlzdE1hcmssIGN4LmxpbmVTdGFydCArIGxpbmUucG9zLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcyArIHNpemUpO1xuICAgICAgICBsaW5lLm1vdmVCYXNlQ29sdW1uKG5ld0Jhc2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIEFUWEhlYWRpbmcoY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IHNpemUgPSBpc0F0eEhlYWRpbmcobGluZSk7XG4gICAgICAgIGlmIChzaXplIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG9mZiA9IGxpbmUucG9zLCBmcm9tID0gY3gubGluZVN0YXJ0ICsgb2ZmO1xuICAgICAgICBsZXQgZW5kT2ZTcGFjZSA9IHNraXBTcGFjZUJhY2sobGluZS50ZXh0LCBsaW5lLnRleHQubGVuZ3RoLCBvZmYpLCBhZnRlciA9IGVuZE9mU3BhY2U7XG4gICAgICAgIHdoaWxlIChhZnRlciA+IG9mZiAmJiBsaW5lLnRleHQuY2hhckNvZGVBdChhZnRlciAtIDEpID09IGxpbmUubmV4dClcbiAgICAgICAgICAgIGFmdGVyLS07XG4gICAgICAgIGlmIChhZnRlciA9PSBlbmRPZlNwYWNlIHx8IGFmdGVyID09IG9mZiB8fCAhc3BhY2UobGluZS50ZXh0LmNoYXJDb2RlQXQoYWZ0ZXIgLSAxKSkpXG4gICAgICAgICAgICBhZnRlciA9IGxpbmUudGV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBidWYgPSBjeC5idWZmZXJcbiAgICAgICAgICAgIC53cml0ZShUeXBlLkhlYWRlck1hcmssIDAsIHNpemUpXG4gICAgICAgICAgICAud3JpdGVFbGVtZW50cyhjeC5wYXJzZXIucGFyc2VJbmxpbmUobGluZS50ZXh0LnNsaWNlKG9mZiArIHNpemUgKyAxLCBhZnRlciksIGZyb20gKyBzaXplICsgMSksIC1mcm9tKTtcbiAgICAgICAgaWYgKGFmdGVyIDwgbGluZS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIGJ1Zi53cml0ZShUeXBlLkhlYWRlck1hcmssIGFmdGVyIC0gb2ZmLCBlbmRPZlNwYWNlIC0gb2ZmKTtcbiAgICAgICAgbGV0IG5vZGUgPSBidWYuZmluaXNoKFR5cGUuQVRYSGVhZGluZzEgLSAxICsgc2l6ZSwgbGluZS50ZXh0Lmxlbmd0aCAtIG9mZik7XG4gICAgICAgIGN4Lm5leHRMaW5lKCk7XG4gICAgICAgIGN4LmFkZE5vZGUobm9kZSwgZnJvbSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgSFRNTEJsb2NrKGN4LCBsaW5lKSB7XG4gICAgICAgIGxldCB0eXBlID0gaXNIVE1MQmxvY2sobGluZSwgY3gsIGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGUgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZnJvbSA9IGN4LmxpbmVTdGFydCArIGxpbmUucG9zLCBlbmQgPSBIVE1MQmxvY2tTdHlsZVt0eXBlXVsxXTtcbiAgICAgICAgbGV0IG1hcmtzID0gW10sIHRyYWlsaW5nID0gZW5kICE9IEVtcHR5TGluZTtcbiAgICAgICAgd2hpbGUgKCFlbmQudGVzdChsaW5lLnRleHQpICYmIGN4Lm5leHRMaW5lKCkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLmRlcHRoIDwgY3guc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IG0gb2YgbGluZS5tYXJrZXJzKVxuICAgICAgICAgICAgICAgIG1hcmtzLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWlsaW5nKVxuICAgICAgICAgICAgY3gubmV4dExpbmUoKTtcbiAgICAgICAgbGV0IG5vZGVUeXBlID0gZW5kID09IENvbW1lbnRFbmQgPyBUeXBlLkNvbW1lbnRCbG9jayA6IGVuZCA9PSBQcm9jZXNzaW5nRW5kID8gVHlwZS5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb25CbG9jayA6IFR5cGUuSFRNTEJsb2NrO1xuICAgICAgICBsZXQgdG8gPSBjeC5wcmV2TGluZUVuZCgpO1xuICAgICAgICBjeC5hZGROb2RlKGN4LmJ1ZmZlci53cml0ZUVsZW1lbnRzKG1hcmtzLCAtZnJvbSkuZmluaXNoKG5vZGVUeXBlLCB0byAtIGZyb20pLCBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBTZXRleHRIZWFkaW5nOiB1bmRlZmluZWQgLy8gU3BlY2lmaWVzIHJlbGF0aXZlIHByZWNlZGVuY2UgZm9yIGJsb2NrLWNvbnRpbnVlIGZ1bmN0aW9uXG59O1xuLy8gVGhpcyBpbXBsZW1lbnRzIGEgc3RhdGUgbWFjaGluZSB0aGF0IGluY3JlbWVudGFsbHkgcGFyc2VzIGxpbmsgcmVmZXJlbmNlcy4gQXQgZWFjaFxuLy8gbmV4dCBsaW5lLCBpdCBsb29rcyBhaGVhZCB0byBzZWUgaWYgdGhlIGxpbmUgY29udGludWVzIHRoZSByZWZlcmVuY2Ugb3Igbm90LiBJZiBpdFxuLy8gZG9lc24ndCBhbmQgYSB2YWxpZCBsaW5rIGlzIGF2YWlsYWJsZSBlbmRpbmcgYmVmb3JlIHRoYXQgbGluZSwgaXQgZmluaXNoZXMgdGhhdC5cbi8vIFNpbWlsYXJseSwgb24gYGZpbmlzaGAgKHdoZW4gdGhlIGxlYWYgaXMgdGVybWluYXRlZCBieSBleHRlcm5hbCBjaXJjdW1zdGFuY2VzKSwgaXRcbi8vIGNyZWF0ZXMgYSBsaW5rIHJlZmVyZW5jZSBpZiB0aGVyZSdzIGEgdmFsaWQgcmVmZXJlbmNlIHVwIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuY2xhc3MgTGlua1JlZmVyZW5jZVBhcnNlciB7XG4gICAgY29uc3RydWN0b3IobGVhZikge1xuICAgICAgICB0aGlzLnN0YWdlID0gMCAvKiBSZWZTdGFnZS5TdGFydCAqLztcbiAgICAgICAgdGhpcy5lbHRzID0gW107XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5zdGFydCA9IGxlYWYuc3RhcnQ7XG4gICAgICAgIHRoaXMuYWR2YW5jZShsZWFmLmNvbnRlbnQpO1xuICAgIH1cbiAgICBuZXh0TGluZShjeCwgbGluZSwgbGVhZikge1xuICAgICAgICBpZiAodGhpcy5zdGFnZSA9PSAtMSAvKiBSZWZTdGFnZS5GYWlsZWQgKi8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjb250ZW50ID0gbGVhZi5jb250ZW50ICsgXCJcXG5cIiArIGxpbmUuc2NydWIoKTtcbiAgICAgICAgbGV0IGZpbmlzaCA9IHRoaXMuYWR2YW5jZShjb250ZW50KTtcbiAgICAgICAgaWYgKGZpbmlzaCA+IC0xICYmIGZpbmlzaCA8IGNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUoY3gsIGxlYWYsIGZpbmlzaCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmluaXNoKGN4LCBsZWFmKSB7XG4gICAgICAgIGlmICgodGhpcy5zdGFnZSA9PSAyIC8qIFJlZlN0YWdlLkxpbmsgKi8gfHwgdGhpcy5zdGFnZSA9PSAzIC8qIFJlZlN0YWdlLlRpdGxlICovKSAmJiBza2lwU3BhY2UobGVhZi5jb250ZW50LCB0aGlzLnBvcykgPT0gbGVhZi5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKGN4LCBsZWFmLCBsZWFmLmNvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb21wbGV0ZShjeCwgbGVhZiwgbGVuKSB7XG4gICAgICAgIGN4LmFkZExlYWZFbGVtZW50KGxlYWYsIGVsdChUeXBlLkxpbmtSZWZlcmVuY2UsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnQgKyBsZW4sIHRoaXMuZWx0cykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbmV4dFN0YWdlKGVsdCkge1xuICAgICAgICBpZiAoZWx0KSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGVsdC50byAtIHRoaXMuc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmVsdHMucHVzaChlbHQpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZSsrO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnN0YWdlID0gLTEgLyogUmVmU3RhZ2UuRmFpbGVkICovO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFkdmFuY2UoY29udGVudCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFnZSA9PSAtMSAvKiBSZWZTdGFnZS5GYWlsZWQgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YWdlID09IDAgLyogUmVmU3RhZ2UuU3RhcnQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubmV4dFN0YWdlKHBhcnNlTGlua0xhYmVsKGNvbnRlbnQsIHRoaXMucG9zLCB0aGlzLnN0YXJ0LCB0cnVlKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC5jaGFyQ29kZUF0KHRoaXMucG9zKSAhPSA1OCAvKiAnOicgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWdlID0gLTEgLyogUmVmU3RhZ2UuRmFpbGVkICovO1xuICAgICAgICAgICAgICAgIHRoaXMuZWx0cy5wdXNoKGVsdChUeXBlLkxpbmtNYXJrLCB0aGlzLnBvcyArIHRoaXMuc3RhcnQsIHRoaXMucG9zICsgdGhpcy5zdGFydCArIDEpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFnZSA9PSAxIC8qIFJlZlN0YWdlLkxhYmVsICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm5leHRTdGFnZShwYXJzZVVSTChjb250ZW50LCBza2lwU3BhY2UoY29udGVudCwgdGhpcy5wb3MpLCB0aGlzLnN0YXJ0KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhZ2UgPT0gMiAvKiBSZWZTdGFnZS5MaW5rICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNraXAgPSBza2lwU3BhY2UoY29udGVudCwgdGhpcy5wb3MpLCBlbmQgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID4gdGhpcy5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gcGFyc2VMaW5rVGl0bGUoY29udGVudCwgc2tpcCwgdGhpcy5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpdGxlRW5kID0gbGluZUVuZChjb250ZW50LCB0aXRsZS50byAtIHRoaXMuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpdGxlRW5kID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YWdlKHRpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0aXRsZUVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVuZClcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gbGluZUVuZChjb250ZW50LCB0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZCA+IDAgJiYgZW5kIDwgY29udGVudC5sZW5ndGggPyBlbmQgOiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBSZWZTdGFnZS5UaXRsZVxuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lRW5kKGNvbnRlbnQsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGxpbmVFbmQodGV4dCwgcG9zKSB7XG4gICAgZm9yICg7IHBvcyA8IHRleHQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICBsZXQgbmV4dCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAobmV4dCA9PSAxMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoIXNwYWNlKG5leHQpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuY2xhc3MgU2V0ZXh0SGVhZGluZ1BhcnNlciB7XG4gICAgbmV4dExpbmUoY3gsIGxpbmUsIGxlYWYpIHtcbiAgICAgICAgbGV0IHVuZGVybGluZSA9IGxpbmUuZGVwdGggPCBjeC5zdGFjay5sZW5ndGggPyAtMSA6IGlzU2V0ZXh0VW5kZXJsaW5lKGxpbmUpO1xuICAgICAgICBsZXQgbmV4dCA9IGxpbmUubmV4dDtcbiAgICAgICAgaWYgKHVuZGVybGluZSA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB1bmRlcmxpbmVNYXJrID0gZWx0KFR5cGUuSGVhZGVyTWFyaywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MsIGN4LmxpbmVTdGFydCArIHVuZGVybGluZSk7XG4gICAgICAgIGN4Lm5leHRMaW5lKCk7XG4gICAgICAgIGN4LmFkZExlYWZFbGVtZW50KGxlYWYsIGVsdChuZXh0ID09IDYxID8gVHlwZS5TZXRleHRIZWFkaW5nMSA6IFR5cGUuU2V0ZXh0SGVhZGluZzIsIGxlYWYuc3RhcnQsIGN4LnByZXZMaW5lRW5kKCksIFtcbiAgICAgICAgICAgIC4uLmN4LnBhcnNlci5wYXJzZUlubGluZShsZWFmLmNvbnRlbnQsIGxlYWYuc3RhcnQpLFxuICAgICAgICAgICAgdW5kZXJsaW5lTWFya1xuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBEZWZhdWx0TGVhZkJsb2NrcyA9IHtcbiAgICBMaW5rUmVmZXJlbmNlKF8sIGxlYWYpIHsgcmV0dXJuIGxlYWYuY29udGVudC5jaGFyQ29kZUF0KDApID09IDkxIC8qICdbJyAqLyA/IG5ldyBMaW5rUmVmZXJlbmNlUGFyc2VyKGxlYWYpIDogbnVsbDsgfSxcbiAgICBTZXRleHRIZWFkaW5nKCkgeyByZXR1cm4gbmV3IFNldGV4dEhlYWRpbmdQYXJzZXI7IH1cbn07XG5jb25zdCBEZWZhdWx0RW5kTGVhZiA9IFtcbiAgICAoXywgbGluZSkgPT4gaXNBdHhIZWFkaW5nKGxpbmUpID49IDAsXG4gICAgKF8sIGxpbmUpID0+IGlzRmVuY2VkQ29kZShsaW5lKSA+PSAwLFxuICAgIChfLCBsaW5lKSA9PiBpc0Jsb2NrcXVvdGUobGluZSkgPj0gMCxcbiAgICAocCwgbGluZSkgPT4gaXNCdWxsZXRMaXN0KGxpbmUsIHAsIHRydWUpID49IDAsXG4gICAgKHAsIGxpbmUpID0+IGlzT3JkZXJlZExpc3QobGluZSwgcCwgdHJ1ZSkgPj0gMCxcbiAgICAocCwgbGluZSkgPT4gaXNIb3Jpem9udGFsUnVsZShsaW5lLCBwLCB0cnVlKSA+PSAwLFxuICAgIChwLCBsaW5lKSA9PiBpc0hUTUxCbG9jayhsaW5lLCBwLCB0cnVlKSA+PSAwXG5dO1xuY29uc3Qgc2NhbkxpbmVSZXN1bHQgPSB7IHRleHQ6IFwiXCIsIGVuZDogMCB9O1xuLyoqXG5CbG9jay1sZXZlbCBwYXJzaW5nIGZ1bmN0aW9ucyBnZXQgYWNjZXNzIHRvIHRoaXMgY29udGV4dCBvYmplY3QuXG4qL1xuY2xhc3MgQmxvY2tDb250ZXh0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwYXJzZXIgY29uZmlndXJhdGlvbiB1c2VkLlxuICAgICovXG4gICAgcGFyc2VyLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlucHV0LCBmcmFnbWVudHMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmxpbmUgPSBuZXcgTGluZSgpO1xuICAgICAgICB0aGlzLmF0RW5kID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBGb3IgcmV1c2VkIG5vZGVzIG9uIGdhcHMsIHdlIGNhbid0IGRpcmVjdGx5IHB1dCB0aGUgb3JpZ2luYWxcbiAgICAgICAgbm9kZSBpbnRvIHRoZSB0cmVlLCBzaW5jZSB0aGF0IG1heSBiZSBiaWdnZXIgdGhhbiBpdHMgcGFyZW50LlxuICAgICAgICBXaGVuIHRoaXMgaGFwcGVucywgd2UgY3JlYXRlIGEgZHVtbXkgdHJlZSB0aGF0IGlzIHJlcGxhY2VkIGJ5XG4gICAgICAgIHRoZSBwcm9wZXIgbm9kZSBpbiBgaW5qZWN0R2Fwc2AgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucmV1c2VQbGFjZWhvbGRlcnMgPSBuZXcgTWFwO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgcmFuZ2UgaW5kZXggdGhhdCBhYnNvbHV0ZUxpbmVTdGFydCBwb2ludHMgaW50byBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZUkgPSAwO1xuICAgICAgICB0aGlzLnRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmFic29sdXRlTGluZVN0YXJ0ID0gdGhpcy5hYnNvbHV0ZUxpbmVFbmQgPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgdGhpcy5ibG9jayA9IENvbXBvc2l0ZUJsb2NrLmNyZWF0ZShUeXBlLkRvY3VtZW50LCAwLCB0aGlzLmxpbmVTdGFydCwgMCwgMCk7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbdGhpcy5ibG9ja107XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzLmxlbmd0aCA/IG5ldyBGcmFnbWVudEN1cnNvcihmcmFnbWVudHMsIGlucHV0KSA6IG51bGw7XG4gICAgICAgIHRoaXMucmVhZExpbmUoKTtcbiAgICB9XG4gICAgZ2V0IHBhcnNlZFBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQ7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBsZXQgeyBsaW5lIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBtYXJrSSA9IDA7Oykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbGluZS5kZXB0aCA8IHRoaXMuc3RhY2subGVuZ3RoID8gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobWFya0kgPCBsaW5lLm1hcmtlcnMubGVuZ3RoICYmICghbmV4dCB8fCBsaW5lLm1hcmtlcnNbbWFya0ldLmZyb20gPCBuZXh0LmVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmsgPSBsaW5lLm1hcmtlcnNbbWFya0krK107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTm9kZShtYXJrLnR5cGUsIG1hcmsuZnJvbSwgbWFyay50byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZS5wb3MgPCBsaW5lLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gRW1wdHkgbGluZVxuICAgICAgICAgICAgaWYgKCF0aGlzLm5leHRMaW5lKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzICYmIHRoaXMucmV1c2VGcmFnbWVudChsaW5lLmJhc2VQb3MpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHN0YXJ0OiBmb3IgKDs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMucGFyc2VyLmJsb2NrUGFyc2VycylcbiAgICAgICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdHlwZSh0aGlzLCBsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZS5mb3J3YXJkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZWFmID0gbmV3IExlYWZCbG9jayh0aGlzLmxpbmVTdGFydCArIGxpbmUucG9zLCBsaW5lLnRleHQuc2xpY2UobGluZS5wb3MpKTtcbiAgICAgICAgZm9yIChsZXQgcGFyc2Ugb2YgdGhpcy5wYXJzZXIubGVhZkJsb2NrUGFyc2VycylcbiAgICAgICAgICAgIGlmIChwYXJzZSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSBwYXJzZSh0aGlzLCBsZWFmKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyKVxuICAgICAgICAgICAgICAgICAgICBsZWFmLnBhcnNlcnMucHVzaChwYXJzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICBsaW5lczogd2hpbGUgKHRoaXMubmV4dExpbmUoKSkge1xuICAgICAgICAgICAgaWYgKGxpbmUucG9zID09IGxpbmUudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobGluZS5pbmRlbnQgPCBsaW5lLmJhc2VJbmRlbnQgKyA0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3RvcCBvZiB0aGlzLnBhcnNlci5lbmRMZWFmQmxvY2spXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKHRoaXMsIGxpbmUsIGxlYWYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgbGluZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBwYXJzZXIgb2YgbGVhZi5wYXJzZXJzKVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIubmV4dExpbmUodGhpcywgbGluZSwgbGVhZikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGVhZi5jb250ZW50ICs9IFwiXFxuXCIgKyBsaW5lLnNjcnViKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBtIG9mIGxpbmUubWFya2VycylcbiAgICAgICAgICAgICAgICBsZWFmLm1hcmtzLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5pc2hMZWFmKGxlYWYpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiB0aGlzLnN0b3BwZWRBdCA8IHBvcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgbW92ZSBzdG9wcGVkQXQgZm9yd2FyZFwiKTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIHJldXNlRnJhZ21lbnQoc3RhcnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdtZW50cy5tb3ZlVG8odGhpcy5hYnNvbHV0ZUxpbmVTdGFydCArIHN0YXJ0LCB0aGlzLmFic29sdXRlTGluZVN0YXJ0KSB8fFxuICAgICAgICAgICAgIXRoaXMuZnJhZ21lbnRzLm1hdGNoZXModGhpcy5ibG9jay5oYXNoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRha2VuID0gdGhpcy5mcmFnbWVudHMudGFrZU5vZGVzKHRoaXMpO1xuICAgICAgICBpZiAoIXRha2VuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmFic29sdXRlTGluZVN0YXJ0ICs9IHRha2VuO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRvUmVsYXRpdmUodGhpcy5hYnNvbHV0ZUxpbmVTdGFydCwgdGhpcy5yYW5nZXMpO1xuICAgICAgICB0aGlzLm1vdmVSYW5nZUkoKTtcbiAgICAgICAgaWYgKHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQgPCB0aGlzLnRvKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVTdGFydCsrO1xuICAgICAgICAgICAgdGhpcy5hYnNvbHV0ZUxpbmVTdGFydCsrO1xuICAgICAgICAgICAgdGhpcy5yZWFkTGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hdEVuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlYWRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgcGFyZW50IGJsb2NrcyBzdXJyb3VuZGluZyB0aGUgY3VycmVudCBibG9jay5cbiAgICAqL1xuICAgIGdldCBkZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHR5cGUgb2YgdGhlIHBhcmVudCBibG9jayBhdCB0aGUgZ2l2ZW4gZGVwdGguIFdoZW4gbm9cbiAgICBkZXB0aCBpcyBwYXNzZWQsIHJldHVybiB0aGUgdHlwZSBvZiB0aGUgaW5uZXJtb3N0IHBhcmVudC5cbiAgICAqL1xuICAgIHBhcmVudFR5cGUoZGVwdGggPSB0aGlzLmRlcHRoIC0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1t0aGlzLnN0YWNrW2RlcHRoXS50eXBlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBpbnB1dCBsaW5lLiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBieVxuICAgIChub24tY29tcG9zaXRlKSBbYmxvY2sgcGFyc2Vyc10oI0Jsb2NrUGFyc2VyLnBhcnNlKSB0aGF0IGNvbnN1bWVcbiAgICB0aGUgbGluZSBkaXJlY3RseSwgb3IgbGVhZiBibG9jayBwYXJzZXJcbiAgICBbYG5leHRMaW5lYF0oI0xlYWZCbG9ja1BhcnNlci5uZXh0TGluZSkgbWV0aG9kcyB3aGVuIHRoZXlcbiAgICBjb25zdW1lIHRoZSBjdXJyZW50IGxpbmUgKGFuZCByZXR1cm4gdHJ1ZSkuXG4gICAgKi9cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgKz0gdGhpcy5saW5lLnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5hYnNvbHV0ZUxpbmVFbmQgPj0gdGhpcy50bykge1xuICAgICAgICAgICAgdGhpcy5hYnNvbHV0ZUxpbmVTdGFydCA9IHRoaXMuYWJzb2x1dGVMaW5lRW5kO1xuICAgICAgICAgICAgdGhpcy5hdEVuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlYWRMaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVTdGFydCsrO1xuICAgICAgICAgICAgdGhpcy5hYnNvbHV0ZUxpbmVTdGFydCA9IHRoaXMuYWJzb2x1dGVMaW5lRW5kICsgMTtcbiAgICAgICAgICAgIHRoaXMubW92ZVJhbmdlSSgpO1xuICAgICAgICAgICAgdGhpcy5yZWFkTGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdGhlIHRleHQgb2YgdGhlIGxpbmUgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLCB3aXRob3V0XG4gICAgYWN0dWFsbHkgbW92aW5nIHRoZSBjb250ZXh0J3MgY3VycmVudCBsaW5lIGZvcndhcmQuXG4gICAgKi9cbiAgICBwZWVrTGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkxpbmUodGhpcy5hYnNvbHV0ZUxpbmVFbmQgKyAxKS50ZXh0O1xuICAgIH1cbiAgICBtb3ZlUmFuZ2VJKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5yYW5nZUkgPCB0aGlzLnJhbmdlcy5sZW5ndGggLSAxICYmIHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQgPj0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUldLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlSSsrO1xuICAgICAgICAgICAgdGhpcy5hYnNvbHV0ZUxpbmVTdGFydCA9IE1hdGgubWF4KHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQsIHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJXS5mcm9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICBDb2xsZWN0IHRoZSB0ZXh0IGZvciB0aGUgbmV4dCBsaW5lLlxuICAgICovXG4gICAgc2NhbkxpbmUoc3RhcnQpIHtcbiAgICAgICAgbGV0IHIgPSBzY2FuTGluZVJlc3VsdDtcbiAgICAgICAgci5lbmQgPSBzdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRoaXMudG8pIHtcbiAgICAgICAgICAgIHIudGV4dCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByLnRleHQgPSB0aGlzLmxpbmVDaHVua0F0KHN0YXJ0KTtcbiAgICAgICAgICAgIHIuZW5kICs9IHIudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0T2Zmc2V0ID0gdGhpcy5hYnNvbHV0ZUxpbmVTdGFydCwgcmFuZ2VJID0gdGhpcy5yYW5nZUk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMucmFuZ2VzW3JhbmdlSV0udG8gPCByLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZUkrKztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRGcm9tID0gdGhpcy5yYW5nZXNbcmFuZ2VJXS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxpbmVDaHVua0F0KG5leHRGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgci5lbmQgPSBuZXh0RnJvbSArIGFmdGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgci50ZXh0ID0gci50ZXh0LnNsaWNlKDAsIHRoaXMucmFuZ2VzW3JhbmdlSSAtIDFdLnRvIC0gdGV4dE9mZnNldCkgKyBhZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE9mZnNldCA9IHIuZW5kIC0gci50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgIFBvcHVsYXRlIHRoaXMubGluZSB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSBuZXh0IGxpbmUuIFNraXBcbiAgICBsZWFkaW5nIGNoYXJhY3RlcnMgY292ZXJlZCBieSBjb21wb3NpdGUgYmxvY2tzLlxuICAgICovXG4gICAgcmVhZExpbmUoKSB7XG4gICAgICAgIGxldCB7IGxpbmUgfSA9IHRoaXMsIHsgdGV4dCwgZW5kIH0gPSB0aGlzLnNjYW5MaW5lKHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQpO1xuICAgICAgICB0aGlzLmFic29sdXRlTGluZUVuZCA9IGVuZDtcbiAgICAgICAgbGluZS5yZXNldCh0ZXh0KTtcbiAgICAgICAgZm9yICg7IGxpbmUuZGVwdGggPCB0aGlzLnN0YWNrLmxlbmd0aDsgbGluZS5kZXB0aCsrKSB7XG4gICAgICAgICAgICBsZXQgY3ggPSB0aGlzLnN0YWNrW2xpbmUuZGVwdGhdLCBoYW5kbGVyID0gdGhpcy5wYXJzZXIuc2tpcENvbnRleHRNYXJrdXBbY3gudHlwZV07XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5oYW5kbGVkIGJsb2NrIGNvbnRleHQgXCIgKyBUeXBlW2N4LnR5cGVdKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRoaXMubGluZS5tYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcihjeCwgdGhpcywgbGluZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lLm1hcmtlcnMubGVuZ3RoID4gbWFya3MpXG4gICAgICAgICAgICAgICAgICAgIGN4LmVuZCA9IHRoaXMubGluZS5tYXJrZXJzW3RoaXMubGluZS5tYXJrZXJzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICAgICAgICAgIGxpbmUuZm9yd2FyZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZS5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGluZUNodW5rQXQocG9zKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5pbnB1dC5jaHVuayhwb3MpLCB0ZXh0O1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQubGluZUNodW5rcykge1xuICAgICAgICAgICAgbGV0IGVvbCA9IG5leHQuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgIHRleHQgPSBlb2wgPCAwID8gbmV4dCA6IG5leHQuc2xpY2UoMCwgZW9sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgPSBuZXh0ID09IFwiXFxuXCIgPyBcIlwiIDogbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zICsgdGV4dC5sZW5ndGggPiB0aGlzLnRvID8gdGV4dC5zbGljZSgwLCB0aGlzLnRvIC0gcG9zKSA6IHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHByZXZpb3VzIGxpbmUuXG4gICAgKi9cbiAgICBwcmV2TGluZUVuZCgpIHsgcmV0dXJuIHRoaXMuYXRFbmQgPyB0aGlzLmxpbmVTdGFydCA6IHRoaXMubGluZVN0YXJ0IC0gMTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhcnRDb250ZXh0KHR5cGUsIHN0YXJ0LCB2YWx1ZSA9IDApIHtcbiAgICAgICAgdGhpcy5ibG9jayA9IENvbXBvc2l0ZUJsb2NrLmNyZWF0ZSh0eXBlLCB2YWx1ZSwgdGhpcy5saW5lU3RhcnQgKyBzdGFydCwgdGhpcy5ibG9jay5oYXNoLCB0aGlzLmxpbmVTdGFydCArIHRoaXMubGluZS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmJsb2NrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgYSBjb21wb3NpdGUgYmxvY2suIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tIFtibG9ja1xuICAgIHBhcnNlciBmdW5jdGlvbnNdKCNCbG9ja1BhcnNlci5wYXJzZSkgdGhhdCByZXR1cm4gbnVsbC5cbiAgICAqL1xuICAgIHN0YXJ0Q29tcG9zaXRlKHR5cGUsIHN0YXJ0LCB2YWx1ZSA9IDApIHtcbiAgICAgICAgdGhpcy5zdGFydENvbnRleHQodGhpcy5wYXJzZXIuZ2V0Tm9kZVR5cGUodHlwZSksIHN0YXJ0LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkTm9kZShibG9jaywgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBibG9jayA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgYmxvY2sgPSBuZXcgVHJlZSh0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2Jsb2NrXSwgbm9uZSwgbm9uZSwgKHRvICE9PSBudWxsICYmIHRvICE9PSB2b2lkIDAgPyB0byA6IHRoaXMucHJldkxpbmVFbmQoKSkgLSBmcm9tKTtcbiAgICAgICAgdGhpcy5ibG9jay5hZGRDaGlsZChibG9jaywgZnJvbSAtIHRoaXMuYmxvY2suZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIGJsb2NrIGVsZW1lbnQuIENhbiBiZSBjYWxsZWQgYnkgW2Jsb2NrXG4gICAgcGFyc2Vyc10oI0Jsb2NrUGFyc2VyLnBhcnNlKS5cbiAgICAqL1xuICAgIGFkZEVsZW1lbnQoZWx0KSB7XG4gICAgICAgIHRoaXMuYmxvY2suYWRkQ2hpbGQoZWx0LnRvVHJlZSh0aGlzLnBhcnNlci5ub2RlU2V0KSwgZWx0LmZyb20gLSB0aGlzLmJsb2NrLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBibG9jayBlbGVtZW50IGZyb20gYSBbbGVhZiBwYXJzZXJdKCNMZWFmQmxvY2tQYXJzZXIpLiBUaGlzXG4gICAgbWFrZXMgc3VyZSBhbnkgZXh0cmEgY29tcG9zaXRlIGJsb2NrIG1hcmt1cCAoc3VjaCBhcyBibG9ja3F1b3RlXG4gICAgbWFya2VycykgaW5zaWRlIHRoZSBibG9jayBhcmUgYWxzbyBhZGRlZCB0byB0aGUgc3ludGF4IHRyZWUuXG4gICAgKi9cbiAgICBhZGRMZWFmRWxlbWVudChsZWFmLCBlbHQpIHtcbiAgICAgICAgdGhpcy5hZGROb2RlKHRoaXMuYnVmZmVyXG4gICAgICAgICAgICAud3JpdGVFbGVtZW50cyhpbmplY3RNYXJrcyhlbHQuY2hpbGRyZW4sIGxlYWYubWFya3MpLCAtZWx0LmZyb20pXG4gICAgICAgICAgICAuZmluaXNoKGVsdC50eXBlLCBlbHQudG8gLSBlbHQuZnJvbSksIGVsdC5mcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5pc2hDb250ZXh0KCkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB0b3AuYWRkQ2hpbGQoY3gudG9UcmVlKHRoaXMucGFyc2VyLm5vZGVTZXQpLCBjeC5mcm9tIC0gdG9wLmZyb20pO1xuICAgICAgICB0aGlzLmJsb2NrID0gdG9wO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENvbnRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkR2Fwcyh0aGlzLmJsb2NrLnRvVHJlZSh0aGlzLnBhcnNlci5ub2RlU2V0LCB0aGlzLmxpbmVTdGFydCkpO1xuICAgIH1cbiAgICBhZGRHYXBzKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLmxlbmd0aCA+IDEgP1xuICAgICAgICAgICAgaW5qZWN0R2Fwcyh0aGlzLnJhbmdlcywgMCwgdHJlZS50b3BOb2RlLCB0aGlzLnJhbmdlc1swXS5mcm9tLCB0aGlzLnJldXNlUGxhY2Vob2xkZXJzKSA6IHRyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluaXNoTGVhZihsZWFmKSB7XG4gICAgICAgIGZvciAobGV0IHBhcnNlciBvZiBsZWFmLnBhcnNlcnMpXG4gICAgICAgICAgICBpZiAocGFyc2VyLmZpbmlzaCh0aGlzLCBsZWFmKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBpbmxpbmUgPSBpbmplY3RNYXJrcyh0aGlzLnBhcnNlci5wYXJzZUlubGluZShsZWFmLmNvbnRlbnQsIGxlYWYuc3RhcnQpLCBsZWFmLm1hcmtzKTtcbiAgICAgICAgdGhpcy5hZGROb2RlKHRoaXMuYnVmZmVyXG4gICAgICAgICAgICAud3JpdGVFbGVtZW50cyhpbmxpbmUsIC1sZWFmLnN0YXJ0KVxuICAgICAgICAgICAgLmZpbmlzaChUeXBlLlBhcmFncmFwaCwgbGVhZi5jb250ZW50Lmxlbmd0aCksIGxlYWYuc3RhcnQpO1xuICAgIH1cbiAgICBlbHQodHlwZSwgZnJvbSwgdG8sIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGVsdCh0aGlzLnBhcnNlci5nZXROb2RlVHlwZSh0eXBlKSwgZnJvbSwgdG8sIGNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlRWxlbWVudCh0eXBlLCBmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgYnVmZmVyKCkgeyByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLnBhcnNlci5ub2RlU2V0KTsgfVxufVxuZnVuY3Rpb24gaW5qZWN0R2FwcyhyYW5nZXMsIHJhbmdlSSwgdHJlZSwgb2Zmc2V0LCBkdW1taWVzKSB7XG4gICAgbGV0IHJhbmdlRW5kID0gcmFuZ2VzW3JhbmdlSV0udG87XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdLCBzdGFydCA9IHRyZWUuZnJvbSArIG9mZnNldDtcbiAgICBmdW5jdGlvbiBtb3ZlUGFzdE5leHQodXB0bywgaW5jbHVzaXZlKSB7XG4gICAgICAgIHdoaWxlIChpbmNsdXNpdmUgPyB1cHRvID49IHJhbmdlRW5kIDogdXB0byA+IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHJhbmdlc1tyYW5nZUkgKyAxXS5mcm9tIC0gcmFuZ2VFbmQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICAgICAgICAgIHVwdG8gKz0gc2l6ZTtcbiAgICAgICAgICAgIHJhbmdlSSsrO1xuICAgICAgICAgICAgcmFuZ2VFbmQgPSByYW5nZXNbcmFuZ2VJXS50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBjaCA9IHRyZWUuZmlyc3RDaGlsZDsgY2g7IGNoID0gY2gubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbW92ZVBhc3ROZXh0KGNoLmZyb20gKyBvZmZzZXQsIHRydWUpO1xuICAgICAgICBsZXQgZnJvbSA9IGNoLmZyb20gKyBvZmZzZXQsIG5vZGUsIHJldXNlID0gZHVtbWllcy5nZXQoY2gudHJlZSk7XG4gICAgICAgIGlmIChyZXVzZSkge1xuICAgICAgICAgICAgbm9kZSA9IHJldXNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoLnRvICsgb2Zmc2V0ID4gcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBpbmplY3RHYXBzKHJhbmdlcywgcmFuZ2VJLCBjaCwgb2Zmc2V0LCBkdW1taWVzKTtcbiAgICAgICAgICAgIG1vdmVQYXN0TmV4dChjaC50byArIG9mZnNldCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IGNoLnRvVHJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBzdGFydCk7XG4gICAgfVxuICAgIG1vdmVQYXN0TmV4dCh0cmVlLnRvICsgb2Zmc2V0LCBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHRyZWUudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdHJlZS50byArIG9mZnNldCAtIHN0YXJ0LCB0cmVlLnRyZWUgPyB0cmVlLnRyZWUucHJvcFZhbHVlcyA6IHVuZGVmaW5lZCk7XG59XG4vKipcbkEgTWFya2Rvd24gcGFyc2VyIGNvbmZpZ3VyYXRpb24uXG4qL1xuY2xhc3MgTWFya2Rvd25QYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBhcnNlcidzIHN5bnRheCBbbm9kZVxuICAgIHR5cGVzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tb24uTm9kZVNldCkuXG4gICAgKi9cbiAgICBub2RlU2V0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJsb2NrUGFyc2VycywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsZWFmQmxvY2tQYXJzZXJzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJsb2NrTmFtZXMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW5kTGVhZkJsb2NrLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNraXBDb250ZXh0TWFya3VwLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlubGluZVBhcnNlcnMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5saW5lTmFtZXMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd3JhcHBlcnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbm9kZVNldDtcbiAgICAgICAgdGhpcy5ibG9ja1BhcnNlcnMgPSBibG9ja1BhcnNlcnM7XG4gICAgICAgIHRoaXMubGVhZkJsb2NrUGFyc2VycyA9IGxlYWZCbG9ja1BhcnNlcnM7XG4gICAgICAgIHRoaXMuYmxvY2tOYW1lcyA9IGJsb2NrTmFtZXM7XG4gICAgICAgIHRoaXMuZW5kTGVhZkJsb2NrID0gZW5kTGVhZkJsb2NrO1xuICAgICAgICB0aGlzLnNraXBDb250ZXh0TWFya3VwID0gc2tpcENvbnRleHRNYXJrdXA7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VycyA9IGlubGluZVBhcnNlcnM7XG4gICAgICAgIHRoaXMuaW5saW5lTmFtZXMgPSBpbmxpbmVOYW1lcztcbiAgICAgICAgdGhpcy53cmFwcGVycyA9IHdyYXBwZXJzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZVR5cGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgdCBvZiBub2RlU2V0LnR5cGVzKVxuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZXNbdC5uYW1lXSA9IHQuaWQ7XG4gICAgfVxuICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSBuZXcgQmxvY2tDb250ZXh0KHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZWNvbmZpZ3VyZSB0aGUgcGFyc2VyLlxuICAgICovXG4gICAgY29uZmlndXJlKHNwZWMpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHJlc29sdmVDb25maWcoc3BlYyk7XG4gICAgICAgIGlmICghY29uZmlnKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCB7IG5vZGVTZXQsIHNraXBDb250ZXh0TWFya3VwIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYmxvY2tQYXJzZXJzID0gdGhpcy5ibG9ja1BhcnNlcnMuc2xpY2UoKSwgbGVhZkJsb2NrUGFyc2VycyA9IHRoaXMubGVhZkJsb2NrUGFyc2Vycy5zbGljZSgpLCBibG9ja05hbWVzID0gdGhpcy5ibG9ja05hbWVzLnNsaWNlKCksIGlubGluZVBhcnNlcnMgPSB0aGlzLmlubGluZVBhcnNlcnMuc2xpY2UoKSwgaW5saW5lTmFtZXMgPSB0aGlzLmlubGluZU5hbWVzLnNsaWNlKCksIGVuZExlYWZCbG9jayA9IHRoaXMuZW5kTGVhZkJsb2NrLnNsaWNlKCksIHdyYXBwZXJzID0gdGhpcy53cmFwcGVycztcbiAgICAgICAgaWYgKG5vbkVtcHR5KGNvbmZpZy5kZWZpbmVOb2RlcykpIHtcbiAgICAgICAgICAgIHNraXBDb250ZXh0TWFya3VwID0gT2JqZWN0LmFzc2lnbih7fSwgc2tpcENvbnRleHRNYXJrdXApO1xuICAgICAgICAgICAgbGV0IG5vZGVUeXBlcyA9IG5vZGVTZXQudHlwZXMuc2xpY2UoKSwgc3R5bGVzO1xuICAgICAgICAgICAgZm9yIChsZXQgcyBvZiBjb25maWcuZGVmaW5lTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBuYW1lLCBibG9jaywgY29tcG9zaXRlLCBzdHlsZSB9ID0gdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IHsgbmFtZTogcyB9IDogcztcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGVzLnNvbWUodCA9PiB0Lm5hbWUgPT0gbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb3NpdGUpXG4gICAgICAgICAgICAgICAgICAgIHNraXBDb250ZXh0TWFya3VwW25vZGVUeXBlcy5sZW5ndGhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIChibCwgY3gsIGxpbmUpID0+IGNvbXBvc2l0ZShjeCwgbGluZSwgYmwudmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IG5vZGVUeXBlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gY29tcG9zaXRlID8gW1wiQmxvY2tcIiwgXCJCbG9ja0NvbnRleHRcIl0gOiAhYmxvY2sgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiBpZCA+PSBUeXBlLkFUWEhlYWRpbmcxICYmIGlkIDw9IFR5cGUuU2V0ZXh0SGVhZGluZzIgPyBbXCJCbG9ja1wiLCBcIkxlYWZCbG9ja1wiLCBcIkhlYWRpbmdcIl0gOiBbXCJCbG9ja1wiLCBcIkxlYWZCbG9ja1wiXTtcbiAgICAgICAgICAgICAgICBub2RlVHlwZXMucHVzaChOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGdyb3VwICYmIFtbTm9kZVByb3AuZ3JvdXAsIGdyb3VwXV1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSB8fCBzdHlsZSBpbnN0YW5jZW9mIFRhZylcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1tuYW1lXSA9IHN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlcywgc3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVTZXQgPSBuZXcgTm9kZVNldChub2RlVHlwZXMpO1xuICAgICAgICAgICAgaWYgKHN0eWxlcylcbiAgICAgICAgICAgICAgICBub2RlU2V0ID0gbm9kZVNldC5leHRlbmQoc3R5bGVUYWdzKHN0eWxlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub25FbXB0eShjb25maWcucHJvcHMpKVxuICAgICAgICAgICAgbm9kZVNldCA9IG5vZGVTZXQuZXh0ZW5kKC4uLmNvbmZpZy5wcm9wcyk7XG4gICAgICAgIGlmIChub25FbXB0eShjb25maWcucmVtb3ZlKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcm0gb2YgY29uZmlnLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgIGxldCBibG9jayA9IHRoaXMuYmxvY2tOYW1lcy5pbmRleE9mKHJtKSwgaW5saW5lID0gdGhpcy5pbmxpbmVOYW1lcy5pbmRleE9mKHJtKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tQYXJzZXJzW2Jsb2NrXSA9IGxlYWZCbG9ja1BhcnNlcnNbYmxvY2tdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChpbmxpbmUgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lUGFyc2Vyc1tpbmxpbmVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25FbXB0eShjb25maWcucGFyc2VCbG9jaykpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2YgY29uZmlnLnBhcnNlQmxvY2spIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBibG9ja05hbWVzLmluZGV4T2Yoc3BlYy5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja1BhcnNlcnNbZm91bmRdID0gc3BlYy5wYXJzZTtcbiAgICAgICAgICAgICAgICAgICAgbGVhZkJsb2NrUGFyc2Vyc1tmb3VuZF0gPSBzcGVjLmxlYWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gc3BlYy5iZWZvcmUgPyBmaW5kTmFtZShibG9ja05hbWVzLCBzcGVjLmJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3BlYy5hZnRlciA/IGZpbmROYW1lKGJsb2NrTmFtZXMsIHNwZWMuYWZ0ZXIpICsgMSA6IGJsb2NrTmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tQYXJzZXJzLnNwbGljZShwb3MsIDAsIHNwZWMucGFyc2UpO1xuICAgICAgICAgICAgICAgICAgICBsZWFmQmxvY2tQYXJzZXJzLnNwbGljZShwb3MsIDAsIHNwZWMubGVhZik7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTmFtZXMuc3BsaWNlKHBvcywgMCwgc3BlYy5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMuZW5kTGVhZilcbiAgICAgICAgICAgICAgICAgICAgZW5kTGVhZkJsb2NrLnB1c2goc3BlYy5lbmRMZWFmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRW1wdHkoY29uZmlnLnBhcnNlSW5saW5lKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBjb25maWcucGFyc2VJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBpbmxpbmVOYW1lcy5pbmRleE9mKHNwZWMubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lUGFyc2Vyc1tmb3VuZF0gPSBzcGVjLnBhcnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IHNwZWMuYmVmb3JlID8gZmluZE5hbWUoaW5saW5lTmFtZXMsIHNwZWMuYmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzcGVjLmFmdGVyID8gZmluZE5hbWUoaW5saW5lTmFtZXMsIHNwZWMuYWZ0ZXIpICsgMSA6IGlubGluZU5hbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlubGluZVBhcnNlcnMuc3BsaWNlKHBvcywgMCwgc3BlYy5wYXJzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlubGluZU5hbWVzLnNwbGljZShwb3MsIDAsIHNwZWMubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcud3JhcClcbiAgICAgICAgICAgIHdyYXBwZXJzID0gd3JhcHBlcnMuY29uY2F0KGNvbmZpZy53cmFwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrZG93blBhcnNlcihub2RlU2V0LCBibG9ja1BhcnNlcnMsIGxlYWZCbG9ja1BhcnNlcnMsIGJsb2NrTmFtZXMsIGVuZExlYWZCbG9jaywgc2tpcENvbnRleHRNYXJrdXAsIGlubGluZVBhcnNlcnMsIGlubGluZU5hbWVzLCB3cmFwcGVycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0Tm9kZVR5cGUobmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm5vZGVUeXBlc1tuYW1lXTtcbiAgICAgICAgaWYgKGZvdW5kID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5rbm93biBub2RlIHR5cGUgJyR7bmFtZX0nYCk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2UgdGhlIGdpdmVuIHBpZWNlIG9mIGlubGluZSB0ZXh0IGF0IHRoZSBnaXZlbiBvZmZzZXQsXG4gICAgcmV0dXJuaW5nIGFuIGFycmF5IG9mIFtgRWxlbWVudGBdKCNFbGVtZW50KSBvYmplY3RzIHJlcHJlc2VudGluZ1xuICAgIHRoZSBpbmxpbmUgY29udGVudC5cbiAgICAqL1xuICAgIHBhcnNlSW5saW5lKHRleHQsIG9mZnNldCkge1xuICAgICAgICBsZXQgY3ggPSBuZXcgSW5saW5lQ29udGV4dCh0aGlzLCB0ZXh0LCBvZmZzZXQpO1xuICAgICAgICBvdXRlcjogZm9yIChsZXQgcG9zID0gb2Zmc2V0OyBwb3MgPCBjeC5lbmQ7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN4LmNoYXIocG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRoaXMuaW5saW5lUGFyc2VycylcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRva2VuKGN4LCBuZXh0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN4LnJlc29sdmVNYXJrZXJzKDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vbkVtcHR5KGEpIHtcbiAgICByZXR1cm4gYSAhPSBudWxsICYmIGEubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDb25maWcoc3BlYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzcGVjKSlcbiAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgaWYgKHNwZWMubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBjb25mID0gcmVzb2x2ZUNvbmZpZyhzcGVjWzBdKTtcbiAgICBpZiAoc3BlYy5sZW5ndGggPT0gMSlcbiAgICAgICAgcmV0dXJuIGNvbmY7XG4gICAgbGV0IHJlc3QgPSByZXNvbHZlQ29uZmlnKHNwZWMuc2xpY2UoMSkpO1xuICAgIGlmICghcmVzdCB8fCAhY29uZilcbiAgICAgICAgcmV0dXJuIGNvbmYgfHwgcmVzdDtcbiAgICBsZXQgY29uYyA9IChhLCBiKSA9PiAoYSB8fCBub25lKS5jb25jYXQoYiB8fCBub25lKTtcbiAgICBsZXQgd3JhcEEgPSBjb25mLndyYXAsIHdyYXBCID0gcmVzdC53cmFwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiBjb25jKGNvbmYucHJvcHMsIHJlc3QucHJvcHMpLFxuICAgICAgICBkZWZpbmVOb2RlczogY29uYyhjb25mLmRlZmluZU5vZGVzLCByZXN0LmRlZmluZU5vZGVzKSxcbiAgICAgICAgcGFyc2VCbG9jazogY29uYyhjb25mLnBhcnNlQmxvY2ssIHJlc3QucGFyc2VCbG9jayksXG4gICAgICAgIHBhcnNlSW5saW5lOiBjb25jKGNvbmYucGFyc2VJbmxpbmUsIHJlc3QucGFyc2VJbmxpbmUpLFxuICAgICAgICByZW1vdmU6IGNvbmMoY29uZi5yZW1vdmUsIHJlc3QucmVtb3ZlKSxcbiAgICAgICAgd3JhcDogIXdyYXBBID8gd3JhcEIgOiAhd3JhcEIgPyB3cmFwQSA6XG4gICAgICAgICAgICAoaW5uZXIsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gd3JhcEEod3JhcEIoaW5uZXIsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyksIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcylcbiAgICB9O1xufVxuZnVuY3Rpb24gZmluZE5hbWUobmFtZXMsIG5hbWUpIHtcbiAgICBsZXQgZm91bmQgPSBuYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChmb3VuZCA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiBzcGVjaWZpZWQgcmVsYXRpdmUgdG8gdW5rbm93biBwYXJzZXIgJHtuYW1lfWApO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmxldCBub2RlVHlwZXMgPSBbTm9kZVR5cGUubm9uZV07XG5mb3IgKGxldCBpID0gMSwgbmFtZTsgbmFtZSA9IFR5cGVbaV07IGkrKykge1xuICAgIG5vZGVUeXBlc1tpXSA9IE5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgIGlkOiBpLFxuICAgICAgICBuYW1lLFxuICAgICAgICBwcm9wczogaSA+PSBUeXBlLkVzY2FwZSA/IFtdIDogW1tOb2RlUHJvcC5ncm91cCwgaSBpbiBEZWZhdWx0U2tpcE1hcmt1cCA/IFtcIkJsb2NrXCIsIFwiQmxvY2tDb250ZXh0XCJdIDogW1wiQmxvY2tcIiwgXCJMZWFmQmxvY2tcIl1dXSxcbiAgICAgICAgdG9wOiBuYW1lID09IFwiRG9jdW1lbnRcIlxuICAgIH0pO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuY2xhc3MgQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlU2V0KSB7XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5vZGVTZXQ7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuICAgIHdyaXRlKHR5cGUsIGZyb20sIHRvLCBjaGlsZHJlbiA9IDApIHtcbiAgICAgICAgdGhpcy5jb250ZW50LnB1c2godHlwZSwgZnJvbSwgdG8sIDQgKyBjaGlsZHJlbiAqIDQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd3JpdGVFbGVtZW50cyhlbHRzLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgZWx0cylcbiAgICAgICAgICAgIGUud3JpdGVUbyh0aGlzLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKHR5cGUsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gVHJlZS5idWlsZCh7XG4gICAgICAgICAgICBidWZmZXI6IHRoaXMuY29udGVudCxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMubm9kZVNldCxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5ub2RlcyxcbiAgICAgICAgICAgIHRvcElEOiB0eXBlLFxuICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuRWxlbWVudHMgYXJlIHVzZWQgdG8gY29tcG9zZSBzeW50YXggbm9kZXMgZHVyaW5nIHBhcnNpbmcuXG4qL1xuY2xhc3MgRWxlbWVudCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSdzXG4gICAgW2lkXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tb24uTm9kZVR5cGUuaWQpLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBub2RlLCBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgbm9kZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgbm9kZSdzIGNoaWxkIG5vZGVzIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hpbGRyZW4gPSBub25lKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdyaXRlVG8oYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0T2ZmID0gYnVmLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICBidWYud3JpdGVFbGVtZW50cyh0aGlzLmNoaWxkcmVuLCBvZmZzZXQpO1xuICAgICAgICBidWYuY29udGVudC5wdXNoKHRoaXMudHlwZSwgdGhpcy5mcm9tICsgb2Zmc2V0LCB0aGlzLnRvICsgb2Zmc2V0LCBidWYuY29udGVudC5sZW5ndGggKyA0IC0gc3RhcnRPZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvVHJlZShub2RlU2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKG5vZGVTZXQpLndyaXRlRWxlbWVudHModGhpcy5jaGlsZHJlbiwgLXRoaXMuZnJvbSkuZmluaXNoKHRoaXMudHlwZSwgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxufVxuY2xhc3MgVHJlZUVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHRyZWUsIGZyb20pIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy50cmVlLmxlbmd0aDsgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy50cmVlLnR5cGUuaWQ7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBub25lOyB9XG4gICAgd3JpdGVUbyhidWYsIG9mZnNldCkge1xuICAgICAgICBidWYubm9kZXMucHVzaCh0aGlzLnRyZWUpO1xuICAgICAgICBidWYuY29udGVudC5wdXNoKGJ1Zi5ub2Rlcy5sZW5ndGggLSAxLCB0aGlzLmZyb20gKyBvZmZzZXQsIHRoaXMudG8gKyBvZmZzZXQsIC0xKTtcbiAgICB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy50cmVlOyB9XG59XG5mdW5jdGlvbiBlbHQodHlwZSwgZnJvbSwgdG8sIGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50KHR5cGUsIGZyb20sIHRvLCBjaGlsZHJlbik7XG59XG5jb25zdCBFbXBoYXNpc1VuZGVyc2NvcmUgPSB7IHJlc29sdmU6IFwiRW1waGFzaXNcIiwgbWFyazogXCJFbXBoYXNpc01hcmtcIiB9O1xuY29uc3QgRW1waGFzaXNBc3RlcmlzayA9IHsgcmVzb2x2ZTogXCJFbXBoYXNpc1wiLCBtYXJrOiBcIkVtcGhhc2lzTWFya1wiIH07XG5jb25zdCBMaW5rU3RhcnQgPSB7fSwgSW1hZ2VTdGFydCA9IHt9O1xuY2xhc3MgSW5saW5lRGVsaW1pdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBmcm9tLCB0bywgc2lkZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgfVxufVxuY29uc3QgRXNjYXBhYmxlID0gXCIhXFxcIiMkJSYnKCkqKywtLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiO1xubGV0IFB1bmN0dWF0aW9uID0gL1shXCIjJCUmJygpKissXFwtLlxcLzo7PD0+P0BcXFtcXFxcXFxdXl9ge3x9flxceEExXFx1MjAxMC1cXHUyMDI3XS87XG50cnkge1xuICAgIFB1bmN0dWF0aW9uID0gbmV3IFJlZ0V4cChcIltcXFxccHtTfXxcXFxccHtQfV1cIiwgXCJ1XCIpO1xufVxuY2F0Y2ggKF8pIHsgfVxuY29uc3QgRGVmYXVsdElubGluZSA9IHtcbiAgICBFc2NhcGUoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ICE9IDkyIC8qICdcXFxcJyAqLyB8fCBzdGFydCA9PSBjeC5lbmQgLSAxKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgZXNjYXBlZCA9IGN4LmNoYXIoc3RhcnQgKyAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBFc2NhcGFibGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoRXNjYXBhYmxlLmNoYXJDb2RlQXQoaSkgPT0gZXNjYXBlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY3guYXBwZW5kKGVsdChUeXBlLkVzY2FwZSwgc3RhcnQsIHN0YXJ0ICsgMikpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICBFbnRpdHkoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ICE9IDM4IC8qICcmJyAqLylcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IG0gPSAvXig/OiNcXGQrfCN4W2EtZlxcZF0rfFxcdyspOy9pLmV4ZWMoY3guc2xpY2Uoc3RhcnQgKyAxLCBzdGFydCArIDMxKSk7XG4gICAgICAgIHJldHVybiBtID8gY3guYXBwZW5kKGVsdChUeXBlLkVudGl0eSwgc3RhcnQsIHN0YXJ0ICsgMSArIG1bMF0ubGVuZ3RoKSkgOiAtMTtcbiAgICB9LFxuICAgIElubGluZUNvZGUoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ICE9IDk2IC8qICdgJyAqLyB8fCBzdGFydCAmJiBjeC5jaGFyKHN0YXJ0IC0gMSkgPT0gOTYpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCBwb3MgPSBzdGFydCArIDE7XG4gICAgICAgIHdoaWxlIChwb3MgPCBjeC5lbmQgJiYgY3guY2hhcihwb3MpID09IDk2KVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIGxldCBzaXplID0gcG9zIC0gc3RhcnQsIGN1clNpemUgPSAwO1xuICAgICAgICBmb3IgKDsgcG9zIDwgY3guZW5kOyBwb3MrKykge1xuICAgICAgICAgICAgaWYgKGN4LmNoYXIocG9zKSA9PSA5Nikge1xuICAgICAgICAgICAgICAgIGN1clNpemUrKztcbiAgICAgICAgICAgICAgICBpZiAoY3VyU2l6ZSA9PSBzaXplICYmIGN4LmNoYXIocG9zICsgMSkgIT0gOTYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjeC5hcHBlbmQoZWx0KFR5cGUuSW5saW5lQ29kZSwgc3RhcnQsIHBvcyArIDEsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsdChUeXBlLkNvZGVNYXJrLCBzdGFydCwgc3RhcnQgKyBzaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsdChUeXBlLkNvZGVNYXJrLCBwb3MgKyAxIC0gc2l6ZSwgcG9zICsgMSlcbiAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyU2l6ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgSFRNTFRhZyhjeCwgbmV4dCwgc3RhcnQpIHtcbiAgICAgICAgaWYgKG5leHQgIT0gNjAgLyogJzwnICovIHx8IHN0YXJ0ID09IGN4LmVuZCAtIDEpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCBhZnRlciA9IGN4LnNsaWNlKHN0YXJ0ICsgMSwgY3guZW5kKTtcbiAgICAgICAgbGV0IHVybCA9IC9eKD86W2Etel1bLVxcdysuXSs6W15cXHM+XSt8W2EtelxcZC4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtelxcZF0oPzpbYS16XFxkLV17MCw2MX1bYS16XFxkXSk/KD86XFwuW2EtelxcZF0oPzpbYS16XFxkLV17MCw2MX1bYS16XFxkXSk/KSopPi9pLmV4ZWMoYWZ0ZXIpO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gY3guYXBwZW5kKGVsdChUeXBlLkF1dG9saW5rLCBzdGFydCwgc3RhcnQgKyAxICsgdXJsWzBdLmxlbmd0aCwgW1xuICAgICAgICAgICAgICAgIGVsdChUeXBlLkxpbmtNYXJrLCBzdGFydCwgc3RhcnQgKyAxKSxcbiAgICAgICAgICAgICAgICAvLyB1cmxbMF0gaW5jbHVkZXMgdGhlIGNsb3NpbmcgYnJhY2tldCwgc28gZXhjbHVkZSBpdCBmcm9tIHRoaXMgc2xpY2VcbiAgICAgICAgICAgICAgICBlbHQoVHlwZS5VUkwsIHN0YXJ0ICsgMSwgc3RhcnQgKyB1cmxbMF0ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBlbHQoVHlwZS5MaW5rTWFyaywgc3RhcnQgKyB1cmxbMF0ubGVuZ3RoLCBzdGFydCArIDEgKyB1cmxbMF0ubGVuZ3RoKVxuICAgICAgICAgICAgXSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb21tZW50ID0gL14hLS1bXj5dKD86LVteLV18W14tXSkqPy0tPi9pLmV4ZWMoYWZ0ZXIpO1xuICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgIHJldHVybiBjeC5hcHBlbmQoZWx0KFR5cGUuQ29tbWVudCwgc3RhcnQsIHN0YXJ0ICsgMSArIGNvbW1lbnRbMF0ubGVuZ3RoKSk7XG4gICAgICAgIGxldCBwcm9jSW5zdCA9IC9eXFw/W15dKj9cXD8+Ly5leGVjKGFmdGVyKTtcbiAgICAgICAgaWYgKHByb2NJbnN0KVxuICAgICAgICAgICAgcmV0dXJuIGN4LmFwcGVuZChlbHQoVHlwZS5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIHN0YXJ0LCBzdGFydCArIDEgKyBwcm9jSW5zdFswXS5sZW5ndGgpKTtcbiAgICAgICAgbGV0IG0gPSAvXig/OiFbQS1aXVteXSo/PnwhXFxbQ0RBVEFcXFtbXl0qP1xcXVxcXT58XFwvXFxzKlthLXpBLVpdW1xcdy1dKlxccyo+fFxccypbYS16QS1aXVtcXHctXSooXFxzK1thLXpBLVo6X11bXFx3LS46XSooPzpcXHMqPVxccyooPzpbXlxcc1wiJz08PmBdK3wnW14nXSonfFwiW15cIl0qXCIpKT8pKlxccyooXFwvXFxzKik/PikvLmV4ZWMoYWZ0ZXIpO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiBjeC5hcHBlbmQoZWx0KFR5cGUuSFRNTFRhZywgc3RhcnQsIHN0YXJ0ICsgMSArIG1bMF0ubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBFbXBoYXNpcyhjeCwgbmV4dCwgc3RhcnQpIHtcbiAgICAgICAgaWYgKG5leHQgIT0gOTUgJiYgbmV4dCAhPSA0MilcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0ICsgMTtcbiAgICAgICAgd2hpbGUgKGN4LmNoYXIocG9zKSA9PSBuZXh0KVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIGxldCBiZWZvcmUgPSBjeC5zbGljZShzdGFydCAtIDEsIHN0YXJ0KSwgYWZ0ZXIgPSBjeC5zbGljZShwb3MsIHBvcyArIDEpO1xuICAgICAgICBsZXQgcEJlZm9yZSA9IFB1bmN0dWF0aW9uLnRlc3QoYmVmb3JlKSwgcEFmdGVyID0gUHVuY3R1YXRpb24udGVzdChhZnRlcik7XG4gICAgICAgIGxldCBzQmVmb3JlID0gL1xcc3xeJC8udGVzdChiZWZvcmUpLCBzQWZ0ZXIgPSAvXFxzfF4kLy50ZXN0KGFmdGVyKTtcbiAgICAgICAgbGV0IGxlZnRGbGFua2luZyA9ICFzQWZ0ZXIgJiYgKCFwQWZ0ZXIgfHwgc0JlZm9yZSB8fCBwQmVmb3JlKTtcbiAgICAgICAgbGV0IHJpZ2h0RmxhbmtpbmcgPSAhc0JlZm9yZSAmJiAoIXBCZWZvcmUgfHwgc0FmdGVyIHx8IHBBZnRlcik7XG4gICAgICAgIGxldCBjYW5PcGVuID0gbGVmdEZsYW5raW5nICYmIChuZXh0ID09IDQyIHx8ICFyaWdodEZsYW5raW5nIHx8IHBCZWZvcmUpO1xuICAgICAgICBsZXQgY2FuQ2xvc2UgPSByaWdodEZsYW5raW5nICYmIChuZXh0ID09IDQyIHx8ICFsZWZ0RmxhbmtpbmcgfHwgcEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGN4LmFwcGVuZChuZXcgSW5saW5lRGVsaW1pdGVyKG5leHQgPT0gOTUgPyBFbXBoYXNpc1VuZGVyc2NvcmUgOiBFbXBoYXNpc0FzdGVyaXNrLCBzdGFydCwgcG9zLCAoY2FuT3BlbiA/IDEgLyogTWFyay5PcGVuICovIDogMCAvKiBNYXJrLk5vbmUgKi8pIHwgKGNhbkNsb3NlID8gMiAvKiBNYXJrLkNsb3NlICovIDogMCAvKiBNYXJrLk5vbmUgKi8pKSk7XG4gICAgfSxcbiAgICBIYXJkQnJlYWsoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ID09IDkyIC8qICdcXFxcJyAqLyAmJiBjeC5jaGFyKHN0YXJ0ICsgMSkgPT0gMTAgLyogJ1xcbicgKi8pXG4gICAgICAgICAgICByZXR1cm4gY3guYXBwZW5kKGVsdChUeXBlLkhhcmRCcmVhaywgc3RhcnQsIHN0YXJ0ICsgMikpO1xuICAgICAgICBpZiAobmV4dCA9PSAzMikge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChjeC5jaGFyKHBvcykgPT0gMzIpXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICBpZiAoY3guY2hhcihwb3MpID09IDEwICYmIHBvcyA+PSBzdGFydCArIDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN4LmFwcGVuZChlbHQoVHlwZS5IYXJkQnJlYWssIHN0YXJ0LCBwb3MgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgTGluayhjeCwgbmV4dCwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG5leHQgPT0gOTEgLyogJ1snICovID8gY3guYXBwZW5kKG5ldyBJbmxpbmVEZWxpbWl0ZXIoTGlua1N0YXJ0LCBzdGFydCwgc3RhcnQgKyAxLCAxIC8qIE1hcmsuT3BlbiAqLykpIDogLTE7XG4gICAgfSxcbiAgICBJbWFnZShjeCwgbmV4dCwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG5leHQgPT0gMzMgLyogJyEnICovICYmIGN4LmNoYXIoc3RhcnQgKyAxKSA9PSA5MSAvKiAnWycgKi9cbiAgICAgICAgICAgID8gY3guYXBwZW5kKG5ldyBJbmxpbmVEZWxpbWl0ZXIoSW1hZ2VTdGFydCwgc3RhcnQsIHN0YXJ0ICsgMiwgMSAvKiBNYXJrLk9wZW4gKi8pKSA6IC0xO1xuICAgIH0sXG4gICAgTGlua0VuZChjeCwgbmV4dCwgc3RhcnQpIHtcbiAgICAgICAgaWYgKG5leHQgIT0gOTMgLyogJ10nICovKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAvLyBTY2FubmluZyBiYWNrIHRvIHRoZSBuZXh0IGxpbmsvaW1hZ2Ugc3RhcnQgbWFya2VyXG4gICAgICAgIGZvciAobGV0IGkgPSBjeC5wYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBjeC5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgSW5saW5lRGVsaW1pdGVyICYmIChwYXJ0LnR5cGUgPT0gTGlua1N0YXJ0IHx8IHBhcnQudHlwZSA9PSBJbWFnZVN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgb25lIGhhcyBiZWVuIHNldCBpbnZhbGlkIChiZWNhdXNlIGl0IHdvdWxkIHByb2R1Y2VcbiAgICAgICAgICAgICAgICAvLyBhIG5lc3RlZCBsaW5rKSBvciB0aGVyZSdzIG5vIHZhbGlkIGxpbmsgaGVyZSBpZ25vcmUgYm90aC5cbiAgICAgICAgICAgICAgICBpZiAoIXBhcnQuc2lkZSB8fCBjeC5za2lwU3BhY2UocGFydC50bykgPT0gc3RhcnQgJiYgIS9bKFxcW10vLnRlc3QoY3guc2xpY2Uoc3RhcnQgKyAxLCBzdGFydCArIDIpKSkge1xuICAgICAgICAgICAgICAgICAgICBjeC5wYXJ0c1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIHRoZSBjb250ZW50IGFuZCByZXBsYWNlIHRoZSBlbnRpcmUgcmFuZ2UgaW5cbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBhcnRzIHdpdGggdGhlIGxpbmsvaW1hZ2Ugbm9kZS5cbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9IGN4LnRha2VDb250ZW50KGkpO1xuICAgICAgICAgICAgICAgIGxldCBsaW5rID0gY3gucGFydHNbaV0gPSBmaW5pc2hMaW5rKGN4LCBjb250ZW50LCBwYXJ0LnR5cGUgPT0gTGlua1N0YXJ0ID8gVHlwZS5MaW5rIDogVHlwZS5JbWFnZSwgcGFydC5mcm9tLCBzdGFydCArIDEpO1xuICAgICAgICAgICAgICAgIC8vIFNldCBhbnkgb3Blbi1saW5rIG1hcmtlcnMgYmVmb3JlIHRoaXMgbGluayB0byBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT0gTGlua1N0YXJ0KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSBjeC5wYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgSW5saW5lRGVsaW1pdGVyICYmIHAudHlwZSA9PSBMaW5rU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5zaWRlID0gMCAvKiBNYXJrLk5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGluay50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGZpbmlzaExpbmsoY3gsIGNvbnRlbnQsIHR5cGUsIHN0YXJ0LCBzdGFydFBvcykge1xuICAgIGxldCB7IHRleHQgfSA9IGN4LCBuZXh0ID0gY3guY2hhcihzdGFydFBvcyksIGVuZFBvcyA9IHN0YXJ0UG9zO1xuICAgIGNvbnRlbnQudW5zaGlmdChlbHQoVHlwZS5MaW5rTWFyaywgc3RhcnQsIHN0YXJ0ICsgKHR5cGUgPT0gVHlwZS5JbWFnZSA/IDIgOiAxKSkpO1xuICAgIGNvbnRlbnQucHVzaChlbHQoVHlwZS5MaW5rTWFyaywgc3RhcnRQb3MgLSAxLCBzdGFydFBvcykpO1xuICAgIGlmIChuZXh0ID09IDQwIC8qICcoJyAqLykge1xuICAgICAgICBsZXQgcG9zID0gY3guc2tpcFNwYWNlKHN0YXJ0UG9zICsgMSk7XG4gICAgICAgIGxldCBkZXN0ID0gcGFyc2VVUkwodGV4dCwgcG9zIC0gY3gub2Zmc2V0LCBjeC5vZmZzZXQpLCB0aXRsZTtcbiAgICAgICAgaWYgKGRlc3QpIHtcbiAgICAgICAgICAgIHBvcyA9IGN4LnNraXBTcGFjZShkZXN0LnRvKTtcbiAgICAgICAgICAgIC8vIFRoZSBkZXN0aW5hdGlvbiBhbmQgdGl0bGUgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZVxuICAgICAgICAgICAgaWYgKHBvcyAhPSBkZXN0LnRvKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBwYXJzZUxpbmtUaXRsZSh0ZXh0LCBwb3MgLSBjeC5vZmZzZXQsIGN4Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlKVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjeC5za2lwU3BhY2UodGl0bGUudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjeC5jaGFyKHBvcykgPT0gNDEgLyogJyknICovKSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goZWx0KFR5cGUuTGlua01hcmssIHN0YXJ0UG9zLCBzdGFydFBvcyArIDEpKTtcbiAgICAgICAgICAgIGVuZFBvcyA9IHBvcyArIDE7XG4gICAgICAgICAgICBpZiAoZGVzdClcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goZGVzdCk7XG4gICAgICAgICAgICBpZiAodGl0bGUpXG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHRpdGxlKTtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChlbHQoVHlwZS5MaW5rTWFyaywgcG9zLCBlbmRQb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChuZXh0ID09IDkxIC8qICdbJyAqLykge1xuICAgICAgICBsZXQgbGFiZWwgPSBwYXJzZUxpbmtMYWJlbCh0ZXh0LCBzdGFydFBvcyAtIGN4Lm9mZnNldCwgY3gub2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgIGVuZFBvcyA9IGxhYmVsLnRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHQodHlwZSwgc3RhcnQsIGVuZFBvcywgY29udGVudCk7XG59XG4vLyBUaGVzZSByZXR1cm4gYG51bGxgIHdoZW4gZmFsbGluZyBvZmYgdGhlIGVuZCBvZiB0aGUgaW5wdXQsIGBmYWxzZWBcbi8vIHdoZW4gcGFyc2luZyBmYWlscyBvdGhlcndpc2UgKGZvciB1c2UgaW4gdGhlIGluY3JlbWVudGFsIGxpbmtcbi8vIHJlZmVyZW5jZSBwYXJzZXIpLlxuZnVuY3Rpb24gcGFyc2VVUkwodGV4dCwgc3RhcnQsIG9mZnNldCkge1xuICAgIGxldCBuZXh0ID0gdGV4dC5jaGFyQ29kZUF0KHN0YXJ0KTtcbiAgICBpZiAobmV4dCA9PSA2MCAvKiAnPCcgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3RhcnQgKyAxOyBwb3MgPCB0ZXh0Lmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgICAgIGxldCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGNoID09IDYyIC8qICc+JyAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gZWx0KFR5cGUuVVJMLCBzdGFydCArIG9mZnNldCwgcG9zICsgMSArIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoY2ggPT0gNjAgfHwgY2ggPT0gMTAgLyogJzxcXG4nICovKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBkZXB0aCA9IDAsIHBvcyA9IHN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBlc2NhcGVkID0gZmFsc2U7IHBvcyA8IHRleHQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICAgICAgbGV0IGNoID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoc3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gNDAgLyogJygnICovKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09IDQxIC8qICcpJyAqLykge1xuICAgICAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PSA5MiAvKiAnXFxcXCcgKi8pIHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zID4gc3RhcnQgPyBlbHQoVHlwZS5VUkwsIHN0YXJ0ICsgb2Zmc2V0LCBwb3MgKyBvZmZzZXQpIDogcG9zID09IHRleHQubGVuZ3RoID8gbnVsbCA6IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlTGlua1RpdGxlKHRleHQsIHN0YXJ0LCBvZmZzZXQpIHtcbiAgICBsZXQgbmV4dCA9IHRleHQuY2hhckNvZGVBdChzdGFydCk7XG4gICAgaWYgKG5leHQgIT0gMzkgJiYgbmV4dCAhPSAzNCAmJiBuZXh0ICE9IDQwIC8qICdcIlxcJygnICovKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVuZCA9IG5leHQgPT0gNDAgPyA0MSA6IG5leHQ7XG4gICAgZm9yIChsZXQgcG9zID0gc3RhcnQgKyAxLCBlc2NhcGVkID0gZmFsc2U7IHBvcyA8IHRleHQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICBsZXQgY2ggPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGVzY2FwZWQpXG4gICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKGNoID09IGVuZClcbiAgICAgICAgICAgIHJldHVybiBlbHQoVHlwZS5MaW5rVGl0bGUsIHN0YXJ0ICsgb2Zmc2V0LCBwb3MgKyAxICsgb2Zmc2V0KTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT0gOTIgLyogJ1xcXFwnICovKVxuICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VMaW5rTGFiZWwodGV4dCwgc3RhcnQsIG9mZnNldCwgcmVxdWlyZU5vbldTKSB7XG4gICAgZm9yIChsZXQgZXNjYXBlZCA9IGZhbHNlLCBwb3MgPSBzdGFydCArIDEsIGVuZCA9IE1hdGgubWluKHRleHQubGVuZ3RoLCBwb3MgKyA5OTkpOyBwb3MgPCBlbmQ7IHBvcysrKSB7XG4gICAgICAgIGxldCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoZXNjYXBlZClcbiAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT0gOTMgLyogJ10nICovKVxuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVOb25XUyA/IGZhbHNlIDogZWx0KFR5cGUuTGlua0xhYmVsLCBzdGFydCArIG9mZnNldCwgcG9zICsgMSArIG9mZnNldCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVOb25XUyAmJiAhc3BhY2UoY2gpKVxuICAgICAgICAgICAgICAgIHJlcXVpcmVOb25XUyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNoID09IDkxIC8qICdbJyAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PSA5MiAvKiAnXFxcXCcgKi8pXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbklubGluZSBwYXJzaW5nIGZ1bmN0aW9ucyBnZXQgYWNjZXNzIHRvIHRoaXMgY29udGV4dCwgYW5kIHVzZSBpdCB0b1xucmVhZCB0aGUgY29udGVudCBhbmQgZW1pdCBzeW50YXggbm9kZXMuXG4qL1xuY2xhc3MgSW5saW5lQ29udGV4dCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHRoYXQgaXMgYmVpbmcgdXNlZC5cbiAgICAqL1xuICAgIHBhcnNlciwgXG4gICAgLyoqXG4gICAgVGhlIHRleHQgb2YgdGhpcyBpbmxpbmUgc2VjdGlvbi5cbiAgICAqL1xuICAgIHRleHQsIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBvZmZzZXQgb2YgdGhlIHNlY3Rpb24gaW4gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hhcmFjdGVyIGNvZGUgYXQgdGhlIGdpdmVuIChkb2N1bWVudC1yZWxhdGl2ZSlcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGNoYXIocG9zKSB7IHJldHVybiBwb3MgPj0gdGhpcy5lbmQgPyAtMSA6IHRoaXMudGV4dC5jaGFyQ29kZUF0KHBvcyAtIHRoaXMub2Zmc2V0KTsgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoaXMgaW5saW5lIHNlY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgR2V0IGEgc3Vic3RyaW5nIG9mIHRoaXMgaW5saW5lIHNlY3Rpb24uIEFnYWluIHVzZXNcbiAgICBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0bykgeyByZXR1cm4gdGhpcy50ZXh0LnNsaWNlKGZyb20gLSB0aGlzLm9mZnNldCwgdG8gLSB0aGlzLm9mZnNldCk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGVuZChlbHQpIHtcbiAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQudG87XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIFtkZWxpbWl0ZXJdKCNEZWxpbWl0ZXJUeXBlKSBhdCB0aGlzIGdpdmVuIHBvc2l0aW9uLiBgb3BlbmBcbiAgICBhbmQgYGNsb3NlYCBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgZGVsaW1pdGVyIGlzIG9wZW5pbmcsIGNsb3NpbmcsXG4gICAgb3IgYm90aC4gUmV0dXJucyB0aGUgZW5kIG9mIHRoZSBkZWxpbWl0ZXIsIGZvciBjb252ZW5pZW50XG4gICAgcmV0dXJuaW5nIGZyb20gW3BhcnNlIGZ1bmN0aW9uc10oI0lubGluZVBhcnNlci5wYXJzZSkuXG4gICAgKi9cbiAgICBhZGREZWxpbWl0ZXIodHlwZSwgZnJvbSwgdG8sIG9wZW4sIGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZChuZXcgSW5saW5lRGVsaW1pdGVyKHR5cGUsIGZyb20sIHRvLCAob3BlbiA/IDEgLyogTWFyay5PcGVuICovIDogMCAvKiBNYXJrLk5vbmUgKi8pIHwgKGNsb3NlID8gMiAvKiBNYXJrLkNsb3NlICovIDogMCAvKiBNYXJrLk5vbmUgKi8pKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZXJlIGlzIGFuIHVubWF0Y2hlZCBsaW5rIG9yIGltYWdlIG9wZW5pbmdcbiAgICB0b2tlbiBiZWZvcmUgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgaGFzT3BlbkxpbmsoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcGFydCA9IHRoaXMucGFydHNbaV07XG4gICAgICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIElubGluZURlbGltaXRlciAmJiAocGFydC50eXBlID09IExpbmtTdGFydCB8fCBwYXJ0LnR5cGUgPT0gSW1hZ2VTdGFydCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYW4gaW5saW5lIGVsZW1lbnQuIFJldHVybnMgdGhlIGVuZCBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGFkZEVsZW1lbnQoZWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZChlbHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNvbHZlIG1hcmtlcnMgYmV0d2VlbiB0aGlzLnBhcnRzLmxlbmd0aCBhbmQgZnJvbSwgd3JhcHBpbmcgbWF0Y2hlZCBtYXJrZXJzIGluIHRoZVxuICAgIGFwcHJvcHJpYXRlIG5vZGUgYW5kIHVwZGF0aW5nIHRoZSBjb250ZW50IG9mIHRoaXMucGFydHMuIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZU1hcmtlcnMoZnJvbSkge1xuICAgICAgICAvLyBTY2FuIGZvcndhcmQsIGxvb2tpbmcgZm9yIGNsb3NpbmcgdG9rZW5zXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdGhpcy5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNsb3NlID0gdGhpcy5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmICghKGNsb3NlIGluc3RhbmNlb2YgSW5saW5lRGVsaW1pdGVyICYmIGNsb3NlLnR5cGUucmVzb2x2ZSAmJiAoY2xvc2Uuc2lkZSAmIDIgLyogTWFyay5DbG9zZSAqLykpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGVtcCA9IGNsb3NlLnR5cGUgPT0gRW1waGFzaXNVbmRlcnNjb3JlIHx8IGNsb3NlLnR5cGUgPT0gRW1waGFzaXNBc3RlcmlzaztcbiAgICAgICAgICAgIGxldCBjbG9zZVNpemUgPSBjbG9zZS50byAtIGNsb3NlLmZyb207XG4gICAgICAgICAgICBsZXQgb3BlbiwgaiA9IGkgLSAxO1xuICAgICAgICAgICAgLy8gQ29udGludWUgc2Nhbm5pbmcgZm9yIGEgbWF0Y2hpbmcgb3BlbmluZyB0b2tlblxuICAgICAgICAgICAgZm9yICg7IGogPj0gZnJvbTsgai0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnQgPSB0aGlzLnBhcnRzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgSW5saW5lRGVsaW1pdGVyICYmIChwYXJ0LnNpZGUgJiAxIC8qIE1hcmsuT3BlbiAqLykgJiYgcGFydC50eXBlID09IGNsb3NlLnR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVtcGhhc2lzIGRlbGltaXRlcnMgd2hlcmUgdGhlIGNoYXJhY3RlciBjb3VudCBkb2Vzbid0IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICEoZW1wICYmICgoY2xvc2Uuc2lkZSAmIDEgLyogTWFyay5PcGVuICovKSB8fCAocGFydC5zaWRlICYgMiAvKiBNYXJrLkNsb3NlICovKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXJ0LnRvIC0gcGFydC5mcm9tICsgY2xvc2VTaXplKSAlIDMgPT0gMCAmJiAoKHBhcnQudG8gLSBwYXJ0LmZyb20pICUgMyB8fCBjbG9zZVNpemUgJSAzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbiA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3BlbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gY2xvc2UudHlwZS5yZXNvbHZlLCBjb250ZW50ID0gW107XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBvcGVuLmZyb20sIGVuZCA9IGNsb3NlLnRvO1xuICAgICAgICAgICAgLy8gRW1waGFzaXMgbWFya2VyIGVmZmVjdCBkZXBlbmRzIG9uIHRoZSBjaGFyYWN0ZXIgY291bnQuIFNpemUgY29uc3VtZWQgaXMgbWluaW11bSBvZiB0aGUgdHdvXG4gICAgICAgICAgICAvLyBtYXJrZXJzLlxuICAgICAgICAgICAgaWYgKGVtcCkge1xuICAgICAgICAgICAgICAgIGxldCBzaXplID0gTWF0aC5taW4oMiwgb3Blbi50byAtIG9wZW4uZnJvbSwgY2xvc2VTaXplKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IG9wZW4udG8gLSBzaXplO1xuICAgICAgICAgICAgICAgIGVuZCA9IGNsb3NlLmZyb20gKyBzaXplO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBzaXplID09IDEgPyBcIkVtcGhhc2lzXCIgOiBcIlN0cm9uZ0VtcGhhc2lzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBjb3ZlcmVkIHJlZ2lvbiBpbnRvIGNvbnRlbnQsIG9wdGlvbmFsbHkgYWRkaW5nIG1hcmtlciBub2Rlc1xuICAgICAgICAgICAgaWYgKG9wZW4udHlwZS5tYXJrKVxuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh0aGlzLmVsdChvcGVuLnR5cGUubWFyaywgc3RhcnQsIG9wZW4udG8pKTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBqICsgMTsgayA8IGk7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcnRzW2tdIGluc3RhbmNlb2YgRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHRoaXMucGFydHNba10pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydHNba10gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsb3NlLnR5cGUubWFyaylcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2godGhpcy5lbHQoY2xvc2UudHlwZS5tYXJrLCBjbG9zZS5mcm9tLCBlbmQpKTtcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gdGhpcy5lbHQodHlwZSwgc3RhcnQsIGVuZCwgY29udGVudCk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbGVmdG92ZXIgZW1waGFzaXMgbWFya2VyIGNoYXJhY3RlcnMsIHNocmluayB0aGUgY2xvc2Uvb3BlbiBtYXJrZXJzLiBPdGhlcndpc2UsIGNsZWFyIHRoZW0uXG4gICAgICAgICAgICB0aGlzLnBhcnRzW2pdID0gZW1wICYmIG9wZW4uZnJvbSAhPSBzdGFydCA/IG5ldyBJbmxpbmVEZWxpbWl0ZXIob3Blbi50eXBlLCBvcGVuLmZyb20sIHN0YXJ0LCBvcGVuLnNpZGUpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBrZWVwID0gdGhpcy5wYXJ0c1tpXSA9IGVtcCAmJiBjbG9zZS50byAhPSBlbmQgPyBuZXcgSW5saW5lRGVsaW1pdGVyKGNsb3NlLnR5cGUsIGVuZCwgY2xvc2UudG8sIGNsb3NlLnNpZGUpIDogbnVsbDtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbmV3IGVsZW1lbnQgaW4gdGhpcy5wYXJ0c1xuICAgICAgICAgICAgaWYgKGtlZXApXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5zcGxpY2UoaSwgMCwgZWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0c1tpXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29sbGVjdCB0aGUgZWxlbWVudHMgcmVtYWluaW5nIGluIHRoaXMucGFydHMgaW50byBhbiBhcnJheS5cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRoaXMucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gdGhpcy5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgRWxlbWVudClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGFuIG9wZW5pbmcgZGVsaW1pdGVyIG9mIHRoZSBnaXZlbiB0eXBlLiBSZXR1cm5zIGBudWxsYCBpZlxuICAgIG5vIGRlbGltaXRlciBpcyBmb3VuZCwgb3IgYW4gaW5kZXggdGhhdCBjYW4gYmUgcGFzc2VkIHRvXG4gICAgW2B0YWtlQ29udGVudGBdKCNJbmxpbmVDb250ZXh0LnRha2VDb250ZW50KSBvdGhlcndpc2UuXG4gICAgKi9cbiAgICBmaW5kT3BlbmluZ0RlbGltaXRlcih0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcGFydCA9IHRoaXMucGFydHNbaV07XG4gICAgICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIElubGluZURlbGltaXRlciAmJiBwYXJ0LnR5cGUgPT0gdHlwZSAmJiAocGFydC5zaWRlICYgMSAvKiBNYXJrLk9wZW4gKi8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgYWxsIGlubGluZSBlbGVtZW50cyBhbmQgZGVsaW1pdGVycyBzdGFydGluZyBmcm9tIHRoZVxuICAgIGdpdmVuIGluZGV4ICh3aGljaCB5b3Ugc2hvdWxkIGdldCBmcm9tXG4gICAgW2BmaW5kT3BlbmluZ0RlbGltaXRlcmBdKCNJbmxpbmVDb250ZXh0LmZpbmRPcGVuaW5nRGVsaW1pdGVyKSxcbiAgICByZXNvbHZlIGRlbGltaXRlcnMgaW5zaWRlIG9mIHRoZW0sIGFuZCByZXR1cm4gdGhlbSBhcyBhbiBhcnJheVxuICAgIG9mIGVsZW1lbnRzLlxuICAgICovXG4gICAgdGFrZUNvbnRlbnQoc3RhcnRJbmRleCkge1xuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMucmVzb2x2ZU1hcmtlcnMoc3RhcnRJbmRleCk7XG4gICAgICAgIHRoaXMucGFydHMubGVuZ3RoID0gc3RhcnRJbmRleDtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZGVsaW1pdGVyIGF0IHRoZSBnaXZlbiBpbmRleC4gTW9zdGx5IHVzZWZ1bCB0byBnZXRcbiAgICBhZGRpdGlvbmFsIGluZm8gb3V0IG9mIGEgZGVsaW1pdGVyIGluZGV4IHJldHVybmVkIGJ5XG4gICAgW2BmaW5kT3BlbmluZ0RlbGltaXRlcmBdKCNJbmxpbmVDb250ZXh0LmZpbmRPcGVuaW5nRGVsaW1pdGVyKS5cbiAgICBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gZGVsaW1pdGVyIGF0IHRoaXMgaW5kZXguXG4gICAgKi9cbiAgICBnZXREZWxpbWl0ZXJBdChpbmRleCkge1xuICAgICAgICBsZXQgcGFydCA9IHRoaXMucGFydHNbaW5kZXhdO1xuICAgICAgICByZXR1cm4gcGFydCBpbnN0YW5jZW9mIElubGluZURlbGltaXRlciA/IHBhcnQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBTa2lwIHNwYWNlIGFmdGVyIHRoZSBnaXZlbiAoZG9jdW1lbnQpIHBvc2l0aW9uLCByZXR1cm5pbmcgZWl0aGVyXG4gICAgdGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IG5vbi1zcGFjZSBjaGFyYWN0ZXIgb3IgdGhlIGVuZCBvZiB0aGVcbiAgICBzZWN0aW9uLlxuICAgICovXG4gICAgc2tpcFNwYWNlKGZyb20pIHsgcmV0dXJuIHNraXBTcGFjZSh0aGlzLnRleHQsIGZyb20gLSB0aGlzLm9mZnNldCkgKyB0aGlzLm9mZnNldDsgfVxuICAgIGVsdCh0eXBlLCBmcm9tLCB0bywgY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gZWx0KHRoaXMucGFyc2VyLmdldE5vZGVUeXBlKHR5cGUpLCBmcm9tLCB0bywgY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVFbGVtZW50KHR5cGUsIGZyb20pO1xuICAgIH1cbn1cbi8qKlxuVGhlIG9wZW5pbmcgZGVsaW1pdGVyIHR5cGUgdXNlZCBieSB0aGUgc3RhbmRhcmQgbGluayBwYXJzZXIuXG4qL1xuSW5saW5lQ29udGV4dC5saW5rU3RhcnQgPSBMaW5rU3RhcnQ7XG4vKipcbk9wZW5pbmcgZGVsaW1pdGVyIHR5cGUgdXNlZCBmb3Igc3RhbmRhcmQgaW1hZ2VzLlxuKi9cbklubGluZUNvbnRleHQuaW1hZ2VTdGFydCA9IEltYWdlU3RhcnQ7XG5mdW5jdGlvbiBpbmplY3RNYXJrcyhlbGVtZW50cywgbWFya3MpIHtcbiAgICBpZiAoIW1hcmtzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIGlmICghZWxlbWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgbGV0IGVsdHMgPSBlbGVtZW50cy5zbGljZSgpLCBlSSA9IDA7XG4gICAgZm9yIChsZXQgbWFyayBvZiBtYXJrcykge1xuICAgICAgICB3aGlsZSAoZUkgPCBlbHRzLmxlbmd0aCAmJiBlbHRzW2VJXS50byA8IG1hcmsudG8pXG4gICAgICAgICAgICBlSSsrO1xuICAgICAgICBpZiAoZUkgPCBlbHRzLmxlbmd0aCAmJiBlbHRzW2VJXS5mcm9tIDwgbWFyay5mcm9tKSB7XG4gICAgICAgICAgICBsZXQgZSA9IGVsdHNbZUldO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFbGVtZW50KVxuICAgICAgICAgICAgICAgIGVsdHNbZUldID0gbmV3IEVsZW1lbnQoZS50eXBlLCBlLmZyb20sIGUudG8sIGluamVjdE1hcmtzKGUuY2hpbGRyZW4sIFttYXJrXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0cy5zcGxpY2UoZUkrKywgMCwgbWFyayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsdHM7XG59XG4vLyBUaGVzZSBhcmUgYmxvY2tzIHRoYXQgY2FuIHNwYW4gYmxhbmsgbGluZXMsIGFuZCBzaG91bGQgdGh1cyBvbmx5IGJlXG4vLyByZXVzZWQgaWYgdGhlaXIgbmV4dCBzaWJsaW5nIGlzIGFsc28gYmVpbmcgcmV1c2VkLlxuY29uc3QgTm90TGFzdCA9IFtUeXBlLkNvZGVCbG9jaywgVHlwZS5MaXN0SXRlbSwgVHlwZS5PcmRlcmVkTGlzdCwgVHlwZS5CdWxsZXRMaXN0XTtcbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMsIGlucHV0KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIC8vIEluZGV4IGludG8gZnJhZ21lbnQgYXJyYXlcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgLy8gQWN0aXZlIGZyYWdtZW50XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYWdtZW50RW5kID0gLTE7XG4gICAgICAgIC8vIEN1cnNvciBpbnRvIHRoZSBjdXJyZW50IGZyYWdtZW50LCBpZiBhbnkuIFdoZW4gYG1vdmVUb2AgcmV0dXJuc1xuICAgICAgICAvLyB0cnVlLCB0aGlzIHBvaW50cyBhdCB0aGUgZmlyc3QgYmxvY2sgYWZ0ZXIgYHBvc2AuXG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgaWYgKGZyYWdtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gdGhpcy5pIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gdGhpcy5mcmFnbWVudHNbdGhpcy5pKytdIDogbnVsbDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYWdtZW50RW5kID0gLTE7XG4gICAgfVxuICAgIG1vdmVUbyhwb3MsIGxpbmVTdGFydCkge1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLmZyYWdtZW50LnRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudCB8fCB0aGlzLmZyYWdtZW50LmZyb20gPiAocG9zID8gcG9zIC0gMSA6IDApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudEVuZCA8IDApIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLmZyYWdtZW50LnRvO1xuICAgICAgICAgICAgd2hpbGUgKGVuZCA+IDAgJiYgdGhpcy5pbnB1dC5yZWFkKGVuZCAtIDEsIGVuZCkgIT0gXCJcXG5cIilcbiAgICAgICAgICAgICAgICBlbmQtLTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRFbmQgPSBlbmQgPyBlbmQgLSAxIDogMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYyA9IHRoaXMuY3Vyc29yO1xuICAgICAgICBpZiAoIWMpIHtcbiAgICAgICAgICAgIGMgPSB0aGlzLmN1cnNvciA9IHRoaXMuZnJhZ21lbnQudHJlZS5jdXJzb3IoKTtcbiAgICAgICAgICAgIGMuZmlyc3RDaGlsZCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByUG9zID0gcG9zICsgdGhpcy5mcmFnbWVudC5vZmZzZXQ7XG4gICAgICAgIHdoaWxlIChjLnRvIDw9IHJQb3MpXG4gICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoYy5mcm9tID49IHJQb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZnJvbSA8PSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICBpZiAoIWMuY2hpbGRBZnRlcihyUG9zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2hlcyhoYXNoKSB7XG4gICAgICAgIGxldCB0cmVlID0gdGhpcy5jdXJzb3IudHJlZTtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSA9PSBoYXNoO1xuICAgIH1cbiAgICB0YWtlTm9kZXMoY3gpIHtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXMuY3Vyc29yLCBvZmYgPSB0aGlzLmZyYWdtZW50Lm9mZnNldCwgZnJhZ0VuZCA9IHRoaXMuZnJhZ21lbnRFbmQgLSAodGhpcy5mcmFnbWVudC5vcGVuRW5kID8gMSA6IDApO1xuICAgICAgICBsZXQgc3RhcnQgPSBjeC5hYnNvbHV0ZUxpbmVTdGFydCwgZW5kID0gc3RhcnQsIGJsb2NrSSA9IGN4LmJsb2NrLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgbGV0IHByZXZFbmQgPSBlbmQsIHByZXZJID0gYmxvY2tJO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoY3VyLnRvIC0gb2ZmID4gZnJhZ0VuZCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIudHlwZS5pc0Fub255bW91cyAmJiBjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwb3MgPSB0b1JlbGF0aXZlKGN1ci5mcm9tIC0gb2ZmLCBjeC5yYW5nZXMpO1xuICAgICAgICAgICAgaWYgKGN1ci50byAtIG9mZiA8PSBjeC5yYW5nZXNbY3gucmFuZ2VJXS50bykgeyAvLyBGaXRzIGluIGN1cnJlbnQgcmFuZ2VcbiAgICAgICAgICAgICAgICBjeC5hZGROb2RlKGN1ci50cmVlLCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGR1bW15ID0gbmV3IFRyZWUoY3gucGFyc2VyLm5vZGVTZXQudHlwZXNbVHlwZS5QYXJhZ3JhcGhdLCBbXSwgW10sIDAsIGN4LmJsb2NrLmhhc2hQcm9wKTtcbiAgICAgICAgICAgICAgICBjeC5yZXVzZVBsYWNlaG9sZGVycy5zZXQoZHVtbXksIGN1ci50cmVlKTtcbiAgICAgICAgICAgICAgICBjeC5hZGROb2RlKGR1bW15LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGFrZW4gY29udGVudCBtdXN0IGFsd2F5cyBlbmQgaW4gYSBibG9jaywgYmVjYXVzZSBpbmNyZW1lbnRhbFxuICAgICAgICAgICAgLy8gcGFyc2luZyBoYXBwZW5zIG9uIGJsb2NrIGJvdW5kYXJpZXMuIE5ldmVyIHN0b3AgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGFmdGVyIGFuIGluZGVudGVkIGNvZGUgYmxvY2ssIHNpbmNlIHRob3NlIGNhbiBjb250aW51ZSBhZnRlclxuICAgICAgICAgICAgLy8gYW55IG51bWJlciBvZiBibGFuayBsaW5lcy5cbiAgICAgICAgICAgIGlmIChjdXIudHlwZS5pcyhcIkJsb2NrXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE5vdExhc3QuaW5kZXhPZihjdXIudHlwZS5pZCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGN1ci50byAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tJID0gY3guYmxvY2suY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gcHJldkVuZDtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tJID0gcHJldkk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZFbmQgPSBjdXIudG8gLSBvZmY7XG4gICAgICAgICAgICAgICAgcHJldkkgPSBjeC5ibG9jay5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjeC5ibG9jay5jaGlsZHJlbi5sZW5ndGggPiBibG9ja0kpIHtcbiAgICAgICAgICAgIGN4LmJsb2NrLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgICAgICAgY3guYmxvY2sucG9zaXRpb25zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmQgLSBzdGFydDtcbiAgICB9XG59XG4vLyBDb252ZXJ0IGFuIGlucHV0LXN0cmVhbS1yZWxhdGl2ZSBwb3NpdGlvbiB0byBhXG4vLyBNYXJrZG93bi1kb2MtcmVsYXRpdmUgcG9zaXRpb24gYnkgc3VidHJhY3RpbmcgdGhlIHNpemUgb2YgYWxsIGlucHV0XG4vLyBnYXBzIGJlZm9yZSBgYWJzYC5cbmZ1bmN0aW9uIHRvUmVsYXRpdmUoYWJzLCByYW5nZXMpIHtcbiAgICBsZXQgcG9zID0gYWJzO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBnYXBGcm9tID0gcmFuZ2VzW2kgLSAxXS50bywgZ2FwVG8gPSByYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgaWYgKGdhcEZyb20gPCBhYnMpXG4gICAgICAgICAgICBwb3MgLT0gZ2FwVG8gLSBnYXBGcm9tO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuY29uc3QgbWFya2Rvd25IaWdobGlnaHRpbmcgPSBzdHlsZVRhZ3Moe1xuICAgIFwiQmxvY2txdW90ZS8uLi5cIjogdGFncy5xdW90ZSxcbiAgICBIb3Jpem9udGFsUnVsZTogdGFncy5jb250ZW50U2VwYXJhdG9yLFxuICAgIFwiQVRYSGVhZGluZzEvLi4uIFNldGV4dEhlYWRpbmcxLy4uLlwiOiB0YWdzLmhlYWRpbmcxLFxuICAgIFwiQVRYSGVhZGluZzIvLi4uIFNldGV4dEhlYWRpbmcyLy4uLlwiOiB0YWdzLmhlYWRpbmcyLFxuICAgIFwiQVRYSGVhZGluZzMvLi4uXCI6IHRhZ3MuaGVhZGluZzMsXG4gICAgXCJBVFhIZWFkaW5nNC8uLi5cIjogdGFncy5oZWFkaW5nNCxcbiAgICBcIkFUWEhlYWRpbmc1Ly4uLlwiOiB0YWdzLmhlYWRpbmc1LFxuICAgIFwiQVRYSGVhZGluZzYvLi4uXCI6IHRhZ3MuaGVhZGluZzYsXG4gICAgXCJDb21tZW50IENvbW1lbnRCbG9ja1wiOiB0YWdzLmNvbW1lbnQsXG4gICAgRXNjYXBlOiB0YWdzLmVzY2FwZSxcbiAgICBFbnRpdHk6IHRhZ3MuY2hhcmFjdGVyLFxuICAgIFwiRW1waGFzaXMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4gICAgXCJTdHJvbmdFbXBoYXNpcy8uLi5cIjogdGFncy5zdHJvbmcsXG4gICAgXCJMaW5rLy4uLiBJbWFnZS8uLi5cIjogdGFncy5saW5rLFxuICAgIFwiT3JkZXJlZExpc3QvLi4uIEJ1bGxldExpc3QvLi4uXCI6IHRhZ3MubGlzdCxcbiAgICBcIkJsb2NrUXVvdGUvLi4uXCI6IHRhZ3MucXVvdGUsXG4gICAgXCJJbmxpbmVDb2RlIENvZGVUZXh0XCI6IHRhZ3MubW9ub3NwYWNlLFxuICAgIFwiVVJMIEF1dG9saW5rXCI6IHRhZ3MudXJsLFxuICAgIFwiSGVhZGVyTWFyayBIYXJkQnJlYWsgUXVvdGVNYXJrIExpc3RNYXJrIExpbmtNYXJrIEVtcGhhc2lzTWFyayBDb2RlTWFya1wiOiB0YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbixcbiAgICBcIkNvZGVJbmZvIExpbmtMYWJlbFwiOiB0YWdzLmxhYmVsTmFtZSxcbiAgICBMaW5rVGl0bGU6IHRhZ3Muc3RyaW5nLFxuICAgIFBhcmFncmFwaDogdGFncy5jb250ZW50XG59KTtcbi8qKlxuVGhlIGRlZmF1bHQgQ29tbW9uTWFyayBwYXJzZXIuXG4qL1xuY29uc3QgcGFyc2VyID0gbmV3IE1hcmtkb3duUGFyc2VyKG5ldyBOb2RlU2V0KG5vZGVUeXBlcykuZXh0ZW5kKG1hcmtkb3duSGlnaGxpZ2h0aW5nKSwgT2JqZWN0LmtleXMoRGVmYXVsdEJsb2NrUGFyc2VycykubWFwKG4gPT4gRGVmYXVsdEJsb2NrUGFyc2Vyc1tuXSksIE9iamVjdC5rZXlzKERlZmF1bHRCbG9ja1BhcnNlcnMpLm1hcChuID0+IERlZmF1bHRMZWFmQmxvY2tzW25dKSwgT2JqZWN0LmtleXMoRGVmYXVsdEJsb2NrUGFyc2VycyksIERlZmF1bHRFbmRMZWFmLCBEZWZhdWx0U2tpcE1hcmt1cCwgT2JqZWN0LmtleXMoRGVmYXVsdElubGluZSkubWFwKG4gPT4gRGVmYXVsdElubGluZVtuXSksIE9iamVjdC5rZXlzKERlZmF1bHRJbmxpbmUpLCBbXSk7XG5cbmZ1bmN0aW9uIGxlZnRPdmVyU3BhY2Uobm9kZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgbiA9IG5vZGUuZmlyc3RDaGlsZCwgcG9zID0gZnJvbTs7IG4gPSBuLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCBuZXh0UG9zID0gbiA/IG4uZnJvbSA6IHRvO1xuICAgICAgICBpZiAobmV4dFBvcyA+IHBvcylcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0bzogbmV4dFBvcyB9KTtcbiAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IG4udG87XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG4vKipcbkNyZWF0ZSBhIE1hcmtkb3duIGV4dGVuc2lvbiB0byBlbmFibGUgbmVzdGVkIHBhcnNpbmcgb24gY29kZVxuYmxvY2tzIGFuZC9vciBlbWJlZGRlZCBIVE1MLlxuKi9cbmZ1bmN0aW9uIHBhcnNlQ29kZShjb25maWcpIHtcbiAgICBsZXQgeyBjb2RlUGFyc2VyLCBodG1sUGFyc2VyIH0gPSBjb25maWc7XG4gICAgbGV0IHdyYXAgPSBwYXJzZU1peGVkKChub2RlLCBpbnB1dCkgPT4ge1xuICAgICAgICBsZXQgaWQgPSBub2RlLnR5cGUuaWQ7XG4gICAgICAgIGlmIChjb2RlUGFyc2VyICYmIChpZCA9PSBUeXBlLkNvZGVCbG9jayB8fCBpZCA9PSBUeXBlLkZlbmNlZENvZGUpKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoaWQgPT0gVHlwZS5GZW5jZWRDb2RlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZm9Ob2RlID0gbm9kZS5ub2RlLmdldENoaWxkKFR5cGUuQ29kZUluZm8pO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgaW5mbyA9IGlucHV0LnJlYWQoaW5mb05vZGUuZnJvbSwgaW5mb05vZGUudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlciA9IGNvZGVQYXJzZXIoaW5mbyk7XG4gICAgICAgICAgICBpZiAocGFyc2VyKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHBhcnNlciwgb3ZlcmxheTogbm9kZSA9PiBub2RlLnR5cGUuaWQgPT0gVHlwZS5Db2RlVGV4dCwgYnJhY2tldGVkOiBpZCA9PSBUeXBlLkZlbmNlZENvZGUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChodG1sUGFyc2VyICYmIChpZCA9PSBUeXBlLkhUTUxCbG9jayB8fCBpZCA9PSBUeXBlLkhUTUxUYWcgfHwgaWQgPT0gVHlwZS5Db21tZW50QmxvY2spKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJzZXI6IGh0bWxQYXJzZXIsIG92ZXJsYXk6IGxlZnRPdmVyU3BhY2Uobm9kZS5ub2RlLCBub2RlLmZyb20sIG5vZGUudG8pIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgd3JhcCB9O1xufVxuXG5jb25zdCBTdHJpa2V0aHJvdWdoRGVsaW0gPSB7IHJlc29sdmU6IFwiU3RyaWtldGhyb3VnaFwiLCBtYXJrOiBcIlN0cmlrZXRocm91Z2hNYXJrXCIgfTtcbi8qKlxuQW4gZXh0ZW5zaW9uIHRoYXQgaW1wbGVtZW50c1xuW0dGTS1zdHlsZV0oaHR0cHM6Ly9naXRodWIuZ2l0aHViLmNvbS9nZm0vI3N0cmlrZXRocm91Z2gtZXh0ZW5zaW9uLSlcblN0cmlrZXRocm91Z2ggc3ludGF4IHVzaW5nIGB+fmAgZGVsaW1pdGVycy5cbiovXG5jb25zdCBTdHJpa2V0aHJvdWdoID0ge1xuICAgIGRlZmluZU5vZGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJTdHJpa2V0aHJvdWdoXCIsXG4gICAgICAgICAgICBzdHlsZTogeyBcIlN0cmlrZXRocm91Z2gvLi4uXCI6IHRhZ3Muc3RyaWtldGhyb3VnaCB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaWtldGhyb3VnaE1hcmtcIixcbiAgICAgICAgICAgIHN0eWxlOiB0YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvblxuICAgICAgICB9XSxcbiAgICBwYXJzZUlubGluZTogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaWtldGhyb3VnaFwiLFxuICAgICAgICAgICAgcGFyc2UoY3gsIG5leHQsIHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IDEyNiAvKiAnficgKi8gfHwgY3guY2hhcihwb3MgKyAxKSAhPSAxMjYgfHwgY3guY2hhcihwb3MgKyAyKSA9PSAxMjYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gY3guc2xpY2UocG9zIC0gMSwgcG9zKSwgYWZ0ZXIgPSBjeC5zbGljZShwb3MgKyAyLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgICBsZXQgc0JlZm9yZSA9IC9cXHN8XiQvLnRlc3QoYmVmb3JlKSwgc0FmdGVyID0gL1xcc3xeJC8udGVzdChhZnRlcik7XG4gICAgICAgICAgICAgICAgbGV0IHBCZWZvcmUgPSBQdW5jdHVhdGlvbi50ZXN0KGJlZm9yZSksIHBBZnRlciA9IFB1bmN0dWF0aW9uLnRlc3QoYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjeC5hZGREZWxpbWl0ZXIoU3RyaWtldGhyb3VnaERlbGltLCBwb3MsIHBvcyArIDIsICFzQWZ0ZXIgJiYgKCFwQWZ0ZXIgfHwgc0JlZm9yZSB8fCBwQmVmb3JlKSwgIXNCZWZvcmUgJiYgKCFwQmVmb3JlIHx8IHNBZnRlciB8fCBwQWZ0ZXIpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlcjogXCJFbXBoYXNpc1wiXG4gICAgICAgIH1dXG59O1xuLy8gUGFyc2UgYSBsaW5lIGFzIGEgdGFibGUgcm93IGFuZCByZXR1cm4gdGhlIHJvdyBjb3VudC4gV2hlbiBgZWx0c2Bcbi8vIGlzIGdpdmVuLCBwdXNoIHN5bnRheCBlbGVtZW50cyBmb3IgdGhlIGNvbnRlbnQgb250byBpdC5cbmZ1bmN0aW9uIHBhcnNlUm93KGN4LCBsaW5lLCBzdGFydEkgPSAwLCBlbHRzLCBvZmZzZXQgPSAwKSB7XG4gICAgbGV0IGNvdW50ID0gMCwgZmlyc3QgPSB0cnVlLCBjZWxsU3RhcnQgPSAtMSwgY2VsbEVuZCA9IC0xLCBlc2MgPSBmYWxzZTtcbiAgICBsZXQgcGFyc2VDZWxsID0gKCkgPT4ge1xuICAgICAgICBlbHRzLnB1c2goY3guZWx0KFwiVGFibGVDZWxsXCIsIG9mZnNldCArIGNlbGxTdGFydCwgb2Zmc2V0ICsgY2VsbEVuZCwgY3gucGFyc2VyLnBhcnNlSW5saW5lKGxpbmUuc2xpY2UoY2VsbFN0YXJ0LCBjZWxsRW5kKSwgb2Zmc2V0ICsgY2VsbFN0YXJ0KSkpO1xuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0STsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5leHQgPSBsaW5lLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChuZXh0ID09IDEyNCAvKiAnfCcgKi8gJiYgIWVzYykge1xuICAgICAgICAgICAgaWYgKCFmaXJzdCB8fCBjZWxsU3RhcnQgPiAtMSlcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChlbHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxTdGFydCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUNlbGwoKTtcbiAgICAgICAgICAgICAgICBlbHRzLnB1c2goY3guZWx0KFwiVGFibGVEZWxpbWl0ZXJcIiwgaSArIG9mZnNldCwgaSArIG9mZnNldCArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxTdGFydCA9IGNlbGxFbmQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlc2MgfHwgbmV4dCAhPSAzMiAmJiBuZXh0ICE9IDkpIHtcbiAgICAgICAgICAgIGlmIChjZWxsU3RhcnQgPCAwKVxuICAgICAgICAgICAgICAgIGNlbGxTdGFydCA9IGk7XG4gICAgICAgICAgICBjZWxsRW5kID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZXNjID0gIWVzYyAmJiBuZXh0ID09IDkyO1xuICAgIH1cbiAgICBpZiAoY2VsbFN0YXJ0ID4gLTEpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgaWYgKGVsdHMpXG4gICAgICAgICAgICBwYXJzZUNlbGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gaGFzUGlwZShzdHIsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChuZXh0ID09IDEyNCAvKiAnfCcgKi8pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG5leHQgPT0gOTIgLyogJ1xcXFwnICovKVxuICAgICAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBkZWxpbWl0ZXJMaW5lID0gL15cXHw/KFxccyo6Py0rOj9cXHMqXFx8KSsoXFxzKjo/LSs6P1xccyopPyQvO1xuY2xhc3MgVGFibGVQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBOdWxsIG1lYW5zIHdlIGhhdmVuJ3Qgc2VlbiB0aGUgc2Vjb25kIGxpbmUgeWV0LCBmYWxzZSBtZWFucyB0aGlzXG4gICAgICAgIC8vIGlzbid0IGEgdGFibGUsIGFuZCBhbiBhcnJheSBtZWFucyB0aGlzIGlzIGEgdGFibGUgYW5kIHdlJ3ZlXG4gICAgICAgIC8vIHBhcnNlZCB0aGUgZ2l2ZW4gcm93cyBzbyBmYXIuXG4gICAgICAgIHRoaXMucm93cyA9IG51bGw7XG4gICAgfVxuICAgIG5leHRMaW5lKGN4LCBsaW5lLCBsZWFmKSB7XG4gICAgICAgIGlmICh0aGlzLnJvd3MgPT0gbnVsbCkgeyAvLyBTZWNvbmQgbGluZVxuICAgICAgICAgICAgdGhpcy5yb3dzID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbGluZVRleHQ7XG4gICAgICAgICAgICBpZiAoKGxpbmUubmV4dCA9PSA0NSB8fCBsaW5lLm5leHQgPT0gNTggfHwgbGluZS5uZXh0ID09IDEyNCAvKiAnLTp8JyAqLykgJiZcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXJMaW5lLnRlc3QobGluZVRleHQgPSBsaW5lLnRleHQuc2xpY2UobGluZS5wb3MpKSkge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdFJvdyA9IFtdLCBmaXJzdENvdW50ID0gcGFyc2VSb3coY3gsIGxlYWYuY29udGVudCwgMCwgZmlyc3RSb3csIGxlYWYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdENvdW50ID09IHBhcnNlUm93KGN4LCBsaW5lVGV4dCwgbGluZS5wb3MpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd3MgPSBbY3guZWx0KFwiVGFibGVIZWFkZXJcIiwgbGVhZi5zdGFydCwgbGVhZi5zdGFydCArIGxlYWYuY29udGVudC5sZW5ndGgsIGZpcnN0Um93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4LmVsdChcIlRhYmxlRGVsaW1pdGVyXCIsIGN4LmxpbmVTdGFydCArIGxpbmUucG9zLCBjeC5saW5lU3RhcnQgKyBsaW5lLnRleHQubGVuZ3RoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yb3dzKSB7IC8vIExpbmUgYWZ0ZXIgdGhlIHNlY29uZFxuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgIHBhcnNlUm93KGN4LCBsaW5lLnRleHQsIGxpbmUucG9zLCBjb250ZW50LCBjeC5saW5lU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2goY3guZWx0KFwiVGFibGVSb3dcIiwgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MsIGN4LmxpbmVTdGFydCArIGxpbmUudGV4dC5sZW5ndGgsIGNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZpbmlzaChjeCwgbGVhZikge1xuICAgICAgICBpZiAoIXRoaXMucm93cylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY3guYWRkTGVhZkVsZW1lbnQobGVhZiwgY3guZWx0KFwiVGFibGVcIiwgbGVhZi5zdGFydCwgbGVhZi5zdGFydCArIGxlYWYuY29udGVudC5sZW5ndGgsIHRoaXMucm93cykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcblRoaXMgZXh0ZW5zaW9uIHByb3ZpZGVzXG5bR0ZNLXN0eWxlXShodHRwczovL2dpdGh1Yi5naXRodWIuY29tL2dmbS8jdGFibGVzLWV4dGVuc2lvbi0pXG50YWJsZXMsIHVzaW5nIHN5bnRheCBsaWtlIHRoaXM6XG5cbmBgYFxufCBoZWFkIDEgfCBoZWFkIDIgfFxufCAtLS0gICAgfCAtLS0gICAgfFxufCBjZWxsIDEgfCBjZWxsIDIgfFxuYGBgXG4qL1xuY29uc3QgVGFibGUgPSB7XG4gICAgZGVmaW5lTm9kZXM6IFtcbiAgICAgICAgeyBuYW1lOiBcIlRhYmxlXCIsIGJsb2NrOiB0cnVlIH0sXG4gICAgICAgIHsgbmFtZTogXCJUYWJsZUhlYWRlclwiLCBzdHlsZTogeyBcIlRhYmxlSGVhZGVyLy4uLlwiOiB0YWdzLmhlYWRpbmcgfSB9LFxuICAgICAgICBcIlRhYmxlUm93XCIsXG4gICAgICAgIHsgbmFtZTogXCJUYWJsZUNlbGxcIiwgc3R5bGU6IHRhZ3MuY29udGVudCB9LFxuICAgICAgICB7IG5hbWU6IFwiVGFibGVEZWxpbWl0ZXJcIiwgc3R5bGU6IHRhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uIH0sXG4gICAgXSxcbiAgICBwYXJzZUJsb2NrOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJUYWJsZVwiLFxuICAgICAgICAgICAgbGVhZihfLCBsZWFmKSB7IHJldHVybiBoYXNQaXBlKGxlYWYuY29udGVudCwgMCkgPyBuZXcgVGFibGVQYXJzZXIgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW5kTGVhZihjeCwgbGluZSwgbGVhZikge1xuICAgICAgICAgICAgICAgIGlmIChsZWFmLnBhcnNlcnMuc29tZShwID0+IHAgaW5zdGFuY2VvZiBUYWJsZVBhcnNlcikgfHwgIWhhc1BpcGUobGluZS50ZXh0LCBsaW5lLmJhc2VQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjeC5wZWVrTGluZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWxpbWl0ZXJMaW5lLnRlc3QobmV4dCkgJiYgcGFyc2VSb3coY3gsIGxpbmUudGV4dCwgbGluZS5iYXNlUG9zKSA9PSBwYXJzZVJvdyhjeCwgbmV4dCwgbGluZS5iYXNlUG9zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiZWZvcmU6IFwiU2V0ZXh0SGVhZGluZ1wiXG4gICAgICAgIH1dXG59O1xuY2xhc3MgVGFza1BhcnNlciB7XG4gICAgbmV4dExpbmUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZpbmlzaChjeCwgbGVhZikge1xuICAgICAgICBjeC5hZGRMZWFmRWxlbWVudChsZWFmLCBjeC5lbHQoXCJUYXNrXCIsIGxlYWYuc3RhcnQsIGxlYWYuc3RhcnQgKyBsZWFmLmNvbnRlbnQubGVuZ3RoLCBbXG4gICAgICAgICAgICBjeC5lbHQoXCJUYXNrTWFya2VyXCIsIGxlYWYuc3RhcnQsIGxlYWYuc3RhcnQgKyAzKSxcbiAgICAgICAgICAgIC4uLmN4LnBhcnNlci5wYXJzZUlubGluZShsZWFmLmNvbnRlbnQuc2xpY2UoMyksIGxlYWYuc3RhcnQgKyAzKVxuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8qKlxuRXh0ZW5zaW9uIHByb3ZpZGluZ1xuW0dGTS1zdHlsZV0oaHR0cHM6Ly9naXRodWIuZ2l0aHViLmNvbS9nZm0vI3Rhc2stbGlzdC1pdGVtcy1leHRlbnNpb24tKVxudGFzayBsaXN0IGl0ZW1zLCB3aGVyZSBsaXN0IGl0ZW1zIGNhbiBiZSBwcmVmaXhlZCB3aXRoIGBbIF1gIG9yXG5gW3hdYCB0byBhZGQgYSBjaGVja2JveC5cbiovXG5jb25zdCBUYXNrTGlzdCA9IHtcbiAgICBkZWZpbmVOb2RlczogW1xuICAgICAgICB7IG5hbWU6IFwiVGFza1wiLCBibG9jazogdHJ1ZSwgc3R5bGU6IHRhZ3MubGlzdCB9LFxuICAgICAgICB7IG5hbWU6IFwiVGFza01hcmtlclwiLCBzdHlsZTogdGFncy5hdG9tIH1cbiAgICBdLFxuICAgIHBhcnNlQmxvY2s6IFt7XG4gICAgICAgICAgICBuYW1lOiBcIlRhc2tMaXN0XCIsXG4gICAgICAgICAgICBsZWFmKGN4LCBsZWFmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC9eXFxbWyB4WF1cXF1bIFxcdF0vLnRlc3QobGVhZi5jb250ZW50KSAmJiBjeC5wYXJlbnRUeXBlKCkubmFtZSA9PSBcIkxpc3RJdGVtXCIgPyBuZXcgVGFza1BhcnNlciA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXI6IFwiU2V0ZXh0SGVhZGluZ1wiXG4gICAgICAgIH1dXG59O1xuY29uc3QgYXV0b2xpbmtSRSA9IC8od3d3XFwuKXwoaHR0cHM/OlxcL1xcLyl8KFtcXHcuKy1dezEsMTAwfUApfChtYWlsdG86fHhtcHA6KS9neTtcbmNvbnN0IHVybFJFID0gL1tcXHctXSsoXFwuW1xcdy1dKykrKFxcL1teXFxzPF0qKT8vZ3k7XG5jb25zdCBsYXN0VHdvRG9tYWluV29yZHMgPSAvW1xcdy1dK1xcLltcXHctXSsoJHxcXC8pLztcbmNvbnN0IGVtYWlsUkUgPSAvW1xcdy4rLV0rQFtcXHctXSsoXFwuW1xcdy4tXSspKy9neTtcbmNvbnN0IHhtcHBSZXNvdXJjZVJFID0gL1xcL1thLXpBLVpcXGRALl0rL2d5O1xuZnVuY3Rpb24gY291bnQoc3RyLCBmcm9tLCB0bywgY2gpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgIGlmIChzdHJbaV0gPT0gY2gpXG4gICAgICAgICAgICByZXN1bHQrKztcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXV0b2xpbmtVUkxFbmQodGV4dCwgZnJvbSkge1xuICAgIHVybFJFLmxhc3RJbmRleCA9IGZyb207XG4gICAgbGV0IG0gPSB1cmxSRS5leGVjKHRleHQpO1xuICAgIGlmICghbSB8fCBsYXN0VHdvRG9tYWluV29yZHMuZXhlYyhtWzBdKVswXS5pbmRleE9mKFwiX1wiKSA+IC0xKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGVuZCA9IGZyb20gKyBtWzBdLmxlbmd0aDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGV4dFtlbmQgLSAxXSwgbTtcbiAgICAgICAgaWYgKC9bPyEuLDoqX35dLy50ZXN0KGxhc3QpIHx8XG4gICAgICAgICAgICBsYXN0ID09IFwiKVwiICYmIGNvdW50KHRleHQsIGZyb20sIGVuZCwgXCIpXCIpID4gY291bnQodGV4dCwgZnJvbSwgZW5kLCBcIihcIikpXG4gICAgICAgICAgICBlbmQtLTtcbiAgICAgICAgZWxzZSBpZiAobGFzdCA9PSBcIjtcIiAmJiAobSA9IC8mKD86I1xcZCt8I3hbYS1mXFxkXSt8XFx3Kyk7JC8uZXhlYyh0ZXh0LnNsaWNlKGZyb20sIGVuZCkpKSlcbiAgICAgICAgICAgIGVuZCA9IGZyb20gKyBtLmluZGV4O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIGF1dG9saW5rRW1haWxFbmQodGV4dCwgZnJvbSkge1xuICAgIGVtYWlsUkUubGFzdEluZGV4ID0gZnJvbTtcbiAgICBsZXQgbSA9IGVtYWlsUkUuZXhlYyh0ZXh0KTtcbiAgICBpZiAoIW0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgbGFzdCA9IG1bMF1bbVswXS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbGFzdCA9PSBcIl9cIiB8fCBsYXN0ID09IFwiLVwiID8gLTEgOiBmcm9tICsgbVswXS5sZW5ndGggLSAobGFzdCA9PSBcIi5cIiA/IDEgOiAwKTtcbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgaW1wbGVtZW50cyBhdXRvbGlua2luZyBmb3JcbmB3d3cuYC9gaHR0cDovL2AvYGh0dHBzOi8vYC9gbWFpbHRvOmAvYHhtcHA6YCBVUkxzIGFuZCBlbWFpbFxuYWRkcmVzc2VzLlxuKi9cbmNvbnN0IEF1dG9saW5rID0ge1xuICAgIHBhcnNlSW5saW5lOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJBdXRvbGlua1wiLFxuICAgICAgICAgICAgcGFyc2UoY3gsIG5leHQsIGFic1Bvcykge1xuICAgICAgICAgICAgICAgIGxldCBwb3MgPSBhYnNQb3MgLSBjeC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyAmJiAvXFx3Ly50ZXN0KGN4LnRleHRbcG9zIC0gMV0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgYXV0b2xpbmtSRS5sYXN0SW5kZXggPSBwb3M7XG4gICAgICAgICAgICAgICAgbGV0IG0gPSBhdXRvbGlua1JFLmV4ZWMoY3gudGV4dCksIGVuZCA9IC0xO1xuICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGlmIChtWzFdIHx8IG1bMl0pIHsgLy8gd3d3LiwgaHR0cDovL1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBhdXRvbGlua1VSTEVuZChjeC50ZXh0LCBwb3MgKyBtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiAtMSAmJiBjeC5oYXNPcGVuTGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vQnJhY2tldCA9IC8oW15cXFtcXF1dfFxcW1teXFxdXSpcXF0pKi8uZXhlYyhjeC50ZXh0LnNsaWNlKHBvcywgZW5kKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBwb3MgKyBub0JyYWNrZXRbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1bM10pIHsgLy8gZW1haWwgYWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBhdXRvbGlua0VtYWlsRW5kKGN4LnRleHQsIHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBtYWlsdG86L3htcHA6XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGF1dG9saW5rRW1haWxFbmQoY3gudGV4dCwgcG9zICsgbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gLTEgJiYgbVswXSA9PSBcInhtcHA6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtcHBSZXNvdXJjZVJFLmxhc3RJbmRleCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB4bXBwUmVzb3VyY2VSRS5leGVjKGN4LnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmQgPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgY3guYWRkRWxlbWVudChjeC5lbHQoXCJVUkxcIiwgYWJzUG9zLCBlbmQgKyBjeC5vZmZzZXQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kICsgY3gub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XVxufTtcbi8qKlxuRXh0ZW5zaW9uIGJ1bmRsZSBjb250YWluaW5nIFtgVGFibGVgXSgjVGFibGUpLFxuW2BUYXNrTGlzdGBdKCNUYXNrTGlzdCksIFtgU3RyaWtldGhyb3VnaGBdKCNTdHJpa2V0aHJvdWdoKSwgYW5kXG5bYEF1dG9saW5rYF0oI0F1dG9saW5rKS5cbiovXG5jb25zdCBHRk0gPSBbVGFibGUsIFRhc2tMaXN0LCBTdHJpa2V0aHJvdWdoLCBBdXRvbGlua107XG5mdW5jdGlvbiBwYXJzZVN1YlN1cGVyKGNoLCBub2RlLCBtYXJrKSB7XG4gICAgcmV0dXJuIChjeCwgbmV4dCwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChuZXh0ICE9IGNoIHx8IGN4LmNoYXIocG9zICsgMSkgPT0gY2gpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCBlbHRzID0gW2N4LmVsdChtYXJrLCBwb3MsIHBvcyArIDEpXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcyArIDE7IGkgPCBjeC5lbmQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjeC5jaGFyKGkpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gY2gpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN4LmFkZEVsZW1lbnQoY3guZWx0KG5vZGUsIHBvcywgaSArIDEsIGVsdHMuY29uY2F0KGN4LmVsdChtYXJrLCBpLCBpICsgMSkpKSk7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSA5MiAvKiAnXFxcXCcgKi8pXG4gICAgICAgICAgICAgICAgZWx0cy5wdXNoKGN4LmVsdChcIkVzY2FwZVwiLCBpLCBpKysgKyAyKSk7XG4gICAgICAgICAgICBpZiAoc3BhY2UobmV4dCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG59XG4vKipcbkV4dGVuc2lvbiBwcm92aWRpbmdcbltQYW5kb2Mtc3R5bGVdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNzdXBlcnNjcmlwdHMtYW5kLXN1YnNjcmlwdHMpXG5zdXBlcnNjcmlwdCB1c2luZyBgXmAgbWFya2Vycy5cbiovXG5jb25zdCBTdXBlcnNjcmlwdCA9IHtcbiAgICBkZWZpbmVOb2RlczogW1xuICAgICAgICB7IG5hbWU6IFwiU3VwZXJzY3JpcHRcIiwgc3R5bGU6IHRhZ3Muc3BlY2lhbCh0YWdzLmNvbnRlbnQpIH0sXG4gICAgICAgIHsgbmFtZTogXCJTdXBlcnNjcmlwdE1hcmtcIiwgc3R5bGU6IHRhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uIH1cbiAgICBdLFxuICAgIHBhcnNlSW5saW5lOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJTdXBlcnNjcmlwdFwiLFxuICAgICAgICAgICAgcGFyc2U6IHBhcnNlU3ViU3VwZXIoOTQgLyogJ14nICovLCBcIlN1cGVyc2NyaXB0XCIsIFwiU3VwZXJzY3JpcHRNYXJrXCIpXG4gICAgICAgIH1dXG59O1xuLyoqXG5FeHRlbnNpb24gcHJvdmlkaW5nXG5bUGFuZG9jLXN0eWxlXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjc3VwZXJzY3JpcHRzLWFuZC1zdWJzY3JpcHRzKVxuc3Vic2NyaXB0IHVzaW5nIGB+YCBtYXJrZXJzLlxuKi9cbmNvbnN0IFN1YnNjcmlwdCA9IHtcbiAgICBkZWZpbmVOb2RlczogW1xuICAgICAgICB7IG5hbWU6IFwiU3Vic2NyaXB0XCIsIHN0eWxlOiB0YWdzLnNwZWNpYWwodGFncy5jb250ZW50KSB9LFxuICAgICAgICB7IG5hbWU6IFwiU3Vic2NyaXB0TWFya1wiLCBzdHlsZTogdGFncy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gfVxuICAgIF0sXG4gICAgcGFyc2VJbmxpbmU6IFt7XG4gICAgICAgICAgICBuYW1lOiBcIlN1YnNjcmlwdFwiLFxuICAgICAgICAgICAgcGFyc2U6IHBhcnNlU3ViU3VwZXIoMTI2IC8qICd+JyAqLywgXCJTdWJzY3JpcHRcIiwgXCJTdWJzY3JpcHRNYXJrXCIpXG4gICAgICAgIH1dXG59O1xuLyoqXG5FeHRlbnNpb24gdGhhdCBwYXJzZXMgdHdvIGNvbG9ucyB3aXRoIG9ubHkgbGV0dGVycywgdW5kZXJzY29yZXMsXG5hbmQgbnVtYmVycyBiZXR3ZWVuIHRoZW0gYXMgYEVtb2ppYCBub2Rlcy5cbiovXG5jb25zdCBFbW9qaSA9IHtcbiAgICBkZWZpbmVOb2RlczogW3sgbmFtZTogXCJFbW9qaVwiLCBzdHlsZTogdGFncy5jaGFyYWN0ZXIgfV0sXG4gICAgcGFyc2VJbmxpbmU6IFt7XG4gICAgICAgICAgICBuYW1lOiBcIkVtb2ppXCIsXG4gICAgICAgICAgICBwYXJzZShjeCwgbmV4dCwgcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IDU4IC8qICc6JyAqLyB8fCAhKG1hdGNoID0gL15bYS16QS1aXzAtOV0rOi8uZXhlYyhjeC5zbGljZShwb3MgKyAxLCBjeC5lbmQpKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3guYWRkRWxlbWVudChjeC5lbHQoXCJFbW9qaVwiLCBwb3MsIHBvcyArIDEgKyBtYXRjaFswXS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV1cbn07XG5cbmV4cG9ydCB7IEF1dG9saW5rLCBCbG9ja0NvbnRleHQsIEVsZW1lbnQsIEVtb2ppLCBHRk0sIElubGluZUNvbnRleHQsIExlYWZCbG9jaywgTGluZSwgTWFya2Rvd25QYXJzZXIsIFN0cmlrZXRocm91Z2gsIFN1YnNjcmlwdCwgU3VwZXJzY3JpcHQsIFRhYmxlLCBUYXNrTGlzdCwgcGFyc2VDb2RlLCBwYXJzZXIgfTtcbiIsICJpbXBvcnQgeyBQYXJzZXIsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgVHJlZSwgSXRlck1vZGUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLyoqXG5BIHBhcnNlIHN0YWNrLiBUaGVzZSBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwYXJzZXIgdG8gdHJhY2tcbnBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xudGhhdCBleHRlcm5hbCBjb2RlIHN1Y2ggYXMgYSB0b2tlbml6ZXIgY2FuIHVzZSB0byBnZXQgaW5mb3JtYXRpb25cbmFib3V0IHRoZSBwYXJzZSBzdGF0ZS5cbiovXG5jbGFzcyBTdGFjayB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcGFyc2UgdGhhdCB0aGlzIHN0YWNrIGlzIHBhcnQgb2YgQGludGVybmFsXG4gICAgKi9cbiAgICBwLCBcbiAgICAvKipcbiAgICBIb2xkcyBzdGF0ZSwgaW5wdXQgcG9zLCBidWZmZXIgaW5kZXggdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlXG4gICAgdG9wIHN0YXRlIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhY2ssIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8vIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgbmV4dCByZWR1Y2Ugc2hvdWxkIHRha2UgcGxhY2UuIFRoaXNcbiAgICAvLyBjYW4gYmUgbGVzcyB0aGFuIGB0aGlzLnBvc2Agd2hlbiBza2lwcGVkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIGFkZGVkIHRvIHRoZSBzdGFjayAod2hpY2ggc2hvdWxkIGJlIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5leHRcbiAgICAvLyByZWR1Y3Rpb24pXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWR1Y2VQb3MsIFxuICAgIC8qKlxuICAgIFRoZSBpbnB1dCBwb3NpdGlvbiB1cCB0byB3aGljaCB0aGlzIHN0YWNrIGhhcyBwYXJzZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIGFuZCBlcnJvci1yZWNvdmVyeSBwZW5hbHRpZXNcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYnVmZmVyLCBcbiAgICAvLyBUaGUgYmFzZSBvZmZzZXQgb2YgdGhlIGJ1ZmZlci4gV2hlbiBzdGFja3MgYXJlIHNwbGl0LCB0aGUgc3BsaXRcbiAgICAvLyBpbnN0YW5jZSBzaGFyZWQgdGhlIGJ1ZmZlciBoaXN0b3J5IHdpdGggaXRzIHBhcmVudCB1cCB0b1xuICAgIC8vIGBidWZmZXJCYXNlYCwgd2hpY2ggaXMgdGhlIGFic29sdXRlIG9mZnNldCAoaW5jbHVkaW5nIHRoZVxuICAgIC8vIG9mZnNldCBvZiBwcmV2aW91cyBzcGxpdHMpIGludG8gdGhlIGJ1ZmZlciBhdCB3aGljaCB0aGlzIHN0YWNrXG4gICAgLy8gc3RhcnRzIHdyaXRpbmcuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBidWZmZXJCYXNlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGN1ckNvbnRleHQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9va0FoZWFkID0gMCwgXG4gICAgLy8gQSBwYXJlbnQgc3RhY2sgZnJvbSB3aGljaCB0aGlzIHdhcyBzcGxpdCBvZmYsIGlmIGFueS4gVGhpcyBpc1xuICAgIC8vIHNldCB1cCBzbyB0aGF0IGl0IGFsd2F5cyBwb2ludHMgdG8gYSBzdGFjayB0aGF0IGhhcyBzb21lXG4gICAgLy8gYWRkaXRpb25hbCBidWZmZXIgY29udGVudCwgbmV2ZXIgdG8gYSBzdGFjayB3aXRoIGFuIGVxdWFsXG4gICAgLy8gYGJ1ZmZlckJhc2VgLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGFyZW50KSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHJlZHVjZVBvcztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuYnVmZmVyQmFzZSA9IGJ1ZmZlckJhc2U7XG4gICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IGN1ckNvbnRleHQ7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgc3RhcnQocCwgc3RhdGUsIHBvcyA9IDApIHtcbiAgICAgICAgbGV0IGN4ID0gcC5wYXJzZXIuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayhwLCBbXSwgc3RhdGUsIHBvcywgcG9zLCAwLCBbXSwgMCwgY3ggPyBuZXcgU3RhY2tDb250ZXh0KGN4LCBjeC5zdGFydCkgOiBudWxsLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN0YWNrJ3MgY3VycmVudCBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyKSB2YWx1ZSwgaWZcbiAgICBhbnkuIEl0cyB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBjb250ZXh0IHRyYWNrZXIncyB0eXBlXG4gICAgcGFyYW1ldGVyLCBvciBpdCB3aWxsIGJlIGBudWxsYCBpZiB0aGVyZSBpcyBubyBjb250ZXh0XG4gICAgdHJhY2tlci5cbiAgICAqL1xuICAgIGdldCBjb250ZXh0KCkgeyByZXR1cm4gdGhpcy5jdXJDb250ZXh0ID8gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQgOiBudWxsOyB9XG4gICAgLy8gUHVzaCBhIHN0YXRlIG9udG8gdGhlIHN0YWNrLCB0cmFja2luZyBpdHMgc3RhcnQgcG9zaXRpb24gYXMgd2VsbFxuICAgIC8vIGFzIHRoZSBidWZmZXIgYmFzZSBhdCB0aGF0IHBvaW50LlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovLCB0eXBlID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLztcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCBsb29rYWhlYWRSZWNvcmQgPSB0aGlzLnJlZHVjZVBvcyA8IHRoaXMucG9zIC0gMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLyAmJiB0aGlzLnNldExvb2tBaGVhZCh0aGlzLnBvcyk7XG4gICAgICAgIGxldCBkUHJlYyA9IHBhcnNlci5keW5hbWljUHJlY2VkZW5jZSh0eXBlKTtcbiAgICAgICAgaWYgKGRQcmVjKVxuICAgICAgICAgICAgdGhpcy5zY29yZSArPSBkUHJlYztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhdGUsIHR5cGUsIHRydWUpLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICAvLyBaZXJvLWRlcHRoIHJlZHVjdGlvbnMgYXJlIGEgc3BlY2lhbCBjYXNlXHUyMDE0dGhleSBhZGQgc3R1ZmYgdG9cbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IHBvcHBpbmcgYW55dGhpbmcgb2ZmLlxuICAgICAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIGxvb2thaGVhZFJlY29yZCA/IDggOiA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8gPyA2IDogMCk7XG4gICAgICAgIGxldCBzdGFydCA9IGJhc2UgPyB0aGlzLnN0YWNrW2Jhc2UgLSAyXSA6IHRoaXMucC5yYW5nZXNbMF0uZnJvbSwgc2l6ZSA9IHRoaXMucmVkdWNlUG9zIC0gc3RhcnQ7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBrbHVkZ2UgdG8gdHJ5IGFuZCBkZXRlY3Qgb3Zlcmx5IGRlZXAgbGVmdC1hc3NvY2lhdGl2ZVxuICAgICAgICAvLyB0cmVlcywgd2hpY2ggd2lsbCBub3QgaW5jcmVhc2UgdGhlIHBhcnNlIHN0YWNrIGRlcHRoIGFuZCB0aHVzXG4gICAgICAgIC8vIHdvbid0IGJlIGNhdWdodCBieSB0aGUgcmVndWxhciBzdGFjay1kZXB0aCBsaW1pdCBjaGVjay5cbiAgICAgICAgaWYgKHNpemUgPj0gMjAwMCAvKiBSZWNvdmVyLk1pbkJpZ1JlZHVjdGlvbiAqLyAmJiAhKChfYSA9IHRoaXMucC5wYXJzZXIubm9kZVNldC50eXBlc1t0eXBlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQW5vbnltb3VzKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplIDwgc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucC5iaWdSZWR1Y3Rpb25Db3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZmZlckJhc2UgPSBiYXNlID8gdGhpcy5zdGFja1tiYXNlIC0gMV0gOiAwLCBjb3VudCA9IHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlckJhc2U7XG4gICAgICAgIC8vIFN0b3JlIG5vcm1hbCB0ZXJtcyBvciBgUiAtPiBSIFJgIHJlcGVhdCByZWR1Y3Rpb25zXG4gICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0gfHwgKGFjdGlvbiAmIDEzMTA3MiAvKiBBY3Rpb24uUmVwZWF0RmxhZyAqLykpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDEgLyogU3RhdGVGbGFnLlNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrW2Jhc2VdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJhc2VTdGF0ZUlEID0gdGhpcy5zdGFja1tiYXNlIC0gM107XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gcGFyc2VyLmdldEdvdG8oYmFzZVN0YXRlSUQsIHR5cGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IGJhc2UpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgIH1cbiAgICAvLyBTaGlmdCBhIHZhbHVlIGludG8gdGhlIGJ1ZmZlclxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBtdXN0U2luayA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogVGVybS5FcnIgKi8gJiZcbiAgICAgICAgICAgICghdGhpcy5zdGFjay5sZW5ndGggfHwgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdIDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5idWZmZXJCYXNlKSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG9taXQvbWVyZ2UgYWRqYWNlbnQgZXJyb3Igbm9kZXNcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLCB0b3AgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9wID09IDAgJiYgY3VyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGN1ci5idWZmZXJCYXNlIC0gY3VyLnBhcmVudC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gMCAmJiBjdXIuYnVmZmVyW3RvcCAtIDRdID09IDAgLyogVGVybS5FcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtdXN0U2luayB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiAodGhpcy5idWZmZXJbaW5kZXggLSA0XSAhPSAwIC8qIFRlcm0uRXJyICovIHx8IHRoaXMuYnVmZmVyW2luZGV4IC0gMV0gPCAwKSkge1xuICAgICAgICAgICAgICAgIGxldCBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHNjYW4gPSBpbmRleDsgc2NhbiA+IDAgJiYgdGhpcy5idWZmZXJbc2NhbiAtIDJdID4gZW5kOyBzY2FuIC09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3NjYW4gLSAxXSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXN0TW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobXVzdE1vdmUpXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGlzIHJlY29yZCBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gdGhpcy5idWZmZXJbaW5kZXggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNoaWZ0KGFjdGlvbiwgdHlwZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgMTMxMDcyIC8qIEFjdGlvbi5Hb3RvRmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgdGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovKSA9PSAwKSB7IC8vIFJlZ3VsYXIgc2hpZnRcbiAgICAgICAgICAgIGxldCBuZXh0U3RhdGUgPSBhY3Rpb24sIHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgICAgIGxldCBza2lwcGVkID0gcGFyc2VyLnN0YXRlRmxhZyhuZXh0U3RhdGUsIDEgLyogU3RhdGVGbGFnLlNraXBwZWQgKi8pO1xuICAgICAgICAgICAgLy8gU2tpcHBlZCBvciB6ZXJvLWxlbmd0aCBub24tdHJlZSB0b2tlbnMgZG9uJ3QgbW92ZSByZWR1Y2VQb3NcbiAgICAgICAgICAgIGlmICghc2tpcHBlZCAmJiAoZW5kID4gc3RhcnQgfHwgdHlwZSA8PSBwYXJzZXIubWF4Tm9kZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0U3RhdGUsIHNraXBwZWQgPyBzdGFydCA6IE1hdGgubWluKHN0YXJ0LCB0aGlzLnJlZHVjZVBvcykpO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPD0gcGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0eXBlLCBzdGFydCwgZW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmICh0eXBlIDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHR5cGUsIHN0YXJ0LCBlbmQsIDQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGFuIGFjdGlvblxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHkoYWN0aW9uLCBuZXh0LCBuZXh0U3RhcnQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKVxuICAgICAgICAgICAgdGhpcy5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zaGlmdChhY3Rpb24sIG5leHQsIG5leHRTdGFydCwgbmV4dEVuZCk7XG4gICAgfVxuICAgIC8vIEFkZCBhIHByZWJ1aWx0IChyZXVzZWQpIG5vZGUgaW50byB0aGUgYnVmZmVyLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXNlTm9kZSh2YWx1ZSwgbmV4dCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnAucmV1c2VkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5wLnJldXNlZFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucC5yZXVzZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zID0gc3RhcnQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbmRleCwgc3RhcnQsIHRoaXMucmVkdWNlUG9zLCAtMSAvKiBzaXplID09IC0xIG1lYW5zIHRoaXMgaXMgYSByZXVzZWQgdmFsdWUgKi8pO1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJldXNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB2YWx1ZSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldCh0aGlzLnBvcyAtIHZhbHVlLmxlbmd0aCkpKTtcbiAgICB9XG4gICAgLy8gU3BsaXQgdGhlIHN0YWNrLiBEdWUgdG8gdGhlIGJ1ZmZlciBzaGFyaW5nIGFuZCB0aGUgZmFjdFxuICAgIC8vIHRoYXQgYHRoaXMuc3RhY2tgIHRlbmRzIHRvIHN0YXkgcXVpdGUgc2hhbGxvdywgdGhpcyBpc24ndCB2ZXJ5XG4gICAgLy8gZXhwZW5zaXZlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLnAsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHRoaXMuY3VyQ29udGV4dCwgdGhpcy5sb29rQWhlYWQsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXJCeURlbGV0ZShuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBpc05vZGUgPSBuZXh0IDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZTtcbiAgICAgICAgaWYgKGlzTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKG5leHQsIHRoaXMucG9zLCBuZXh0RW5kLCA0KTtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMTkwIC8qIFJlY292ZXIuRGVsZXRlICovO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiB0aGUgZ2l2ZW4gdGVybSB3b3VsZCBiZSBhYmxlIHRvIGJlIHNoaWZ0ZWQgKG9wdGlvbmFsbHlcbiAgICBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICBleHRlcm5hbCB0b2tlbml6ZXJzIHRoYXQgd2FudCB0byBtYWtlIHN1cmUgdGhleSBvbmx5IHByb3ZpZGUgYVxuICAgIGdpdmVuIHRva2VuIHdoZW4gaXQgYXBwbGllcy5cbiAgICAqL1xuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdChzaW0uc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKSB8fCB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzaW0uc3RhdGUsIHRlcm0pO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3ZlckJ5SW5zZXJ0KG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID49IDMwMCAvKiBSZWNvdmVyLk1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5wLnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlcy5sZW5ndGggPiA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLyA8PCAxIHx8IHRoaXMuc3RhY2subGVuZ3RoID49IDEyMCAvKiBSZWNvdmVyLkRhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pIHtcbiAgICAgICAgICAgIGxldCBiZXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgczsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHMgPSBuZXh0U3RhdGVzW2kgKyAxXSkgIT0gdGhpcy5zdGF0ZSAmJiB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzLCBuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMTIwIC8qIFJlY292ZXIuRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLyA8PCAxICYmIGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVzdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gcykpXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFN0YXRlcyA9IGJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLzsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHMgPT0gdGhpcy5zdGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2hTdGF0ZShzLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgc3RhY2sucG9zLCBzdGFjay5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgc3RhY2suc2hpZnRDb250ZXh0KG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZVBvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgc3RhY2suc2NvcmUgLT0gMjAwIC8qIFJlY292ZXIuSW5zZXJ0ICovO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZvcmNlIGEgcmVkdWNlLCBpZiBwb3NzaWJsZS4gUmV0dXJuIGZhbHNlIGlmIHRoYXQgY2FuJ3RcbiAgICAvLyBiZSBkb25lLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZm9yY2VSZWR1Y2UoKSB7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgcmVkdWNlID0gcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA1IC8qIFBhcnNlU3RhdGUuRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgaWYgKChyZWR1Y2UgJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwYXJzZXIudmFsaWRBY3Rpb24odGhpcy5zdGF0ZSwgcmVkdWNlKSkge1xuICAgICAgICAgICAgbGV0IGRlcHRoID0gcmVkdWNlID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovLCB0ZXJtID0gcmVkdWNlICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIGRlcHRoICogMztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPCAwIHx8IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCBiYWNrdXAgPSB0aGlzLmZpbmRGb3JjZWRSZWR1Y3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFja3VwID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICByZWR1Y2UgPSBiYWNrdXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY29yZSAtPSAxMDAgLyogUmVjb3Zlci5SZWR1Y2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2UocmVkdWNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBzY2FuIHRocm91Z2ggdGhlIGF1dG9tYXRvbiB0byBmaW5kIHNvbWUga2luZCBvZiByZWR1Y3Rpb25cbiAgICB0aGF0IGNhbiBiZSBhcHBsaWVkLiBVc2VkIHdoZW4gdGhlIHJlZ3VsYXIgRm9yY2VkUmVkdWNlIGZpZWxkXG4gICAgaXNuJ3QgYSB2YWxpZCBhY3Rpb24uIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluZEZvcmNlZFJlZHVjdGlvbigpIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnAsIHNlZW4gPSBbXTtcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAoc3RhdGUsIGRlcHRoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmNsdWRlcyhzdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuYWxsQWN0aW9ucyhzdGF0ZSwgKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gJiAoMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLyB8IDEzMTA3MiAvKiBBY3Rpb24uR290b0ZsYWcgKi8pKSA7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJEZXB0aCA9IChhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8pIC0gZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyRGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gckRlcHRoICogMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPj0gMCAmJiBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RhcmdldF0sIHRlcm0sIGZhbHNlKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAockRlcHRoIDw8IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovKSB8IDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovIHwgdGVybTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZXhwbG9yZShhY3Rpb24sIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXhwbG9yZSh0aGlzLnN0YXRlLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3JjZUFsbCgpIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLnAucGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAyIC8qIFN0YXRlRmxhZy5BY2NlcHRpbmcgKi8pKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VSZWR1Y2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgdG9wIHN0YXRlLCBzaW5jZSBhbnkgb3RoZXIgc3RhdGVzIG11c3QgYmUgYWJsZSB0byBjb250aW51ZVxuICAgIHNvbWVob3cpLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXN0YXJ0IHRoZSBzdGFjayAocHV0IGl0IGJhY2sgaW4gaXRzIHN0YXJ0IHN0YXRlKS4gT25seSBzYWZlXG4gICAgd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgc3RhdGUpLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrWzBdO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2FtZVN0YXRlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IG90aGVyLnN0YXRlIHx8IHRoaXMuc3RhY2subGVuZ3RoICE9IG90aGVyLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tbaV0gIT0gb3RoZXIuc3RhY2tbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwYXJzZXIgdXNlZCBieSB0aGlzIHN0YWNrLlxuICAgICovXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXI7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgYSBnaXZlbiBkaWFsZWN0IChieSBudW1lcmljIElELCBhcyBleHBvcnRlZCBmcm9tXG4gICAgdGhlIHRlcm1zIGZpbGUpIGlzIGVuYWJsZWQuXG4gICAgKi9cbiAgICBkaWFsZWN0RW5hYmxlZChkaWFsZWN0SUQpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG4gICAgc2hpZnRDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc2hpZnQodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIHJlZHVjZUNvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZWR1Y2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW1pdENvbnRleHQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC0zKVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmN1ckNvbnRleHQuaGFzaCwgdGhpcy5wb3MsIHRoaXMucG9zLCAtMyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW1pdExvb2tBaGVhZCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTQpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMubG9va0FoZWFkLCB0aGlzLnBvcywgdGhpcy5wb3MsIC00KTtcbiAgICB9XG4gICAgdXBkYXRlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ICE9IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgbmV3Q3ggPSBuZXcgU3RhY2tDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChuZXdDeC5oYXNoICE9IHRoaXMuY3VyQ29udGV4dC5oYXNoKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IG5ld0N4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0TG9va0FoZWFkKGxvb2tBaGVhZCkge1xuICAgICAgICBpZiAobG9va0FoZWFkIDw9IHRoaXMubG9va0FoZWFkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YXJ0LnN0YWNrO1xuICAgICAgICB0aGlzLmJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB9XG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2sgPT0gdGhpcy5zdGFydC5zdGFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iYXNlICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFydC5wLnBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGhpcy5iYXNlIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaywgcG9zID0gc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgcG9zLCBwb3MgLSBzdGFjay5idWZmZXJCYXNlKTtcbiAgICB9XG4gICAgbWF5YmVOZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RhY2sucGFyZW50O1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5idWZmZXJCYXNlIC0gbmV4dC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5leHQuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgICAgICAgdGhpcy5wb3MgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3IodGhpcy5zdGFjaywgdGhpcy5wb3MsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogRW5jb2RlLkJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEVuY29kZS5CaWdWYWwgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+PSA5MiAvKiBFbmNvZGUuR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBFbmNvZGUuR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogRW5jb2RlLlN0YXJ0ICovO1xuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IDQ2IC8qIEVuY29kZS5CYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5KVxuICAgICAgICAgICAgYXJyYXlbb3V0KytdID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmNsYXNzIENhY2hlZFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSAwO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAwO1xuICAgIH1cbn1cbmNvbnN0IG51bGxUb2tlbiA9IG5ldyBDYWNoZWRUb2tlbjtcbi8qKlxuW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbnRocm91Z2ggdGhpcyBpbnRlcmZhY2UuIEl0IHByZXNlbnRzIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZlxuY2hhcmFjdGVycywgdHJhY2tpbmcgbG9va2FoZWFkIGFuZCBoaWRpbmcgdGhlIGNvbXBsZXhpdHkgb2ZcbltyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbiovXG5jbGFzcyBJbnB1dFN0cmVhbSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmdlcykge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgQmFja3VwIGNodW5rXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsyID0gXCJcIjtcbiAgICAgICAgdGhpcy5jaHVuazJQb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGNoYXJhY3RlciBjb2RlIG9mIHRoZSBuZXh0IGNvZGUgdW5pdCBpbiB0aGUgaW5wdXQsIG9yIC0xXG4gICAgICAgIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVPZmZzZXQob2Zmc2V0LCBhc3NvYykge1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJhbmdlLCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICB3aGlsZSAocG9zIDwgcmFuZ2UuZnJvbSkge1xuICAgICAgICAgICAgaWYgKCFpbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbLS1pbmRleF07XG4gICAgICAgICAgICBwb3MgLT0gcmFuZ2UuZnJvbSAtIG5leHQudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFzc29jIDwgMCA/IHBvcyA+IHJhbmdlLnRvIDogcG9zID49IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbKytpbmRleF07XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5mcm9tIC0gcmFuZ2UudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjbGlwUG9zKHBvcykge1xuICAgICAgICBpZiAocG9zID49IHRoaXMucmFuZ2UuZnJvbSAmJiBwb3MgPCB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG4gICAgICAgICAgICBpZiAocmFuZ2UudG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHBvcywgcmFuZ2UuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBhdCBhIGNvZGUgdW5pdCBuZWFyIHRoZSBzdHJlYW0gcG9zaXRpb24uIGAucGVlaygwKWAgZXF1YWxzXG4gICAgYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIG9uLlxuICAgIFxuICAgIE5vdGUgdGhhdCBsb29raW5nIGFyb3VuZCBkdXJpbmcgdG9rZW5pemluZyBjcmVhdGVzIGRlcGVuZGVuY2llc1xuICAgIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgZWZmZWN0aXZlbmVzcyBpbmNyZW1lbnRhbCBwYXJzaW5nXHUyMDE0d2hlbiBsb29raW5nIGZvcndhcmRcdTIwMTRvciBldmVuXG4gICAgY2F1c2UgaW52YWxpZCByZXBhcnNlcyB3aGVuIGxvb2tpbmcgYmFja3dhcmQgbW9yZSB0aGFuIDI1IGNvZGVcbiAgICB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICAqL1xuICAgIHBlZWsob2Zmc2V0KSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmNodW5rT2ZmICsgb2Zmc2V0LCBwb3MsIHJlc3VsdDtcbiAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlT2Zmc2V0KG9mZnNldCwgMSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBwb3MgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgcG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KHBvcyAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdGhpcy5yYW5nZUluZGV4LCByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlLnRvIDw9IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlc1srK2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLmNodW5rMlBvcyA9IHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCA+IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bmsyLnNsaWNlKDAsIHJhbmdlLnRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuLiBCeSBkZWZhdWx0LCB0aGUgZW5kIG9mIHRoZSB0b2tlbiBpcyBzZXQgdG8gdGhlXG4gICAgY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIHRoZSBzdHJlYW0gcG9zaXRpb24pIHRvIGNoYW5nZSB0aGF0LlxuICAgICovXG4gICAgYWNjZXB0VG9rZW4odG9rZW4sIGVuZE9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGVuZCA9IGVuZE9mZnNldCA/IHRoaXMucmVzb2x2ZU9mZnNldChlbmRPZmZzZXQsIC0xKSA6IHRoaXMucG9zO1xuICAgICAgICBpZiAoZW5kID09IG51bGwgfHwgZW5kIDwgdGhpcy50b2tlbi5zdGFydClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9rZW4gZW5kIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuIGVuZGluZyBhdCBhIHNwZWNpZmljIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgYWNjZXB0VG9rZW5Ubyh0b2tlbiwgZW5kUG9zKSB7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmRQb3M7XG4gICAgfVxuICAgIGdldENodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgdGhpcy5wb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgY2h1bmssIGNodW5rUG9zIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IHRoaXMuY2h1bmsyO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMuY2h1bmsyUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSBjaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gY2h1bmtQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gdGhpcy5wb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgbGV0IG5leHRDaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5wb3MpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucG9zICsgbmV4dENodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBlbmQgPiB0aGlzLnJhbmdlLnRvID8gbmV4dENodW5rLnNsaWNlKDAsIHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcykgOiBuZXh0Q2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPj0gdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID09IHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KHRoaXMuY2h1bmtPZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgdGhlIG5ldyB2YWx1ZSBvZiBbYG5leHRgXSgjbHIuSW5wdXRTdHJlYW0ubmV4dCkuXG4gICAgKi9cbiAgICBhZHZhbmNlKG4gPSAxKSB7XG4gICAgICAgIHRoaXMuY2h1bmtPZmYgKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zICsgbiA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgbiAtPSB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJhbmdlLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIHNldERvbmUoKSB7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHRoaXMuZW5kO1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4ID0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQocG9zLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgdG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4uZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zICE9IHBvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgICAgICBpZiAocG9zID09IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5yYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1stLXRoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVua1BvcyAmJiBwb3MgPCB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gcG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgdGhpcy5pZCwgcGFyc2VyLmRhdGEsIHBhcnNlci50b2tlblByZWNUYWJsZSk7XG4gICAgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vKipcbkBoaWRlXG4qL1xuY2xhc3MgTG9jYWxUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwcmVjVGFibGUsIGVsc2VUb2tlbikge1xuICAgICAgICB0aGlzLnByZWNUYWJsZSA9IHByZWNUYWJsZTtcbiAgICAgICAgdGhpcy5lbHNlVG9rZW4gPSBlbHNlVG9rZW47XG4gICAgICAgIHRoaXMuZGF0YSA9IHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgPyBkZWNvZGVBcnJheShkYXRhKSA6IGRhdGE7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgc3RhcnQgPSBpbnB1dC5wb3MsIHNraXBwZWQgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYXRFb2YgPSBpbnB1dC5uZXh0IDwgMCwgbmV4dFBvcyA9IGlucHV0LnJlc29sdmVPZmZzZXQoMSwgMSk7XG4gICAgICAgICAgICByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgc3RhY2ssIDAsIHRoaXMuZGF0YSwgdGhpcy5wcmVjVGFibGUpO1xuICAgICAgICAgICAgaWYgKGlucHV0LnRva2VuLnZhbHVlID4gLTEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5lbHNlVG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWF0RW9mKVxuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgIGlmIChuZXh0UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpbnB1dC5yZXNldChuZXh0UG9zLCBpbnB1dC50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnJlc2V0KHN0YXJ0LCBpbnB1dC50b2tlbik7XG4gICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0aGlzLmVsc2VUb2tlbiwgc2tpcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Mb2NhbFRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLyoqXG5gQGV4dGVybmFsIHRva2Vuc2AgZGVjbGFyYXRpb25zIGluIHRoZSBncmFtbWFyIHNob3VsZCByZXNvbHZlIHRvXG5hbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuKi9cbmNsYXNzIEV4dGVybmFsVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgcmVjb2duaXplcyBhdCB0aGUgc3RyZWFtJ3MgcG9zaXRpb24sIGFuZCBjYWxsc1xuICAgIFtgYWNjZXB0VG9rZW5gXSgjbHIuSW5wdXRTdHJlYW0uYWNjZXB0VG9rZW4pIHdoZW4gaXQgZmluZHNcbiAgICBvbmUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGBpbnB1dC50b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCwgcHJlY1RhYmxlLCBwcmVjT2Zmc2V0KSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgeyBkaWFsZWN0IH0gPSBzdGFjay5wLnBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlLCBwcmVjVGFibGUsIHByZWNPZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGlucHV0Lm5leHQsIGxvdyA9IDAsIGhpZ2ggPSBkYXRhW3N0YXRlICsgMl07XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgRU9GXG4gICAgICAgIGlmIChpbnB1dC5uZXh0IDwgMCAmJiBoaWdoID4gbG93ICYmIGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAzXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAoOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdIHx8IDB4MTAwMDA7XG4gICAgICAgICAgICBpZiAobmV4dCA8IGZyb20pXG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gdG8pXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogU2VxLkVuZCAqLzsgaSsrKVxuICAgICAgICBpZiAobmV4dCA9PSB0ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIGkgLSBzdGFydDtcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBvdmVycmlkZXModG9rZW4sIHByZXYsIHRhYmxlRGF0YSwgdGFibGVPZmZzZXQpIHtcbiAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRhYmxlRGF0YSwgdGFibGVPZmZzZXQsIHByZXYpO1xuICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0YWJsZURhdGEsIHRhYmxlT2Zmc2V0LCB0b2tlbikgPCBpUHJldjtcbn1cblxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIExvb2thaGVhZC5NYXJnaW4gKi8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbih0cmVlLmxlbmd0aCwgTWF0aC5tYXgoY3Vyc29yLmZyb20gKyAxLCBwb3MgKyAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IDAgOiB0cmVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzLCBub2RlU2V0KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYWZlRnJvbSA9IC0xO1xuICAgICAgICB0aGlzLnNhZmVUbyA9IC0xO1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBuZXh0RnJhZ21lbnQoKSB7XG4gICAgICAgIGxldCBmciA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICAgICAgaWYgKGZyKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVGcm9tID0gZnIub3BlblN0YXJ0ID8gY3V0QXQoZnIudHJlZSwgZnIuZnJvbSArIGZyLm9mZnNldCwgMSkgLSBmci5vZmZzZXQgOiBmci5mcm9tO1xuICAgICAgICAgICAgdGhpcy5zYWZlVG8gPSBmci5vcGVuRW5kID8gY3V0QXQoZnIudHJlZSwgZnIudG8gKyBmci5vZmZzZXQsIC0xKSAtIGZyLm9mZnNldCA6IGZyLnRvO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHJlZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2goZnIudHJlZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goLWZyLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHRoaXMuc2FmZUZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IDFlOTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBgcG9zYCBtdXN0IGJlID49IGFueSBwcmV2aW91c2x5IGdpdmVuIGBwb3NgIGZvciB0aGlzIGN1cnNvclxuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2FmZVRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJlZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgeyAvLyBFbmQgb2YgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50cmVlc1tsYXN0XSwgaW5kZXggPSB0aGlzLmluZGV4W2xhc3RdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRvcC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnRbbGFzdF0gKyB0b3AucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHRoaXMuc2FmZUZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSBuZXh0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9va0FoZWFkIHx8IGVuZCArIGxvb2tBaGVhZCA8IHRoaXMuZnJhZ21lbnQudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIHBvcykpIHsgLy8gRW50ZXIgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrKSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IHRva2VuaXplcnMgfSA9IHBhcnNlcjtcbiAgICAgICAgbGV0IG1hc2sgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCAzIC8qIFBhcnNlU3RhdGUuVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3RhY2suY3VyQ29udGV4dCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgIGxldCBsb29rQWhlYWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKDEgPDwgaSkgJiBtYXNrKSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRva2VuaXplciA9IHRva2VuaXplcnNbaV0sIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAobWFpbiAmJiAhdG9rZW5pemVyLmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRva2VuaXplci5jb250ZXh0dWFsIHx8IHRva2VuLnN0YXJ0ICE9IHN0YWNrLnBvcyB8fCB0b2tlbi5tYXNrICE9IG1hc2sgfHwgdG9rZW4uY29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgdG9rZW4ubWFzayA9IG1hc2s7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4ubG9va0FoZWFkID4gdG9rZW4uZW5kICsgMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBNYXRoLm1heCh0b2tlbi5sb29rQWhlYWQsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgIT0gMCAvKiBUZXJtLkVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmIChsb29rQWhlYWQpXG4gICAgICAgICAgICBzdGFjay5zZXRMb29rQWhlYWQobG9va0FoZWFkKTtcbiAgICAgICAgaWYgKCFtYWluICYmIHN0YWNrLnBvcyA9PSB0aGlzLnN0cmVhbS5lbmQpIHtcbiAgICAgICAgICAgIG1haW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4gICAgICAgICAgICBtYWluLnZhbHVlID0gc3RhY2sucC5wYXJzZXIuZW9mVGVybTtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBtYWluLmVuZCA9IHN0YWNrLnBvcztcbiAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCBtYWluLnZhbHVlLCBtYWluLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgZ2V0TWFpblRva2VuKHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW5Ub2tlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW5Ub2tlbjtcbiAgICAgICAgbGV0IG1haW4gPSBuZXcgQ2FjaGVkVG9rZW4sIHsgcG9zLCBwIH0gPSBzdGFjaztcbiAgICAgICAgbWFpbi5zdGFydCA9IHBvcztcbiAgICAgICAgbWFpbi5lbmQgPSBNYXRoLm1pbihwb3MgKyAxLCBwLnN0cmVhbS5lbmQpO1xuICAgICAgICBtYWluLnZhbHVlID0gcG9zID09IHAuc3RyZWFtLmVuZCA/IHAucGFyc2VyLmVvZlRlcm0gOiAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhzdGFjay5wb3MpO1xuICAgICAgICB0b2tlbml6ZXIudG9rZW4odGhpcy5zdHJlYW0ucmVzZXQoc3RhcnQsIHRva2VuKSwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZXIuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zcGVjaWFsaXplZFtpXSA9PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VyLnNwZWNpYWxpemVyc1tpXSh0aGlzLnN0cmVhbS5yZWFkKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPj0gMCAmJiBzdGFjay5wLnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICB0b2tlbi5lbmQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBTZXEuT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAyKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0OyAvLyBcdTI2NTQsIFx1MjY1NSwgXHUyNjU2LCBcdTI2NTcsIFx1MjY1OCwgXHUyNjU5LCBcdTI2NjAsIFx1MjY2MSwgXHUyNjYyLCBcdTI2NjMsIFx1MjY2NCwgXHUyNjY1LCBcdTI2NjYsIFx1MjY2N1xuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gMDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMDtcbiAgICAgICAgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBJZiBhIGxhcmdlIGFtb3VudCBvZiByZWR1Y3Rpb25zIGhhcHBlbmVkIHdpdGggdGhlIHNhbWUgc3RhcnRcbiAgICAgICAgLy8gcG9zaXRpb24sIGZvcmNlIHRoZSBzdGFjayBvdXQgb2YgdGhhdCBwcm9kdWN0aW9uIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGF2b2lkIGNyZWF0aW5nIGEgdHJlZSB0b28gZGVlcCB0byByZWN1cnNlIHRocm91Z2guXG4gICAgICAgIC8vIChUaGlzIGlzIGFuIHVnbHkga2x1ZGdlLCBiZWNhdXNlIHVuZm9ydHVuYXRlbHkgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gc3RyYWlnaHRmb3J3YXJkLCBjaGVhcCB3YXkgdG8gY2hlY2sgZm9yIHRoaXMgaGFwcGVuaW5nLCBkdWUgdG9cbiAgICAgICAgLy8gdGhlIGhpc3Rvcnkgb2YgcmVkdWN0aW9ucyBvbmx5IGJlaW5nIGF2YWlsYWJsZSBpbiBhblxuICAgICAgICAvLyBleHBlbnNpdmUtdG8tYWNjZXNzIGZvcm1hdCBpbiB0aGUgc3RhY2sgYnVmZmVycy4pXG4gICAgICAgIGlmICh0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID4gMzAwIC8qIFJlYy5NYXhMZWZ0QXNzb2NpYXRpdmVSZWR1Y3Rpb25Db3VudCAqLyAmJiBzdGFja3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBbc10gPSBzdGFja3M7XG4gICAgICAgICAgICB3aGlsZSAocy5mb3JjZVJlZHVjZSgpICYmIHMuc3RhY2subGVuZ3RoICYmIHMuc3RhY2tbcy5zdGFjay5sZW5ndGggLSAyXSA+PSB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCkgeyB9XG4gICAgICAgICAgICB0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID0gdGhpcy5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCBhZHZhbmNpbmcgYW55IHN0YWNrcyBhdCBgcG9zYCB1bnRpbCB0aGV5IGVpdGhlciBtb3ZlXG4gICAgICAgIC8vIGZvcndhcmQgb3IgY2FuJ3QgYmUgYWR2YW5jZWQuIEdhdGhlciBzdGFja3MgdGhhdCBjYW4ndCBiZVxuICAgICAgICAvLyBhZHZhbmNlZCBmdXJ0aGVyIGluIGBzdG9wcGVkYC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLmdldE1haW5Ub2tlbihzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmluaXNoIHdpdGggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgJiYgc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdHVjayB3aXRoIHRva2VuIFwiICsgKHRoaXMudG9rZW5zLm1haW5Ub2tlbiA/IHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSA6IFwibm9uZVwiKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBSZWMuRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0b3BwZWRbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBzdG9wcGVkWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3JjZS1maW5pc2ggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBSZWMuTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8gJiYgb3RoZXIuYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8pIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8sIG5ld1N0YWNrcy5sZW5ndGggLSAxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1swXS5wb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5wb3MgPCB0aGlzLm1pblN0YWNrUG9zKVxuICAgICAgICAgICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiB0aGlzLnN0b3BwZWRBdCA8IHBvcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgbW92ZSBzdG9wcGVkQXQgZm9yd2FyZFwiKTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBzdGFjaywgb3IgbnVsbCBpZiB0aGVcbiAgICAvLyBzdGFjayBjYW4ndCBhZHZhbmNlIG5vcm1hbGx5LiBXaGVuIGBzcGxpdGAgYW5kIGBzdGFja3NgIGFyZVxuICAgIC8vIGdpdmVuLCBzdGFja3Mgc3BsaXQgb2ZmIGJ5IGFtYmlndW91cyBvcGVyYXRpb25zIHdpbGwgYmUgcHVzaGVkIHRvXG4gICAgLy8gYHNwbGl0YCwgb3IgYWRkZWQgdG8gYHN0YWNrc2AgaWYgdGhleSBtb3ZlIGBwb3NgIGZvcndhcmQuXG4gICAgYWR2YW5jZVN0YWNrKHN0YWNrLCBzdGFja3MsIHNwbGl0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YWNrLnBvcywgeyBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0YXJ0ID4gdGhpcy5zdG9wcGVkQXQpXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suZm9yY2VSZWR1Y2UoKSA/IHN0YWNrIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICBsZXQgc3RyaWN0Q3ggPSBzdGFjay5jdXJDb250ZXh0ICYmIHN0YWNrLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QsIGN4SGFzaCA9IHN0cmljdEN4ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNhY2hlZCA9IHRoaXMuZnJhZ21lbnRzLm5vZGVBdChzdGFydCk7IGNhY2hlZDspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2NhY2hlZC50eXBlLmlkXSA9PSBjYWNoZWQudHlwZSA/IHBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBjYWNoZWQudHlwZS5pZCkgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPiAtMSAmJiBjYWNoZWQubGVuZ3RoICYmICghc3RyaWN0Q3ggfHwgKGNhY2hlZC5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSB8fCAwKSA9PSBjeEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVzZU5vZGUoY2FjaGVkLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmV1c2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShjYWNoZWQudHlwZS5pZCl9KWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVkIGluc3RhbmNlb2YgVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgVHJlZSAmJiBjYWNoZWQucG9zaXRpb25zWzBdID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGlmIChkZWZhdWx0UmVkdWNlID4gMCkge1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlKGRlZmF1bHRSZWR1Y2UpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgYWx3YXlzLXJlZHVjZSAke3BhcnNlci5nZXROYW1lKGRlZmF1bHRSZWR1Y2UgJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suc3RhY2subGVuZ3RoID49IDg0MDAgLyogUmVjLkN1dERlcHRoICovKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2suc3RhY2subGVuZ3RoID4gNjAwMCAvKiBSZWMuQ3V0VG8gKi8gJiYgc3RhY2suZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLnRva2Vucy5nZXRBY3Rpb25zKHN0YWNrKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsZXQgbWFpbiA9IHRoaXMudG9rZW5zLm1haW5Ub2tlbjtcbiAgICAgICAgICAgIGxvY2FsU3RhY2suYXBwbHkoYWN0aW9uLCB0ZXJtLCBtYWluID8gbWFpbi5zdGFydCA6IGxvY2FsU3RhY2sucG9zLCBlbmQpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChsb2NhbFN0YWNrKSArIGAgKHZpYSAkeyhhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMCA/IFwic2hpZnRcIlxuICAgICAgICAgICAgICAgICAgICA6IGByZWR1Y2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovKX1gfSBmb3IgJHtwYXJzZXIuZ2V0TmFtZSh0ZXJtKX0gQCAke3N0YXJ0fSR7bG9jYWxTdGFjayA9PSBzdGFjayA/IFwiXCIgOiBcIiwgc3BsaXRcIn0pYCk7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsU3RhY2sucG9zID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgc3RhY2tzLnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3BsaXQucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkdmFuY2UgYSBnaXZlbiBzdGFjayBmb3J3YXJkIGFzIGZhciBhcyBpdCB3aWxsIGdvLiBSZXR1cm5zIHRoZVxuICAgIC8vIChwb3NzaWJseSB1cGRhdGVkKSBzdGFjayBpZiBpdCBnb3Qgc3R1Y2ssIG9yIG51bGwgaWYgaXQgbW92ZWRcbiAgICAvLyBmb3J3YXJkIGFuZCB3YXMgZ2l2ZW4gdG8gYHB1c2hTdGFja0RlZHVwYC5cbiAgICBhZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgcG9zID0gc3RhY2sucG9zO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBudWxsLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuUmVjb3Zlcnkoc3RhY2tzLCB0b2tlbnMsIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBudWxsLCByZXN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgdG9rZW4gPSB0b2tlbnNbaSA8PCAxXSwgdG9rZW5FbmQgPSB0b2tlbnNbKGkgPDwgMSkgKyAxXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoc3RhY2suZGVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIChyZXN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlID0gc3RhY2suc3BsaXQoKSwgZm9yY2VCYXNlID0gYmFzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTAgLyogUmVjLkZvcmNlUmVkdWNlTGltaXQgKi8gJiYgZm9yY2UuZm9yY2VSZWR1Y2UoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcmNlQmFzZSArIHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAodmlhIGZvcmNlLXJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShmb3JjZSwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbS5lbmQgPiBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5FbmQgPT0gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gMCAvKiBUZXJtLkVyciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucmVjb3ZlckJ5RGVsZXRlKHRva2VuLCB0b2tlbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJlY292ZXItZGVsZXRlICR7dGhpcy5wYXJzZXIuZ2V0TmFtZSh0b2tlbil9KWApO1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmlzaGVkIHx8IGZpbmlzaGVkLnNjb3JlIDwgZm9yY2Uuc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IGZvcmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgc3RhY2sncyBidWZmZXIgdG8gYSBzeW50YXggdHJlZS5cbiAgICBzdGFja1RvVHJlZShzdGFjaykge1xuICAgICAgICBzdGFjay5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gVHJlZS5idWlsZCh7IGJ1ZmZlcjogU3RhY2tCdWZmZXJDdXJzb3IuY3JlYXRlKHN0YWNrKSxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBsZW5ndGg6IHN0YWNrLnBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBtaW5SZXBlYXRUeXBlOiB0aGlzLnBhcnNlci5taW5SZXBlYXRUZXJtIH0pO1xuICAgIH1cbiAgICBzdGFja0lEKHN0YWNrKSB7XG4gICAgICAgIGxldCBpZCA9IChzdGFja0lEcyB8fCAoc3RhY2tJRHMgPSBuZXcgV2Vha01hcCkpLmdldChzdGFjayk7XG4gICAgICAgIGlmICghaWQpXG4gICAgICAgICAgICBzdGFja0lEcy5zZXQoc3RhY2ssIGlkID0gU3RyaW5nLmZyb21Db2RlUG9pbnQodGhpcy5uZXh0U3RhY2tJRCsrKSk7XG4gICAgICAgIHJldHVybiBpZCArIHN0YWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3NbaV07XG4gICAgICAgIGlmIChvdGhlci5wb3MgPT0gc3RhY2sucG9zICYmIG90aGVyLnNhbWVTdGF0ZShzdGFjaykpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0uc2NvcmUgPCBzdGFjay5zY29yZSlcbiAgICAgICAgICAgICAgICBuZXdTdGFja3NbaV0gPSBzdGFjaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG59XG5jbGFzcyBEaWFsZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGZsYWdzLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIGFsbG93cyh0ZXJtKSB7IHJldHVybiAhdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkW3Rlcm1dID09IDA7IH1cbn1cbmNvbnN0IGlkID0geCA9PiB4O1xuLyoqXG5Db250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbmluZGVudGF0aW9uIGluIHRoZSBQeXRob24gZ3JhbW1hciwgb3IgcGFyZW50IGVsZW1lbnRzIGluIHRoZSBYTUxcbmdyYW1tYXIpIG5lZWRlZCBieSBleHRlcm5hbCB0b2tlbml6ZXJzLiBZb3UgZGVjbGFyZSB0aGVtIGluIGFcbmdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuXG5Db250ZXh0IHZhbHVlcyBzaG91bGQgYmUgaW1tdXRhYmxlLCBhbmQgY2FuIGJlIHVwZGF0ZWQgKHJlcGxhY2VkKVxub24gc2hpZnQgb3IgcmVkdWNlIGFjdGlvbnMuXG5cblRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbnR5cGUuXG4qL1xuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8qKlxuICAgIERlZmluZSBhIGNvbnRleHQgdHJhY2tlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHNwZWMuc3RhcnQ7XG4gICAgICAgIHRoaXMuc2hpZnQgPSBzcGVjLnNoaWZ0IHx8IGlkO1xuICAgICAgICB0aGlzLnJlZHVjZSA9IHNwZWMucmVkdWNlIHx8IGlkO1xuICAgICAgICB0aGlzLnJldXNlID0gc3BlYy5yZXVzZSB8fCBpZDtcbiAgICAgICAgdGhpcy5oYXNoID0gc3BlYy5oYXNoIHx8ICgoKSA9PiAwKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBzcGVjLnN0cmljdCAhPT0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG5Ib2xkcyB0aGUgcGFyc2UgdGFibGVzIGZvciBhIGdpdmVuIGdyYW1tYXIsIGFzIGdlbmVyYXRlZCBieVxuYGxlemVyLWdlbmVyYXRvcmAsIGFuZCBwcm92aWRlcyBbbWV0aG9kc10oI2NvbW1vbi5QYXJzZXIpIHRvIHBhcnNlXG5jb250ZW50IHdpdGguXG4qL1xuY2xhc3MgTFJQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMud3JhcHBlcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxNCAvKiBGaWxlLlZlcnNpb24gKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUGFyc2VyIHZlcnNpb24gKCR7c3BlYy52ZXJzaW9ufSkgZG9lc24ndCBtYXRjaCBydW50aW1lIHZlcnNpb24gKCR7MTQgLyogRmlsZS5WZXJzaW9uICovfSlgKTtcbiAgICAgICAgbGV0IG5vZGVOYW1lcyA9IHNwZWMubm9kZU5hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdGhpcy5taW5SZXBlYXRUZXJtID0gbm9kZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnJlcGVhdE5vZGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgbm9kZU5hbWVzLnB1c2goXCJcIik7XG4gICAgICAgIGxldCB0b3BUZXJtcyA9IE9iamVjdC5rZXlzKHNwZWMudG9wUnVsZXMpLm1hcChyID0+IHNwZWMudG9wUnVsZXNbcl1bMV0pO1xuICAgICAgICBsZXQgbm9kZVByb3BzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZU5hbWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZVByb3BzLnB1c2goW10pO1xuICAgICAgICBmdW5jdGlvbiBzZXRQcm9wKG5vZGVJRCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIG5vZGVQcm9wc1tub2RlSURdLnB1c2goW3Byb3AsIHByb3AuZGVzZXJpYWxpemUoU3RyaW5nKHZhbHVlKSldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYy5ub2RlUHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wU3BlYyBvZiBzcGVjLm5vZGVQcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcHJvcFNwZWNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBOb2RlUHJvcFtwcm9wXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZU5hbWVzLm1hcCgobmFtZSwgaSkgPT4gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wU291cmNlcylcbiAgICAgICAgICAgIHRoaXMubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uc3BlYy5wcm9wU291cmNlcyk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHRva2VuQXJyYXkgPSBkZWNvZGVBcnJheShzcGVjLnRva2VuRGF0YSk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHNwZWMuY29udGV4dDtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplclNwZWNzID0gc3BlYy5zcGVjaWFsaXplZCB8fCBbXTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplZCA9IG5ldyBVaW50MTZBcnJheSh0aGlzLnNwZWNpYWxpemVyU3BlY3MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNwZWNpYWxpemVyU3BlY3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVkW2ldID0gdGhpcy5zcGVjaWFsaXplclNwZWNzW2ldLnRlcm07XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplclNwZWNzLm1hcChnZXRTcGVjaWFsaXplcik7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZXMsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZURhdGEpO1xuICAgICAgICB0aGlzLmdvdG8gPSBkZWNvZGVBcnJheShzcGVjLmdvdG8pO1xuICAgICAgICB0aGlzLm1heFRlcm0gPSBzcGVjLm1heFRlcm07XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IHNwZWMudG9rZW5pemVycy5tYXAodmFsdWUgPT4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyBuZXcgVG9rZW5Hcm91cCh0b2tlbkFycmF5LCB2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgIHRoaXMudG9wUnVsZXMgPSBzcGVjLnRvcFJ1bGVzO1xuICAgICAgICB0aGlzLmRpYWxlY3RzID0gc3BlYy5kaWFsZWN0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljUHJlY2VkZW5jZXMgPSBzcGVjLmR5bmFtaWNQcmVjZWRlbmNlcyB8fCBudWxsO1xuICAgICAgICB0aGlzLnRva2VuUHJlY1RhYmxlID0gc3BlYy50b2tlblByZWM7XG4gICAgICAgIHRoaXMudGVybU5hbWVzID0gc3BlYy50ZXJtTmFtZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tYXhOb2RlID0gdGhpcy5ub2RlU2V0LnR5cGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KCk7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3BSdWxlc1tPYmplY3Qua2V5cyh0aGlzLnRvcFJ1bGVzKVswXV07XG4gICAgfVxuICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSBuZXcgUGFyc2UodGhpcywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgdyBvZiB0aGlzLndyYXBwZXJzKVxuICAgICAgICAgICAgcGFyc2UgPSB3KHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICByZXR1cm4gcGFyc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGdvdG8gdGFibGUgZW50cnkgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiB0aGlzIHN0YXRlIGhhcyBhbiBhY3Rpb24gZm9yIGEgZ2l2ZW4gdGVybWluYWwgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNBY3Rpb24oc3RhdGUsIHRlcm1pbmFsKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFBhcnNlU3RhdGUuU2tpcCAqLyA6IDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKSwgbmV4dDs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmICgobmV4dCA9IGRhdGFbaV0pID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gZGF0YVtpID0gcGFpcihkYXRhLCBpICsgMildO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhW2kgKyAxXSA9PSAyIC8qIFNlcS5PdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IHRlcm1pbmFsIHx8IG5leHQgPT0gMCAvKiBUZXJtLkVyciAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRlU2xvdChzdGF0ZSwgc2xvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbKHN0YXRlICogNiAvKiBQYXJzZVN0YXRlLlNpemUgKi8pICsgc2xvdF07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGVGbGFnKHN0YXRlLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogUGFyc2VTdGF0ZS5GbGFncyAqLykgJiBmbGFnKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsaWRBY3Rpb24oc3RhdGUsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gISF0aGlzLmFsbEFjdGlvbnMoc3RhdGUsIGEgPT4gYSA9PSBhY3Rpb24gPyB0cnVlIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWxsQWN0aW9ucyhzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGxldCBkZWZsdCA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBkZWZsdCA/IGFjdGlvbihkZWZsdCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOyByZXN1bHQgPT0gbnVsbDsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gYWN0aW9uKHBhaXIodGhpcy5kYXRhLCBpICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgc3RhdGVzIHRoYXQgY2FuIGZvbGxvdyB0aGlzIG9uZSB0aHJvdWdoIHNoaWZ0IGFjdGlvbnMgb3JcbiAgICBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5leHRTdGF0ZXMoc3RhdGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLyA+PiAxNikpID09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZGF0YVtpXSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbmZpZ3VyZSB0aGUgcGFyc2VyLiBSZXR1cm5zIGEgbmV3IHBhcnNlciBpbnN0YW5jZSB0aGF0IGhhcyB0aGVcbiAgICBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIGtlcHQgZnJvbSB0aGUgb3JpZ2luYWwgcGFyc2VyLlxuICAgICovXG4gICAgY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICAvLyBIaWRlb3VzIHJlZmxlY3Rpb24tYmFzZWQga2x1ZGdlIHRvIG1ha2UgaXQgZWFzeSB0byBjcmVhdGUgYVxuICAgICAgICAvLyBzbGlnaHRseSBtb2RpZmllZCBjb3B5IG9mIGEgcGFyc2VyLlxuICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShMUlBhcnNlci5wcm90b3R5cGUpLCB0aGlzKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9wcylcbiAgICAgICAgICAgIGNvcHkubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uY29uZmlnLnByb3BzKTtcbiAgICAgICAgaWYgKGNvbmZpZy50b3ApIHtcbiAgICAgICAgICAgIGxldCBpbmZvID0gdGhpcy50b3BSdWxlc1tjb25maWcudG9wXTtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCB0b3AgcnVsZSBuYW1lICR7Y29uZmlnLnRvcH1gKTtcbiAgICAgICAgICAgIGNvcHkudG9wID0gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnRva2VuaXplcnMpXG4gICAgICAgICAgICBjb3B5LnRva2VuaXplcnMgPSB0aGlzLnRva2VuaXplcnMubWFwKHQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy50b2tlbml6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gZm91bmQudG8gOiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuc3BlY2lhbGl6ZXJzKSB7XG4gICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVycyA9IHRoaXMuc3BlY2lhbGl6ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyU3BlY3MgPSB0aGlzLnNwZWNpYWxpemVyU3BlY3MubWFwKChzLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnNwZWNpYWxpemVycy5maW5kKHIgPT4gci5mcm9tID09IHMuZXh0ZXJuYWwpO1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIGxldCBzcGVjID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzKSwgeyBleHRlcm5hbDogZm91bmQudG8gfSk7XG4gICAgICAgICAgICAgICAgY29weS5zcGVjaWFsaXplcnNbaV0gPSBnZXRTcGVjaWFsaXplcihzcGVjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuY29udGV4dFRyYWNrZXIpXG4gICAgICAgICAgICBjb3B5LmNvbnRleHQgPSBjb25maWcuY29udGV4dFRyYWNrZXI7XG4gICAgICAgIGlmIChjb25maWcuZGlhbGVjdClcbiAgICAgICAgICAgIGNvcHkuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KGNvbmZpZy5kaWFsZWN0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpY3QgIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuc3RyaWN0ID0gY29uZmlnLnN0cmljdDtcbiAgICAgICAgaWYgKGNvbmZpZy53cmFwKVxuICAgICAgICAgICAgY29weS53cmFwcGVycyA9IGNvcHkud3JhcHBlcnMuY29uY2F0KGNvbmZpZy53cmFwKTtcbiAgICAgICAgaWYgKGNvbmZpZy5idWZmZXJMZW5ndGggIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuYnVmZmVyTGVuZ3RoID0gY29uZmlnLmJ1ZmZlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIGFueSBbcGFyc2Ugd3JhcHBlcnNdKCNsci5QYXJzZXJDb25maWcud3JhcClcbiAgICBhcmUgcmVnaXN0ZXJlZCBmb3IgdGhpcyBwYXJzZXIuXG4gICAgKi9cbiAgICBoYXNXcmFwcGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlcnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZXJtLiBUaGlzIHdpbGwgb25seVxuICAgIHdvcmsgZm9yIGFsbCB0ZXJtcyB3aGVuIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCB3aXRoIHRoZVxuICAgIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICBzdG9yZWQuXG4gICAgKi9cbiAgICBnZXROYW1lKHRlcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybU5hbWVzID8gdGhpcy50ZXJtTmFtZXNbdGVybV0gOiBTdHJpbmcodGVybSA8PSB0aGlzLm1heE5vZGUgJiYgdGhpcy5ub2RlU2V0LnR5cGVzW3Rlcm1dLm5hbWUgfHwgdGVybSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgdHlwZXMuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVvZlRlcm0oKSB7IHJldHVybiB0aGlzLm1heE5vZGUgKyAxOyB9XG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdG9wIG5vZGUgcHJvZHVjZWQgYnkgdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGdldCB0b3BOb2RlKCkgeyByZXR1cm4gdGhpcy5ub2RlU2V0LnR5cGVzW3RoaXMudG9wWzFdXTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXJzZURpYWxlY3QoZGlhbGVjdCkge1xuICAgICAgICBsZXQgdmFsdWVzID0gT2JqZWN0LmtleXModGhpcy5kaWFsZWN0cyksIGZsYWdzID0gdmFsdWVzLm1hcCgoKSA9PiBmYWxzZSk7XG4gICAgICAgIGlmIChkaWFsZWN0KVxuICAgICAgICAgICAgZm9yIChsZXQgcGFydCBvZiBkaWFsZWN0LnNwbGl0KFwiIFwiKSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHZhbHVlcy5pbmRleE9mKHBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpZCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBmbGFnc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghZmxhZ3NbaV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5kaWFsZWN0c1t2YWx1ZXNbaV1dLCBpZDsgKGlkID0gdGhpcy5kYXRhW2orK10pICE9IDY1NTM1IC8qIFNlcS5FbmQgKi87KVxuICAgICAgICAgICAgICAgICAgICAoZGlzYWJsZWQgfHwgKGRpc2FibGVkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhUZXJtICsgMSkpKVtpZF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERpYWxlY3QoZGlhbGVjdCwgZmxhZ3MsIGRpc2FibGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNlZCBieSB0aGUgb3V0cHV0IG9mIHRoZSBwYXJzZXIgZ2VuZXJhdG9yLiBOb3QgYXZhaWxhYmxlIHRvXG4gICAgdXNlciBjb2RlLiBAaGlkZVxuICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUlBhcnNlcihzcGVjKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYWlyKGRhdGEsIG9mZikgeyByZXR1cm4gZGF0YVtvZmZdIHwgKGRhdGFbb2ZmICsgMV0gPDwgMTYpOyB9XG5mdW5jdGlvbiBmaW5kRmluaXNoZWQoc3RhY2tzKSB7XG4gICAgbGV0IGJlc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBsZXQgc3RvcHBlZCA9IHN0YWNrLnAuc3RvcHBlZEF0O1xuICAgICAgICBpZiAoKHN0YWNrLnBvcyA9PSBzdGFjay5wLnN0cmVhbS5lbmQgfHwgc3RvcHBlZCAhPSBudWxsICYmIHN0YWNrLnBvcyA+IHN0b3BwZWQpICYmXG4gICAgICAgICAgICBzdGFjay5wLnBhcnNlci5zdGF0ZUZsYWcoc3RhY2suc3RhdGUsIDIgLyogU3RhdGVGbGFnLkFjY2VwdGluZyAqLykgJiZcbiAgICAgICAgICAgICghYmVzdCB8fCBiZXN0LnNjb3JlIDwgc3RhY2suc2NvcmUpKVxuICAgICAgICAgICAgYmVzdCA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cbmZ1bmN0aW9uIGdldFNwZWNpYWxpemVyKHNwZWMpIHtcbiAgICBpZiAoc3BlYy5leHRlcm5hbCkge1xuICAgICAgICBsZXQgbWFzayA9IHNwZWMuZXh0ZW5kID8gMSAvKiBTcGVjaWFsaXplLkV4dGVuZCAqLyA6IDAgLyogU3BlY2lhbGl6ZS5TcGVjaWFsaXplICovO1xuICAgICAgICByZXR1cm4gKHZhbHVlLCBzdGFjaykgPT4gKHNwZWMuZXh0ZXJuYWwodmFsdWUsIHN0YWNrKSA8PCAxKSB8IG1hc2s7XG4gICAgfVxuICAgIHJldHVybiBzcGVjLmdldDtcbn1cblxuZXhwb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBJbnB1dFN0cmVhbSwgTFJQYXJzZXIsIExvY2FsVG9rZW5Hcm91cCwgU3RhY2sgfTtcbiIsICJpbXBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIExSUGFyc2VyIH0gZnJvbSAnQGxlemVyL2xyJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuaW1wb3J0IHsgcGFyc2VNaXhlZCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNjcmlwdFRleHQgPSA1NSxcbiAgU3RhcnRDbG9zZVNjcmlwdFRhZyA9IDEsXG4gIHN0eWxlVGV4dCA9IDU2LFxuICBTdGFydENsb3NlU3R5bGVUYWcgPSAyLFxuICB0ZXh0YXJlYVRleHQgPSA1NyxcbiAgU3RhcnRDbG9zZVRleHRhcmVhVGFnID0gMyxcbiAgRW5kVGFnID0gNCxcbiAgU2VsZkNsb3NpbmdFbmRUYWcgPSA1LFxuICBTdGFydFRhZyA9IDYsXG4gIFN0YXJ0U2NyaXB0VGFnID0gNyxcbiAgU3RhcnRTdHlsZVRhZyA9IDgsXG4gIFN0YXJ0VGV4dGFyZWFUYWcgPSA5LFxuICBTdGFydFNlbGZDbG9zaW5nVGFnID0gMTAsXG4gIFN0YXJ0Q2xvc2VUYWcgPSAxMSxcbiAgTm9NYXRjaFN0YXJ0Q2xvc2VUYWcgPSAxMixcbiAgTWlzbWF0Y2hlZFN0YXJ0Q2xvc2VUYWcgPSAxMyxcbiAgbWlzc2luZ0Nsb3NlVGFnID0gNTgsXG4gIEluY29tcGxldGVUYWcgPSAxNCxcbiAgSW5jb21wbGV0ZUNsb3NlVGFnID0gMTUsXG4gIGNvbW1lbnRDb250ZW50JDEgPSA1OSxcbiAgRWxlbWVudCA9IDIxLFxuICBUYWdOYW1lID0gMjMsXG4gIEF0dHJpYnV0ZSA9IDI0LFxuICBBdHRyaWJ1dGVOYW1lID0gMjUsXG4gIEF0dHJpYnV0ZVZhbHVlID0gMjcsXG4gIFVucXVvdGVkQXR0cmlidXRlVmFsdWUgPSAyOCxcbiAgU2NyaXB0VGV4dCA9IDI5LFxuICBTdHlsZVRleHQgPSAzMixcbiAgVGV4dGFyZWFUZXh0ID0gMzUsXG4gIE9wZW5UYWcgPSAzNyxcbiAgQ2xvc2VUYWcgPSAzOCxcbiAgRGlhbGVjdF9ub01hdGNoID0gMCxcbiAgRGlhbGVjdF9zZWxmQ2xvc2luZyA9IDE7XG5cbi8qIEhhbmQtd3JpdHRlbiB0b2tlbml6ZXJzIGZvciBIVE1MLiAqL1xuXG5jb25zdCBzZWxmQ2xvc2VycyA9IHtcbiAgYXJlYTogdHJ1ZSwgYmFzZTogdHJ1ZSwgYnI6IHRydWUsIGNvbDogdHJ1ZSwgY29tbWFuZDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsIGZyYW1lOiB0cnVlLCBocjogdHJ1ZSwgaW1nOiB0cnVlLCBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLCBsaW5rOiB0cnVlLCBtZXRhOiB0cnVlLCBwYXJhbTogdHJ1ZSwgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSwgd2JyOiB0cnVlLCBtZW51aXRlbTogdHJ1ZVxufTtcblxuY29uc3QgaW1wbGljaXRseUNsb3NlZCA9IHtcbiAgZGQ6IHRydWUsIGxpOiB0cnVlLCBvcHRncm91cDogdHJ1ZSwgb3B0aW9uOiB0cnVlLCBwOiB0cnVlLFxuICBycDogdHJ1ZSwgcnQ6IHRydWUsIHRib2R5OiB0cnVlLCB0ZDogdHJ1ZSwgdGZvb3Q6IHRydWUsXG4gIHRoOiB0cnVlLCB0cjogdHJ1ZVxufTtcblxuY29uc3QgY2xvc2VPbk9wZW4gPSB7XG4gIGRkOiB7ZGQ6IHRydWUsIGR0OiB0cnVlfSxcbiAgZHQ6IHtkZDogdHJ1ZSwgZHQ6IHRydWV9LFxuICBsaToge2xpOiB0cnVlfSxcbiAgb3B0aW9uOiB7b3B0aW9uOiB0cnVlLCBvcHRncm91cDogdHJ1ZX0sXG4gIG9wdGdyb3VwOiB7b3B0Z3JvdXA6IHRydWV9LFxuICBwOiB7XG4gICAgYWRkcmVzczogdHJ1ZSwgYXJ0aWNsZTogdHJ1ZSwgYXNpZGU6IHRydWUsIGJsb2NrcXVvdGU6IHRydWUsIGRpcjogdHJ1ZSxcbiAgICBkaXY6IHRydWUsIGRsOiB0cnVlLCBmaWVsZHNldDogdHJ1ZSwgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLFxuICAgIGgxOiB0cnVlLCBoMjogdHJ1ZSwgaDM6IHRydWUsIGg0OiB0cnVlLCBoNTogdHJ1ZSwgaDY6IHRydWUsXG4gICAgaGVhZGVyOiB0cnVlLCBoZ3JvdXA6IHRydWUsIGhyOiB0cnVlLCBtZW51OiB0cnVlLCBuYXY6IHRydWUsIG9sOiB0cnVlLFxuICAgIHA6IHRydWUsIHByZTogdHJ1ZSwgc2VjdGlvbjogdHJ1ZSwgdGFibGU6IHRydWUsIHVsOiB0cnVlXG4gIH0sXG4gIHJwOiB7cnA6IHRydWUsIHJ0OiB0cnVlfSxcbiAgcnQ6IHtycDogdHJ1ZSwgcnQ6IHRydWV9LFxuICB0Ym9keToge3Rib2R5OiB0cnVlLCB0Zm9vdDogdHJ1ZX0sXG4gIHRkOiB7dGQ6IHRydWUsIHRoOiB0cnVlfSxcbiAgdGZvb3Q6IHt0Ym9keTogdHJ1ZX0sXG4gIHRoOiB7dGQ6IHRydWUsIHRoOiB0cnVlfSxcbiAgdGhlYWQ6IHt0Ym9keTogdHJ1ZSwgdGZvb3Q6IHRydWV9LFxuICB0cjoge3RyOiB0cnVlfVxufTtcblxuZnVuY3Rpb24gbmFtZUNoYXIoY2gpIHtcbiAgcmV0dXJuIGNoID09IDQ1IHx8IGNoID09IDQ2IHx8IGNoID09IDU4IHx8IGNoID49IDY1ICYmIGNoIDw9IDkwIHx8IGNoID09IDk1IHx8IGNoID49IDk3ICYmIGNoIDw9IDEyMiB8fCBjaCA+PSAxNjFcbn1cblxubGV0IGNhY2hlZE5hbWUgPSBudWxsLCBjYWNoZWRJbnB1dCA9IG51bGwsIGNhY2hlZFBvcyA9IDA7XG5mdW5jdGlvbiB0YWdOYW1lQWZ0ZXIoaW5wdXQsIG9mZnNldCkge1xuICBsZXQgcG9zID0gaW5wdXQucG9zICsgb2Zmc2V0O1xuICBpZiAoY2FjaGVkUG9zID09IHBvcyAmJiBjYWNoZWRJbnB1dCA9PSBpbnB1dCkgcmV0dXJuIGNhY2hlZE5hbWVcbiAgbGV0IG5leHQgPSBpbnB1dC5wZWVrKG9mZnNldCksIG5hbWUgPSBcIlwiO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKCFuYW1lQ2hhcihuZXh0KSkgYnJlYWtcbiAgICBuYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dCk7XG4gICAgbmV4dCA9IGlucHV0LnBlZWsoKytvZmZzZXQpO1xuICB9XG4gIC8vIFVuZGVmaW5lZCB0byBzaWduYWwgdGhlcmUncyBhIDw/IG9yIDwhLCBudWxsIGZvciBqdXN0IG1pc3NpbmdcbiAgY2FjaGVkSW5wdXQgPSBpbnB1dDsgY2FjaGVkUG9zID0gcG9zO1xuICByZXR1cm4gY2FjaGVkTmFtZSA9IG5hbWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiBuZXh0ID09IHF1ZXN0aW9uIHx8IG5leHQgPT0gYmFuZyA/IHVuZGVmaW5lZCA6IG51bGxcbn1cblxuY29uc3QgbGVzc1RoYW4gPSA2MCwgZ3JlYXRlclRoYW4gPSA2Miwgc2xhc2ggPSA0NywgcXVlc3Rpb24gPSA2MywgYmFuZyA9IDMzLCBkYXNoID0gNDU7XG5cbmZ1bmN0aW9uIEVsZW1lbnRDb250ZXh0KG5hbWUsIHBhcmVudCkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbn1cblxuY29uc3Qgc3RhcnRUYWdUZXJtcyA9IFtTdGFydFRhZywgU3RhcnRTZWxmQ2xvc2luZ1RhZywgU3RhcnRTY3JpcHRUYWcsIFN0YXJ0U3R5bGVUYWcsIFN0YXJ0VGV4dGFyZWFUYWddO1xuXG5jb25zdCBlbGVtZW50Q29udGV4dCA9IG5ldyBDb250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiBudWxsLFxuICBzaGlmdChjb250ZXh0LCB0ZXJtLCBzdGFjaywgaW5wdXQpIHtcbiAgICByZXR1cm4gc3RhcnRUYWdUZXJtcy5pbmRleE9mKHRlcm0pID4gLTEgPyBuZXcgRWxlbWVudENvbnRleHQodGFnTmFtZUFmdGVyKGlucHV0LCAxKSB8fCBcIlwiLCBjb250ZXh0KSA6IGNvbnRleHRcbiAgfSxcbiAgcmVkdWNlKGNvbnRleHQsIHRlcm0pIHtcbiAgICByZXR1cm4gdGVybSA9PSBFbGVtZW50ICYmIGNvbnRleHQgPyBjb250ZXh0LnBhcmVudCA6IGNvbnRleHRcbiAgfSxcbiAgcmV1c2UoY29udGV4dCwgbm9kZSwgc3RhY2ssIGlucHV0KSB7XG4gICAgbGV0IHR5cGUgPSBub2RlLnR5cGUuaWQ7XG4gICAgcmV0dXJuIHR5cGUgPT0gU3RhcnRUYWcgfHwgdHlwZSA9PSBPcGVuVGFnXG4gICAgICA/IG5ldyBFbGVtZW50Q29udGV4dCh0YWdOYW1lQWZ0ZXIoaW5wdXQsIDEpIHx8IFwiXCIsIGNvbnRleHQpIDogY29udGV4dFxuICB9LFxuICBzdHJpY3Q6IGZhbHNlXG59KTtcblxuY29uc3QgdGFnU3RhcnQgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCAhPSBsZXNzVGhhbikge1xuICAgIC8vIEVuZCBvZiBmaWxlLCBjbG9zZSBhbnkgb3BlbiB0YWdzXG4gICAgaWYgKGlucHV0Lm5leHQgPCAwICYmIHN0YWNrLmNvbnRleHQpIGlucHV0LmFjY2VwdFRva2VuKG1pc3NpbmdDbG9zZVRhZyk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaW5wdXQuYWR2YW5jZSgpO1xuICBsZXQgY2xvc2UgPSBpbnB1dC5uZXh0ID09IHNsYXNoO1xuICBpZiAoY2xvc2UpIGlucHV0LmFkdmFuY2UoKTtcbiAgbGV0IG5hbWUgPSB0YWdOYW1lQWZ0ZXIoaW5wdXQsIDApO1xuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgaWYgKCFuYW1lKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oY2xvc2UgPyBJbmNvbXBsZXRlQ2xvc2VUYWcgOiBJbmNvbXBsZXRlVGFnKVxuXG4gIGxldCBwYXJlbnQgPSBzdGFjay5jb250ZXh0ID8gc3RhY2suY29udGV4dC5uYW1lIDogbnVsbDtcbiAgaWYgKGNsb3NlKSB7XG4gICAgaWYgKG5hbWUgPT0gcGFyZW50KSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRDbG9zZVRhZylcbiAgICBpZiAocGFyZW50ICYmIGltcGxpY2l0bHlDbG9zZWRbcGFyZW50XSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKG1pc3NpbmdDbG9zZVRhZywgLTIpXG4gICAgaWYgKHN0YWNrLmRpYWxlY3RFbmFibGVkKERpYWxlY3Rfbm9NYXRjaCkpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihOb01hdGNoU3RhcnRDbG9zZVRhZylcbiAgICBmb3IgKGxldCBjeCA9IHN0YWNrLmNvbnRleHQ7IGN4OyBjeCA9IGN4LnBhcmVudCkgaWYgKGN4Lm5hbWUgPT0gbmFtZSkgcmV0dXJuXG4gICAgaW5wdXQuYWNjZXB0VG9rZW4oTWlzbWF0Y2hlZFN0YXJ0Q2xvc2VUYWcpO1xuICB9IGVsc2Uge1xuICAgIGlmIChuYW1lID09IFwic2NyaXB0XCIpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFNjcmlwdFRhZylcbiAgICBpZiAobmFtZSA9PSBcInN0eWxlXCIpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFN0eWxlVGFnKVxuICAgIGlmIChuYW1lID09IFwidGV4dGFyZWFcIikgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0VGV4dGFyZWFUYWcpXG4gICAgaWYgKHNlbGZDbG9zZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRTZWxmQ2xvc2luZ1RhZylcbiAgICBpZiAocGFyZW50ICYmIGNsb3NlT25PcGVuW3BhcmVudF0gJiYgY2xvc2VPbk9wZW5bcGFyZW50XVtuYW1lXSkgaW5wdXQuYWNjZXB0VG9rZW4obWlzc2luZ0Nsb3NlVGFnLCAtMSk7XG4gICAgZWxzZSBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFRhZyk7XG4gIH1cbn0sIHtjb250ZXh0dWFsOiB0cnVlfSk7XG5cbmNvbnN0IGNvbW1lbnRDb250ZW50ID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgZm9yIChsZXQgZGFzaGVzID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICBpZiAoaW5wdXQubmV4dCA8IDApIHtcbiAgICAgIGlmIChpKSBpbnB1dC5hY2NlcHRUb2tlbihjb21tZW50Q29udGVudCQxKTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnB1dC5uZXh0ID09IGRhc2gpIHtcbiAgICAgIGRhc2hlcysrO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQubmV4dCA9PSBncmVhdGVyVGhhbiAmJiBkYXNoZXMgPj0gMikge1xuICAgICAgaWYgKGkgPj0gMykgaW5wdXQuYWNjZXB0VG9rZW4oY29tbWVudENvbnRlbnQkMSwgLTIpO1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgZGFzaGVzID0gMDtcbiAgICB9XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gaW5Gb3JlaWduRWxlbWVudChjb250ZXh0KSB7XG4gIGZvciAoOyBjb250ZXh0OyBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQpXG4gICAgaWYgKGNvbnRleHQubmFtZSA9PSBcInN2Z1wiIHx8IGNvbnRleHQubmFtZSA9PSBcIm1hdGhcIikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IGVuZFRhZyA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGlmIChpbnB1dC5uZXh0ID09IHNsYXNoICYmIGlucHV0LnBlZWsoMSkgPT0gZ3JlYXRlclRoYW4pIHtcbiAgICBsZXQgc2VsZkNsb3NpbmcgPSBzdGFjay5kaWFsZWN0RW5hYmxlZChEaWFsZWN0X3NlbGZDbG9zaW5nKSB8fCBpbkZvcmVpZ25FbGVtZW50KHN0YWNrLmNvbnRleHQpO1xuICAgIGlucHV0LmFjY2VwdFRva2VuKHNlbGZDbG9zaW5nID8gU2VsZkNsb3NpbmdFbmRUYWcgOiBFbmRUYWcsIDIpO1xuICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgPT0gZ3JlYXRlclRoYW4pIHtcbiAgICBpbnB1dC5hY2NlcHRUb2tlbihFbmRUYWcsIDEpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gY29udGVudFRva2VuaXplcih0YWcsIHRleHRUb2tlbiwgZW5kVG9rZW4pIHtcbiAgbGV0IGxhc3RTdGF0ZSA9IDIgKyB0YWcubGVuZ3RoO1xuICByZXR1cm4gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgICAvLyBzdGF0ZSBtZWFuczpcbiAgICAvLyAtIDAgbm90aGluZyBtYXRjaGVkXG4gICAgLy8gLSAxICc8JyBtYXRjaGVkXG4gICAgLy8gLSAyICc8LydcbiAgICAvLyAtIDMtKDErdGFnLmxlbmd0aCkgcGFydCBvZiB0aGUgdGFnIG1hdGNoZWRcbiAgICAvLyAtIGxhc3RTdGF0ZSB3aG9sZSB0YWcgKyBwb3NzaWJseSB3aGl0ZXNwYWNlIG1hdGNoZWRcbiAgICBmb3IgKGxldCBzdGF0ZSA9IDAsIG1hdGNoZWRMZW4gPSAwLCBpID0gMDs7IGkrKykge1xuICAgICAgaWYgKGlucHV0Lm5leHQgPCAwKSB7XG4gICAgICAgIGlmIChpKSBpbnB1dC5hY2NlcHRUb2tlbih0ZXh0VG9rZW4pO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09IDAgJiYgaW5wdXQubmV4dCA9PSBsZXNzVGhhbiB8fFxuICAgICAgICAgIHN0YXRlID09IDEgJiYgaW5wdXQubmV4dCA9PSBzbGFzaCB8fFxuICAgICAgICAgIHN0YXRlID49IDIgJiYgc3RhdGUgPCBsYXN0U3RhdGUgJiYgaW5wdXQubmV4dCA9PSB0YWcuY2hhckNvZGVBdChzdGF0ZSAtIDIpKSB7XG4gICAgICAgIHN0YXRlKys7XG4gICAgICAgIG1hdGNoZWRMZW4rKztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gbGFzdFN0YXRlICYmIGlucHV0Lm5leHQgPT0gZ3JlYXRlclRoYW4pIHtcbiAgICAgICAgaWYgKGkgPiBtYXRjaGVkTGVuKVxuICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRleHRUb2tlbiwgLW1hdGNoZWRMZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4oZW5kVG9rZW4sIC0obWF0Y2hlZExlbiAtIDIpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAoKGlucHV0Lm5leHQgPT0gMTAgLyogJ1xcbicgKi8gfHwgaW5wdXQubmV4dCA9PSAxMyAvKiAnXFxyJyAqLykgJiYgaSkge1xuICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXh0VG9rZW4sIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSBtYXRjaGVkTGVuID0gMDtcbiAgICAgIH1cbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICB9XG4gIH0pXG59XG5cbmNvbnN0IHNjcmlwdFRva2VucyA9IGNvbnRlbnRUb2tlbml6ZXIoXCJzY3JpcHRcIiwgc2NyaXB0VGV4dCwgU3RhcnRDbG9zZVNjcmlwdFRhZyk7XG5cbmNvbnN0IHN0eWxlVG9rZW5zID0gY29udGVudFRva2VuaXplcihcInN0eWxlXCIsIHN0eWxlVGV4dCwgU3RhcnRDbG9zZVN0eWxlVGFnKTtcblxuY29uc3QgdGV4dGFyZWFUb2tlbnMgPSBjb250ZW50VG9rZW5pemVyKFwidGV4dGFyZWFcIiwgdGV4dGFyZWFUZXh0LCBTdGFydENsb3NlVGV4dGFyZWFUYWcpO1xuXG5jb25zdCBodG1sSGlnaGxpZ2h0aW5nID0gc3R5bGVUYWdzKHtcbiAgXCJUZXh0IFJhd1RleHQgSW5jb21wbGV0ZVRhZyBJbmNvbXBsZXRlQ2xvc2VUYWdcIjogdGFncy5jb250ZW50LFxuICBcIlN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWcgU2VsZkNsb3NpbmdFbmRUYWcgRW5kVGFnXCI6IHRhZ3MuYW5nbGVCcmFja2V0LFxuICBUYWdOYW1lOiB0YWdzLnRhZ05hbWUsXG4gIFwiTWlzbWF0Y2hlZENsb3NlVGFnL1RhZ05hbWVcIjogW3RhZ3MudGFnTmFtZSwgIHRhZ3MuaW52YWxpZF0sXG4gIEF0dHJpYnV0ZU5hbWU6IHRhZ3MuYXR0cmlidXRlTmFtZSxcbiAgXCJBdHRyaWJ1dGVWYWx1ZSBVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlXCI6IHRhZ3MuYXR0cmlidXRlVmFsdWUsXG4gIElzOiB0YWdzLmRlZmluaXRpb25PcGVyYXRvcixcbiAgXCJFbnRpdHlSZWZlcmVuY2UgQ2hhcmFjdGVyUmVmZXJlbmNlXCI6IHRhZ3MuY2hhcmFjdGVyLFxuICBDb21tZW50OiB0YWdzLmJsb2NrQ29tbWVudCxcbiAgUHJvY2Vzc2luZ0luc3Q6IHRhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLFxuICBEb2N0eXBlRGVjbDogdGFncy5kb2N1bWVudE1ldGFcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIseE9WTyFyT09PIVpRI3RPJyNDck8hYFEjdE8nI0N7TyFlUSN0TycjRE9PIWpRI3RPJyNEUk8hb1EjdE8nI0RUTyF0T2FPJyNDcU8jUE9iTycjQ3FPI1tPZE8nI0NxTyRrTyFyTycjQ3FPT09gJyNDcScjQ3FPJHJPJGZPJyNEVU8kelEjdE8nI0RXTyVQUSN0TycjRFhPT09gJyNEbCcjRGxPT09gJyNEWicjRFpRVk8hck9PTyVVUSZyTyw1OV5PJWFRJnJPLDU5Z08lbFEmck8sNTlqTyV3USZyTyw1OW1PJlNRJnJPLDU5b09PT2EnI0RfJyNEX08mX09hTycjQ3lPJmpPYU8sNTldT09PYicjRGAnI0RgTyZyT2JPJyNDfE8mfU9iTyw1OV1PT09kJyNEYScjRGFPJ1ZPZE8nI0RQTydiT2RPLDU5XU9PT2AnI0RiJyNEYk8nak8hck8sNTldTydxUSN0TycjRFNPT09gLDU5XSw1OV1PT09wJyNEYycjRGNPJ3ZPJGZPLDU5cE9PT2AsNTlwLDU5cE8oT1EjfE8sNTlyTyhUUSN8Tyw1OXNPT09gLUU3WC1FN1hPKFlRJnJPJyNDdE9PUVcnI0RbJyNEW08oaFEmck8xRy54T09PYTFHLngxRy54T09PYDFHL1oxRy9aTyhzUSZyTzFHL1JPT09iMUcvUjFHL1JPKU9RJnJPMUcvVU9PT2QxRy9VMUcvVU8pWlEmck8xRy9YT09PYDFHL1gxRy9YTylmUSZyTzFHL1pPT09hLUU3XS1FN11PKXFRI3RPJyNDek9PT2AxRy53MUcud09PT2ItRTdeLUU3Xk8pdlEjdE8nI0N9T09PZC1FN18tRTdfTyl7USN0TycjRFFPT09gLUU3YC1FN2BPKlFRI3xPLDU5bk9PT3AtRTdhLUU3YU9PT2AxRy9bMUcvW09PT2AxRy9eMUcvXk9PT2AxRy9fMUcvX08qVlEsVU8sNTlgT09RVy1FN1ktRTdZT09PYTcrJGQ3KyRkT09PYDcrJHU3KyR1T09PYjcrJG03KyRtT09PZDcrJHA3KyRwT09PYDcrJHM3KyRzTypiUSN8Tyw1OWZPKmdRI3xPLDU5aU8qbFEjfE8sNTlsT09PYDFHL1kxRy9ZTypxTzdbTycjQ3dPK1NPTWhPJyNDd09PUVcxRy56MUcuek9PT2AxRy9RMUcvUU9PT2AxRy9UMUcvVE9PT2AxRy9XMUcvV09PT08nI0RdJyNEXU8rZU83W08sNTljT09RVyw1OWMsNTljT09PTycjRF4nI0ReTyt2T01oTyw1OWNPT09PLUU3Wi1FN1pPT1FXMUcufTFHLn1PT09PLUU3Wy1FN1tcIixcbiAgc3RhdGVEYXRhOiBcIixjfk8hX09Tfk9VU09WUE9XUU9YUk9ZVE9bXU9dW09eXk9fXk9hXk9iXk9jXk9kXk95Xk98X08hZVpPfk9nYU9+T2diT35PZ2NPfk9nZE9+T2dlT35PIVhmT1BtUCFbbVB+TyFZaU9RcFAhW3BQfk8hWmxPUnNQIVtzUH5PVVNPVlBPV1FPWFJPWVRPWnFPW11PXVtPXl5PX15PYV5PYl5PY15PZF5PeV5PIWVaT35PIVtyT35QI2dPIV1zTyFmdU9+T2d2T35PZ3dPfk9TfE9UfU9peU9+T1MhUE9UfU9peU9+T1MhUk9UfU9peU9+T1MhVE9UfU9peU9+T1N9T1R9T2l5T35PIVhmT1BtWCFbbVh+T1AhV08hWyFYT35PIVlpT1FwWCFbcFh+T1EhWk8hWyFYT35PIVpsT1JzWCFbc1h+T1IhXU8hWyFYT35PIVshWE9+UCNnT2chX09+TyFdc08hZiFhT35PUyFiT35PUyFjT35PaiFkT1NoWFRoWGloWH5PUyFmT1QhZ09peU9+T1MhaE9UIWdPaXlPfk9TIWlPVCFnT2l5T35PUyFqT1QhZ09peU9+T1MhZ09UIWdPaXlPfk9nIWtPfk9nIWxPfk9nIW1Pfk9TIW5Pfk9sIXFPIWEhb08hYyFwT35PUyFyT35PUyFzT35PUyF0T35PYiF1T2MhdU9kIXVPIWEhd08hYiF1T35PYiF4T2MheE9kIXhPIWMhd08hZCF4T35PYiF1T2MhdU9kIXVPIWEhe08hYiF1T35PYiF4T2MheE9kIXhPIWMhe08hZCF4T35PVH5jYmQhZXl8IWV+XCIsXG4gIGdvdG86IFwiJXEhYVBQUFBQUFBQUFBQUFBQUFBQUFBQUCFiIWhQIW5QUCF6UCF9I1EjVCNaI14jYSNnI2ojbSNzI3khYlAhYiFiUCRQJFYkbSRzJHklUCVWJV0lY1BQUFBQUFBQJWlYXk9YYHBYVU9YYHBlemFiY2RleyFPIVEhUyFVUiFxIWRSaFVSIVhoWFZPWGBwUmtWUiFYa1hXT1hgcFJuV1IhWG5YWE9YYHBRclhSIVhwWFlPWGBwUWBPUnhgUXthUSFPYlEhUWNRIVNkUSFVZVohZXshTyFRIVMhVVEhdiFvUiF6IXZRIXkhcFIhfCF5UWdVUiFWZ1FqVlIhWWpRbVdSIVttUXBYUiFecFF0WlIhYHRTX09gVG9YcFwiLFxuICBub2RlTmFtZXM6IFwiXHUyNkEwIFN0YXJ0Q2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIEVuZFRhZyBTZWxmQ2xvc2luZ0VuZFRhZyBTdGFydFRhZyBTdGFydFRhZyBTdGFydFRhZyBTdGFydFRhZyBTdGFydFRhZyBTdGFydENsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBJbmNvbXBsZXRlVGFnIEluY29tcGxldGVDbG9zZVRhZyBEb2N1bWVudCBUZXh0IEVudGl0eVJlZmVyZW5jZSBDaGFyYWN0ZXJSZWZlcmVuY2UgSW52YWxpZEVudGl0eSBFbGVtZW50IE9wZW5UYWcgVGFnTmFtZSBBdHRyaWJ1dGUgQXR0cmlidXRlTmFtZSBJcyBBdHRyaWJ1dGVWYWx1ZSBVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlIFNjcmlwdFRleHQgQ2xvc2VUYWcgT3BlblRhZyBTdHlsZVRleHQgQ2xvc2VUYWcgT3BlblRhZyBUZXh0YXJlYVRleHQgQ2xvc2VUYWcgT3BlblRhZyBDbG9zZVRhZyBTZWxmQ2xvc2luZ1RhZyBDb21tZW50IFByb2Nlc3NpbmdJbnN0IE1pc21hdGNoZWRDbG9zZVRhZyBDbG9zZVRhZyBEb2N0eXBlRGVjbFwiLFxuICBtYXhUZXJtOiA2OCxcbiAgY29udGV4dDogZWxlbWVudENvbnRleHQsXG4gIG5vZGVQcm9wczogW1xuICAgIFtcImNsb3NlZEJ5XCIsIC0xMCwxLDIsMyw3LDgsOSwxMCwxMSwxMiwxMyxcIkVuZFRhZ1wiLDYsXCJFbmRUYWcgU2VsZkNsb3NpbmdFbmRUYWdcIiwtNCwyMiwzMSwzNCwzNyxcIkNsb3NlVGFnXCJdLFxuICAgIFtcIm9wZW5lZEJ5XCIsIDQsXCJTdGFydFRhZyBTdGFydENsb3NlVGFnXCIsNSxcIlN0YXJ0VGFnXCIsLTQsMzAsMzMsMzYsMzgsXCJPcGVuVGFnXCJdLFxuICAgIFtcImdyb3VwXCIsIC0xMCwxNCwxNSwxOCwxOSwyMCwyMSw0MCw0MSw0Miw0MyxcIkVudGl0eVwiLDE3LFwiRW50aXR5IFRleHRDb250ZW50XCIsLTMsMjksMzIsMzUsXCJUZXh0Q29udGVudCBFbnRpdHlcIl0sXG4gICAgW1wiaXNvbGF0ZVwiLCAtMTEsMjIsMzAsMzEsMzMsMzQsMzYsMzcsMzgsMzksNDIsNDMsXCJsdHJcIiwtMywyNywyOCw0MCxcIlwiXVxuICBdLFxuICBwcm9wU291cmNlczogW2h0bWxIaWdobGlnaHRpbmddLFxuICBza2lwcGVkTm9kZXM6IFswXSxcbiAgcmVwZWF0Tm9kZUNvdW50OiA5LFxuICB0b2tlbkRhdGE6IFwiITxwIWFSIVlPWCRxWFksUVlaLFFaWyRxW10mWF1eLFFecCRxcHEsUXFyLV9yczNfc3YtX3Z3M313eEhZeH0tX30hT0h7IU8hUC1fIVAhUSRxIVEhWy1fIVshXU16IV0hXi1fIV4hXyEkUyFfIWAhO3ghYCFhJlghYSFjLV8hYyF9TXohfSNSLV8jUiNTTXojUyNUMWsjVCNvTXojbyNzLV8jcyRmJHEkZiVXLV8lVyVvTXolbyVwLV8lcCZhTXomYSZiLV8mYjFwTXoxcDRVLV80VTRkTXo0ZDRlLV80ZSRJU016JElTJElgLV8kSWAkSWJNeiRJYiRLaC1fJEtoJSN0TXolI3QmL3gtXyYveCZFdE16JkV0JkZWLV8mRlY7J1NNejsnUzs6aiEjfDs6ajs9YDNYPCVsPyZyLV8/JnI/QWhNej9BaD9CWSRxP0JZP01uTXo/TW5PJHEhWiR8Y2FQbFchYmAhZHBPWCRxWFomWFpbJHFbXiZYXnAkcXBxJlhxciRxcnMmfXN2JHF2dytQd3godHghXiRxIV4hXypWIV8hYSZYIWEjUyRxI1MjVCZYI1Q7J1MkcTsnUzs9YCt6PCVsTyRxIVImYlhhUCFiYCFkcE9yJlhycyZ9c3YmWHd4KHR4IV4mWCFeIV8qViFfOydTJlg7J1M7PWAqeTwlbE8mWHEnVVZhUCFkcE92Jn13eCdreCFeJn0hXiFfKFYhXzsnUyZ9OydTOz1gKG48JWxPJn1QJ3BUYVBPdidrdyFeJ2shXzsnUydrOydTOz1gKFA8JWxPJ2tQKFNQOz1gPCVsJ2twKFtTIWRwT3YoVng7J1MoVjsnUzs9YChoPCVsTyhWcChrUDs9YDwlbChWcShxUDs9YDwlbCZ9YSh7V2FQIWJgT3IodHJzJ2tzdih0dyFeKHQhXiFfKWUhXzsnUyh0OydTOz1gKlA8JWxPKHRgKWpUIWJgT3IpZXN2KWV3OydTKWU7J1M7PWApeTwlbE8pZWApfFA7PWA8JWwpZWEqU1A7PWA8JWwodCFRKl5WIWJgIWRwT3IqVnJzKFZzdipWd3gpZXg7J1MqVjsnUzs9YCpzPCVsTypWIVEqdlA7PWA8JWwqViFSKnxQOz1gPCVsJlhXK1VZbFdPWCtQWlsrUF5wK1BxcitQc3crUHghXitQIWEjUytQI1Q7J1MrUDsnUzs9YCt0PCVsTytQVyt3UDs9YDwlbCtQIVorfVA7PWA8JWwkcSFhLF1gYVAhYmAhZHAhX15PWCZYWFksUVlaLFFaXSZYXV4sUV5wJlhwcSxRcXImWHJzJn1zdiZYd3godHghXiZYIV4hXypWIV87J1MmWDsnUzs9YCp5PCVsTyZYIV8tbGppU2FQbFchYmAhZHBPWCRxWFomWFpbJHFbXiZYXnAkcXBxJlhxci1fcnMmfXN2LV92dy9ed3godHghUC1fIVAhUSRxIVEhXi1fIV4hXypWIV8hYSZYIWEjUy1fI1MjVDFrI1Qjcy1fI3MkZiRxJGY7J1MtXzsnUzs9YDNYPCVsP0FoLV8/QWg/QlkkcT9CWT9Nbi1fP01uTyRxWy9lYmlTbFdPWCtQWlsrUF5wK1Bxci9ec3cvXnghUC9eIVAhUStQIVEhXi9eIWEjUy9eI1MjVDBtI1Qjcy9eI3MkZitQJGY7J1MvXjsnUzs9YDFlPCVsP0FoL14/QWg/QlkrUD9CWT9Nbi9eP01uTytQUzByWGlTcXIwbXN3MG14IVAwbSFRIV4wbSFhI3MwbSRmOydTMG07J1M7PWAxXzwlbD9BaDBtP0JZP01uMG1TMWJQOz1gPCVsMG1bMWhQOz1gPCVsL14hVjF2Y2lTYVAhYmAhZHBPcSZYcXIxa3JzJn1zdjFrdncwbXd4KHR4IVAxayFQIVEmWCFRIV4xayFeIV8qViFfIWEmWCFhI3MxayNzJGYmWCRmOydTMWs7J1M7PWAzUjwlbD9BaDFrP0FoP0JZJlg/Qlk/TW4xaz9Nbk8mWCFWM1VQOz1gPCVsMWshXzNbUDs9YDwlbC1fIVozaFYhYWhhUCFkcE92Jn13eCdreCFeJn0hXiFfKFYhXzsnUyZ9OydTOz1gKG48JWxPJn0hXzRXaWlTbFdkIVJPWDV1WFo3U1pbNXVbXjdTXnA1dXFyOHRyczdTc3Q+XXR3OHR3eDdTeCFQOHQhUCFRNXUhUSFdOHQhXSFeL14hXiFhN1MhYSNTOHQjUyNUO3sjVCNzOHQjcyRmNXUkZjsnUzh0OydTOz1gPlY8JWw/QWg4dD9BaD9CWTV1P0JZP01uOHQ/TW5PNXUhWjV6YmxXT1g1dVhaN1NaWzV1W143U15wNXVxcjV1cnM3U3N0K1B0dzV1d3g3U3ghXTV1IV0hXjd3IV4hYTdTIWEjUzV1I1MjVDdTI1Q7J1M1dTsnUzs9YDhuPCVsTzV1IVI3VlZPcDdTcXM3U3QhXTdTIV0hXjdsIV47J1M3UzsnUzs9YDdxPCVsTzdTIVI3cU9iIVIhUjd0UDs9YDwlbDdTIVo4T1lsV2IhUk9YK1BaWytQXnArUHFyK1BzdytQeCFeK1AhYSNTK1AjVDsnUytQOydTOz1gK3Q8JWxPK1AhWjhxUDs9YDwlbDV1IV84e2lpU2xXT1g1dVhaN1NaWzV1W143U15wNXVxcjh0cnM3U3N0L150dzh0d3g3U3ghUDh0IVAhUTV1IVEhXTh0IV0hXjpqIV4hYTdTIWEjUzh0I1MjVDt7I1Qjczh0I3MkZjV1JGY7J1M4dDsnUzs9YD5WPCVsP0FoOHQ/QWg/Qlk1dT9CWT9Nbjh0P01uTzV1IV86c2JpU2xXYiFST1grUFpbK1BecCtQcXIvXnN3L154IVAvXiFQIVErUCFRIV4vXiFhI1MvXiNTI1QwbSNUI3MvXiNzJGYrUCRmOydTL147J1M7PWAxZTwlbD9BaC9eP0FoP0JZK1A/Qlk/TW4vXj9Nbk8rUCFWPFFjaVNPcDdTcXI7e3JzN1NzdDBtdHc7e3d4N1N4IVA7eyFQIVE3UyFRIV07eyFdIV49XSFeIWE3UyFhI3M7eyNzJGY3UyRmOydTO3s7J1M7PWA+UDwlbD9BaDt7P0FoP0JZN1M/Qlk/TW47ez9Nbk83UyFWPWRYaVNiIVJxcjBtc3cwbXghUDBtIVEhXjBtIWEjczBtJGY7J1MwbTsnUzs9YDFfPCVsP0FoMG0/Qlk/TW4wbSFWPlNQOz1gPCVsO3shXz5ZUDs9YDwlbDh0IV8+ZGhpU2xXT1hAT1haQVlaW0BPW15BWV5wQE9xckJ3cnNBWXN3Qnd3eEFZeCFQQnchUCFRQE8hUSFdQnchXSFeL14hXiFhQVkhYSNTQncjUyNURXsjVCNzQncjcyRmQE8kZjsnU0J3OydTOz1gSFM8JWw/QWhCdz9BaD9CWUBPP0JZP01uQnc/TW5PQE8hWkBUYWxXT1hAT1haQVlaW0BPW15BWV5wQE9xckBPcnNBWXN3QE93eEFZeCFdQE8hXSFeQXohXiFhQVkhYSNTQE8jUyNUQVkjVDsnU0BPOydTOz1gQnE8JWxPQE8hUkFdVU9wQVlxIV1BWSFdIV5BbyFeOydTQVk7J1M7PWBBdDwlbE9BWSFSQXRPYyFSIVJBd1A7PWA8JWxBWSFaQlJZbFdjIVJPWCtQWlsrUF5wK1BxcitQc3crUHghXitQIWEjUytQI1Q7J1MrUDsnUzs9YCt0PCVsTytQIVpCdFA7PWA8JWxATyFfQ09oaVNsV09YQE9YWkFZWltAT1teQVlecEBPcXJCd3JzQVlzd0J3d3hBWXghUEJ3IVAhUUBPIVEhXUJ3IV0hXkRqIV4hYUFZIWEjU0J3I1MjVEV7I1Qjc0J3I3MkZkBPJGY7J1NCdzsnUzs9YEhTPCVsP0FoQnc/QWg/QllATz9CWT9NbkJ3P01uT0BPIV9Ec2JpU2xXYyFST1grUFpbK1BecCtQcXIvXnN3L154IVAvXiFQIVErUCFRIV4vXiFhI1MvXiNTI1QwbSNUI3MvXiNzJGYrUCRmOydTL147J1M7PWAxZTwlbD9BaC9eP0FoP0JZK1A/Qlk/TW4vXj9Nbk8rUCFWRlFiaVNPcEFZcXJFe3JzQVlzd0V7d3hBWXghUEV7IVAhUUFZIVEhXUV7IV0hXkdZIV4hYUFZIWEjc0V7I3MkZkFZJGY7J1NFezsnUzs9YEd8PCVsP0FoRXs/QWg/QllBWT9CWT9NbkV7P01uT0FZIVZHYVhpU2MhUnFyMG1zdzBteCFQMG0hUSFeMG0hYSNzMG0kZjsnUzBtOydTOz1gMV88JWw/QWgwbT9CWT9NbjBtIVZIUFA7PWA8JWxFeyFfSFZQOz1gPCVsQnchWkhjVyFjeGFQIWJgT3IodHJzJ2tzdih0dyFeKHQhXiFfKWUhXzsnUyh0OydTOz1gKlA8JWxPKHQhYUlZbGlTYVBsVyFiYCFkcE9YJHFYWiZYWlskcVteJlhecCRxcHEmWHFyLV9ycyZ9c3YtX3Z3L153eCh0eH0tX30hT0tRIU8hUC1fIVAhUSRxIVEhXi1fIV4hXypWIV8hYSZYIWEjUy1fI1MjVDFrI1Qjcy1fI3MkZiRxJGY7J1MtXzsnUzs9YDNYPCVsP0FoLV8/QWg/QlkkcT9CWT9Nbi1fP01uTyRxIWFLX2tpU2FQbFchYmAhZHBPWCRxWFomWFpbJHFbXiZYXnAkcXBxJlhxci1fcnMmfXN2LV92dy9ed3godHghUC1fIVAhUSRxIVEhXi1fIV4hXypWIV8hYCZYIWAhYU1TIWEjUy1fI1MjVDFrI1Qjcy1fI3MkZiRxJGY7J1MtXzsnUzs9YDNYPCVsP0FoLV8/QWg/QlkkcT9CWT9Nbi1fP01uTyRxIVRNX1hhUCFiYCFkcCFmUU9yJlhycyZ9c3YmWHd4KHR4IV4mWCFeIV8qViFfOydTJlg7J1M7PWAqeTwlbE8mWCFhTlohWmlTZ1FhUGxXIWJgIWRwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXItX3JzJn1zdi1fdncvXnd4KHR4fS1ffSFPTXohTyFQTXohUCFRJHEhUSFbTXohWyFdTXohXSFeLV8hXiFfKlYhXyFhJlghYSFjLV8hYyF9TXohfSNSLV8jUiNTTXojUyNUMWsjVCNvTXojbyNzLV8jcyRmJHEkZiR9LV8kfSVPTXolTyVXLV8lVyVvTXolbyVwLV8lcCZhTXomYSZiLV8mYjFwTXoxcDRVTXo0VTRkTXo0ZDRlLV80ZSRJU016JElTJElgLV8kSWAkSWJNeiRJYiRKZS1fJEplJEpnTXokSmckS2gtXyRLaCUjdE16JSN0Ji94LV8mL3gmRXRNeiZFdCZGVi1fJkZWOydTTXo7J1M7OmohI3w7Omo7PWAzWDwlbD8mci1fPyZyP0FoTXo/QWg/QlkkcT9CWT9Nbk16P01uTyRxIWEhJFBQOz1gPCVsTXohUiEkWlkhYmAhZHBPcSpWcXIhJHlycyhWc3YqVnd4KWV4IWEqViFhIWIhNHQhYjsnUypWOydTOz1gKnM8JWxPKlYhUiElUV0hYmAhZHBPcipWcnMoVnN2KlZ3eClleH0qVn0hTyEleSFPIWYqViFmIWchJ10hZyNXKlYjVyNYITBgI1g7J1MqVjsnUzs9YCpzPCVsTypWIVIhJlFYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXh9KlZ9IU8hJm0hTzsnUypWOydTOz1gKnM8JWxPKlYhUiEmdlYhYmAhZHAhZVBPcipWcnMoVnN2KlZ3eClleDsnUypWOydTOz1gKnM8JWxPKlYhUiEnZFghYmAhZHBPcipWcnMoVnN2KlZ3eClleCFxKlYhcSFyIShQIXI7J1MqVjsnUzs9YCpzPCVsTypWIVIhKFdYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXghZSpWIWUhZiEocyFmOydTKlY7J1M7PWAqczwlbE8qViFSISh6WCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4IXYqViF2IXchKWchdzsnUypWOydTOz1gKnM8JWxPKlYhUiEpblghYmAhZHBPcipWcnMoVnN2KlZ3eClleCF7KlYheyF8ISpaIXw7J1MqVjsnUzs9YCpzPCVsTypWIVIhKmJYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXghcipWIXIhcyEqfSFzOydTKlY7J1M7PWAqczwlbE8qViFSIStVWCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4IWcqViFnIWghK3EhaDsnUypWOydTOz1gKnM8JWxPKlYhUiEreFkhYmAhZHBPciErcXJzISxoc3YhK3F2dyEtU3d4IS5beCFgIStxIWAhYSEvaiFhOydTIStxOydTOz1gITBZPCVsTyErcXEhLG1WIWRwT3YhLGh2eCEtU3ghYCEsaCFgIWEhLXEhYTsnUyEsaDsnUzs9YCEuVTwlbE8hLGhQIS1WVE8hYCEtUyFgIWEhLWYhYTsnUyEtUzsnUzs9YCEtazwlbE8hLVNQIS1rT3xQUCEtblA7PWA8JWwhLVNxIS14UyFkcHxQT3YoVng7J1MoVjsnUzs9YChoPCVsTyhWcSEuWFA7PWA8JWwhLGhhIS5hWCFiYE9yIS5bcnMhLVNzdiEuW3Z3IS1TdyFgIS5bIWAhYSEufCFhOydTIS5bOydTOz1gIS9kPCVsTyEuW2EhL1RUIWJgfFBPcillc3YpZXc7J1MpZTsnUzs9YCl5PCVsTyllYSEvZ1A7PWA8JWwhLlshUiEvc1YhYmAhZHB8UE9yKlZycyhWc3YqVnd4KWV4OydTKlY7J1M7PWAqczwlbE8qViFSITBdUDs9YDwlbCErcSFSITBnWCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4I2MqViNjI2QhMVMjZDsnUypWOydTOz1gKnM8JWxPKlYhUiExWlghYmAhZHBPcipWcnMoVnN2KlZ3eClleCNWKlYjViNXITF2I1c7J1MqVjsnUzs9YCpzPCVsTypWIVIhMX1YIWJgIWRwT3IqVnJzKFZzdipWd3gpZXgjaCpWI2gjaSEyaiNpOydTKlY7J1M7PWAqczwlbE8qViFSITJxWCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4I20qViNtI24hM14jbjsnUypWOydTOz1gKnM8JWxPKlYhUiEzZVghYmAhZHBPcipWcnMoVnN2KlZ3eClleCNkKlYjZCNlITRRI2U7J1MqVjsnUzs9YCpzPCVsTypWIVIhNFhYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXgjWCpWI1gjWSErcSNZOydTKlY7J1M7PWAqczwlbE8qViFSITR7WSFiYCFkcE9yITR0cnMhNWtzdiE0dHZ3ITZWd3ghOF14IWEhNHQhYSFiITpdIWI7J1MhNHQ7J1M7PWAhO3I8JWxPITR0cSE1cFYhZHBPdiE1a3Z4ITZWeCFhITVrIWEhYiE3VyFiOydTITVrOydTOz1gIThWPCVsTyE1a1AhNllUTyFhITZWIWEhYiE2aSFiOydTITZWOydTOz1gITdRPCVsTyE2VlAhNmxUTyFgITZWIWAhYSE2eyFhOydTITZWOydTOz1gITdRPCVsTyE2VlAhN1FPeVBQITdUUDs9YDwlbCE2VnEhN11WIWRwT3YhNWt2eCE2VnghYCE1ayFgIWEhN3IhYTsnUyE1azsnUzs9YCE4VjwlbE8hNWtxITd5UyFkcHlQT3YoVng7J1MoVjsnUzs9YChoPCVsTyhWcSE4WVA7PWA8JWwhNWthIThiWCFiYE9yIThdcnMhNlZzdiE4XXZ3ITZWdyFhIThdIWEhYiE4fSFiOydTIThdOydTOz1gITpWPCVsTyE4XWEhOVNYIWJgT3IhOF1ycyE2VnN2IThddnchNlZ3IWAhOF0hYCFhITlvIWE7J1MhOF07J1M7PWAhOlY8JWxPIThdYSE5dlQhYmB5UE9yKWVzdilldzsnUyllOydTOz1gKXk8JWxPKWVhITpZUDs9YDwlbCE4XSFSITpkWSFiYCFkcE9yITR0cnMhNWtzdiE0dHZ3ITZWd3ghOF14IWAhNHQhYCFhITtTIWE7J1MhNHQ7J1M7PWAhO3I8JWxPITR0IVIhO11WIWJgIWRweVBPcipWcnMoVnN2KlZ3eClleDsnUypWOydTOz1gKnM8JWxPKlYhUiE7dVA7PWA8JWwhNHQhViE8VFhqU2FQIWJgIWRwT3ImWHJzJn1zdiZYd3godHghXiZYIV4hXypWIV87J1MmWDsnUzs9YCp5PCVsTyZYXCIsXG4gIHRva2VuaXplcnM6IFtzY3JpcHRUb2tlbnMsIHN0eWxlVG9rZW5zLCB0ZXh0YXJlYVRva2VucywgZW5kVGFnLCB0YWdTdGFydCwgY29tbWVudENvbnRlbnQsIDAsIDEsIDIsIDMsIDQsIDVdLFxuICB0b3BSdWxlczoge1wiRG9jdW1lbnRcIjpbMCwxNl19LFxuICBkaWFsZWN0czoge25vTWF0Y2g6IDAsIHNlbGZDbG9zaW5nOiA1MTV9LFxuICB0b2tlblByZWM6IDUxN1xufSk7XG5cbmZ1bmN0aW9uIGdldEF0dHJzKG9wZW5UYWcsIGlucHV0KSB7XG4gIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAobGV0IGF0dCBvZiBvcGVuVGFnLmdldENoaWxkcmVuKEF0dHJpYnV0ZSkpIHtcbiAgICBsZXQgbmFtZSA9IGF0dC5nZXRDaGlsZChBdHRyaWJ1dGVOYW1lKSwgdmFsdWUgPSBhdHQuZ2V0Q2hpbGQoQXR0cmlidXRlVmFsdWUpIHx8IGF0dC5nZXRDaGlsZChVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKTtcbiAgICBpZiAobmFtZSkgYXR0cnNbaW5wdXQucmVhZChuYW1lLmZyb20sIG5hbWUudG8pXSA9XG4gICAgICAhdmFsdWUgPyBcIlwiIDogdmFsdWUudHlwZS5pZCA9PSBBdHRyaWJ1dGVWYWx1ZSA/IGlucHV0LnJlYWQodmFsdWUuZnJvbSArIDEsIHZhbHVlLnRvIC0gMSkgOiBpbnB1dC5yZWFkKHZhbHVlLmZyb20sIHZhbHVlLnRvKTtcbiAgfVxuICByZXR1cm4gYXR0cnNcbn1cblxuZnVuY3Rpb24gZmluZFRhZ05hbWUob3BlblRhZywgaW5wdXQpIHtcbiAgbGV0IHRhZ05hbWVOb2RlID0gb3BlblRhZy5nZXRDaGlsZChUYWdOYW1lKTtcbiAgcmV0dXJuIHRhZ05hbWVOb2RlID8gaW5wdXQucmVhZCh0YWdOYW1lTm9kZS5mcm9tLCB0YWdOYW1lTm9kZS50bykgOiBcIiBcIlxufVxuXG5mdW5jdGlvbiBtYXliZU5lc3Qobm9kZSwgaW5wdXQsIHRhZ3MpIHtcbiAgbGV0IGF0dHJzO1xuICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgIGlmICghdGFnLmF0dHJzIHx8IHRhZy5hdHRycyhhdHRycyB8fCAoYXR0cnMgPSBnZXRBdHRycyhub2RlLm5vZGUucGFyZW50LmZpcnN0Q2hpbGQsIGlucHV0KSkpKVxuICAgICAgcmV0dXJuIHtwYXJzZXI6IHRhZy5wYXJzZXIsIGJyYWNrZXRlZDogdHJ1ZX1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyB0YWdzPzoge1xuLy8gICB0YWc6IHN0cmluZyxcbi8vICAgYXR0cnM/OiAoe1thdHRyOiBzdHJpbmddOiBzdHJpbmd9KSA9PiBib29sZWFuLFxuLy8gICBwYXJzZXI6IFBhcnNlclxuLy8gfVtdXG4vLyBhdHRyaWJ1dGVzPzoge1xuLy8gICBuYW1lOiBzdHJpbmcsXG4vLyAgIHRhZ05hbWU/OiBzdHJpbmcsXG4vLyAgIHBhcnNlcjogUGFyc2VyXG4vLyB9W11cbiBcbmZ1bmN0aW9uIGNvbmZpZ3VyZU5lc3RpbmcodGFncyA9IFtdLCBhdHRyaWJ1dGVzID0gW10pIHtcbiAgbGV0IHNjcmlwdCA9IFtdLCBzdHlsZSA9IFtdLCB0ZXh0YXJlYSA9IFtdLCBvdGhlciA9IFtdO1xuICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgIGxldCBhcnJheSA9IHRhZy50YWcgPT0gXCJzY3JpcHRcIiA/IHNjcmlwdCA6IHRhZy50YWcgPT0gXCJzdHlsZVwiID8gc3R5bGUgOiB0YWcudGFnID09IFwidGV4dGFyZWFcIiA/IHRleHRhcmVhIDogb3RoZXI7XG4gICAgYXJyYXkucHVzaCh0YWcpO1xuICB9XG4gIGxldCBhdHRycyA9IGF0dHJpYnV0ZXMubGVuZ3RoID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IG51bGw7XG4gIGZvciAobGV0IGF0dHIgb2YgYXR0cmlidXRlcykgKGF0dHJzW2F0dHIubmFtZV0gfHwgKGF0dHJzW2F0dHIubmFtZV0gPSBbXSkpLnB1c2goYXR0cik7XG5cbiAgcmV0dXJuIHBhcnNlTWl4ZWQoKG5vZGUsIGlucHV0KSA9PiB7XG4gICAgbGV0IGlkID0gbm9kZS50eXBlLmlkO1xuICAgIGlmIChpZCA9PSBTY3JpcHRUZXh0KSByZXR1cm4gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCBzY3JpcHQpXG4gICAgaWYgKGlkID09IFN0eWxlVGV4dCkgcmV0dXJuIG1heWJlTmVzdChub2RlLCBpbnB1dCwgc3R5bGUpXG4gICAgaWYgKGlkID09IFRleHRhcmVhVGV4dCkgcmV0dXJuIG1heWJlTmVzdChub2RlLCBpbnB1dCwgdGV4dGFyZWEpXG5cbiAgICBpZiAoaWQgPT0gRWxlbWVudCAmJiBvdGhlci5sZW5ndGgpIHtcbiAgICAgIGxldCBuID0gbm9kZS5ub2RlLCBvcGVuID0gbi5maXJzdENoaWxkLCB0YWdOYW1lID0gb3BlbiAmJiBmaW5kVGFnTmFtZShvcGVuLCBpbnB1dCksIGF0dHJzO1xuICAgICAgaWYgKHRhZ05hbWUpIGZvciAobGV0IHRhZyBvZiBvdGhlcikge1xuICAgICAgICBpZiAodGFnLnRhZyA9PSB0YWdOYW1lICYmICghdGFnLmF0dHJzIHx8IHRhZy5hdHRycyhhdHRycyB8fCAoYXR0cnMgPSBnZXRBdHRycyhvcGVuLCBpbnB1dCkpKSkpIHtcbiAgICAgICAgICBsZXQgY2xvc2UgPSBuLmxhc3RDaGlsZDtcbiAgICAgICAgICBsZXQgdG8gPSBjbG9zZS50eXBlLmlkID09IENsb3NlVGFnID8gY2xvc2UuZnJvbSA6IG4udG87XG4gICAgICAgICAgaWYgKHRvID4gb3Blbi50bylcbiAgICAgICAgICAgIHJldHVybiB7cGFyc2VyOiB0YWcucGFyc2VyLCBvdmVybGF5OiBbe2Zyb206IG9wZW4udG8sIHRvfV19XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXR0cnMgJiYgaWQgPT0gQXR0cmlidXRlKSB7XG4gICAgICBsZXQgbiA9IG5vZGUubm9kZSwgbmFtZU5vZGU7XG4gICAgICBpZiAobmFtZU5vZGUgPSBuLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBhdHRyc1tpbnB1dC5yZWFkKG5hbWVOb2RlLmZyb20sIG5hbWVOb2RlLnRvKV07XG4gICAgICAgIGlmIChtYXRjaGVzKSBmb3IgKGxldCBhdHRyIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICBpZiAoYXR0ci50YWdOYW1lICYmIGF0dHIudGFnTmFtZSAhPSBmaW5kVGFnTmFtZShuLnBhcmVudCwgaW5wdXQpKSBjb250aW51ZVxuICAgICAgICAgIGxldCB2YWx1ZSA9IG4ubGFzdENoaWxkO1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlLmlkID09IEF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZhbHVlLmZyb20gKyAxO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB2YWx1ZS5sYXN0Q2hpbGQsIHRvID0gdmFsdWUudG8gLSAobGFzdCAmJiBsYXN0LmlzRXJyb3IgPyAwIDogMSk7XG4gICAgICAgICAgICBpZiAodG8gPiBmcm9tKSByZXR1cm4ge3BhcnNlcjogYXR0ci5wYXJzZXIsIG92ZXJsYXk6IFt7ZnJvbSwgdG99XSwgYnJhY2tldGVkOiB0cnVlfVxuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUudHlwZS5pZCA9PSBVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3BhcnNlcjogYXR0ci5wYXJzZXIsIG92ZXJsYXk6IFt7ZnJvbTogdmFsdWUuZnJvbSwgdG86IHZhbHVlLnRvfV19XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH0pXG59XG5cbmV4cG9ydCB7IGNvbmZpZ3VyZU5lc3RpbmcsIHBhcnNlciB9O1xuIiwgImltcG9ydCB7IEV4dGVybmFsVG9rZW5pemVyLCBMUlBhcnNlciwgTG9jYWxUb2tlbkdyb3VwIH0gZnJvbSAnQGxlemVyL2xyJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IGRlc2NlbmRhbnRPcCA9IDEyMixcbiAgVW5pdCA9IDEsXG4gIGlkZW50aWZpZXIgPSAxMjMsXG4gIGNhbGxlZSA9IDEyNCxcbiAgVmFyaWFibGVOYW1lID0gMixcbiAgcXVlcnlJZGVudGlmaWVyID0gMTI1LFxuICBxdWVyeVZhcmlhYmxlTmFtZSA9IDMsXG4gIFF1ZXJ5Q2FsbGVlID0gNDtcblxuLyogSGFuZC13cml0dGVuIHRva2VuaXplcnMgZm9yIENTUyB0b2tlbnMgdGhhdCBjYW4ndCBiZVxuICAgZXhwcmVzc2VkIGJ5IExlemVyJ3MgYnVpbHQtaW4gdG9rZW5pemVyLiAqL1xuXG5jb25zdCBzcGFjZSA9IFs5LCAxMCwgMTEsIDEyLCAxMywgMzIsIDEzMywgMTYwLCA1NzYwLCA4MTkyLCA4MTkzLCA4MTk0LCA4MTk1LCA4MTk2LCA4MTk3LFxuICAgICAgICAgICAgICAgODE5OCwgODE5OSwgODIwMCwgODIwMSwgODIwMiwgODIzMiwgODIzMywgODIzOSwgODI4NywgMTIyODhdO1xuY29uc3QgY29sb24gPSA1OCwgcGFyZW5MID0gNDAsIHVuZGVyc2NvcmUgPSA5NSwgYnJhY2tldEwgPSA5MSwgZGFzaCA9IDQ1LCBwZXJpb2QgPSA0NixcbiAgICAgIGhhc2ggPSAzNSwgcGVyY2VudCA9IDM3LCBhbXBlcnNhbmQgPSAzOCwgYmFja3NsYXNoID0gOTIsIG5ld2xpbmUgPSAxMCwgYXN0ZXJpc2sgPSA0MjtcblxuZnVuY3Rpb24gaXNBbHBoYShjaCkgeyByZXR1cm4gY2ggPj0gNjUgJiYgY2ggPD0gOTAgfHwgY2ggPj0gOTcgJiYgY2ggPD0gMTIyIHx8IGNoID49IDE2MSB9XG5cbmZ1bmN0aW9uIGlzRGlnaXQoY2gpIHsgcmV0dXJuIGNoID49IDQ4ICYmIGNoIDw9IDU3IH1cblxuZnVuY3Rpb24gaXNIZXgoY2gpIHsgcmV0dXJuIGlzRGlnaXQoY2gpIHx8IGNoID49IDk3ICYmIGNoIDw9IDEwMiB8fCBjaCA+PSA2NSAmJiBjaCA8PSA3MCB9XG5cbmNvbnN0IGlkZW50aWZpZXJUb2tlbnMgPSAoaWQsIHZhck5hbWUsIGNhbGxlZSkgPT4gKGlucHV0LCBzdGFjaykgPT4ge1xuICBmb3IgKGxldCBpbnNpZGUgPSBmYWxzZSwgZGFzaGVzID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICBsZXQge25leHR9ID0gaW5wdXQ7XG4gICAgaWYgKGlzQWxwaGEobmV4dCkgfHwgbmV4dCA9PSBkYXNoIHx8IG5leHQgPT0gdW5kZXJzY29yZSB8fCAoaW5zaWRlICYmIGlzRGlnaXQobmV4dCkpKSB7XG4gICAgICBpZiAoIWluc2lkZSAmJiAobmV4dCAhPSBkYXNoIHx8IGkgPiAwKSkgaW5zaWRlID0gdHJ1ZTtcbiAgICAgIGlmIChkYXNoZXMgPT09IGkgJiYgbmV4dCA9PSBkYXNoKSBkYXNoZXMrKztcbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT0gYmFja3NsYXNoICYmIGlucHV0LnBlZWsoMSkgIT0gbmV3bGluZSkge1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgaWYgKGlzSGV4KGlucHV0Lm5leHQpKSB7XG4gICAgICAgIGRvIHsgaW5wdXQuYWR2YW5jZSgpOyB9IHdoaWxlIChpc0hleChpbnB1dC5uZXh0KSlcbiAgICAgICAgaWYgKGlucHV0Lm5leHQgPT0gMzIpIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQubmV4dCA+IC0xKSB7XG4gICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIH1cbiAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbnNpZGUpIGlucHV0LmFjY2VwdFRva2VuKFxuICAgICAgICBkYXNoZXMgPT0gMiAmJiBzdGFjay5jYW5TaGlmdChWYXJpYWJsZU5hbWUpID8gdmFyTmFtZSA6IG5leHQgPT0gcGFyZW5MID8gY2FsbGVlIDogaWRcbiAgICAgICk7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgaWRlbnRpZmllcnMgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoXG4gIGlkZW50aWZpZXJUb2tlbnMoaWRlbnRpZmllciwgVmFyaWFibGVOYW1lLCBjYWxsZWUpXG4pO1xuY29uc3QgcXVlcnlJZGVudGlmaWVycyA9IG5ldyBFeHRlcm5hbFRva2VuaXplcihcbiAgaWRlbnRpZmllclRva2VucyhxdWVyeUlkZW50aWZpZXIsIHF1ZXJ5VmFyaWFibGVOYW1lLCBRdWVyeUNhbGxlZSlcbik7XG5cbmNvbnN0IGRlc2NlbmRhbnQgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoaW5wdXQgPT4ge1xuICBpZiAoc3BhY2UuaW5jbHVkZXMoaW5wdXQucGVlaygtMSkpKSB7XG4gICAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICAgIGlmIChpc0FscGhhKG5leHQpIHx8IG5leHQgPT0gdW5kZXJzY29yZSB8fCBuZXh0ID09IGhhc2ggfHwgbmV4dCA9PSBwZXJpb2QgfHxcbiAgICAgICAgbmV4dCA9PSBhc3RlcmlzayB8fCBuZXh0ID09IGJyYWNrZXRMIHx8IG5leHQgPT0gY29sb24gJiYgaXNBbHBoYShpbnB1dC5wZWVrKDEpKSB8fFxuICAgICAgICBuZXh0ID09IGRhc2ggfHwgbmV4dCA9PSBhbXBlcnNhbmQpXG4gICAgICBpbnB1dC5hY2NlcHRUb2tlbihkZXNjZW5kYW50T3ApO1xuICB9XG59KTtcblxuY29uc3QgdW5pdFRva2VuID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgaWYgKCFzcGFjZS5pbmNsdWRlcyhpbnB1dC5wZWVrKC0xKSkpIHtcbiAgICBsZXQge25leHR9ID0gaW5wdXQ7XG4gICAgaWYgKG5leHQgPT0gcGVyY2VudCkgeyBpbnB1dC5hZHZhbmNlKCk7IGlucHV0LmFjY2VwdFRva2VuKFVuaXQpOyB9XG4gICAgaWYgKGlzQWxwaGEobmV4dCkpIHtcbiAgICAgIGRvIHsgaW5wdXQuYWR2YW5jZSgpOyB9IHdoaWxlIChpc0FscGhhKGlucHV0Lm5leHQpIHx8IGlzRGlnaXQoaW5wdXQubmV4dCkpXG4gICAgICBpbnB1dC5hY2NlcHRUb2tlbihVbml0KTtcbiAgICB9XG4gIH1cbn0pO1xuXG5jb25zdCBjc3NIaWdobGlnaHRpbmcgPSBzdHlsZVRhZ3Moe1xuICBcIkF0S2V5d29yZCBpbXBvcnQgY2hhcnNldCBuYW1lc3BhY2Uga2V5ZnJhbWVzIG1lZGlhIHN1cHBvcnRzXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiZnJvbSB0byBzZWxlY3RvclwiOiB0YWdzLmtleXdvcmQsXG4gIE5hbWVzcGFjZU5hbWU6IHRhZ3MubmFtZXNwYWNlLFxuICBLZXlmcmFtZU5hbWU6IHRhZ3MubGFiZWxOYW1lLFxuICBLZXlmcmFtZVJhbmdlTmFtZTogdGFncy5vcGVyYXRvcktleXdvcmQsXG4gIFRhZ05hbWU6IHRhZ3MudGFnTmFtZSxcbiAgQ2xhc3NOYW1lOiB0YWdzLmNsYXNzTmFtZSxcbiAgUHNldWRvQ2xhc3NOYW1lOiB0YWdzLmNvbnN0YW50KHRhZ3MuY2xhc3NOYW1lKSxcbiAgSWROYW1lOiB0YWdzLmxhYmVsTmFtZSxcbiAgXCJGZWF0dXJlTmFtZSBQcm9wZXJ0eU5hbWVcIjogdGFncy5wcm9wZXJ0eU5hbWUsXG4gIEF0dHJpYnV0ZU5hbWU6IHRhZ3MuYXR0cmlidXRlTmFtZSxcbiAgTnVtYmVyTGl0ZXJhbDogdGFncy5udW1iZXIsXG4gIEtleXdvcmRRdWVyeTogdGFncy5rZXl3b3JkLFxuICBVbmFyeVF1ZXJ5T3A6IHRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuICBcIkNhbGxUYWcgVmFsdWVOYW1lXCI6IHRhZ3MuYXRvbSxcbiAgVmFyaWFibGVOYW1lOiB0YWdzLnZhcmlhYmxlTmFtZSxcbiAgQ2FsbGVlOiB0YWdzLm9wZXJhdG9yS2V5d29yZCxcbiAgVW5pdDogdGFncy51bml0LFxuICBcIlVuaXZlcnNhbFNlbGVjdG9yIE5lc3RpbmdTZWxlY3RvclwiOiB0YWdzLmRlZmluaXRpb25PcGVyYXRvcixcbiAgXCJNYXRjaE9wIENvbXBhcmVPcFwiOiB0YWdzLmNvbXBhcmVPcGVyYXRvcixcbiAgXCJDaGlsZE9wIFNpYmxpbmdPcCwgTG9naWNPcFwiOiB0YWdzLmxvZ2ljT3BlcmF0b3IsXG4gIEJpbk9wOiB0YWdzLmFyaXRobWV0aWNPcGVyYXRvcixcbiAgSW1wb3J0YW50OiB0YWdzLm1vZGlmaWVyLFxuICBDb21tZW50OiB0YWdzLmJsb2NrQ29tbWVudCxcbiAgQ29sb3JMaXRlcmFsOiB0YWdzLmNvbG9yLFxuICBcIlBhcmVudGhlc2l6ZWRDb250ZW50IFN0cmluZ0xpdGVyYWxcIjogdGFncy5zdHJpbmcsXG4gIFwiOlwiOiB0YWdzLnB1bmN0dWF0aW9uLFxuICBcIlBzZXVkb09wICNcIjogdGFncy5kZXJlZk9wZXJhdG9yLFxuICBcIjsgLFwiOiB0YWdzLnNlcGFyYXRvcixcbiAgXCIoIClcIjogdGFncy5wYXJlbixcbiAgXCJbIF1cIjogdGFncy5zcXVhcmVCcmFja2V0LFxuICBcInsgfVwiOiB0YWdzLmJyYWNlXG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX2NhbGxlZSA9IHtfX3Byb3RvX186bnVsbCxsYW5nOjM4LCBcIm50aC1jaGlsZFwiOjM4LCBcIm50aC1sYXN0LWNoaWxkXCI6MzgsIFwibnRoLW9mLXR5cGVcIjozOCwgXCJudGgtbGFzdC1vZi10eXBlXCI6MzgsIGRpcjozOCwgXCJob3N0LWNvbnRleHRcIjozOCwgaWY6ODQsIHVybDoxMjQsIFwidXJsLXByZWZpeFwiOjEyNCwgZG9tYWluOjEyNCwgcmVnZXhwOjEyNH07XG5jb25zdCBzcGVjX3F1ZXJ5SWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxvcjo5OCwgYW5kOjk4LCBub3Q6MTA2LCBvbmx5OjEwNiwgbGF5ZXI6MTcwfTtcbmNvbnN0IHNwZWNfUXVlcnlDYWxsZWUgPSB7X19wcm90b19fOm51bGwsc2VsZWN0b3I6MTEyLCBsYXllcjoxNjZ9O1xuY29uc3Qgc3BlY19BdEtleXdvcmQgPSB7X19wcm90b19fOm51bGwsXCJAaW1wb3J0XCI6MTYyLCBcIkBtZWRpYVwiOjE3NCwgXCJAY2hhcnNldFwiOjE3OCwgXCJAbmFtZXNwYWNlXCI6MTgyLCBcIkBrZXlmcmFtZXNcIjoxODgsIFwiQHN1cHBvcnRzXCI6MjAwLCBcIkBzY29wZVwiOjIwNH07XG5jb25zdCBzcGVjX2lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsdG86MjA3fTtcbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCJFYlFZUWRPT08jcVFkT09QI3hPYE9PT09RUCcjQ2YnI0NmT09RUCcjQ2UnI0NlTyN9UWRPJyNDaE8kblFhTycjQ2NPJHhRZE8nI0NrTyVUUWRPJyNEcE8lWVFkTycjRHJPJV9RZE8nI0R1TyVfUWRPJyNEeE9PUVAnI0ZWJyNGVk8mZVFoTycjRWhPT1FTJyNGVScjRlVPT1FTJyNFaycjRWtRWVFkT09PJmxRZE8nI0VPTyZQUWhPJyNFVU8mbFFkTycjRVdPJ2FRZE8nI0VZTydsUWRPJyNFXU8ndFFoTycjRWNPKFZRZE8nI0VlTyhiUWFPJyNDZk8pVlFgTycjRHtPKVtRYE8nI0ZgTylnUWRPJyNGYFFPUWBPT1ApcU8mak8nI0NhUE9PTylDQHQpQ0B0T09RUCcjQ2onI0NqT09RUCw1OVMsNTlTTyN9UWRPLDU5U08pfFFkTyw1OVZPJVRRZE8sNTpbTyVZUWRPLDU6Xk8lX1FkTyw1OmFPJV9RZE8sNTpjTyVfUWRPLDU6ZE8lX1FkTycjRXJPKlhRYE8sNTh9TyphUWRPJyNEek9PUVMsNTh9LDU4fU9PUVAnI0NuJyNDbk9PUU8nI0RuJyNEbk9PUVAsNTlWLDU5Vk8qaFFgTyw1OVZPKm1RYE8sNTlWT09RUCcjRHEnI0RxT09RUCw1OlssNTpbT09RTycjRHMnI0RzTypyUXBPLDU6Xk8rXVFhTyw1OmFPK3NRYU8sNTpkT09RVycjRFonI0RaTyxaUWhPJyNEZE8seFFoTycjRmFPJ3RRaE8nI0RiTy1XUWBPJyNEaE9PUVcnI0ZbJyNGW08tXVFgTyw1O1NPLWVRYE8nI0RlT09RUy1FOGktRThpT09RWycjQ3MnI0NzTy1qUWRPJyNDdE8uUVFkTycjQ3pPLmhRZE8nI0N9Ty9PUSFwTycjRFBPMVJRIWpPLDU6ak9PUU8nI0RVJyNEVU8qbVFgTycjRFRPMWNRIW5PJyNGWE8zYFFgTycjRFZPM2VRYE8nI0RrT09RWycjRlgnI0ZYTy1gUWBPLDU6cE8zalEhYk8sNTpyT09RUycjRVsnI0VbTzNyUWBPLDU6dE8zd1FkTyw1OnRPT1FPJyNFXycjRV9PNFBRYE8sNTp3TzRVUWhPLDU6fU8lX1FkTycjRGdPT1FTLDU7UCw1O1BPLWVRYE8sNTtQTzReUWRPLDU7UE80ZlFkTyw1OmdPNHZRZE8nI0V0TzVUUWBPLDU7ek81VFFgTyw1O3pQT09PJyNFaicjRWpQNWBPJmpPLDU4e1BPT08sNTh7LDU4e09PUVAxRy5uMUcubk9PUVAxRy5xMUcucU8qaFFgTzFHLnFPKm1RYE8xRy5xT09RUDFHL3YxRy92TzVrUXBPMUcveE81c1FhTzFHL3tPNlpRYU8xRy99TzZxUWFPMUcwT083WFFhTyw1O15PT1FPLUU4cC1FOHBPT1FTMUcuaTFHLmlPN2NRYE8sNTpmTzdoUWRPJyNEb083b1FkTycjQ3JPT1FQMUcveDFHL3hPJmxRZE8xRy94Tzd2USFqTycjRFpPOFVRIWJPLDU5dk84XlFoTyw1Ok9PT1FPJyNGXScjRl1POFhRIWJPLDU5ek8ndFFoTyw1OXhPOGZRaE8nI0V2TzhzUWBPLDU7e085T1FoTyw1OXxPOXVRaE8nI0RpT09RVyw1OlMsNTpTT09RUzFHMG4xRzBuT09RVyw1OlAsNTpQTzl8USFmTycjRllPT1FTJyNGWScjRllPT1FTJyNFbScjRW1PO15RZE8sNTlgT09RWyw1OWAsNTlgTzt0UWRPLDU5Zk9PUVssNTlmLDU5Zk88W1FkTyw1OWlPT1FbLDU5aSw1OWlPT1FbLDU5ayw1OWtPJmxRZE8sNTltTzxyUWhPJyNFUU9PUVcnI0VRJyNFUU89V1FgTzFHMFVPMVtRaE8xRzBVT09RWyw1OW8sNTlvTyd0UWhPJyNEWE9PUVssNTlxLDU5cU89XVEjdE8sNTpWT09RUzFHMFsxRzBbT09RUzFHMF4xRzBeT09RUzFHMGAxRzBgTz1oUWBPMUcwYE89bVFkTycjRWBPT1FTMUcwYzFHMGNPT1FTMUcwaTFHMGlPPXhRYU8sNTpSTy1gUWBPMUcwa09PUVMxRzBrMUcwa08tZVFgTzFHMGtPPlBRIWZPMUcwUk9PUU8xRzBSMUcwUk9PUU8sNTtgLDU7YE8+Z1FkTyw1O2BPT1FPLUU4ci1FOHJPPnRRYE8xRzFmUE9PTy1FOGgtRThoUE9PTzFHLmcxRy5nT09RUDcrJF03KyRdT09RUDcrJWQ3KyVkTyZsUWRPNyslZE9PUVMxRzBRMUcwUU8/UFFhTycjRl9PP1pRYE8sNTpaTz9gUSFmTycjRWxPQF5RZE8nI0ZXT0BoUWBPLDU5Xk9AbVEhYk83KyVkTyZsUWRPMUcvYk9AdVFoTzFHL2ZPT1FXMUcvajFHL2pPT1FXMUcvZDFHL2RPQVdRaE8sNTtiT09RTy1FOHQtRTh0T0FmUWhPJyNEWk9BdFFoTycjRl5PQlBRYE8nI0ZeT0JVUWBPLDU6VE9PUVMtRThrLUU4a09PUVsxRy56MUcuek9PUVsxRy9RMUcvUU9PUVsxRy9UMUcvVE9PUVsxRy9YMUcvWE9CWlFkTyw1OmxPT1FTNyslcDcrJXBPQmBRYE83KyVwT0JlUWhPJyNEWU9CbVFgTyw1OXNPJ3RRaE8sNTlzT09RWzFHL3ExRy9xT0J1UWBPMUcvcU9PUVM3KyV6Nyslek9CelFiTycjRFBPT1FPJyNFYicjRWJPQ1lRYE8nI0VhT09RTycjRWEnI0VhT0NlUWBPJyNFd09DbVFkTyw1OnpPT1FTLDU6eiw1OnpPT1FbMUcvbTFHL21PT1FTNysmVjcrJlZPLWBRYE83KyZWT0N4USFmTycjRXNPJmxRZE8nI0VzT0VQUWRPNyslbU9PUU83KyVtNyslbU9PUU8xRzB6MUcwek9FZFEhYk88PElPT0VsUWRPJyNFcU9FdlFgTyw1O3lPT1FQMUcvdTFHL3VPT1FTLUU4ai1FOGpPRk9RZE8nI0VwT0ZZUWBPLDU7ck9PUV0xRy54MUcueE9PUVA8PElPPDxJT09GYlFkTzcrJHxPT1FPJyNEXScjRF1PRmlRIWJPNyslUU9GcVFoTycjRW9PRntRYE8sNTt4TyZsUWRPLDU7eE9PUVcxRy9vMUcvb09PUU8nI0VTJyNFU09HVFFgTzFHMFdPT1FTPDxJWzw8SVtPJmxRZE8sNTl0T0duUWhPMUcvX09PUVsxRy9fMUcvX09HdVFgTzFHL19PT1FXLUU4bC1FOGxPT1FbNyslXTcrJV1PT1FPLDU6eyw1OntPPXBRZE8nI0V4T0NlUWBPLDU7Y09PUVMsNTtjLDU7Y09PUVMtRTh1LUU4dU9PUVMxRzBmMUcwZk9PUVM8PElxPDxJcU9HfVEhZk8sNTtfT09RUy1FOHEtRThxT09RTzw8SVg8PElYT09RUEFOPmpBTj5qT0lVUWFPLDU7XU9PUU8tRThvLUU4b09JYFFkTyw1O1tPT1FPLUU4bi1FOG5PT1FXPDxIaDw8SGhPT1FXPDxIbDw8SGxPSWpRaE88PEhsT0l7UWhPLDU7Wk9KV1FgTyw1O1pPT1FPLUU4bS1FOG1PSl1RZE8xRzFkT0JaUWRPJyNFdU9KZ1FgTzcrJXJPT1FXNyslcjcrJXJPSm9RIWJPMUcvYE9PUVs3KyR5NyskeU9KelFoTzcrJHlQS1JRYE8nI0VuT09RTyw1O2QsNTtkT09RTy1FOHYtRTh2T09RUzFHMH0xRzB9T0tXUWBPQU4+V08mbFFkTzFHMHVPS11RYE83KydPT09RTyw1O2EsNTthT09RTy1FOHMtRThzT09RVzw8SV48PEleT09RWzw8SGU8PEhlUE9RVyw1O1ksNTtZT09RV0cyM3JHMjNyT0tlUWRPNysmYVwiLFxuICBzdGF0ZURhdGE6IFwiS3h+TyNzT1MjdFFRfk9XW09aW09dVE9gVk9hVk9pXU9qV09tWE8hallPIW1aTyFzYU8heWJPIXtjTyF9ZE8jUWVPI1dmTyNZZ08jb1JPfk9RaU9XW09aW09dVE9gVk9hVk9pXU9qV09tWE8hallPIW1aTyFzYU8heWJPIXtjTyF9ZE8jUWVPI1dmTyNZZ08jb2hPfk8jbSRTUH5QIWRPI3RtT35PI29vT35PXXFPYHJPYXJPanNPbXRPIWp1TyFtd08jbnZPfk9wek8hXnhPflAkU09jIVFPI298TyNwfU9+TyNvIVJPfk8jbyFUT35PV1tPWltPXVRPYFZPYVZPaldPbVhPIWpZTyFtWk8jb1JPfk9TIV1PZSFZTyFWIVtPIVkhYE8jcSFYT3AkVFB+T2skVFB+UCZQT1Ehak9lIWNPbSFkT3AhZU9yIW1PdCFtT3oha08hYCFsTyNvIWJPI3AhaE8jfSFmT35PdCFxTyFgIWxPI28hcE9+T3Qhc08jbyFzT35PUyFdT2UhWU8hViFbTyFZIWBPI3EhWE9+T2Uhdk9wek8jWiF4T35PXVlYYFlYYCFwWGFZWGpZWG1ZWHBZWCFeWVghallYIW1ZWCNuWVh+T2Ahek9+T2she08jbSRTWG8kU1h+TyNtJFNYbyRTWH5QIWRPI3UjT08jdiNPTyN3I1FPfk9jI1VPI298TyNwfU9+T3B6TyFeeE9+T28kU1B+UCFkT2UjYE9+T2UjYU9+T2wjYk8haCNjT35PXXFPYHJPYXJPanNPbXRPfk9wIWlhIV4haWEhaiFpYSFtIWlhI24haWFkIWlhflAqek9wIWxhIV4hbGEhaiFsYSFtIWxhI24hbGFkIWxhflAqek9SI2dPUyFdT2UhWU9yI2dPdCNnTyFWIVtPIVkhYE8jcSNkTyN9IWZPfk8hUiNpTyFeI2pPayRUWHAkVFh+T2UjbU9+T2sjb09wek9+T2Uhdk9+T10jck9gI3JPZCN1T2kjck9qI3JPayNyT35QJmxPXSNyT2Ajck9pI3JPaiNyT2sjck9sI3dPflAmbE9dI3JPYCNyT2kjck9qI3JPayNyT28jeU9+UCZsT1Ajek9Tc1hlc1hrc1h2c1ghVnNYIVlzWCF1c1ghd3NYI3FzWCFUc1hRc1hdc1hgc1hkc1hpc1hqc1htc1hwc1hyc1h0c1h6c1ghYHNYI29zWCNwc1gjfXNYbHNYb3NYIV5zWCFxc1gjbXNYfk92I3tPIXUjfE8hdyN9T2skVFB+UCd0T2UjYU9TI3tYayN7WHYje1ghViN7WCFZI3tYIXUje1ghdyN7WCNxI3tYUSN7WF0je1hgI3tYZCN7WGkje1hqI3tYbSN7WHAje1hyI3tYdCN7WHoje1ghYCN7WCNvI3tYI3Aje1gjfSN7WGwje1hvI3tYIV4je1ghcSN7WCNtI3tYfk9lJFJPfk9lJFRPfk9rJFZPdiN7T35PayRXT35PdCRYTyFgIWxPfk9wJFlPfk9wek8hUiNpT35PcHpPI1okYE9+TyFxJGJPayFvYSNtIW9hbyFvYX5QJmxPayNoWCNtI2hYbyNoWH5QIWRPayF7TyNtJFNhbyRTYX5PI3UjT08jdiNPTyN3JGhPfk9sJGpPIWgka09+T3AhaWkhXiFpaSFqIWlpIW0haWkjbiFpaWQhaWl+UCp6T3Aha2khXiFraSFqIWtpIW0ha2kjbiFraWQha2l+UCp6T3AhbGkhXiFsaSFqIWxpIW0hbGkjbiFsaWQhbGl+UCp6T3AjZmEhXiNmYX5QJFNPbyRsT35PZCRSUH5QJV9PZCN6UH5QJmxPYCFQWGR9WCFSfVghVCFQWH5PYCRzTyFUJHRPfk9kJHVPIVIjaU9+T2sjalhwI2pYIV4jalh+UCd0TyFeI2pPayRUYXAkVGF+TyFSI2lPayFVYXAhVWEhXiFVYWQhVWFgIVVhfk9TIV1PZSFZTyFWIVtPIVkhYE8jcSR5T35PZCRRUH5QOWRPdiN7T1EjfFhdI3xYYCN8WGQjfFhlI3xYaSN8WGojfFhrI3xYbSN8WHAjfFhyI3xYdCN8WHojfFghYCN8WCNvI3xYI3AjfFgjfSN8WGwjfFhvI3xYfk9dI3JPYCNyT2QlT09pI3JPaiNyT2sjck9+UCZsT10jck9gI3JPaSNyT2ojck9rI3JPbCVQT35QJmxPXSNyT2Ajck9pI3JPaiNyT2sjck9vJVFPflAmbE9lJVNPUyF0WGshdFghViF0WCFZIXRYI3EhdFh+T2slVE9+T2QlWU90JVpPIWElWk9+T2slW09+T28lY08jbyVeTyN9JV1Pfk9kJWRPflAkU092I3tPIV4laE8hcSVqT2shb2kjbSFvaW8hb2l+UCZsT2sjaGEjbSNoYW8jaGF+UCFkT2she08jbSRTaW8kU2l+TyFeJW1PZCRSWH5QJFNPZCVvT35PdiN7T1EjYFhkI2BYZSNgWG0jYFhwI2BYciNgWHQjYFh6I2BYIV4jYFghYCNgWCNvI2BYI3AjYFgjfSNgWH5PIV4lcU9kI3pYflAmbE9kJXNPfk9sJXRPdiN7T35PUiNnT3IjZ090I2dPI3Eldk8jfSFmT35PIVIjaU9rI2phcCNqYSFeI2phfk9gIVBYZH1YIVJ9WCFefVh+TyFSI2lPIV4leE9kJFFYfk9gJXpPfk9kJXtPfk8jbyV8T35PayZPT35PYCZQTyFSI2lPfk9kJlJPayZRT35PZCZVT35PUCN6T3BzWCFec1hkc1h+TyN9JV1PcCNUWCFeI1RYfk9wek8hXiZXT35PbyZbTyNvJV5PI30lXU9+T3Yje09RI2dYZSNnWGsjZ1htI2dYcCNnWHIjZ1h0I2dYeiNnWCFeI2dYIWAjZ1ghcSNnWCNtI2dYI28jZ1gjcCNnWCN9I2dYbyNnWH5PIV4laE8hcSZgT2shb3EjbSFvcW8hb3F+UCZsT2wmYU92I3tPfk9kI2VYIV4jZVh+UCVfTyFeJW1PZCRSYX5PZCNkWCFeI2RYflAmbE8hXiVxT2QjemF+T2QmZk9+UCZsT2QmZ08hVCZoT35PZCNjWCFeI2NYflA5ZE8hXiV4T2QkUWF+T10mbU9kJm9Pfk9TI2JhZSNiYSFWI2JhIVkjYmEjcSNiYX5PZCZxT35QR11PZCZxT2smck9+T3Yje09RI2dhZSNnYWsjZ2FtI2dhcCNnYXIjZ2F0I2dheiNnYSFeI2dhIWAjZ2EhcSNnYSNtI2dhI28jZ2EjcCNnYSN9I2dhbyNnYX5PZCNlYSFeI2VhflAkU09kI2RhIV4jZGF+UCZsT1IjZ09yI2dPdCNnTyNxJXZPI30lXU9+TyFSI2lPZCNjYSFeI2Nhfk9gJnhPfk8hXiV4T2QkUWl+UCZsT10mbU9kJnxPfk92I3tPZHxpa3xpfk9kJn1PflBHXU9rJ09Pfk9kJ1BPfk8hXiV4T2QkUXF+T2QjY3EhXiNjcX5QJmxPI3MhYSN0I31dI312IW1+XCIsXG4gIGdvdG86IFwiMmgkVVBQUFBQJFZQJFlQJGMkdVAkY1AlWCRjUFAlX1BQUCVlJW8lb1BQUFBQJW9QUCVvUCZdUCVvUCVvJ1clb1AndCd3J30nfSheJ31QJ31QJ31QJ30nfVAobSd9KHlQKHxQUClwKXYkYyl8JGMqU1AkY1AkYyRjUCpZKnsrWVAkWVArYVArZFAkWVAkWVAkWVAraiRZUCttK3Arcyt6JFlQJFlQUCRZUCxQLFYsZix8LVstYi1sLXIteC5PLlUuYC5mLmwuclBQUFBQUFBQUFBQLngvUi93L3owfFAxVTF1Mk8yUjJVMltSblFfXk9QYGt6IXskZHFbT1BZWmBrdXZ3eHohdiF7I2AkZCVtcVNPUFlaYGt1dnd4eiF2IXsjYCRkJW1RcFRSI1JxUSFPVlIjU3JRI1MhUVMkUSFpIWpSJGkjVSFWIW1hYyFjIWQhZSF6I2EjYyN0I3YjeCN7JGEkayRwJHMlaCVpJXEldSV6JlAmZCZsJngnUSFVIW1hYyFjIWQhZSF6I2EjYyN0I3YjeCN7JGEkayRwJHMlaCVpJXEldSV6JlAmZCZsJngnUVUjZyFZJHQmaFUlYCRZJWImV1ImViVfIVYhaWFjIWMhZCFlIXojYSNjI3QjdiN4I3skYSRrJHAkcyVoJWklcSV1JXomUCZkJmwmeCdRUiRTIWtRJVckUlImUyVYayFeXWJmIVkhWyFnI2kjaiNtJFAkUiVYJXhRI2UhWVEkeyNtUSV3JHRRJmoleFImdyZoUSF5Z1EjcCFgUSReIXhSJWYkYFIjbiFdIVUhbWFjIWMhZCFlIXojYSNjI3QjdiN4I3skYSRrJHAkcyVoJWklcSV1JXomUCZkJmwmeCdRUSFxZFIkWCFyUSFQVlIjVHJRI1MhUFIkaSNUUSFTV1IjVnNRIVVYUiNXdFF7VVEhd2dRI155USNvIV9RJFUhblEkWyF1USRfIXlRJWUkXlEmWSVhUSZdJWZSJnYmWFNqUHpRIX1rUSRjIXtSJWskZFppUGt6IXskZFIkUCFnUSV9JVNSJnombVIhcmRSIXRlUiRaIXRTJWEkWSViUiZ0JldWJV8kWSViJldRI1BtUiRnI1BRYE9Ta1B6VSFhYGskZFIkZCF7USRwI2FZJXAkcCV1JmQmbCdRUSV1JHNRJmQlcVEmbCV6UidRJnhRI3QhY1EjdiFkUSN4IWVWJH0jdCN2I3hRJVgkUlImVCVYUSV5JHpTJmsleSZ5UiZ5JmxRJXIkcFImZSVyUSVuJG1SJmMlblF5VVIjXXlRJWkkYVImXyVpUSF8alMkZSF8JGZSJGYhfVEmbiV9UiZ7Jm5RI2shWlIkeCNrUSViJFlSJlolYlEmWCVhUiZ1JlhfX09QYGt6IXskZF5VT1Bga3oheyRkUSFWWVEhV1pRI1h1USNZdlEjWndRI1t4USRdIXZRJG0jYFImYiVtUiRxI2FRIWdhUSFvY1sjcSFjIWQhZSN0I3YjeFEkYSF6ZCRvI2EkcCRzJXEldSV6JmQmbCZ4J1FRJHIjY1ElUiN7UyVnJGElaVElbCRrUSZeJWhSJnAmUF0jcyFjIWQhZSN0I3YjeFchWl1iIWckUFEhdWZRI2YhWVEjbCFbUSR2I2lRJHcjalEkeiNtUyVWJFIlWFImaSV4USNoIVlRJXckdFImdyZoUiR8I21SJG4jYFFsUFIjX3pRIV9dUSFuYlEkTyFnUiVVJFBcIixcbiAgbm9kZU5hbWVzOiBcIlx1MjZBMCBVbml0IFZhcmlhYmxlTmFtZSBWYXJpYWJsZU5hbWUgUXVlcnlDYWxsZWUgQ29tbWVudCBTdHlsZVNoZWV0IFJ1bGVTZXQgVW5pdmVyc2FsU2VsZWN0b3IgVGFnU2VsZWN0b3IgVGFnTmFtZSBOZXN0aW5nU2VsZWN0b3IgQ2xhc3NTZWxlY3RvciAuIENsYXNzTmFtZSBQc2V1ZG9DbGFzc1NlbGVjdG9yIDogOjogUHNldWRvQ2xhc3NOYW1lIFBzZXVkb0NsYXNzTmFtZSApICggQXJnTGlzdCBWYWx1ZU5hbWUgUGFyZW50aGVzaXplZFZhbHVlIEF0S2V5d29yZCAjIDsgXSBbIEJyYWNrZXRlZFZhbHVlIH0geyBCcmFjZWRWYWx1ZSBDb2xvckxpdGVyYWwgTnVtYmVyTGl0ZXJhbCBTdHJpbmdMaXRlcmFsIEJpbmFyeUV4cHJlc3Npb24gQmluT3AgQ2FsbEV4cHJlc3Npb24gQ2FsbGVlIElmRXhwcmVzc2lvbiBpZiBBcmdMaXN0IElmQnJhbmNoIEtleXdvcmRRdWVyeSBGZWF0dXJlUXVlcnkgRmVhdHVyZU5hbWUgQmluYXJ5UXVlcnkgTG9naWNPcCBDb21wYXJpc29uUXVlcnkgQ29tcGFyZU9wIFVuYXJ5UXVlcnkgVW5hcnlRdWVyeU9wIFBhcmVudGhlc2l6ZWRRdWVyeSBTZWxlY3RvclF1ZXJ5IHNlbGVjdG9yIFBhcmVudGhlc2l6ZWRTZWxlY3RvciBDYWxsUXVlcnkgQXJnTGlzdCAsIENhbGxMaXRlcmFsIENhbGxUYWcgUGFyZW50aGVzaXplZENvbnRlbnQgUHNldWRvQ2xhc3NOYW1lIEFyZ0xpc3QgSWRTZWxlY3RvciBJZE5hbWUgQXR0cmlidXRlU2VsZWN0b3IgQXR0cmlidXRlTmFtZSBNYXRjaE9wIENoaWxkU2VsZWN0b3IgQ2hpbGRPcCBEZXNjZW5kYW50U2VsZWN0b3IgU2libGluZ1NlbGVjdG9yIFNpYmxpbmdPcCBCbG9jayBEZWNsYXJhdGlvbiBQcm9wZXJ0eU5hbWUgSW1wb3J0YW50IEltcG9ydFN0YXRlbWVudCBpbXBvcnQgTGF5ZXIgbGF5ZXIgTGF5ZXJOYW1lIGxheWVyIE1lZGlhU3RhdGVtZW50IG1lZGlhIENoYXJzZXRTdGF0ZW1lbnQgY2hhcnNldCBOYW1lc3BhY2VTdGF0ZW1lbnQgbmFtZXNwYWNlIE5hbWVzcGFjZU5hbWUgS2V5ZnJhbWVzU3RhdGVtZW50IGtleWZyYW1lcyBLZXlmcmFtZU5hbWUgS2V5ZnJhbWVMaXN0IEtleWZyYW1lU2VsZWN0b3IgS2V5ZnJhbWVSYW5nZU5hbWUgU3VwcG9ydHNTdGF0ZW1lbnQgc3VwcG9ydHMgU2NvcGVTdGF0ZW1lbnQgc2NvcGUgdG8gQXRSdWxlIFN0eWxlc1wiLFxuICBtYXhUZXJtOiAxNDMsXG4gIG5vZGVQcm9wczogW1xuICAgIFtcImlzb2xhdGVcIiwgLTIsNSwzNixcIlwiXSxcbiAgICBbXCJvcGVuZWRCeVwiLCAyMCxcIihcIiwyOCxcIltcIiwzMSxcIntcIl0sXG4gICAgW1wiY2xvc2VkQnlcIiwgMjEsXCIpXCIsMjksXCJdXCIsMzIsXCJ9XCJdXG4gIF0sXG4gIHByb3BTb3VyY2VzOiBbY3NzSGlnaGxpZ2h0aW5nXSxcbiAgc2tpcHBlZE5vZGVzOiBbMCw1LDEwNl0sXG4gIHJlcGVhdE5vZGVDb3VudDogMTUsXG4gIHRva2VuRGF0YTogXCJKUX5SIVlPWCRxWF4laV5wJHFwcSVpcXIoe3JzLXVzdC9pdHU2V3V2JHF2dzdRd3g3Y3h5OVF5ejljens5aHt8OlJ8fT50fSFPP1YhTyFQP3QhUCFRQF0hUSFbQVUhWyFdQlAhXSFeQnshXiFfQ14hXyFgRFkhYCFhRG0hYSFiJHEhYiFjRW4hYyF9JHEhfSNPR3sjTyNQJHEjUCNRSF4jUSNSNlcjUiNvJHEjbyNwSG8jcCNxNlcjcSNySVEjciNzSWMjcyN5JHEjeSN6JWkjeiRmJHEkZiRnJWkkZyNCWSRxI0JZI0JaJWkjQlokSVMkcSRJUyRJXyVpJElfJEl8JHEkSXwkSk8laSRKTyRKVCRxJEpUJEpVJWkkSlUkS1YkcSRLViRLVyVpJEtXJkZVJHEmRlUmRlYlaSZGVjsnUyRxOydTOz1gSXo8JWxPJHFgJHRTT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRYCVWUyFhYE95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWAlZlA7PWA8JWwlUX4lbmgjc35PWCVRWF4nWV5wJVFwcSdZcXklUXojeSVRI3kjeidZI3okZiVRJGYkZydZJGcjQlklUSNCWSNCWidZI0JaJElTJVEkSVMkSV8nWSRJXyRJfCVRJEl8JEpPJ1kkSk8kSlQlUSRKVCRKVSdZJEpVJEtWJVEkS1YkS1cnWSRLVyZGVSVRJkZVJkZWJ1kmRlY7J1MlUTsnUzs9YCVjPCVsTyVRfidhaCNzfiFhYE9YJVFYXidZXnAlUXBxJ1lxeSVReiN5JVEjeSN6J1kjeiRmJVEkZiRnJ1kkZyNCWSVRI0JZI0JaJ1kjQlokSVMlUSRJUyRJXydZJElfJEl8JVEkSXwkSk8nWSRKTyRKVCVRJEpUJEpVJ1kkSlUkS1YlUSRLViRLVydZJEtXJkZVJVEmRlUmRlYnWSZGVjsnUyVROydTOz1gJWM8JWxPJVFqKU9VT3klUXojXSVRI10jXiliI147J1MlUTsnUzs9YCVjPCVsTyVRailnVSFhYE95JVF6I2ElUSNhI2IpeSNiOydTJVE7J1M7PWAlYzwlbE8lUWoqT1UhYWBPeSVReiNkJVEjZCNlKmIjZTsnUyVROydTOz1gJWM8JWxPJVFqKmdVIWFgT3klUXojYyVRI2MjZCp5I2Q7J1MlUTsnUzs9YCVjPCVsTyVRaitPVSFhYE95JVF6I2YlUSNmI2crYiNnOydTJVE7J1M7PWAlYzwlbE8lUWorZ1UhYWBPeSVReiNoJVEjaCNpK3kjaTsnUyVROydTOz1gJWM8JWxPJVFqLE9VIWFgT3klUXojVCVRI1QjVSxiI1U7J1MlUTsnUzs9YCVjPCVsTyVRaixnVSFhYE95JVF6I2IlUSNiI2MseSNjOydTJVE7J1M7PWAlYzwlbE8lUWotT1UhYWBPeSVReiNoJVEjaCNpLWIjaTsnUyVROydTOz1gJWM8JWxPJVFqLWlTIXFZIWFgT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRfi14V09ZLXVaci11cnMuYnMjTy11I08jUC5nI1A7J1MtdTsnUzs9YC9jPCVsTy11fi5nT3R+fi5qUk87J1MtdTsnUzs9YC5zOz1gTy11fi52WE9ZLXVaci11cnMuYnMjTy11I08jUC5nI1A7J1MtdTsnUzs9YC9jOz1gPCVsLXU8JWxPLXV+L2ZQOz1gPCVsLXVqL25ZallPeSVReiFRJVEhUSFbMF4hWyFjJVEhYyFpMF4haSNUJVEjVCNaMF4jWjsnUyVROydTOz1gJWM8JWxPJVFqMGNZIWFgT3klUXohUSVRIVEhWzFSIVshYyVRIWMhaTFSIWkjVCVRI1QjWjFSI1o7J1MlUTsnUzs9YCVjPCVsTyVRajFXWSFhYE95JVF6IVElUSFRIVsxdiFbIWMlUSFjIWkxdiFpI1QlUSNUI1oxdiNaOydTJVE7J1M7PWAlYzwlbE8lUWoxfVlyWSFhYE95JVF6IVElUSFRIVsybSFbIWMlUSFjIWkybSFpI1QlUSNUI1oybSNaOydTJVE7J1M7PWAlYzwlbE8lUWoydFlyWSFhYE95JVF6IVElUSFRIVszZCFbIWMlUSFjIWkzZCFpI1QlUSNUI1ozZCNaOydTJVE7J1M7PWAlYzwlbE8lUWozaVkhYWBPeSVReiFRJVEhUSFbNFghWyFjJVEhYyFpNFghaSNUJVEjVCNaNFgjWjsnUyVROydTOz1gJWM8JWxPJVFqNGBZclkhYWBPeSVReiFRJVEhUSFbNU8hWyFjJVEhYyFpNU8haSNUJVEjVCNaNU8jWjsnUyVROydTOz1gJWM8JWxPJVFqNVRZIWFgT3klUXohUSVRIVEhWzVzIVshYyVRIWMhaTVzIWkjVCVRI1QjWjVzI1o7J1MlUTsnUzs9YCVjPCVsTyVRajV6U3JZIWFgT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRZDZaVU95JVF6IV8lUSFfIWA2bSFgOydTJVE7J1M7PWAlYzwlbE8lUWQ2dFMhaFMhYWBPeSVRejsnUyVROydTOz1gJWM8JWxPJVFiN1ZTWlFPeSVRejsnUyVROydTOz1gJWM8JWxPJVF+N2ZXT1k3Y1p3N2N3eC5ieCNPN2MjTyNQOE8jUDsnUzdjOydTOz1gOHo8JWxPN2N+OFJSTzsnUzdjOydTOz1gOFs7PWBPN2N+OF9YT1k3Y1p3N2N3eC5ieCNPN2MjTyNQOE8jUDsnUzdjOydTOz1gOHo7PWA8JWw3YzwlbE83Y344fVA7PWA8JWw3Y2o5VlNlWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUX45aE9kfm45b1VXUXZXT3klUXohXyVRIV8hYDZtIWA7J1MlUTsnUzs9YCVjPCVsTyVRajpZV3ZXIW1RT3klUXohTyVRIU8hUDpyIVAhUSVRIVEhWz13IVs7J1MlUTsnUzs9YCVjPCVsTyVRajp3VSFhYE95JVF6IVElUSFRIVs7WiFbOydTJVE7J1M7PWAlYzwlbE8lUWo7YlkhYWAjfVlPeSVReiFRJVEhUSFbO1ohWyFnJVEhZyFoPFEhaCNYJVEjWCNZPFEjWTsnUyVROydTOz1gJWM8JWxPJVFqPFZZIWFgT3klUXp7JVF7fDx1fH0lUX0hTzx1IU8hUSVRIVEhWz1eIVs7J1MlUTsnUzs9YCVjPCVsTyVRajx6VSFhYE95JVF6IVElUSFRIVs9XiFbOydTJVE7J1M7PWAlYzwlbE8lUWo9ZVUhYWAjfVlPeSVReiFRJVEhUSFbPV4hWzsnUyVROydTOz1gJWM8JWxPJVFqPk9bIWFgI31ZT3klUXohTyVRIU8hUDtaIVAhUSVRIVEhWz13IVshZyVRIWchaDxRIWgjWCVRI1gjWTxRI1k7J1MlUTsnUzs9YCVjPCVsTyVRaj55UyFeWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWo/W1d2V095JVF6IU8lUSFPIVA6ciFQIVElUSFRIVs9dyFbOydTJVE7J1M7PWAlYzwlbE8lUWo/eVVdWU95JVF6IVElUSFRIVs7WiFbOydTJVE7J1M7PWAlYzwlbE8lUX5AYlR2V095JVF6e0BxezsnUyVROydTOz1gJWM8JWxPJVF+QHhTIWFgI3R+T3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRakFaWyN9WU95JVF6IU8lUSFPIVA7WiFQIVElUSFRIVs9dyFbIWclUSFnIWg8USFoI1glUSNYI1k8USNZOydTJVE7J1M7PWAlYzwlbE8lUWpCVVVgWU95JVF6IVslUSFbIV1CaCFdOydTJVE7J1M7PWAlYzwlbE8lUWJCb1NhUSFhYE95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWpDUVNrWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWhDY1UhVFdPeSVReiFfJVEhXyFgQ3UhYDsnUyVROydTOz1gJWM8JWxPJVFoQ3xTIVRXIWFgT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRbERhUyFUVyFoU095JVF6OydTJVE7J1M7PWAlYzwlbE8lUWpEdFYhalEhVFdPeSVReiFfJVEhXyFgQ3UhYCFhRVohYTsnUyVROydTOz1gJWM8JWxPJVFiRWJTIWpRIWFgT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRakVxWU95JVF6fSVRfSFPRmEhTyFjJVEhYyF9R08hfSNUJVEjVCNvR08jbzsnUyVROydTOz1gJWM8JWxPJVFqRmZXIWFgT3klUXohYyVRIWMhfUdPIX0jVCVRI1Qjb0dPI287J1MlUTsnUzs9YCVjPCVsTyVRakdWW2lZIWFgT3klUXp9JVF9IU9HTyFPIVElUSFRIVtHTyFbIWMlUSFjIX1HTyF9I1QlUSNUI29HTyNvOydTJVE7J1M7PWAlYzwlbE8lUWpIUVNtWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUW5IY1NsXk95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWpIdFNwWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWpJVlNvWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWZJaFUhbVFPeSVReiFfJVEhXyFgNm0hYDsnUyVROydTOz1gJWM8JWxPJVFgSX1QOz1gPCVsJHFcIixcbiAgdG9rZW5pemVyczogW2Rlc2NlbmRhbnQsIHVuaXRUb2tlbiwgaWRlbnRpZmllcnMsIHF1ZXJ5SWRlbnRpZmllcnMsIDEsIDIsIDMsIDQsIG5ldyBMb2NhbFRva2VuR3JvdXAoXCJtflJSWVpbenthfn5nfmFPI3Z+fmRQIVAhUWd+bE8jd35+XCIsIDI4LCAxMjkpXSxcbiAgdG9wUnVsZXM6IHtcIlN0eWxlU2hlZXRcIjpbMCw2XSxcIlN0eWxlc1wiOlsxLDEwNV19LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAxMjQsIGdldDogKHZhbHVlKSA9PiBzcGVjX2NhbGxlZVt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiAxMjUsIGdldDogKHZhbHVlKSA9PiBzcGVjX3F1ZXJ5SWRlbnRpZmllclt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiA0LCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19RdWVyeUNhbGxlZVt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiAyNSwgZ2V0OiAodmFsdWUpID0+IHNwZWNfQXRLZXl3b3JkW3ZhbHVlXSB8fCAtMX0se3Rlcm06IDEyMywgZ2V0OiAodmFsdWUpID0+IHNwZWNfaWRlbnRpZmllclt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiAxOTYzXG59KTtcblxuZXhwb3J0IHsgcGFyc2VyIH07XG4iLCAiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnQGxlemVyL2Nzcyc7XG5pbXBvcnQgeyBzeW50YXhUcmVlLCBMUkxhbmd1YWdlLCBpbmRlbnROb2RlUHJvcCwgY29udGludWVkSW5kZW50LCBmb2xkTm9kZVByb3AsIGZvbGRJbnNpZGUsIExhbmd1YWdlU3VwcG9ydCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IE5vZGVXZWFrTWFwLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG5sZXQgX3Byb3BlcnRpZXMgPSBudWxsO1xuZnVuY3Rpb24gcHJvcGVydGllcygpIHtcbiAgICBpZiAoIV9wcm9wZXJ0aWVzICYmIHR5cGVvZiBkb2N1bWVudCA9PSBcIm9iamVjdFwiICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgbGV0IHsgc3R5bGUgfSA9IGRvY3VtZW50LmJvZHksIG5hbWVzID0gW10sIHNlZW4gPSBuZXcgU2V0O1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHN0eWxlKVxuICAgICAgICAgICAgaWYgKHByb3AgIT0gXCJjc3NUZXh0XCIgJiYgcHJvcCAhPSBcImNzc0Zsb2F0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlW3Byb3BdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9bQS1aXS8udGVzdChwcm9wKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSBwcm9wLnJlcGxhY2UoL1tBLVpdL2csIGNoID0+IFwiLVwiICsgY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2Vlbi5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuLmFkZChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgX3Byb3BlcnRpZXMgPSBuYW1lcy5zb3J0KCkubWFwKG5hbWUgPT4gKHsgdHlwZTogXCJwcm9wZXJ0eVwiLCBsYWJlbDogbmFtZSwgYXBwbHk6IG5hbWUgKyBcIjogXCIgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Byb3BlcnRpZXMgfHwgW107XG59XG5jb25zdCBwc2V1ZG9DbGFzc2VzID0gLypAX19QVVJFX18qL1tcbiAgICBcImFjdGl2ZVwiLCBcImFmdGVyXCIsIFwiYW55LWxpbmtcIiwgXCJhdXRvZmlsbFwiLCBcImJhY2tkcm9wXCIsIFwiYmVmb3JlXCIsXG4gICAgXCJjaGVja2VkXCIsIFwiY3VlXCIsIFwiZGVmYXVsdFwiLCBcImRlZmluZWRcIiwgXCJkaXNhYmxlZFwiLCBcImVtcHR5XCIsXG4gICAgXCJlbmFibGVkXCIsIFwiZmlsZS1zZWxlY3Rvci1idXR0b25cIiwgXCJmaXJzdFwiLCBcImZpcnN0LWNoaWxkXCIsXG4gICAgXCJmaXJzdC1sZXR0ZXJcIiwgXCJmaXJzdC1saW5lXCIsIFwiZmlyc3Qtb2YtdHlwZVwiLCBcImZvY3VzXCIsXG4gICAgXCJmb2N1cy12aXNpYmxlXCIsIFwiZm9jdXMtd2l0aGluXCIsIFwiZnVsbHNjcmVlblwiLCBcImhhc1wiLCBcImhvc3RcIixcbiAgICBcImhvc3QtY29udGV4dFwiLCBcImhvdmVyXCIsIFwiaW4tcmFuZ2VcIiwgXCJpbmRldGVybWluYXRlXCIsIFwiaW52YWxpZFwiLFxuICAgIFwiaXNcIiwgXCJsYW5nXCIsIFwibGFzdC1jaGlsZFwiLCBcImxhc3Qtb2YtdHlwZVwiLCBcImxlZnRcIiwgXCJsaW5rXCIsIFwibWFya2VyXCIsXG4gICAgXCJtb2RhbFwiLCBcIm5vdFwiLCBcIm50aC1jaGlsZFwiLCBcIm50aC1sYXN0LWNoaWxkXCIsIFwibnRoLWxhc3Qtb2YtdHlwZVwiLFxuICAgIFwibnRoLW9mLXR5cGVcIiwgXCJvbmx5LWNoaWxkXCIsIFwib25seS1vZi10eXBlXCIsIFwib3B0aW9uYWxcIiwgXCJvdXQtb2YtcmFuZ2VcIixcbiAgICBcInBhcnRcIiwgXCJwbGFjZWhvbGRlclwiLCBcInBsYWNlaG9sZGVyLXNob3duXCIsIFwicmVhZC1vbmx5XCIsIFwicmVhZC13cml0ZVwiLFxuICAgIFwicmVxdWlyZWRcIiwgXCJyaWdodFwiLCBcInJvb3RcIiwgXCJzY29wZVwiLCBcInNlbGVjdGlvblwiLCBcInNsb3R0ZWRcIiwgXCJ0YXJnZXRcIixcbiAgICBcInRhcmdldC10ZXh0XCIsIFwidmFsaWRcIiwgXCJ2aXNpdGVkXCIsIFwid2hlcmVcIlxuXS5tYXAobmFtZSA9PiAoeyB0eXBlOiBcImNsYXNzXCIsIGxhYmVsOiBuYW1lIH0pKTtcbmNvbnN0IHZhbHVlcyA9IC8qQF9fUFVSRV9fKi9bXG4gICAgXCJhYm92ZVwiLCBcImFic29sdXRlXCIsIFwiYWN0aXZlYm9yZGVyXCIsIFwiYWRkaXRpdmVcIiwgXCJhY3RpdmVjYXB0aW9uXCIsIFwiYWZ0ZXItd2hpdGUtc3BhY2VcIixcbiAgICBcImFoZWFkXCIsIFwiYWxpYXNcIiwgXCJhbGxcIiwgXCJhbGwtc2Nyb2xsXCIsIFwiYWxwaGFiZXRpY1wiLCBcImFsdGVybmF0ZVwiLCBcImFsd2F5c1wiLFxuICAgIFwiYW50aWFsaWFzZWRcIiwgXCJhcHB3b3Jrc3BhY2VcIiwgXCJhc3Rlcmlza3NcIiwgXCJhdHRyXCIsIFwiYXV0b1wiLCBcImF1dG8tZmxvd1wiLCBcImF2b2lkXCIsIFwiYXZvaWQtY29sdW1uXCIsXG4gICAgXCJhdm9pZC1wYWdlXCIsIFwiYXZvaWQtcmVnaW9uXCIsIFwiYXhpcy1wYW5cIiwgXCJiYWNrZ3JvdW5kXCIsIFwiYmFja3dhcmRzXCIsIFwiYmFzZWxpbmVcIiwgXCJiZWxvd1wiLFxuICAgIFwiYmlkaS1vdmVycmlkZVwiLCBcImJsaW5rXCIsIFwiYmxvY2tcIiwgXCJibG9jay1heGlzXCIsIFwiYm9sZFwiLCBcImJvbGRlclwiLCBcImJvcmRlclwiLCBcImJvcmRlci1ib3hcIixcbiAgICBcImJvdGhcIiwgXCJib3R0b21cIiwgXCJicmVha1wiLCBcImJyZWFrLWFsbFwiLCBcImJyZWFrLXdvcmRcIiwgXCJidWxsZXRzXCIsIFwiYnV0dG9uXCIsIFwiYnV0dG9uLWJldmVsXCIsXG4gICAgXCJidXR0b25mYWNlXCIsIFwiYnV0dG9uaGlnaGxpZ2h0XCIsIFwiYnV0dG9uc2hhZG93XCIsIFwiYnV0dG9udGV4dFwiLCBcImNhbGNcIiwgXCJjYXBpdGFsaXplXCIsXG4gICAgXCJjYXBzLWxvY2staW5kaWNhdG9yXCIsIFwiY2FwdGlvblwiLCBcImNhcHRpb250ZXh0XCIsIFwiY2FyZXRcIiwgXCJjZWxsXCIsIFwiY2VudGVyXCIsIFwiY2hlY2tib3hcIiwgXCJjaXJjbGVcIixcbiAgICBcImNqay1kZWNpbWFsXCIsIFwiY2xlYXJcIiwgXCJjbGlwXCIsIFwiY2xvc2UtcXVvdGVcIiwgXCJjb2wtcmVzaXplXCIsIFwiY29sbGFwc2VcIiwgXCJjb2xvclwiLCBcImNvbG9yLWJ1cm5cIixcbiAgICBcImNvbG9yLWRvZGdlXCIsIFwiY29sdW1uXCIsIFwiY29sdW1uLXJldmVyc2VcIiwgXCJjb21wYWN0XCIsIFwiY29uZGVuc2VkXCIsIFwiY29udGFpblwiLCBcImNvbnRlbnRcIixcbiAgICBcImNvbnRlbnRzXCIsIFwiY29udGVudC1ib3hcIiwgXCJjb250ZXh0LW1lbnVcIiwgXCJjb250aW51b3VzXCIsIFwiY29weVwiLCBcImNvdW50ZXJcIiwgXCJjb3VudGVyc1wiLCBcImNvdmVyXCIsXG4gICAgXCJjcm9wXCIsIFwiY3Jvc3NcIiwgXCJjcm9zc2hhaXJcIiwgXCJjdXJyZW50Y29sb3JcIiwgXCJjdXJzaXZlXCIsIFwiY3ljbGljXCIsIFwiZGFya2VuXCIsIFwiZGFzaGVkXCIsIFwiZGVjaW1hbFwiLFxuICAgIFwiZGVjaW1hbC1sZWFkaW5nLXplcm9cIiwgXCJkZWZhdWx0XCIsIFwiZGVmYXVsdC1idXR0b25cIiwgXCJkZW5zZVwiLCBcImRlc3RpbmF0aW9uLWF0b3BcIiwgXCJkZXN0aW5hdGlvbi1pblwiLFxuICAgIFwiZGVzdGluYXRpb24tb3V0XCIsIFwiZGVzdGluYXRpb24tb3ZlclwiLCBcImRpZmZlcmVuY2VcIiwgXCJkaXNjXCIsIFwiZGlzY2FyZFwiLCBcImRpc2Nsb3N1cmUtY2xvc2VkXCIsXG4gICAgXCJkaXNjbG9zdXJlLW9wZW5cIiwgXCJkb2N1bWVudFwiLCBcImRvdC1kYXNoXCIsIFwiZG90LWRvdC1kYXNoXCIsIFwiZG90dGVkXCIsIFwiZG91YmxlXCIsIFwiZG93blwiLCBcImUtcmVzaXplXCIsXG4gICAgXCJlYXNlXCIsIFwiZWFzZS1pblwiLCBcImVhc2UtaW4tb3V0XCIsIFwiZWFzZS1vdXRcIiwgXCJlbGVtZW50XCIsIFwiZWxsaXBzZVwiLCBcImVsbGlwc2lzXCIsIFwiZW1iZWRcIiwgXCJlbmRcIixcbiAgICBcImV0aGlvcGljLWFiZWdlZGUtZ2V6XCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtYWEtZXJcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1nZXpcIiwgXCJldy1yZXNpemVcIiwgXCJleGNsdXNpb25cIixcbiAgICBcImV4cGFuZGVkXCIsIFwiZXh0ZW5kc1wiLCBcImV4dHJhLWNvbmRlbnNlZFwiLCBcImV4dHJhLWV4cGFuZGVkXCIsIFwiZmFudGFzeVwiLCBcImZhc3RcIiwgXCJmaWxsXCIsIFwiZmlsbC1ib3hcIixcbiAgICBcImZpeGVkXCIsIFwiZmxhdFwiLCBcImZsZXhcIiwgXCJmbGV4LWVuZFwiLCBcImZsZXgtc3RhcnRcIiwgXCJmb290bm90ZXNcIiwgXCJmb3J3YXJkc1wiLCBcImZyb21cIixcbiAgICBcImdlb21ldHJpY1ByZWNpc2lvblwiLCBcImdyYXl0ZXh0XCIsIFwiZ3JpZFwiLCBcImdyb292ZVwiLCBcImhhbmRcIiwgXCJoYXJkLWxpZ2h0XCIsIFwiaGVscFwiLCBcImhpZGRlblwiLCBcImhpZGVcIixcbiAgICBcImhpZ2hlclwiLCBcImhpZ2hsaWdodFwiLCBcImhpZ2hsaWdodHRleHRcIiwgXCJob3Jpem9udGFsXCIsIFwiaHNsXCIsIFwiaHNsYVwiLCBcImh1ZVwiLCBcImljb25cIiwgXCJpZ25vcmVcIixcbiAgICBcImluYWN0aXZlYm9yZGVyXCIsIFwiaW5hY3RpdmVjYXB0aW9uXCIsIFwiaW5hY3RpdmVjYXB0aW9udGV4dFwiLCBcImluZmluaXRlXCIsIFwiaW5mb2JhY2tncm91bmRcIiwgXCJpbmZvdGV4dFwiLFxuICAgIFwiaW5oZXJpdFwiLCBcImluaXRpYWxcIiwgXCJpbmxpbmVcIiwgXCJpbmxpbmUtYXhpc1wiLCBcImlubGluZS1ibG9ja1wiLCBcImlubGluZS1mbGV4XCIsIFwiaW5saW5lLWdyaWRcIixcbiAgICBcImlubGluZS10YWJsZVwiLCBcImluc2V0XCIsIFwiaW5zaWRlXCIsIFwiaW50cmluc2ljXCIsIFwiaW52ZXJ0XCIsIFwiaXRhbGljXCIsIFwianVzdGlmeVwiLCBcImtlZXAtYWxsXCIsXG4gICAgXCJsYW5kc2NhcGVcIiwgXCJsYXJnZVwiLCBcImxhcmdlclwiLCBcImxlZnRcIiwgXCJsZXZlbFwiLCBcImxpZ2h0ZXJcIiwgXCJsaWdodGVuXCIsIFwibGluZS10aHJvdWdoXCIsIFwibGluZWFyXCIsXG4gICAgXCJsaW5lYXItZ3JhZGllbnRcIiwgXCJsaW5lc1wiLCBcImxpc3QtaXRlbVwiLCBcImxpc3Rib3hcIiwgXCJsaXN0aXRlbVwiLCBcImxvY2FsXCIsIFwibG9naWNhbFwiLCBcImxvdWRcIiwgXCJsb3dlclwiLFxuICAgIFwibG93ZXItaGV4YWRlY2ltYWxcIiwgXCJsb3dlci1sYXRpblwiLCBcImxvd2VyLW5vcndlZ2lhblwiLCBcImxvd2VyY2FzZVwiLCBcImx0clwiLCBcImx1bWlub3NpdHlcIiwgXCJtYW5pcHVsYXRpb25cIixcbiAgICBcIm1hdGNoXCIsIFwibWF0cml4XCIsIFwibWF0cml4M2RcIiwgXCJtZWRpdW1cIiwgXCJtZW51XCIsIFwibWVudXRleHRcIiwgXCJtZXNzYWdlLWJveFwiLCBcIm1pZGRsZVwiLCBcIm1pbi1pbnRyaW5zaWNcIixcbiAgICBcIm1peFwiLCBcIm1vbm9zcGFjZVwiLCBcIm1vdmVcIiwgXCJtdWx0aXBsZVwiLCBcIm11bHRpcGxlX21hc2tfaW1hZ2VzXCIsIFwibXVsdGlwbHlcIiwgXCJuLXJlc2l6ZVwiLCBcIm5hcnJvd2VyXCIsXG4gICAgXCJuZS1yZXNpemVcIiwgXCJuZXN3LXJlc2l6ZVwiLCBcIm5vLWNsb3NlLXF1b3RlXCIsIFwibm8tZHJvcFwiLCBcIm5vLW9wZW4tcXVvdGVcIiwgXCJuby1yZXBlYXRcIiwgXCJub25lXCIsXG4gICAgXCJub3JtYWxcIiwgXCJub3QtYWxsb3dlZFwiLCBcIm5vd3JhcFwiLCBcIm5zLXJlc2l6ZVwiLCBcIm51bWJlcnNcIiwgXCJudW1lcmljXCIsIFwibnctcmVzaXplXCIsIFwibndzZS1yZXNpemVcIixcbiAgICBcIm9ibGlxdWVcIiwgXCJvcGFjaXR5XCIsIFwib3Blbi1xdW90ZVwiLCBcIm9wdGltaXplTGVnaWJpbGl0eVwiLCBcIm9wdGltaXplU3BlZWRcIiwgXCJvdXRzZXRcIiwgXCJvdXRzaWRlXCIsXG4gICAgXCJvdXRzaWRlLXNoYXBlXCIsIFwib3ZlcmxheVwiLCBcIm92ZXJsaW5lXCIsIFwicGFkZGluZ1wiLCBcInBhZGRpbmctYm94XCIsIFwicGFpbnRlZFwiLCBcInBhZ2VcIiwgXCJwYXVzZWRcIixcbiAgICBcInBlcnNwZWN0aXZlXCIsIFwicGluY2gtem9vbVwiLCBcInBsdXMtZGFya2VyXCIsIFwicGx1cy1saWdodGVyXCIsIFwicG9pbnRlclwiLCBcInBvbHlnb25cIiwgXCJwb3J0cmFpdFwiLFxuICAgIFwicHJlXCIsIFwicHJlLWxpbmVcIiwgXCJwcmUtd3JhcFwiLCBcInByZXNlcnZlLTNkXCIsIFwicHJvZ3Jlc3NcIiwgXCJwdXNoLWJ1dHRvblwiLCBcInJhZGlhbC1ncmFkaWVudFwiLCBcInJhZGlvXCIsXG4gICAgXCJyZWFkLW9ubHlcIiwgXCJyZWFkLXdyaXRlXCIsIFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLCBcInJlY3RhbmdsZVwiLCBcInJlZ2lvblwiLCBcInJlbGF0aXZlXCIsIFwicmVwZWF0XCIsXG4gICAgXCJyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50XCIsIFwicmVwZWF0aW5nLXJhZGlhbC1ncmFkaWVudFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgXCJyZXNldFwiLCBcInJldmVyc2VcIixcbiAgICBcInJnYlwiLCBcInJnYmFcIiwgXCJyaWRnZVwiLCBcInJpZ2h0XCIsIFwicm90YXRlXCIsIFwicm90YXRlM2RcIiwgXCJyb3RhdGVYXCIsIFwicm90YXRlWVwiLCBcInJvdGF0ZVpcIiwgXCJyb3VuZFwiLFxuICAgIFwicm93XCIsIFwicm93LXJlc2l6ZVwiLCBcInJvdy1yZXZlcnNlXCIsIFwicnRsXCIsIFwicnVuLWluXCIsIFwicnVubmluZ1wiLCBcInMtcmVzaXplXCIsIFwic2Fucy1zZXJpZlwiLCBcInNhdHVyYXRpb25cIixcbiAgICBcInNjYWxlXCIsIFwic2NhbGUzZFwiLCBcInNjYWxlWFwiLCBcInNjYWxlWVwiLCBcInNjYWxlWlwiLCBcInNjcmVlblwiLCBcInNjcm9sbFwiLCBcInNjcm9sbGJhclwiLCBcInNjcm9sbC1wb3NpdGlvblwiLFxuICAgIFwic2UtcmVzaXplXCIsIFwic2VsZi1zdGFydFwiLCBcInNlbGYtZW5kXCIsIFwic2VtaS1jb25kZW5zZWRcIiwgXCJzZW1pLWV4cGFuZGVkXCIsIFwic2VwYXJhdGVcIiwgXCJzZXJpZlwiLCBcInNob3dcIixcbiAgICBcInNpbmdsZVwiLCBcInNrZXdcIiwgXCJza2V3WFwiLCBcInNrZXdZXCIsIFwic2tpcC13aGl0ZS1zcGFjZVwiLCBcInNsaWRlXCIsIFwic2xpZGVyLWhvcml6b250YWxcIixcbiAgICBcInNsaWRlci12ZXJ0aWNhbFwiLCBcInNsaWRlcnRodW1iLWhvcml6b250YWxcIiwgXCJzbGlkZXJ0aHVtYi12ZXJ0aWNhbFwiLCBcInNsb3dcIiwgXCJzbWFsbFwiLCBcInNtYWxsLWNhcHNcIixcbiAgICBcInNtYWxsLWNhcHRpb25cIiwgXCJzbWFsbGVyXCIsIFwic29mdC1saWdodFwiLCBcInNvbGlkXCIsIFwic291cmNlLWF0b3BcIiwgXCJzb3VyY2UtaW5cIiwgXCJzb3VyY2Utb3V0XCIsXG4gICAgXCJzb3VyY2Utb3ZlclwiLCBcInNwYWNlXCIsIFwic3BhY2UtYXJvdW5kXCIsIFwic3BhY2UtYmV0d2VlblwiLCBcInNwYWNlLWV2ZW5seVwiLCBcInNwZWxsLW91dFwiLCBcInNxdWFyZVwiLCBcInN0YXJ0XCIsXG4gICAgXCJzdGF0aWNcIiwgXCJzdGF0dXMtYmFyXCIsIFwic3RyZXRjaFwiLCBcInN0cm9rZVwiLCBcInN0cm9rZS1ib3hcIiwgXCJzdWJcIiwgXCJzdWJwaXhlbC1hbnRpYWxpYXNlZFwiLCBcInN2Z19tYXNrc1wiLFxuICAgIFwic3VwZXJcIiwgXCJzdy1yZXNpemVcIiwgXCJzeW1ib2xpY1wiLCBcInN5bWJvbHNcIiwgXCJzeXN0ZW0tdWlcIiwgXCJ0YWJsZVwiLCBcInRhYmxlLWNhcHRpb25cIiwgXCJ0YWJsZS1jZWxsXCIsXG4gICAgXCJ0YWJsZS1jb2x1bW5cIiwgXCJ0YWJsZS1jb2x1bW4tZ3JvdXBcIiwgXCJ0YWJsZS1mb290ZXItZ3JvdXBcIiwgXCJ0YWJsZS1oZWFkZXItZ3JvdXBcIiwgXCJ0YWJsZS1yb3dcIixcbiAgICBcInRhYmxlLXJvdy1ncm91cFwiLCBcInRleHRcIiwgXCJ0ZXh0LWJvdHRvbVwiLCBcInRleHQtdG9wXCIsIFwidGV4dGFyZWFcIiwgXCJ0ZXh0ZmllbGRcIiwgXCJ0aGlja1wiLCBcInRoaW5cIixcbiAgICBcInRocmVlZGRhcmtzaGFkb3dcIiwgXCJ0aHJlZWRmYWNlXCIsIFwidGhyZWVkaGlnaGxpZ2h0XCIsIFwidGhyZWVkbGlnaHRzaGFkb3dcIiwgXCJ0aHJlZWRzaGFkb3dcIiwgXCJ0b1wiLCBcInRvcFwiLFxuICAgIFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlXCIsIFwidHJhbnNsYXRlM2RcIiwgXCJ0cmFuc2xhdGVYXCIsIFwidHJhbnNsYXRlWVwiLCBcInRyYW5zbGF0ZVpcIiwgXCJ0cmFuc3BhcmVudFwiLFxuICAgIFwidWx0cmEtY29uZGVuc2VkXCIsIFwidWx0cmEtZXhwYW5kZWRcIiwgXCJ1bmRlcmxpbmVcIiwgXCJ1bmlkaXJlY3Rpb25hbC1wYW5cIiwgXCJ1bnNldFwiLCBcInVwXCIsIFwidXBwZXItbGF0aW5cIixcbiAgICBcInVwcGVyY2FzZVwiLCBcInVybFwiLCBcInZhclwiLCBcInZlcnRpY2FsXCIsIFwidmVydGljYWwtdGV4dFwiLCBcInZpZXctYm94XCIsIFwidmlzaWJsZVwiLCBcInZpc2libGVGaWxsXCIsXG4gICAgXCJ2aXNpYmxlUGFpbnRlZFwiLCBcInZpc2libGVTdHJva2VcIiwgXCJ2aXN1YWxcIiwgXCJ3LXJlc2l6ZVwiLCBcIndhaXRcIiwgXCJ3YXZlXCIsIFwid2lkZXJcIiwgXCJ3aW5kb3dcIiwgXCJ3aW5kb3dmcmFtZVwiLFxuICAgIFwid2luZG93dGV4dFwiLCBcIndvcmRzXCIsIFwid3JhcFwiLCBcIndyYXAtcmV2ZXJzZVwiLCBcIngtbGFyZ2VcIiwgXCJ4LXNtYWxsXCIsIFwieG9yXCIsIFwieHgtbGFyZ2VcIiwgXCJ4eC1zbWFsbFwiXG5dLm1hcChuYW1lID0+ICh7IHR5cGU6IFwia2V5d29yZFwiLCBsYWJlbDogbmFtZSB9KSkuY29uY2F0KC8qQF9fUFVSRV9fKi9bXG4gICAgXCJhbGljZWJsdWVcIiwgXCJhbnRpcXVld2hpdGVcIiwgXCJhcXVhXCIsIFwiYXF1YW1hcmluZVwiLCBcImF6dXJlXCIsIFwiYmVpZ2VcIixcbiAgICBcImJpc3F1ZVwiLCBcImJsYWNrXCIsIFwiYmxhbmNoZWRhbG1vbmRcIiwgXCJibHVlXCIsIFwiYmx1ZXZpb2xldFwiLCBcImJyb3duXCIsXG4gICAgXCJidXJseXdvb2RcIiwgXCJjYWRldGJsdWVcIiwgXCJjaGFydHJldXNlXCIsIFwiY2hvY29sYXRlXCIsIFwiY29yYWxcIiwgXCJjb3JuZmxvd2VyYmx1ZVwiLFxuICAgIFwiY29ybnNpbGtcIiwgXCJjcmltc29uXCIsIFwiY3lhblwiLCBcImRhcmtibHVlXCIsIFwiZGFya2N5YW5cIiwgXCJkYXJrZ29sZGVucm9kXCIsXG4gICAgXCJkYXJrZ3JheVwiLCBcImRhcmtncmVlblwiLCBcImRhcmtraGFraVwiLCBcImRhcmttYWdlbnRhXCIsIFwiZGFya29saXZlZ3JlZW5cIixcbiAgICBcImRhcmtvcmFuZ2VcIiwgXCJkYXJrb3JjaGlkXCIsIFwiZGFya3JlZFwiLCBcImRhcmtzYWxtb25cIiwgXCJkYXJrc2VhZ3JlZW5cIixcbiAgICBcImRhcmtzbGF0ZWJsdWVcIiwgXCJkYXJrc2xhdGVncmF5XCIsIFwiZGFya3R1cnF1b2lzZVwiLCBcImRhcmt2aW9sZXRcIixcbiAgICBcImRlZXBwaW5rXCIsIFwiZGVlcHNreWJsdWVcIiwgXCJkaW1ncmF5XCIsIFwiZG9kZ2VyYmx1ZVwiLCBcImZpcmVicmlja1wiLFxuICAgIFwiZmxvcmFsd2hpdGVcIiwgXCJmb3Jlc3RncmVlblwiLCBcImZ1Y2hzaWFcIiwgXCJnYWluc2Jvcm9cIiwgXCJnaG9zdHdoaXRlXCIsXG4gICAgXCJnb2xkXCIsIFwiZ29sZGVucm9kXCIsIFwiZ3JheVwiLCBcImdyZXlcIiwgXCJncmVlblwiLCBcImdyZWVueWVsbG93XCIsIFwiaG9uZXlkZXdcIixcbiAgICBcImhvdHBpbmtcIiwgXCJpbmRpYW5yZWRcIiwgXCJpbmRpZ29cIiwgXCJpdm9yeVwiLCBcImtoYWtpXCIsIFwibGF2ZW5kZXJcIixcbiAgICBcImxhdmVuZGVyYmx1c2hcIiwgXCJsYXduZ3JlZW5cIiwgXCJsZW1vbmNoaWZmb25cIiwgXCJsaWdodGJsdWVcIiwgXCJsaWdodGNvcmFsXCIsXG4gICAgXCJsaWdodGN5YW5cIiwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiLCBcImxpZ2h0Z3JheVwiLCBcImxpZ2h0Z3JlZW5cIiwgXCJsaWdodHBpbmtcIixcbiAgICBcImxpZ2h0c2FsbW9uXCIsIFwibGlnaHRzZWFncmVlblwiLCBcImxpZ2h0c2t5Ymx1ZVwiLCBcImxpZ2h0c2xhdGVncmF5XCIsXG4gICAgXCJsaWdodHN0ZWVsYmx1ZVwiLCBcImxpZ2h0eWVsbG93XCIsIFwibGltZVwiLCBcImxpbWVncmVlblwiLCBcImxpbmVuXCIsIFwibWFnZW50YVwiLFxuICAgIFwibWFyb29uXCIsIFwibWVkaXVtYXF1YW1hcmluZVwiLCBcIm1lZGl1bWJsdWVcIiwgXCJtZWRpdW1vcmNoaWRcIiwgXCJtZWRpdW1wdXJwbGVcIixcbiAgICBcIm1lZGl1bXNlYWdyZWVuXCIsIFwibWVkaXVtc2xhdGVibHVlXCIsIFwibWVkaXVtc3ByaW5nZ3JlZW5cIiwgXCJtZWRpdW10dXJxdW9pc2VcIixcbiAgICBcIm1lZGl1bXZpb2xldHJlZFwiLCBcIm1pZG5pZ2h0Ymx1ZVwiLCBcIm1pbnRjcmVhbVwiLCBcIm1pc3R5cm9zZVwiLCBcIm1vY2Nhc2luXCIsXG4gICAgXCJuYXZham93aGl0ZVwiLCBcIm5hdnlcIiwgXCJvbGRsYWNlXCIsIFwib2xpdmVcIiwgXCJvbGl2ZWRyYWJcIiwgXCJvcmFuZ2VcIiwgXCJvcmFuZ2VyZWRcIixcbiAgICBcIm9yY2hpZFwiLCBcInBhbGVnb2xkZW5yb2RcIiwgXCJwYWxlZ3JlZW5cIiwgXCJwYWxldHVycXVvaXNlXCIsIFwicGFsZXZpb2xldHJlZFwiLFxuICAgIFwicGFwYXlhd2hpcFwiLCBcInBlYWNocHVmZlwiLCBcInBlcnVcIiwgXCJwaW5rXCIsIFwicGx1bVwiLCBcInBvd2RlcmJsdWVcIixcbiAgICBcInB1cnBsZVwiLCBcInJlYmVjY2FwdXJwbGVcIiwgXCJyZWRcIiwgXCJyb3N5YnJvd25cIiwgXCJyb3lhbGJsdWVcIiwgXCJzYWRkbGVicm93blwiLFxuICAgIFwic2FsbW9uXCIsIFwic2FuZHlicm93blwiLCBcInNlYWdyZWVuXCIsIFwic2Vhc2hlbGxcIiwgXCJzaWVubmFcIiwgXCJzaWx2ZXJcIiwgXCJza3libHVlXCIsXG4gICAgXCJzbGF0ZWJsdWVcIiwgXCJzbGF0ZWdyYXlcIiwgXCJzbm93XCIsIFwic3ByaW5nZ3JlZW5cIiwgXCJzdGVlbGJsdWVcIiwgXCJ0YW5cIixcbiAgICBcInRlYWxcIiwgXCJ0aGlzdGxlXCIsIFwidG9tYXRvXCIsIFwidHVycXVvaXNlXCIsIFwidmlvbGV0XCIsIFwid2hlYXRcIiwgXCJ3aGl0ZVwiLFxuICAgIFwid2hpdGVzbW9rZVwiLCBcInllbGxvd1wiLCBcInllbGxvd2dyZWVuXCJcbl0ubWFwKG5hbWUgPT4gKHsgdHlwZTogXCJjb25zdGFudFwiLCBsYWJlbDogbmFtZSB9KSkpO1xuY29uc3QgdGFncyA9IC8qQF9fUFVSRV9fKi9bXG4gICAgXCJhXCIsIFwiYWJiclwiLCBcImFkZHJlc3NcIiwgXCJhcnRpY2xlXCIsIFwiYXNpZGVcIiwgXCJiXCIsIFwiYmRpXCIsIFwiYmRvXCIsIFwiYmxvY2txdW90ZVwiLCBcImJvZHlcIixcbiAgICBcImJyXCIsIFwiYnV0dG9uXCIsIFwiY2FudmFzXCIsIFwiY2FwdGlvblwiLCBcImNpdGVcIiwgXCJjb2RlXCIsIFwiY29sXCIsIFwiY29sZ3JvdXBcIiwgXCJkZFwiLCBcImRlbFwiLFxuICAgIFwiZGV0YWlsc1wiLCBcImRmblwiLCBcImRpYWxvZ1wiLCBcImRpdlwiLCBcImRsXCIsIFwiZHRcIiwgXCJlbVwiLCBcImZpZ2NhcHRpb25cIiwgXCJmaWd1cmVcIiwgXCJmb290ZXJcIixcbiAgICBcImZvcm1cIiwgXCJoZWFkZXJcIiwgXCJoZ3JvdXBcIiwgXCJoMVwiLCBcImgyXCIsIFwiaDNcIiwgXCJoNFwiLCBcImg1XCIsIFwiaDZcIiwgXCJoclwiLCBcImh0bWxcIiwgXCJpXCIsIFwiaWZyYW1lXCIsXG4gICAgXCJpbWdcIiwgXCJpbnB1dFwiLCBcImluc1wiLCBcImtiZFwiLCBcImxhYmVsXCIsIFwibGVnZW5kXCIsIFwibGlcIiwgXCJtYWluXCIsIFwibWV0ZXJcIiwgXCJuYXZcIiwgXCJvbFwiLCBcIm91dHB1dFwiLFxuICAgIFwicFwiLCBcInByZVwiLCBcInJ1YnlcIiwgXCJzZWN0aW9uXCIsIFwic2VsZWN0XCIsIFwic21hbGxcIiwgXCJzb3VyY2VcIiwgXCJzcGFuXCIsIFwic3Ryb25nXCIsIFwic3ViXCIsIFwic3VtbWFyeVwiLFxuICAgIFwic3VwXCIsIFwidGFibGVcIiwgXCJ0Ym9keVwiLCBcInRkXCIsIFwidGVtcGxhdGVcIiwgXCJ0ZXh0YXJlYVwiLCBcInRmb290XCIsIFwidGhcIiwgXCJ0aGVhZFwiLCBcInRyXCIsIFwidVwiLCBcInVsXCJcbl0ubWFwKG5hbWUgPT4gKHsgdHlwZTogXCJ0eXBlXCIsIGxhYmVsOiBuYW1lIH0pKTtcbmNvbnN0IGF0UnVsZXMgPSAvKkBfX1BVUkVfXyovW1xuICAgIFwiQGNoYXJzZXRcIiwgXCJAY29sb3ItcHJvZmlsZVwiLCBcIkBjb250YWluZXJcIiwgXCJAY291bnRlci1zdHlsZVwiLCBcIkBmb250LWZhY2VcIiwgXCJAZm9udC1mZWF0dXJlLXZhbHVlc1wiLFxuICAgIFwiQGZvbnQtcGFsZXR0ZS12YWx1ZXNcIiwgXCJAaW1wb3J0XCIsIFwiQGtleWZyYW1lc1wiLCBcIkBsYXllclwiLCBcIkBtZWRpYVwiLCBcIkBuYW1lc3BhY2VcIiwgXCJAcGFnZVwiLFxuICAgIFwiQHBvc2l0aW9uLXRyeVwiLCBcIkBwcm9wZXJ0eVwiLCBcIkBzY29wZVwiLCBcIkBzdGFydGluZy1zdHlsZVwiLCBcIkBzdXBwb3J0c1wiLCBcIkB2aWV3LXRyYW5zaXRpb25cIlxuXS5tYXAobGFiZWwgPT4gKHsgdHlwZTogXCJrZXl3b3JkXCIsIGxhYmVsIH0pKTtcbmNvbnN0IGlkZW50aWZpZXIgPSAvXihcXHdbXFx3LV0qfC1cXHdbXFx3LV0qfCkkLywgdmFyaWFibGUgPSAvXi0oLVtcXHctXSopPyQvO1xuZnVuY3Rpb24gaXNWYXJBcmcobm9kZSwgZG9jKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChub2RlLm5hbWUgPT0gXCIoXCIgfHwgbm9kZS50eXBlLmlzRXJyb3IpXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudCB8fCBub2RlO1xuICAgIGlmIChub2RlLm5hbWUgIT0gXCJBcmdMaXN0XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2FsbGVlID0gKF9hID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJzdENoaWxkO1xuICAgIGlmICgoY2FsbGVlID09PSBudWxsIHx8IGNhbGxlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGVlLm5hbWUpICE9IFwiQ2FsbGVlXCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZG9jLnNsaWNlU3RyaW5nKGNhbGxlZS5mcm9tLCBjYWxsZWUudG8pID09IFwidmFyXCI7XG59XG5jb25zdCBWYXJpYWJsZXNCeU5vZGUgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVXZWFrTWFwKCk7XG5jb25zdCBkZWNsU2VsZWN0b3IgPSBbXCJEZWNsYXJhdGlvblwiXTtcbmZ1bmN0aW9uIGFzdFRvcChub2RlKSB7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTs7KSB7XG4gICAgICAgIGlmIChjdXIudHlwZS5pc1RvcClcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIGlmICghKGN1ciA9IGN1ci5wYXJlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFyaWFibGVOYW1lcyhkb2MsIG5vZGUsIGlzVmFyaWFibGUpIHtcbiAgICBpZiAobm9kZS50byAtIG5vZGUuZnJvbSA+IDQwOTYpIHtcbiAgICAgICAgbGV0IGtub3duID0gVmFyaWFibGVzQnlOb2RlLmdldChub2RlKTtcbiAgICAgICAgaWYgKGtub3duKVxuICAgICAgICAgICAgcmV0dXJuIGtub3duO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBuZXcgU2V0LCBjdXJzb3IgPSBub2RlLmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTtcbiAgICAgICAgaWYgKGN1cnNvci5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIHZhcmlhYmxlTmFtZXMoZG9jLCBjdXJzb3Iubm9kZSwgaXNWYXJpYWJsZSkpXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2Vlbi5oYXMob3B0aW9uLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbi5hZGQob3B0aW9uLmxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgVmFyaWFibGVzQnlOb2RlLnNldChub2RlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBzZWVuID0gbmV3IFNldDtcbiAgICAgICAgbm9kZS5jdXJzb3IoKS5pdGVyYXRlKG5vZGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUobm9kZSkgJiYgbm9kZS5tYXRjaENvbnRleHQoZGVjbFNlbGVjdG9yKSAmJiAoKF9hID0gbm9kZS5ub2RlLm5leHRTaWJsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGRvYy5zbGljZVN0cmluZyhub2RlLmZyb20sIG5vZGUudG8pO1xuICAgICAgICAgICAgICAgIGlmICghc2Vlbi5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vlbi5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgbGFiZWw6IG5hbWUsIHR5cGU6IFwidmFyaWFibGVcIiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlIGEgY29tcGxldGlvbiBzb3VyY2UgZm9yIGEgQ1NTIGRpYWxlY3QsIHByb3ZpZGluZyBhXG5wcmVkaWNhdGUgZm9yIGRldGVybWluaW5nIHdoYXQga2luZCBvZiBzeW50YXggbm9kZSBjYW4gYWN0IGFzIGFcbmNvbXBsZXRhYmxlIHZhcmlhYmxlLiBUaGlzIGlzIHVzZWQgYnkgbGFuZ3VhZ2UgbW9kZXMgbGlrZSBTYXNzIGFuZFxuTGVzcyB0byByZXVzZSB0aGlzIHBhY2thZ2UncyBjb21wbGV0aW9uIGxvZ2ljLlxuKi9cbmNvbnN0IGRlZmluZUNTU0NvbXBsZXRpb25Tb3VyY2UgPSAoaXNWYXJpYWJsZSkgPT4gY29udGV4dCA9PiB7XG4gICAgbGV0IHsgc3RhdGUsIHBvcyB9ID0gY29udGV4dCwgbm9kZSA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MsIC0xKTtcbiAgICBsZXQgaXNEYXNoID0gbm9kZS50eXBlLmlzRXJyb3IgJiYgbm9kZS5mcm9tID09IG5vZGUudG8gLSAxICYmIHN0YXRlLmRvYy5zbGljZVN0cmluZyhub2RlLmZyb20sIG5vZGUudG8pID09IFwiLVwiO1xuICAgIGlmIChub2RlLm5hbWUgPT0gXCJQcm9wZXJ0eU5hbWVcIiB8fFxuICAgICAgICAoaXNEYXNoIHx8IG5vZGUubmFtZSA9PSBcIlRhZ05hbWVcIikgJiYgL14oQmxvY2t8U3R5bGVzKSQvLnRlc3Qobm9kZS5yZXNvbHZlKG5vZGUudG8pLm5hbWUpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBub2RlLmZyb20sIG9wdGlvbnM6IHByb3BlcnRpZXMoKSwgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbiAgICBpZiAobm9kZS5uYW1lID09IFwiVmFsdWVOYW1lXCIpXG4gICAgICAgIHJldHVybiB7IGZyb206IG5vZGUuZnJvbSwgb3B0aW9uczogdmFsdWVzLCB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xuICAgIGlmIChub2RlLm5hbWUgPT0gXCJQc2V1ZG9DbGFzc05hbWVcIilcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogbm9kZS5mcm9tLCBvcHRpb25zOiBwc2V1ZG9DbGFzc2VzLCB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xuICAgIGlmIChpc1ZhcmlhYmxlKG5vZGUpIHx8IChjb250ZXh0LmV4cGxpY2l0IHx8IGlzRGFzaCkgJiYgaXNWYXJBcmcobm9kZSwgc3RhdGUuZG9jKSlcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogaXNWYXJpYWJsZShub2RlKSB8fCBpc0Rhc2ggPyBub2RlLmZyb20gOiBwb3MsXG4gICAgICAgICAgICBvcHRpb25zOiB2YXJpYWJsZU5hbWVzKHN0YXRlLmRvYywgYXN0VG9wKG5vZGUpLCBpc1ZhcmlhYmxlKSxcbiAgICAgICAgICAgIHZhbGlkRm9yOiB2YXJpYWJsZSB9O1xuICAgIGlmIChub2RlLm5hbWUgPT0gXCJUYWdOYW1lXCIpIHtcbiAgICAgICAgZm9yIChsZXQgeyBwYXJlbnQgfSA9IG5vZGU7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudClcbiAgICAgICAgICAgIGlmIChwYXJlbnQubmFtZSA9PSBcIkJsb2NrXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogbm9kZS5mcm9tLCBvcHRpb25zOiBwcm9wZXJ0aWVzKCksIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG4gICAgICAgIHJldHVybiB7IGZyb206IG5vZGUuZnJvbSwgb3B0aW9uczogdGFncywgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbiAgICB9XG4gICAgaWYgKG5vZGUubmFtZSA9PSBcIkF0S2V5d29yZFwiKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBub2RlLmZyb20sIG9wdGlvbnM6IGF0UnVsZXMsIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG4gICAgaWYgKCFjb250ZXh0LmV4cGxpY2l0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYWJvdmUgPSBub2RlLnJlc29sdmUocG9zKSwgYmVmb3JlID0gYWJvdmUuY2hpbGRCZWZvcmUocG9zKTtcbiAgICBpZiAoYmVmb3JlICYmIGJlZm9yZS5uYW1lID09IFwiOlwiICYmIGFib3ZlLm5hbWUgPT0gXCJQc2V1ZG9DbGFzc1NlbGVjdG9yXCIpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgb3B0aW9uczogcHNldWRvQ2xhc3NlcywgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbiAgICBpZiAoYmVmb3JlICYmIGJlZm9yZS5uYW1lID09IFwiOlwiICYmIGFib3ZlLm5hbWUgPT0gXCJEZWNsYXJhdGlvblwiIHx8IGFib3ZlLm5hbWUgPT0gXCJBcmdMaXN0XCIpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgb3B0aW9uczogdmFsdWVzLCB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xuICAgIGlmIChhYm92ZS5uYW1lID09IFwiQmxvY2tcIiB8fCBhYm92ZS5uYW1lID09IFwiU3R5bGVzXCIpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgb3B0aW9uczogcHJvcGVydGllcygpLCB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuQ1NTIHByb3BlcnR5LCB2YXJpYWJsZSwgYW5kIHZhbHVlIGtleXdvcmQgY29tcGxldGlvbiBzb3VyY2UuXG4qL1xuY29uc3QgY3NzQ29tcGxldGlvblNvdXJjZSA9IC8qQF9fUFVSRV9fKi9kZWZpbmVDU1NDb21wbGV0aW9uU291cmNlKG4gPT4gbi5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIpO1xuXG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgYmFzZWQgb24gdGhlIFtMZXplciBDU1NcbnBhcnNlcl0oaHR0cHM6Ly9naXRodWIuY29tL2xlemVyLXBhcnNlci9jc3MpLCBleHRlbmRlZCB3aXRoXG5oaWdobGlnaHRpbmcgYW5kIGluZGVudGF0aW9uIGluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IGNzc0xhbmd1YWdlID0gLypAX19QVVJFX18qL0xSTGFuZ3VhZ2UuZGVmaW5lKHtcbiAgICBuYW1lOiBcImNzc1wiLFxuICAgIHBhcnNlcjogLypAX19QVVJFX18qL3BhcnNlci5jb25maWd1cmUoe1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgLypAX19QVVJFX18qL2luZGVudE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgRGVjbGFyYXRpb246IC8qQF9fUFVSRV9fKi9jb250aW51ZWRJbmRlbnQoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgXCJCbG9jayBLZXlmcmFtZUxpc3RcIjogZm9sZEluc2lkZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgIH0pLFxuICAgIGxhbmd1YWdlRGF0YToge1xuICAgICAgICBjb21tZW50VG9rZW5zOiB7IGJsb2NrOiB7IG9wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIiB9IH0sXG4gICAgICAgIGluZGVudE9uSW5wdXQ6IC9eXFxzKlxcfSQvLFxuICAgICAgICB3b3JkQ2hhcnM6IFwiLVwiXG4gICAgfVxufSk7XG4vKipcbkxhbmd1YWdlIHN1cHBvcnQgZm9yIENTUy5cbiovXG5mdW5jdGlvbiBjc3MoKSB7XG4gICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN1cHBvcnQoY3NzTGFuZ3VhZ2UsIGNzc0xhbmd1YWdlLmRhdGEub2YoeyBhdXRvY29tcGxldGU6IGNzc0NvbXBsZXRpb25Tb3VyY2UgfSkpO1xufVxuXG5leHBvcnQgeyBjc3MsIGNzc0NvbXBsZXRpb25Tb3VyY2UsIGNzc0xhbmd1YWdlLCBkZWZpbmVDU1NDb21wbGV0aW9uU291cmNlIH07XG4iLCAiaW1wb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBMUlBhcnNlciwgTG9jYWxUb2tlbkdyb3VwIH0gZnJvbSAnQGxlemVyL2xyJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IG5vU2VtaSA9IDMxNixcbiAgbm9TZW1pVHlwZSA9IDMxNyxcbiAgaW5jZGVjID0gMSxcbiAgaW5jZGVjUHJlZml4ID0gMixcbiAgcXVlc3Rpb25Eb3QgPSAzLFxuICBKU1hTdGFydFRhZyA9IDQsXG4gIGluc2VydFNlbWkgPSAzMTgsXG4gIHNwYWNlcyA9IDMyMCxcbiAgbmV3bGluZSA9IDMyMSxcbiAgTGluZUNvbW1lbnQgPSA1LFxuICBCbG9ja0NvbW1lbnQgPSA2LFxuICBEaWFsZWN0X2pzeCA9IDA7XG5cbi8qIEhhbmQtd3JpdHRlbiB0b2tlbml6ZXJzIGZvciBKYXZhU2NyaXB0IHRva2VucyB0aGF0IGNhbid0IGJlXG4gICBleHByZXNzZWQgYnkgbGV6ZXIncyBidWlsdC1pbiB0b2tlbml6ZXIuICovXG5cbmNvbnN0IHNwYWNlID0gWzksIDEwLCAxMSwgMTIsIDEzLCAzMiwgMTMzLCAxNjAsIDU3NjAsIDgxOTIsIDgxOTMsIDgxOTQsIDgxOTUsIDgxOTYsIDgxOTcsIDgxOTgsIDgxOTksIDgyMDAsXG4gICAgICAgICAgICAgICA4MjAxLCA4MjAyLCA4MjMyLCA4MjMzLCA4MjM5LCA4Mjg3LCAxMjI4OF07XG5cbmNvbnN0IGJyYWNlUiA9IDEyNSwgc2VtaWNvbG9uID0gNTksIHNsYXNoID0gNDcsIHN0YXIgPSA0MiwgcGx1cyA9IDQzLCBtaW51cyA9IDQ1LCBsdCA9IDYwLCBjb21tYSA9IDQ0LFxuICAgICAgcXVlc3Rpb24gPSA2MywgZG90ID0gNDYsIGJyYWNrZXRMID0gOTE7XG5cbmNvbnN0IHRyYWNrTmV3bGluZSA9IG5ldyBDb250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiBmYWxzZSxcbiAgc2hpZnQoY29udGV4dCwgdGVybSkge1xuICAgIHJldHVybiB0ZXJtID09IExpbmVDb21tZW50IHx8IHRlcm0gPT0gQmxvY2tDb21tZW50IHx8IHRlcm0gPT0gc3BhY2VzID8gY29udGV4dCA6IHRlcm0gPT0gbmV3bGluZVxuICB9LFxuICBzdHJpY3Q6IGZhbHNlXG59KTtcblxuY29uc3QgaW5zZXJ0U2VtaWNvbG9uID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICBpZiAobmV4dCA9PSBicmFjZVIgfHwgbmV4dCA9PSAtMSB8fCBzdGFjay5jb250ZXh0KVxuICAgIGlucHV0LmFjY2VwdFRva2VuKGluc2VydFNlbWkpO1xufSwge2NvbnRleHR1YWw6IHRydWUsIGZhbGxiYWNrOiB0cnVlfSk7XG5cbmNvbnN0IG5vU2VtaWNvbG9uID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0LCBhZnRlcjtcbiAgaWYgKHNwYWNlLmluZGV4T2YobmV4dCkgPiAtMSkgcmV0dXJuXG4gIGlmIChuZXh0ID09IHNsYXNoICYmICgoYWZ0ZXIgPSBpbnB1dC5wZWVrKDEpKSA9PSBzbGFzaCB8fCBhZnRlciA9PSBzdGFyKSkgcmV0dXJuXG4gIGlmIChuZXh0ICE9IGJyYWNlUiAmJiBuZXh0ICE9IHNlbWljb2xvbiAmJiBuZXh0ICE9IC0xICYmICFzdGFjay5jb250ZXh0KVxuICAgIGlucHV0LmFjY2VwdFRva2VuKG5vU2VtaSk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBub1NlbWljb2xvblR5cGUgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCA9PSBicmFja2V0TCAmJiAhc3RhY2suY29udGV4dCkgaW5wdXQuYWNjZXB0VG9rZW4obm9TZW1pVHlwZSk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBvcGVyYXRvclRva2VuID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICBpZiAobmV4dCA9PSBwbHVzIHx8IG5leHQgPT0gbWludXMpIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgaWYgKG5leHQgPT0gaW5wdXQubmV4dCkge1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgbGV0IG1heVBvc3RmaXggPSAhc3RhY2suY29udGV4dCAmJiBzdGFjay5jYW5TaGlmdChpbmNkZWMpO1xuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4obWF5UG9zdGZpeCA/IGluY2RlYyA6IGluY2RlY1ByZWZpeCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5leHQgPT0gcXVlc3Rpb24gJiYgaW5wdXQucGVlaygxKSA9PSBkb3QpIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7IGlucHV0LmFkdmFuY2UoKTtcbiAgICBpZiAoaW5wdXQubmV4dCA8IDQ4IHx8IGlucHV0Lm5leHQgPiA1NykgLy8gTm8gZGlnaXQgYWZ0ZXJcbiAgICAgIGlucHV0LmFjY2VwdFRva2VuKHF1ZXN0aW9uRG90KTtcbiAgfVxufSwge2NvbnRleHR1YWw6IHRydWV9KTtcblxuZnVuY3Rpb24gaWRlbnRpZmllckNoYXIoY2gsIHN0YXJ0KSB7XG4gIHJldHVybiBjaCA+PSA2NSAmJiBjaCA8PSA5MCB8fCBjaCA+PSA5NyAmJiBjaCA8PSAxMjIgfHwgY2ggPT0gOTUgfHwgY2ggPj0gMTkyIHx8XG4gICAgIXN0YXJ0ICYmIGNoID49IDQ4ICYmIGNoIDw9IDU3XG59XG5cbmNvbnN0IGpzeCA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGlmIChpbnB1dC5uZXh0ICE9IGx0IHx8ICFzdGFjay5kaWFsZWN0RW5hYmxlZChEaWFsZWN0X2pzeCkpIHJldHVyblxuICBpbnB1dC5hZHZhbmNlKCk7XG4gIGlmIChpbnB1dC5uZXh0ID09IHNsYXNoKSByZXR1cm5cbiAgLy8gU2NhbiBmb3IgYW4gaWRlbnRpZmllciBmb2xsb3dlZCBieSBhIGNvbW1hIG9yICdleHRlbmRzJywgZG9uJ3RcbiAgLy8gdHJlYXQgdGhpcyBhcyBhIHN0YXJ0IHRhZyBpZiBwcmVzZW50LlxuICBsZXQgYmFjayA9IDA7XG4gIHdoaWxlIChzcGFjZS5pbmRleE9mKGlucHV0Lm5leHQpID4gLTEpIHsgaW5wdXQuYWR2YW5jZSgpOyBiYWNrKys7IH1cbiAgaWYgKGlkZW50aWZpZXJDaGFyKGlucHV0Lm5leHQsIHRydWUpKSB7XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIGJhY2srKztcbiAgICB3aGlsZSAoaWRlbnRpZmllckNoYXIoaW5wdXQubmV4dCwgZmFsc2UpKSB7IGlucHV0LmFkdmFuY2UoKTsgYmFjaysrOyB9XG4gICAgd2hpbGUgKHNwYWNlLmluZGV4T2YoaW5wdXQubmV4dCkgPiAtMSkgeyBpbnB1dC5hZHZhbmNlKCk7IGJhY2srKzsgfVxuICAgIGlmIChpbnB1dC5uZXh0ID09IGNvbW1hKSByZXR1cm5cbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgaWYgKGkgPT0gNykge1xuICAgICAgICBpZiAoIWlkZW50aWZpZXJDaGFyKGlucHV0Lm5leHQsIHRydWUpKSByZXR1cm5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dC5uZXh0ICE9IFwiZXh0ZW5kc1wiLmNoYXJDb2RlQXQoaSkpIGJyZWFrXG4gICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICBiYWNrKys7XG4gICAgfVxuICB9XG4gIGlucHV0LmFjY2VwdFRva2VuKEpTWFN0YXJ0VGFnLCAtYmFjayk7XG59KTtcblxuY29uc3QganNIaWdobGlnaHQgPSBzdHlsZVRhZ3Moe1xuICBcImdldCBzZXQgYXN5bmMgc3RhdGljXCI6IHRhZ3MubW9kaWZpZXIsXG4gIFwiZm9yIHdoaWxlIGRvIGlmIGVsc2Ugc3dpdGNoIHRyeSBjYXRjaCBmaW5hbGx5IHJldHVybiB0aHJvdyBicmVhayBjb250aW51ZSBkZWZhdWx0IGNhc2UgZGVmZXJcIjogdGFncy5jb250cm9sS2V5d29yZCxcbiAgXCJpbiBvZiBhd2FpdCB5aWVsZCB2b2lkIHR5cGVvZiBkZWxldGUgaW5zdGFuY2VvZiBhcyBzYXRpc2ZpZXNcIjogdGFncy5vcGVyYXRvcktleXdvcmQsXG4gIFwibGV0IHZhciBjb25zdCB1c2luZyBmdW5jdGlvbiBjbGFzcyBleHRlbmRzXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiaW1wb3J0IGV4cG9ydCBmcm9tXCI6IHRhZ3MubW9kdWxlS2V5d29yZCxcbiAgXCJ3aXRoIGRlYnVnZ2VyIG5ld1wiOiB0YWdzLmtleXdvcmQsXG4gIFRlbXBsYXRlU3RyaW5nOiB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpLFxuICBzdXBlcjogdGFncy5hdG9tLFxuICBCb29sZWFuTGl0ZXJhbDogdGFncy5ib29sLFxuICB0aGlzOiB0YWdzLnNlbGYsXG4gIG51bGw6IHRhZ3MubnVsbCxcbiAgU3RhcjogdGFncy5tb2RpZmllcixcbiAgVmFyaWFibGVOYW1lOiB0YWdzLnZhcmlhYmxlTmFtZSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9WYXJpYWJsZU5hbWUgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uL1ZhcmlhYmxlTmFtZVwiOiB0YWdzLmZ1bmN0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgVmFyaWFibGVEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICBMYWJlbDogdGFncy5sYWJlbE5hbWUsXG4gIFByb3BlcnR5TmFtZTogdGFncy5wcm9wZXJ0eU5hbWUsXG4gIFByaXZhdGVQcm9wZXJ0eU5hbWU6IHRhZ3Muc3BlY2lhbCh0YWdzLnByb3BlcnR5TmFtZSksXG4gIFwiQ2FsbEV4cHJlc3Npb24vTWVtYmVyRXhwcmVzc2lvbi9Qcm9wZXJ0eU5hbWVcIjogdGFncy5mdW5jdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gIFwiRnVuY3Rpb25EZWNsYXJhdGlvbi9WYXJpYWJsZURlZmluaXRpb25cIjogdGFncy5mdW5jdGlvbih0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpKSxcbiAgXCJDbGFzc0RlY2xhcmF0aW9uL1ZhcmlhYmxlRGVmaW5pdGlvblwiOiB0YWdzLmRlZmluaXRpb24odGFncy5jbGFzc05hbWUpLFxuICBcIk5ld0V4cHJlc3Npb24vVmFyaWFibGVOYW1lXCI6IHRhZ3MuY2xhc3NOYW1lLFxuICBQcm9wZXJ0eURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gIFByaXZhdGVQcm9wZXJ0eURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnNwZWNpYWwodGFncy5wcm9wZXJ0eU5hbWUpKSxcbiAgVXBkYXRlT3A6IHRhZ3MudXBkYXRlT3BlcmF0b3IsXG4gIFwiTGluZUNvbW1lbnQgSGFzaGJhbmdcIjogdGFncy5saW5lQ29tbWVudCxcbiAgQmxvY2tDb21tZW50OiB0YWdzLmJsb2NrQ29tbWVudCxcbiAgTnVtYmVyOiB0YWdzLm51bWJlcixcbiAgU3RyaW5nOiB0YWdzLnN0cmluZyxcbiAgRXNjYXBlOiB0YWdzLmVzY2FwZSxcbiAgQXJpdGhPcDogdGFncy5hcml0aG1ldGljT3BlcmF0b3IsXG4gIExvZ2ljT3A6IHRhZ3MubG9naWNPcGVyYXRvcixcbiAgQml0T3A6IHRhZ3MuYml0d2lzZU9wZXJhdG9yLFxuICBDb21wYXJlT3A6IHRhZ3MuY29tcGFyZU9wZXJhdG9yLFxuICBSZWdFeHA6IHRhZ3MucmVnZXhwLFxuICBFcXVhbHM6IHRhZ3MuZGVmaW5pdGlvbk9wZXJhdG9yLFxuICBBcnJvdzogdGFncy5mdW5jdGlvbih0YWdzLnB1bmN0dWF0aW9uKSxcbiAgXCI6IFNwcmVhZFwiOiB0YWdzLnB1bmN0dWF0aW9uLFxuICBcIiggKVwiOiB0YWdzLnBhcmVuLFxuICBcIlsgXVwiOiB0YWdzLnNxdWFyZUJyYWNrZXQsXG4gIFwieyB9XCI6IHRhZ3MuYnJhY2UsXG4gIFwiSW50ZXJwb2xhdGlvblN0YXJ0IEludGVycG9sYXRpb25FbmRcIjogdGFncy5zcGVjaWFsKHRhZ3MuYnJhY2UpLFxuICBcIi5cIjogdGFncy5kZXJlZk9wZXJhdG9yLFxuICBcIiwgO1wiOiB0YWdzLnNlcGFyYXRvcixcbiAgXCJAXCI6IHRhZ3MubWV0YSxcblxuICBUeXBlTmFtZTogdGFncy50eXBlTmFtZSxcbiAgVHlwZURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnR5cGVOYW1lKSxcbiAgXCJ0eXBlIGVudW0gaW50ZXJmYWNlIGltcGxlbWVudHMgbmFtZXNwYWNlIG1vZHVsZSBkZWNsYXJlXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiYWJzdHJhY3QgZ2xvYmFsIFByaXZhY3kgcmVhZG9ubHkgb3ZlcnJpZGVcIjogdGFncy5tb2RpZmllcixcbiAgXCJpcyBrZXlvZiB1bmlxdWUgaW5mZXIgYXNzZXJ0c1wiOiB0YWdzLm9wZXJhdG9yS2V5d29yZCxcblxuICBKU1hBdHRyaWJ1dGVWYWx1ZTogdGFncy5hdHRyaWJ1dGVWYWx1ZSxcbiAgSlNYVGV4dDogdGFncy5jb250ZW50LFxuICBcIkpTWFN0YXJ0VGFnIEpTWFN0YXJ0Q2xvc2VUYWcgSlNYU2VsZkNsb3NlRW5kVGFnIEpTWEVuZFRhZ1wiOiB0YWdzLmFuZ2xlQnJhY2tldCxcbiAgXCJKU1hJZGVudGlmaWVyIEpTWE5hbWVTcGFjZWROYW1lXCI6IHRhZ3MudGFnTmFtZSxcbiAgXCJKU1hBdHRyaWJ1dGUvSlNYSWRlbnRpZmllciBKU1hBdHRyaWJ1dGUvSlNYTmFtZVNwYWNlZE5hbWVcIjogdGFncy5hdHRyaWJ1dGVOYW1lLFxuICBcIkpTWEJ1aWx0aW4vSlNYSWRlbnRpZmllclwiOiB0YWdzLnN0YW5kYXJkKHRhZ3MudGFnTmFtZSlcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNwZWNfaWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxleHBvcnQ6MjAsIGFzOjI1LCBmcm9tOjMzLCBkZWZhdWx0OjM2LCBhc3luYzo0MSwgZnVuY3Rpb246NDIsIGluOjUyLCBvdXQ6NTUsIGNvbnN0OjU2LCBleHRlbmRzOjYwLCB0aGlzOjY0LCB0cnVlOjcyLCBmYWxzZTo3MiwgbnVsbDo4NCwgdm9pZDo4OCwgdHlwZW9mOjkyLCBzdXBlcjoxMDgsIG5ldzoxNDIsIGRlbGV0ZToxNTQsIHlpZWxkOjE2MywgYXdhaXQ6MTY3LCBjbGFzczoxNzIsIHB1YmxpYzoyMzUsIHByaXZhdGU6MjM1LCBwcm90ZWN0ZWQ6MjM1LCByZWFkb25seToyMzcsIGluc3RhbmNlb2Y6MjU2LCBzYXRpc2ZpZXM6MjU5LCBpbXBvcnQ6MjkyLCBrZXlvZjozNDksIHVuaXF1ZTozNTMsIGluZmVyOjM1OSwgYXNzZXJ0czozOTUsIGlzOjM5NywgYWJzdHJhY3Q6NDE3LCBpbXBsZW1lbnRzOjQxOSwgdHlwZTo0MjEsIGxldDo0MjQsIHZhcjo0MjYsIHVzaW5nOjQyOSwgaW50ZXJmYWNlOjQzNSwgZW51bTo0MzksIG5hbWVzcGFjZTo0NDUsIG1vZHVsZTo0NDcsIGRlY2xhcmU6NDUxLCBnbG9iYWw6NDU1LCBkZWZlcjo0NzEsIGZvcjo0NzYsIG9mOjQ4NSwgd2hpbGU6NDg4LCB3aXRoOjQ5MiwgZG86NDk2LCBpZjo1MDAsIGVsc2U6NTAyLCBzd2l0Y2g6NTA2LCBjYXNlOjUxMiwgdHJ5OjUxOCwgY2F0Y2g6NTIyLCBmaW5hbGx5OjUyNiwgcmV0dXJuOjUzMCwgdGhyb3c6NTM0LCBicmVhazo1MzgsIGNvbnRpbnVlOjU0MiwgZGVidWdnZXI6NTQ2fTtcbmNvbnN0IHNwZWNfd29yZCA9IHtfX3Byb3RvX186bnVsbCxhc3luYzoxMjksIGdldDoxMzEsIHNldDoxMzMsIGRlY2xhcmU6MTk1LCBwdWJsaWM6MTk3LCBwcml2YXRlOjE5NywgcHJvdGVjdGVkOjE5Nywgc3RhdGljOjE5OSwgYWJzdHJhY3Q6MjAxLCBvdmVycmlkZToyMDMsIHJlYWRvbmx5OjIwOSwgYWNjZXNzb3I6MjExLCBuZXc6NDAxfTtcbmNvbnN0IHNwZWNfTGVzc1RoYW4gPSB7X19wcm90b19fOm51bGwsXCI8XCI6MTkzfTtcbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIkRnxRJVRRbE9PTyVbUWxPT08nX1FwT09QKGxPYE9PTyp6USEwTXhPJyNDaU8rUk8jdE8nI0NqTythTyZqTycjQ2pPK29PI0BJdE8nI0RhTy5RUWxPJyNEZ08uYlFsTycjRHJPJVtRbE8nI0R6TzBmUWxPJyNFU09PUSEwTGYnI0VbJyNFW08xUFFgTycjRVhPT1FPJyNFcCcjRXBPT1FPJyNJbCcjSWxPMVhRYE8nI0dzTzFkUWBPJyNFb08xaVFgTycjRW9PM2hRITBNeE8nI0pyTzZbUSEwTXhPJyNKc082dVFgTycjRl1PNnpRLFVPJyNGdE9PUSEwTGYnI0ZmJyNGZk83Vk83ZE8nI0ZmTzlYUU1oTycjRnxPOWBRYE8nI0Z7T09RITBMZicjSnMnI0pzT09RITBMYicjSnInI0pyTzllUWBPJyNHd09PUVsnI0tfJyNLX085cFFgTycjSVlPOXVRITBMck8nI0laT09RWycjSmAnI0pgT09RWycjSV8nI0lfUWBRbE9PUWBRbE9PTzl9USFMXk8nI0R2TzpVUWxPJyNFT086XVFsTycjRVFPOWtRYE8nI0dzTzpkUU1oTycjQ29POnJRYE8nI0VuTzp9UWBPJyNFeU87aFFNaE8nI0ZlTzt4UWBPJyNHc09PUU8nI0tgJyNLYE87fVFgTycjS2BPPF1RYE8nI0d7TzxdUWBPJyNHfE88XVFgTycjSE9POWtRYE8nI0hSTz1TUWBPJyNIVU8+a1FgTycjQ2VPPntRYE8nI0hjTz9UUWBPJyNIaU8/VFFgTycjSGtPYFFsTycjSG1PP1RRYE8nI0hvTz9UUWBPJyNIck8/WVFgTycjSHhPP19RITBMc08nI0lPTyVbUWxPJyNJUU8/alEhMExzTycjSVNPP3VRITBMc08nI0lVTzl1USEwTHJPJyNJV09AUVEhME14TycjQ2lPQVNRcE8nI0RsUU9RYE9PTyVbUWxPJyNFUU9BalFgTycjRVRPOmRRTWhPJyNFbk9BdVFgTycjRW5PQlFRIWJPJyNGZU9PUVsnI0NnJyNDZ09PUSEwTGInI0RxJyNEcU9PUSEwTGInI0p2JyNKdk8lW1FsTycjSnZPT1FPJyNKeScjSnlPT1FPJyNJaCcjSWhPQ1FRcE8nI0VnT09RITBMYicjRWYnI0VmT09RITBMYicjSn0nI0p9T0N8USEwTVNPJyNFZ09EV1FwTycjRVdPT1FPJyNKeCcjSnhPRGxRcE8nI0p5T0V5UXBPJyNFV09EV1FwTycjRWdQRldPJjJEak8nI0NiUE9PTylDRH0pQ0R9T09PTycjSWAnI0lgT0ZjTyN0Tyw1OVVPT1EhMExoLDU5VSw1OVVPT09PJyNJYScjSWFPRnFPJmpPLDU5VU9HUFEhTF5PJyNEY09PT08nI0ljJyNJY09HV08jQEl0Tyw1OXtPT1EhMExmLDU5eyw1OXtPR2ZRbE8nI0lkT0d5UWBPJyNKdE9JeFEhZk8nI0p0Tyt9UWxPJyNKdE9KUFFgTyw1OlJPSmdRYE8nI0VwT0p0UWBPJyNLVE9LUFFgTycjS1NPS1BRYE8nI0tTT0tYUWBPLDU7Xk9LXlFgTycjS1JPT1EhMExuLDU6Xiw1Ol5PS2VRbE8sNTpeT01jUSEwTXhPLDU6Zk9OU1FgTyw1Om5PTm1RITBMck8nI0tRT050UWBPJyNLUE85ZVFgTycjS1BPISBZUWBPJyNLUE8hIGJRYE8sNTtdTyEgZ1FgTycjS1BPISNsUSFmTycjSnNPT1EhMExoJyNDaScjQ2lPJVtRbE8nI0VTTyEkW1EhZk8sNTpzT09RUycjSnonI0p6T09RTy1FPGotRTxqTzlrUWBPLDU9X08hJHJRYE8sNT1fTyEkd1FsTyw1O1pPISZ6UU1oTycjRWtPIShlUWBPLDU7Wk8hKGpRbE8nI0R5TyEodFFwTyw1O2RPISh8UXBPLDU7ZE8lW1FsTyw1O2RPT1FbJyNGVCcjRlRPT1FbJyNGVicjRlZPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlT09RWycjRlonI0ZaTyEpW1FsTyw1O3RPT1EhMExmLDU7eSw1O3lPT1EhMExmLDU7eiw1O3pPT1EhMExmLDU7fCw1O3xPJVtRbE8nI0lwTyErX1EhMExyTyw1PGlPJVtRbE8sNTtlTyEmelFNaE8sNTtlTyErfFFNaE8sNTtlTyEtblFNaE8nI0VeTyVbUWxPLDU7d09PUSEwTGYsNTt7LDU7e08hLXVRLFVPJyNGak8hLnJRLFVPJyNLWE8hLl5RLFVPJyNLWE8hLnlRLFVPJyNLWE9PUU8nI0tYJyNLWE8hL19RLFVPLDU8U09PT1csNTxgLDU8YE8hL3BRbE8nI0Z2T09PVycjSW8nI0lvTzdWTzdkTyw1PFFPIS93USxVTycjRnhPT1EhMExmLDU8USw1PFFPITBoUSRJVU8nI0N5T09RITBMaCcjQ30nI0N9TyEwe08jQEl0TycjRFJPITFpUU1qTyw1PGVPITFwUWBPLDU8aE8hM1lRKENXTycjR1hPITNqUWBPJyNHWU8hM29RYE8nI0dZTyE1X1EoQ1dPJyNHXk8hNmRRcE8nI0diT09RTycjR24nI0duTyEsVFFNaE8nI0dtT09RTycjR3AnI0dwTyEsVFFNaE8nI0dvTyE3VlEkSVVPJyNKbE9PUSEwTGgnI0psJyNKbE8hN2FRYE8nI0prTyE3b1FgTycjSmpPITd3UWBPJyNDdU9PUSEwTGgnI0N7JyNDe08hOFlRYE8nI0N9T09RITBMaCcjRFYnI0RWT09RITBMaCcjRFgnI0RYTyE4X1FgTyw1PGVPMVNRYE8nI0RaTyEsVFFNaE8nI0dQTyEsVFFNaE8nI0dSTyE4Z1FgTycjR1RPIThsUWBPJyNHVU8hM29RYE8nI0dbTyEsVFFNaE8nI0dhTzxdUWBPJyNKa08hOHFRYE8nI0VxTyE5YFFgTyw1PGdPT1EhMExiJyNDcicjQ3JPITloUWBPJyNFck8hOmJRcE8nI0VzT09RITBMYicjS1InI0tSTyE6aVEhMExyTycjS2FPOXVRITBMck8sNT1jT2BRbE8sNT50T09RWycjSmgnI0poT09RWyw1PnUsNT51T09RWy1FPF0tRTxdTyE8aFEhME14Tyw1OmJPITpdUXBPLDU6YE8hP1JRITBNeE8sNTpqTyVbUWxPLDU6ak8hQWlRITBNeE8sNTpsT09RTyw1QHosNUB6TyFCWVFNaE8sNT1fTyFCaFEhMExyTycjSmlPOWBRYE8nI0ppTyFCeVEhMExyTyw1OVpPIUNVUXBPLDU5Wk8hQ15RTWhPLDU5Wk86ZFFNaE8sNTlaTyFDaVFgTyw1O1pPIUNxUWBPJyNIYk8hRFZRYE8nI0tkTyVbUWxPLDU7fU8hOl1RcE8sNTxQTyFEX1FgTyw1PXpPIURkUWBPLDU9ek8hRGlRYE8sNT16TyFEd1FgTyw1PXpPOXVRITBMck8sNT16TzxdUWBPLDU9ak9PUU8nI0N5JyNDeU8hRU9RcE8sNT1nTyFFV1FNaE8sNT1oTyFFY1FgTyw1PWpPIUVoUSFiTyw1PW1PIUVwUWBPJyNLYE8/WVFgTycjSFdPOWtRYE8nI0hZTyFFdVFgTycjSFlPOmRRTWhPJyNIW08hRXpRYE8nI0hbT09RWyw1PXAsNT1wTyFGUFFgTycjSF1PIUZiUWBPJyNDb08hRmdRYE8sNTlQTyFGcVFgTyw1OVBPIUh2UWxPLDU5UE9PUVssNTlQLDU5UE8hSVdRITBMck8sNTlQTyVbUWxPLDU5UE8hS2NRbE8nI0hlT09RWycjSGYnI0hmT09RWycjSGcnI0hnT2BRbE8sNT19TyFLeVFgTyw1PX1PYFFsTyw1PlRPYFFsTyw1PlZPIUxPUWBPLDU+WE9gUWxPLDU+Wk8hTFRRYE8sNT5eTyFMWVFsTyw1PmRPT1FbLDU+aiw1PmpPJVtRbE8sNT5qTzl1USEwTHJPLDU+bE9PUVssNT5uLDU+bk8jIWRRYE8sNT5uT09RWyw1PnAsNT5wTyMhZFFgTyw1PnBPT1FbLDU+ciw1PnJPIyNRUXBPJyNEX08lW1FsTycjSnZPIyNzUXBPJyNKdk8jI31RcE8nI0RtTyMkYFFwTycjRG1PIyZxUWxPJyNEbU8jJnhRYE8nI0p1TyMnUVFgTyw1OldPIydWUWBPJyNFdE8jJ2VRYE8nI0tVTyMnbVFgTyw1O19PIydyUXBPJyNEbU8jKFBRcE8nI0VWT09RITBMZiw1Om8sNTpvTyVbUWxPLDU6b08jKFdRYE8sNTpvTz9ZUWBPLDU7WU8hQ1VRcE8sNTtZTyFDXlFNaE8sNTtZTzpkUU1oTyw1O1lPIyhgUWBPLDVAYk8jKGVRMDdkTyw1OnNPT1FPLUU8Zi1FPGZPIylrUSEwTVNPLDU7Uk9EV1FwTyw1OnJPIyl1UXBPLDU6ck9EV1FwTyw1O1JPIUJ5USEwTHJPLDU6ck9PUSEwTGInI0VqJyNFak9PUU8sNTtSLDU7Uk8lW1FsTyw1O1JPIypTUSEwTHJPLDU7Uk8jKl9RITBMck8sNTtSTyFDVVFwTyw1OnJPT1FPLDU7WCw1O1hPIyptUSEwTHJPLDU7UlBPT08nI0leJyNJXlAjK1JPJjJEak8sNTh8UE9PTyw1OHwsNTh8T09PTy1FPF4tRTxeT09RITBMaDFHLnAxRy5wT09PTy1FPF8tRTxfT09PTyw1OX0sNTl9TyMrXlEhYk8sNTl9T09PTy1FPGEtRTxhT09RITBMZjFHL2cxRy9nTyMrY1EhZk8sNT9PTyt9UWxPLDU/T09PUU8sNT9VLDU/VU8jK21RbE8nI0lkT09RTy1FPGItRTxiTyMrelFgTyw1QGBPIyxTUSFmTyw1QGBPIyxaUWBPLDVAbk9PUSEwTGYxRy9tMUcvbU8lW1FsTyw1QG9PIyxjUWBPJyNJak9PUU8tRTxoLUU8aE8jLFpRYE8sNUBuT09RITBMYjFHMHgxRzB4T09RITBMbjFHL3gxRy94T09RITBMbjFHMFkxRzBZTyVbUWxPLDVAbE8jLHdRITBMck8sNUBsTyMtWVEhMExyTyw1QGxPIy1hUWBPLDVAa085ZVFgTyw1QGtPIy1pUWBPLDVAa08jLXdRYE8nI0ltTyMtYVFgTyw1QGtPT1EhMExiMUcwdzFHMHdPISh0UXBPLDU6dU8hKVBRcE8sNTp1T09RUyw1OncsNTp3TyMuaVFkTyw1OndPIy5xUU1oTzFHMnlPOWtRYE8xRzJ5T09RITBMZjFHMHUxRzB1TyMvUFEhME14TzFHMHVPIzBVUSEwTXZPLDU7Vk9PUSEwTGgnI0dXJyNHV08jMHJRITBNek8nI0psTyEkd1FsTzFHMHVPIzJ9USFmTycjSndPJVtRbE8nI0p3TyMzWFFgTyw1OmVPT1EhMExoJyNEXycjRF9PT1EhMExmMUcxTzFHMU9PJVtRbE8xRzFPT09RITBMZjFHMWYxRzFmTyMzXlFgTzFHMU9PIzVyUSEwTXhPMUcxUE8jNXlRITBNeE8xRzFQTyM4YVEhME14TzFHMVBPIzhoUSEwTXhPMUcxUE8jO09RITBNeE8xRzFQTyM9ZlEhME14TzFHMVBPIz1tUSEwTXhPMUcxUE8jPXRRITBNeE8xRzFQTyNAW1EhME14TzFHMVBPI0BjUSEwTXhPMUcxUE8jQnBRP010TycjQ2lPI0RrUT9NdE8xRzFgTyNEclE/TXRPJyNKc08jRVZRITBNeE8sNT9bT09RITBMYi1FPG4tRTxuTyNHZFEhME14TzFHMVBPI0hhUSEwTXpPMUcxUE9PUSEwTGYxRzFQMUcxUE8jSWRRTWpPJyNKfE8jSW5RYE8sNTp4TyNJc1EhME14TzFHMWNPI0pnUSxVTyw1PFdPI0pvUSxVTyw1PFhPI0p3USxVTycjRm9PI0tgUWBPJyNGbk9PUU8nI0tZJyNLWU9PUU8nI0luJyNJbk8jS2VRLFVPMUcxbk9PUSEwTGYxRzFuMUcxbk9PT1cxRzF5MUcxeU8jS3ZRP010TycjSnJPI0xRUWBPLDU8Yk8hKVtRbE8sNTxiT09PVy1FPG0tRTxtT09RITBMZjFHMWwxRzFsTyNMVlFwTycjS1hPT1EhMExmLDU8ZCw1PGRPI0xfUXBPLDU8ZE8jTGRRTWhPJyNEVE9PT08nI0liJyNJYk8jTGtPI0BJdE8sNTltT09RITBMaCw1OW0sNTltTyVbUWxPMUcyUE8hOGxRYE8nI0lyTyNMdlFgTyw1PHpPT1EhMExoLDU8dyw1PHdPISxUUU1oTycjSXVPI01kUU1qTyw1PVhPISxUUU1oTycjSXdPI05WUU1qTyw1PVpPISZ6UU1oTyw1PV1PT1FPMUcyUzFHMlNPI05hUSFkTycjQ3JPI050UShDV08nI0VyTyQgfFFwTycjR2JPJCFkUSFkTyw1PHNPJCFrUWBPJyNLW085ZVFgTycjS1tPJCF5UWBPLDU8dU8kI2FRIWRPJyNDe08hLFRRTWhPLDU8dE8kI2tRYE8nI0daTyQkUFFgTyw1PHRPJCRVUSFkTycjR1dPJCRjUSFkTycjS11PJCRtUWBPJyNLXU8hJnpRTWhPJyNLXU8kJHJRYE8sNTx4TyQkd1FsTycjSnZPJCVSUXBPJyNHY08jJGBRcE8nI0djTyQlZFFgTycjR2dPITNvUWBPJyNHa08kJWlRITBMck8nI0l0TyQldFFwTyw1PHxPT1EhMExwLDU8fCw1PHxPJCV7UXBPJyNHY08kJllRcE8nI0dkTyQma1FwTycjR2RPJCZwUU1qTyw1PVhPJCdRUU1qTyw1PVpPT1EhMExoLDU9Xiw1PV5PISxUUU1oTyw1QFZPISxUUU1oTyw1QFZPJCdiUWBPJyNJeU8kJ3ZRYE8sNUBVTyQoT1FgTyw1OWFPT1EhMExoLDU5aSw1OWlPJChUUWBPLDVAVk8kKVRRJElZTyw1OXVPT1EhMExoJyNKcCcjSnBPJCl2UU1qTyw1PGtPJCppUU1qTyw1PG1PQHpRYE8sNTxvT09RITBMaCw1PHAsNTxwTyQqc1FgTyw1PHZPJCp4UU1qTyw1PHtPJCtZUWBPJyNLUE8hJHdRbE8xRzJSTyQrX1FgTzFHMlJPOWVRYE8nI0tTTzllUWBPJyNFdE8lW1FsTycjRXRPOWVRYE8nI0l7TyQrZFEhMExyTyw1QHtPT1FbMUcyfTFHMn1PT1FbMUc0YDFHNGBPT1EhMExmMUcvfDFHL3xPT1EhMExmMUcvejFHL3pPJC1mUSEwTXhPMUcwVU9PUVsxRzJ5MUcyeU8hJnpRTWhPMUcyeU8lW1FsTzFHMnlPIy50UWBPMUcyeU8kL2pRTWhPJyNFa09PUSEwTGIsNUBULDVAVE8kL3dRITBMck8sNUBUT09RWzFHLnUxRy51TyFCeVEhMExyTzFHLnVPIUNVUXBPMUcudU8hQ15RTWhPMUcudU8kMFlRYE8xRzB1TyQwX1FgTycjQ2lPJDBqUWBPJyNLZU8kMHJRYE8sNT18TyQwd1FgTycjS2VPJDB8UWBPJyNLZU8kMVtRYE8nI0pSTyQxalFgTyw1QU9PJDFyUSFmTzFHMWlPT1EhMExmMUcxazFHMWtPOWtRYE8xRzNmT0B6UWBPMUczZk8kMXlRYE8xRzNmTyQyT1FgTzFHM2ZPIURpUWBPMUczZk85dVEhMExyTzFHM2ZPT1FbMUczZjFHM2ZPIUVjUWBPMUczVU8hJnpRTWhPMUczUk8kMlRRYE8xRzNST09RWzFHM1MxRzNTTyEmelFNaE8xRzNTTyQyWVFgTzFHM1NPJDJiUXBPJyNIUU9PUVsxRzNVMUczVU8hNl9RcE8nI0l9TyFFaFEhYk8xRzNYT09RWzFHM1gxRzNYT09RWyw1PXIsNT1yTyQyalFNaE8sNT10TzlrUWBPLDU9dE8kJWRRYE8sNT12TzlgUWBPLDU9dk8hQ1VRcE8sNT12TyFDXlFNaE8sNT12TzpkUU1oTyw1PXZPJDJ4UWBPJyNLY08kM1RRYE8sNT13T09RWzFHLmsxRy5rTyQzWVEhMExyTzFHLmtPQHpRYE8xRy5rTyQzZVFgTzFHLmtPOXVRITBMck8xRy5rTyQ1bVEhZk8sNUFRTyQ1elFgTyw1QVFPOWVRYE8sNUFRTyQ2VlFsTyw1PlBPJDZeUWBPLDU+UE9PUVsxRzNpMUczaU9gUWxPMUczaU9PUVsxRzNvMUczb09PUVsxRzNxMUczcU8/VFFgTzFHM3NPJDZjUWxPMUczdU8kOmdRbE8nI0h0T09RWzFHM3gxRzN4TyQ6dFFgTycjSHpPP1lRYE8nI0h8T09RWzFHNE8xRzRPTyQ6fFFsTzFHNE9POXVRITBMck8xRzRVT09RWzFHNFcxRzRXT09RITBMYicjR18nI0dfTzl1USEwTHJPMUc0WU85dVEhMExyTzFHNFtPJD9UUWBPLDVAYk8hKVtRbE8sNTtgTzllUWBPLDU7YE8/WVFgTyw1OlhPISlbUWxPLDU6WE8hQ1VRcE8sNTpYTyQ/WVE/TXRPLDU6WE9PUU8sNTtgLDU7YE8kP2RRcE8nI0llTyQ/elFgTyw1QGFPT1EhMExmMUcvcjFHL3JPJEBTUXBPJyNJa08kQF5RYE8sNUBwT09RITBMYjFHMHkxRzB5TyMkYFFwTyw1OlhPT1FPJyNJZycjSWdPJEBmUXBPLDU6cU9PUSEwTG4sNTpxLDU6cU8jKFpRYE8xRzBaT09RITBMZjFHMFoxRzBaTyVbUWxPMUcwWk9PUSEwTGYxRzB0MUcwdE8/WVFgTzFHMHRPIUNVUXBPMUcwdE8hQ15RTWhPMUcwdE9PUSEwTGIxRzV8MUc1fE8hQnlRITBMck8xRzBeT09RTzFHMG0xRzBtTyVbUWxPMUcwbU8kQG1RITBMck8xRzBtTyRAeFEhMExyTzFHMG1PIUNVUXBPMUcwXk9EV1FwTzFHMF5PJEFXUSEwTHJPMUcwbU9PUU8xRzBeMUcwXk8kQWxRITBNeE8xRzBtUE9PTy1FPFstRTxbUE9PTzFHLmgxRy5oT09PTzFHL2kxRy9pTyRBdlEhYk8sNTxpTyRCT1EhZk8xRzRqT09RTzFHNHAxRzRwTyVbUWxPLDU/T08kQllRYE8xRzV6TyRCYlFgTzFHNllPJEJqUSFmTzFHNlpPOWVRYE8sNT9VTyRCdFEhME14TzFHNldPJVtRbE8xRzZXTyRDVVEhMExyTzFHNldPJENnUWBPMUc2Vk8kQ2dRYE8xRzZWTzllUWBPMUc2Vk8kQ29RYE8sNT9YTzllUWBPLDU/WE9PUU8sNT9YLDU/WE8kRFRRYE8sNT9YTyQrWVFgTyw1P1hPT1FPLUU8ay1FPGtPT1FTMUcwYTFHMGFPT1FTMUcwYzFHMGNPIy5sUWBPMUcwY09PUVs3KyhlNysoZU8hJnpRTWhPNysoZU8lW1FsTzcrKGVPJERjUWBPNysoZU8kRG5RTWhPNysoZU8kRHxRITBNek8sNT1YTyRHWFEhME16Tyw1PVpPJElkUSEwTXpPLDU9WE8kS3VRITBNek8sNT1aTyROV1EhME16Tyw1OXVPJSFdUSEwTXpPLDU8a08lJGhRITBNek8sNTxtTyUmc1EhME16Tyw1PHtPT1EhMExmNysmYTcrJmFPJSlVUSEwTXhPNysmYU8lKXhRbE8nI0lmTyUqVlFgTyw1QGNPJSpfUSFmTyw1QGNPT1EhMExmMUcwUDFHMFBPJSppUWBPNysmak9PUSEwTGY3KyZqNysmak8lKm5RP010Tyw1OmZPJVtRbE83KyZ6TyUqeFE/TXRPLDU6Yk8lK1ZRP010Tyw1OmpPJSthUT9NdE8sNTpsTyUra1FNaE8nI0lpTyUrdVFgTyw1QGhPT1EhMExoMUcwZDFHMGRPT1FPMUcxcjFHMXJPT1FPMUcxczFHMXNPJSt9USFqTyw1PFpPISlbUWxPLDU8WU9PUU8tRTxsLUU8bE9PUSEwTGY3KydZNysnWU9PT1c3KydlNysnZU9PT1cxRzF8MUcxfE8lLFlRYE8xRzF8T09RITBMZjFHMk8xRzJPT09PTyw1OW8sNTlvTyUsX1EhZE8sNTlvT09PTy1FPGAtRTxgT09RITBMaDFHL1gxRy9YTyUsZlEhME14TzcrJ2tPT1EhMExoLDU/Xiw1P15PJS1ZUU1oTzFHMmZQJS1hUWBPJyNJclBPUSEwTGgtRTxwLUU8cE8lLX1RTWpPLDU/YU9PUSEwTGgtRTxzLUU8c08lLnBRTWpPLDU/Y09PUSEwTGgtRTx1LUU8dU8lLnpRIWRPMUcyd08lL1JRIWRPJyNDck8lL2lRTWhPJyNLU08kJHdRbE8nI0p2T09RITBMaDFHMl8xRzJfTyUvc1FgTycjSXFPJTBbUWBPLDVAdk8lMFtRYE8sNUB2TyUwZFFgTyw1QHZPJTBvUWBPLDVAdk9PUU8xRzJhMUcyYU8lMH1RTWpPMUcyYE8kK1lRYE8nI0tbTyEsVFFNaE8xRzJgTyUxX1EoQ1dPJyNJc08lMWxRYE8sNUB3TyEmelFNaE8sNUB3TyUxdFEhZE8sNUB3T09RITBMaDFHMmQxRzJkTyU0VVEhZk8nI0NpTyU0YFFgTyw1PVBPT1EhMExiLDU8fSw1PH1PJTRoUXBPLDU8fU9PUSEwTGIsNT1PLDU9T09Dd1FgTyw1PH1PJTRzUXBPLDU8fU9PUSEwTGIsNT1SLDU9Uk8kK1lRYE8sNT1WT09RTyw1P2AsNT9gT09RTy1FPHItRTxyT09RITBMcDFHMmgxRzJoTyMkYFFwTyw1PH1PJCR3UWxPLDU9UE8lNVJRYE8sNT1PTyU1XlFwTyw1PU9PISxUUU1oTycjSXVPJTZXUU1qTzFHMnNPISxUUU1oTycjSXdPJTZ5UU1qTzFHMnVPJTdUUU1qTzFHNXFPJTdfUU1qTzFHNXFPT1FPLDU/ZSw1P2VPT1FPLUU8dy1FPHdPT1FPMUcuezFHLntPISxUUU1oTzFHNXFPISxUUU1oTzFHNXFPITpdUXBPLDU5d08lW1FsTyw1OXdPT1EhMExoLDU8aiw1PGpPJTdsUWBPMUcyWk8hLFRRTWhPMUcyYk8lN3FRITBNeE83KydtT09RITBMZjcrJ203KydtTyEkd1FsTzcrJ21PJThlUWBPLDU7YE9PUSEwTGIsNT9nLDU/Z09PUSEwTGItRTx5LUU8eU8lOGpRIWRPJyNLXk8jKFpRYE83KyhlTzRVUSFmTzcrKGVPJERmUWBPNysoZU8lOHRRITBNdk8nI0NpTyU5WFEhME12Tyw1PVNPJTlsUWBPLDU9U08lOXRRYE8sNT1TT09RITBMYjFHNW8xRzVvT09RWzcrJGE3KyRhTyFCeVEhMExyTzcrJGFPIUNVUXBPNyskYU8hJHdRbE83KyZhTyU5eVFgTycjSlFPJTpiUWBPLDVBUE9PUU8xRzNoMUczaE85a1FgTyw1QVBPJTpiUWBPLDVBUE8lOmpRYE8sNUFQT09RTyw1P20sNT9tT09RTy1FPVAtRT1QT09RITBMZjcrJ1Q3KydUTyU6b1FgTzcrKVFPOXVRITBMck83KylRTzlrUWBPNyspUU9AelFgTzcrKVFPJTp0UWBPNyspUU9PUVs3KylRNyspUU9PUVs3KyhwNysocE8lOnlRITBNdk83KyhtTyEmelFNaE83KyhtTyFFXlFgTzcrKG5PT1FbNysobjcrKG5PISZ6UU1oTzcrKG5PJTtUUWBPJyNLYk8lO2BRYE8sNT1sT09RTyw1P2ksNT9pT09RTy1FPHstRTx7T09RWzcrKHM3KyhzTyU8clFwTycjSFpPT1FbMUczYDFHM2BPISZ6UU1oTzFHM2BPJVtRbE8xRzNgTyU8eVFgTzFHM2BPJT1VUU1oTzFHM2BPOXVRITBMck8xRzNiTyQlZFFgTzFHM2JPOWBRYE8xRzNiTyFDVVFwTzFHM2JPIUNeUU1oTzFHM2JPJT1kUWBPJyNKUE8lPXhRYE8sNUB9TyU+UVFwTyw1QH1PT1EhMExiMUczYzFHM2NPT1FbNyskVjcrJFZPQHpRYE83KyRWTzl1USEwTHJPNyskVk8lPl1RYE83KyRWTyVbUWxPMUc2bE8lW1FsTzFHNm1PJT5iUSEwTHJPMUc2bE8lPmxRbE8xRzNrTyU+c1FgTzFHM2tPJT54UWxPMUcza09PUVs3KylUNyspVE85dVEhMExyTzcrKV9PYFFsTzcrKWFPT1FbJyNLaCcjS2hPT1FbJyNKUycjSlNPJT9QUWxPLDU+YE9PUVssNT5gLDU+YE8lW1FsTycjSHVPJT9eUWBPJyNId09PUVssNT5mLDU+Zk85ZVFgTyw1PmZPT1FbLDU+aCw1PmhPT1FbNyspajcrKWpPT1FbNyspcDcrKXBPT1FbNyspdDcrKXRPT1FbNyspdjcrKXZPJT9jUXBPMUc1fE8lP31RP010TzFHMHpPJUBYUWBPMUcwek9PUU8xRy9zMUcvc08lQGRRP010TzFHL3NPP1lRYE8xRy9zTyEpW1FsTycjRG1PT1FPLDU/UCw1P1BPT1FPLUU8Yy1FPGNPT1FPLDU/Viw1P1ZPT1FPLUU8aS1FPGlPIUNVUXBPMUcvc09PUU8tRTxlLUU8ZU9PUSEwTG4xRzBdMUcwXU9PUSEwTGY3KyV1NysldU8jKFpRYE83KyV1T09RITBMZjcrJmA3KyZgTz9ZUWBPNysmYE8hQ1VRcE83KyZgT09RTzcrJXg3KyV4TyRBbFEhME14TzcrJlhPT1FPNysmWDcrJlhPJVtRbE83KyZYTyVAblEhMExyTzcrJlhPIUJ5USEwTHJPNysleE8hQ1VRcE83KyV4TyVAeVEhMExyTzcrJlhPJUFYUSEwTXhPNysrck8lW1FsTzcrK3JPJUFpUWBPNysrcU8lQWlRYE83KytxT09RTzFHNHMxRzRzTzllUWBPMUc0c08lQXFRYE8xRzRzT09RUzcrJX03KyV9TyMoWlFgTzw8TFBPNFVRIWZPPDxMUE8lQlBRYE88PExQT09RWzw8TFA8PExQTyEmelFNaE88PExQTyVbUWxPPDxMUE8lQlhRYE88PExQTyVCZFEhME16Tyw1P2FPJURvUSEwTXpPLDU/Y08lRnpRITBNek8xRzJgTyVJXVEhME16TzFHMnNPJUtoUSEwTXpPMUcydU8lTXNRIWZPLDU/UU8lW1FsTyw1P1FPT1FPLUU8ZC1FPGRPJU19UWBPMUc1fU9PUSEwTGY8PEpVPDxKVU8lTlZRP010TzFHMHVPJiFeUT9NdE8xRzFQTyYhZVE/TXRPMUcxUE8mJGZRP010TzFHMVBPJiRtUT9NdE8xRzFQTyYmblE/TXRPMUcxUE8mKG9RP010TzFHMVBPJih2UT9NdE8xRzFQTyYofVE/TXRPMUcxUE8mK09RP010TzFHMVBPJitWUT9NdE8xRzFQTyYrXlEhME14Tzw8SmZPJi1VUT9NdE8xRzFQTyYuUlE/TXZPMUcxUE8mL1VRP012TycjSmxPJjFbUT9NdE8xRzFjTyYxaVE/TXRPMUcwVU8mMXNRTWpPLDU/VE9PUU8tRTxnLUU8Z08hKVtRbE8nI0ZxT09RTycjS1onI0taT09RTzFHMXUxRzF1TyYxfVFgTzFHMXRPJjJTUT9NdE8sNT9bT09PVzcrJ2g3KydoT09PTzFHL1oxRy9aTyYyXlEhZE8xRzR4T09RITBMaDcrKFE3KyhRUCEmelFNaE8sNT9eTyEsVFFNaE83KyhjTyYyZVFgTyw1P11POWVRYE8sNT9dTyQrWVFgTyw1P11PT1FPLUU8by1FPG9PJjJzUWBPMUc2Yk8mMnNRYE8xRzZiTyYye1FgTzFHNmJPJjNXUU1qTzcrJ3pPJjNoUSFkTyw1P19PJjNyUWBPLDU/X08hJnpRTWhPLDU/X09PUU8tRTxxLUU8cU8mM3dRIWRPMUc2Y08mNFJRYE8xRzZjTyY0WlFgTzFHMmtPISZ6UU1oTzFHMmtPT1EhMExiMUcyaTFHMmlPT1EhMExiMUcyajFHMmpPJTRoUXBPMUcyaU8hQ1VRcE8xRzJpT0N3UWBPMUcyaU9PUSEwTGIxRzJxMUcycU8mNGBRcE8xRzJpTyY0blFgTzFHMmtPJCtZUWBPMUcyak9Dd1FgTzFHMmpPJCR3UWxPMUcya08mNHZRYE8xRzJqTyY1alFNak8sNT9hT09RITBMaC1FPHQtRTx0TyY2XVFNak8sNT9jT09RITBMaC1FPHYtRTx2TyEsVFFNaE83KytdTyY2Z1FNak83KytdTyY2cVFNak83KytdT09RITBMaDFHL2MxRy9jTyY3T1FgTzFHL2NPT1EhMExoNysndTcrJ3VPJjdUUU1qTzcrJ3xPJjdlUSEwTXhPPDxLWE9PUSEwTGY8PEtYPDxLWE8mOFhRYE8xRzB6TyEmelFNaE8nI0l6TyY4XlFgTyw1QHhPJjpgUSFmTzw8TFBPISZ6UU1oTzFHMm5PJjpnUSEwTHJPMUcybk9PUVs8PEd7PDxHe08hQnlRITBMck88PEd7TyY6eFEhME14Tzw8SXtPT1EhMExmPDxJezw8SXtPT1FPLDU/bCw1P2xPJjtsUWBPLDU/bE8mO3FRYE8sNT9sT09RTy1FPU8tRT1PTyY8UFFgTzFHNmtPJjxQUWBPMUc2a085a1FgTzFHNmtPQHpRYE88PExsT09RWzw8TGw8PExsTyY8WFFgTzw8TGxPOXVRITBMck88PExsTzlrUWBPPDxMbE9PUVs8PExYPDxMWE8lOnlRITBNdk88PExYT09RWzw8TFk8PExZTyFFXlFgTzw8TFlPJjxeUXBPJyNJfE8mPGlRYE8sNUB8TyEpW1FsTyw1QHxPT1FbMUczVzFHM1dPT1FPJyNKTycjSk9POXVRITBMck8nI0pPTyY8cVFwTyw1PXVPT1FbLDU9dSw1PXVPJjx4UXBPJyNFZ08mPVBRcE8nI0dlTyY9VVFgTzcrKHpPJj1aUWBPNysoek9PUVs3Kyh6Nysoek8hJnpRTWhPNysoek8lW1FsTzcrKHpPJj1jUWBPNysoek9PUVs3Kyh8NysofE85dVEhMExyTzcrKHxPJCVkUWBPNysofE85YFFgTzcrKHxPIUNVUXBPNysofE8mPW5RYE8sNT9rT09RTy1FPH0tRTx9T09RTycjSF4nI0heTyY9eVFgTzFHNmlPOXVRITBMck88PEdxT09RWzw8R3E8PEdxT0B6UWBPPDxHcU8mPlJRYE83KyxXTyY+V1FgTzcrLFhPJVtRbE83KyxXTyVbUWxPNyssWE9PUVs3KylWNyspVk8mPl1RYE83KylWTyY+YlFsTzcrKVZPJj5pUWBPNyspVk9PUVs8PEx5PDxMeU9PUVs8PEx7PDxMe09PUVstRT1RLUU9UU9PUVsxRzN6MUczek8mPm5RYE8sNT5hT09RWyw1PmMsNT5jTyY+c1FgTzFHNFFPOWVRYE83KyZmTyEpW1FsTzcrJmZPT1FPNyslXzcrJV9PJj54UT9NdE8xRzZaTz9ZUWBPNyslX09PUSEwTGY8PElhPDxJYU9PUSEwTGY8PEl6PDxJek8/WVFgTzw8SXpPT1FPPDxJczw8SXNPJEFsUSEwTXhPPDxJc08lW1FsTzw8SXNPT1FPPDxJZDw8SWRPIUJ5USEwTHJPPDxJZE8mP1NRITBMck88PElzTyY/X1EhME14Tzw9IF5PJj9vUWBPPD0gXU9PUU83KypfNysqX085ZVFgTzcrKl9PT1FbQU5Ba0FOQWtPJj93USFmT0FOQWtPISZ6UU1oT0FOQWtPIyhaUWBPQU5Ba080VVEhZk9BTkFrTyZAT1FgT0FOQWtPJVtRbE9BTkFrTyZAV1EhME16TzcrJ3pPJkJpUSEwTXpPLDU/YU8mRHRRITBNek8sNT9jTyZHUFEhME16TzcrJ3xPJkliUSFmTzFHNGxPJklsUT9NdE83KyZhTyZLcFE/TXZPLDU9WE8mTXdRP012Tyw1PVpPJk5YUT9Ndk8sNT1YTyZOaVE/TXZPLDU9Wk8mTnlRP012Tyw1OXVPJyNQUT9Ndk8sNTxrTyclU1E/TXZPLDU8bU8nJ2hRP012Tyw1PHtPJyleUT9NdE83KydrTycpa1E/TXRPNysnbU8nKXhRYE8sNTxdT09RTzcrJ2A3KydgT09RITBMaDcrKmQ3KypkTycpfVFNak88PEt9T09RTzFHNHcxRzR3TycqVVFgTzFHNHdPJyphUWBPMUc0d08nKm9RYE83Kyt8Tycqb1FgTzcrK3xPISZ6UU1oTzFHNHlPJyp3USFkTzFHNHlPJytSUWBPNysrfU8nK1pRYE83KyhWTycrZlEhZE83KyhWT09RITBMYjcrKFQ3KyhUT09RITBMYjcrKFU3KyhVTyFDVVFwTzcrKFRPQ3dRYE83KyhUTycrcFFgTzcrKFZPISZ6UU1oTzcrKFZPJCtZUWBPNysoVU8nK3VRYE83KyhWT0N3UWBPNysoVU8nK31RTWpPPDxOd08hLFRRTWhPPDxOd09PUSEwTGg3KyR9NyskfU8nLFhRIWRPLDU/Zk9PUU8tRTx4LUU8eE8nLGNRITBNdk83KyhZTyEmelFNaE83KyhZT09RW0FOPWdBTj1nTzlrUWBPMUc1V09PUU8xRzVXMUc1V08nLHNRYE8xRzVXTycseFFgTzcrLFZPJyx4UWBPNyssVk85dVEhMExyT0FOQldPQHpRYE9BTkJXT09RW0FOQldBTkJXTyctUVFgT0FOQldPT1FbQU5Bc0FOQXNPT1FbQU5BdEFOQXRPJy1WUWBPLDU/aE9PUU8tRTx6LUU8ek8nLWJRP010TzFHNmhPT1FPLDU/aiw1P2pPT1FPLUU8fC1FPHxPT1FbMUczYTFHM2FPJy1sUWBPLDU9UE9PUVs8PExmPDxMZk8hJnpRTWhPPDxMZk8mPVVRYE88PExmTyctcVFgTzw8TGZPJVtRbE88PExmT09RWzw8TGg8PExoTzl1USEwTHJPPDxMaE8kJWRRYE88PExoTzlgUWBPPDxMaE8nLXlRcE8xRzVWTycuVVFgTzcrLFRPT1FbQU49XUFOPV1POXVRITBMck9BTj1dT09RWzw9IHI8PSByT09RWzw9IHM8PSBzTycuXlFgTzw9IHJPJy5jUWBPPD0gc09PUVs8PExxPDxMcU8nLmhRYE88PExxTycubVFsTzw8THFPT1FbMUczezFHM3tPP1lRYE83KylsTycudFFgTzw8SlFPJy9QUT9NdE88PEpRT09RTzw8SHk8PEh5T09RITBMZkFOP2ZBTj9mT09RT0FOP19BTj9fTyRBbFEhME14T0FOP19PT1FPQU4/T0FOP09PJVtRbE9BTj9fT09RTzw8TXk8PE15T09RW0cyN1ZHMjdWTyEmelFNaE9HMjdWTyMoWlFgT0cyN1ZPJy9aUSFmT0cyN1ZPNFVRIWZPRzI3Vk8nL2JRYE9HMjdWTycvalE/TXRPPDxKZk8nL3dRP012TzFHMmBPJzFtUT9Ndk8sNT9hTyczcFE/TXZPLDU/Y08nNXNRP012TzFHMnNPJzd2UT9Ndk8xRzJ1Tyc5eVE/TXRPPDxLWE8nOldRP010Tzw8SXtPT1FPMUcxdzFHMXdPISxUUU1oT0FOQWlPT1FPNysqYzcrKmNPJzplUWBPNysqY08nOnBRYE88PSBoTyc6eFEhZE83KyplT09RITBMYjw8S3E8PEtxTyQrWVFgTzw8S3FPQ3dRYE88PEtxTyc7U1FgTzw8S3FPISZ6UU1oTzw8S3FPT1EhMExiPDxLbzw8S29PIUNVUXBPPDxLb08nO19RIWRPPDxLcU9PUSEwTGI8PEtwPDxLcE8nO2lRYE88PEtxTyEmelFNaE88PEtxTyQrWVFgTzw8S3BPJztuUU1qT0FORGNPJzt4USEwTXZPPDxLdE9PUU83KypyNysqck85a1FgTzcrKnJPJzxZUWBPPD0gcU9PUVtHMjdyRzI3ck85dVEhMExyT0cyN3JPQHpRYE9HMjdyTyEpW1FsTzFHNVNPJzxiUWBPNyssU08nPGpRYE8xRzJrTyY9VVFgT0FOQlFPT1FbQU5CUUFOQlFPISZ6UU1oT0FOQlFPJzxvUWBPQU5CUU9PUVtBTkJTQU5CU085dVEhMExyT0FOQlNPJCVkUWBPQU5CU09PUU8nI0hfJyNIX09PUU83KypxNysqcU9PUVtHMjJ3RzIyd09PUVtBTkVeQU5FXk9PUVtBTkVfQU5FX09PUVtBTkJdQU5CXU8nPHdRYE9BTkJdT09RWzw8TVc8PE1XTyEpW1FsT0FOP2xPT1FPRzI0eUcyNHlPJEFsUSEwTXhPRzI0eU8jKFpRYE9MRCxxT09RW0xELHFMRCxxTyEmelFNaE9MRCxxTyc8fFEhZk9MRCxxTyc9VFE/TXZPNysnek8nPnlRP012Tyw1P2FPJ0B8UT9Ndk8sNT9jTydDUFE/TXZPNysnfE8nRHVRTWpPRzI3VE9PUU88PE19PDxNfU9PUSEwTGJBTkFdQU5BXU8kK1lRYE9BTkFdT0N3UWBPQU5BXU8nRVZRIWRPQU5BXU9PUSEwTGJBTkFaQU5BWk8nRV5RYE9BTkFdTyEmelFNaE9BTkFdTydFaVEhZE9BTkFdT09RITBMYkFOQVtBTkFbT09RTzw8Tl48PE5eT09RW0xELV5MRC1eTzl1USEwTHJPTEQtXk8nRXNRP010TzcrKm5PT1FPJyNHZicjR2ZPT1FbRzI3bEcyN2xPJj1VUWBPRzI3bE8hJnpRTWhPRzI3bE9PUVtHMjduRzI3bk85dVEhMExyT0cyN25PT1FbRzI3d0cyN3dPJ0V9UT9NdE9HMjVXT09RT0xEKmVMRCplT09RWyEkKCFdISQoIV1PIyhaUWBPISQoIV1PISZ6UU1oTyEkKCFdTydGWFEhME16T0cyN1RPT1EhMExiRzI2d0cyNndPJCtZUWBPRzI2d08nSGpRYE9HMjZ3T0N3UWBPRzI2d08nSHVRIWRPRzI2d08hJnpRTWhPRzI2d09PUVshJCgheCEkKCF4T09RW0xELVdMRC1XTyY9VVFgT0xELVdPT1FbTEQtWUxELVlPT1FbISk5RXchKTlFd08jKFpRYE8hKTlFd09PUSEwTGJMRCxjTEQsY08kK1lRYE9MRCxjT0N3UWBPTEQsY08nSHxRYE9MRCxjTydJWFEhZE9MRCxjT09RWyEkKCFyISQoIXJPT1FbIS5LO2MhLks7Y08nSWBRP012T0cyN1RPT1EhMExiISQoIH0hJCggfU8kK1lRYE8hJCggfU9Dd1FgTyEkKCB9TydLVVFgTyEkKCB9T09RITBMYiEpOUVpISk5RWlPJCtZUWBPISk5RWlPQ3dRYE8hKTlFaU9PUSEwTGIhLks7VCEuSztUTyQrWVFgTyEuSztUT09RITBMYiE0LzBvITQvMG9PISlbUWxPJyNEek8xUFFgTycjRVhPJ0thUSFmTycjSnJPJ0toUSFMXk8nI0R2TydLb1FsTycjRU9PJ0t2USFmTycjQ2lPJ05eUSFmTycjQ2lPISlbUWxPJyNFUU8nTm5RbE8sNTtaTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPJyNJcE8oIXFRYE8sNTxpTyEpW1FsTyw1O2VPKCF5UU1oTyw1O2VPKCRkUU1oTyw1O2VPISlbUWxPLDU7d08hJnpRTWhPJyNHbU8oIXlRTWhPJyNHbU8hJnpRTWhPJyNHb08oIXlRTWhPJyNHb08xU1FgTycjRFpPMVNRYE8nI0RaTyEmelFNaE8nI0dQTygheVFNaE8nI0dQTyEmelFNaE8nI0dSTygheVFNaE8nI0dSTyEmelFNaE8nI0dhTygheVFNaE8nI0dhTyEpW1FsTyw1OmpPKCRrUXBPJyNEX08oJHVRcE8nI0p2TyEpW1FsTyw1QG9PJ05uUWxPMUcwdU8oJVBRP010TycjQ2lPISlbUWxPMUcyUE8hJnpRTWhPJyNJdU8oIXlRTWhPJyNJdU8hJnpRTWhPJyNJd08oIXlRTWhPJyNJd08oJVpRIWRPJyNDck8hJnpRTWhPLDU8dE8oIXlRTWhPLDU8dE8nTm5RbE8xRzJSTyEpW1FsTzcrJnpPISZ6UU1oTzFHMmBPKCF5UU1oTzFHMmBPISZ6UU1oTycjSXVPKCF5UU1oTycjSXVPISZ6UU1oTycjSXdPKCF5UU1oTycjSXdPISZ6UU1oTzFHMmJPKCF5UU1oTzFHMmJPJ05uUWxPNysnbU8nTm5RbE83KyZhTyEmelFNaE9BTkFpTygheVFNaE9BTkFpTyglblFgTycjRW9PKCVzUWBPJyNFb08oJXtRYE8nI0ZdTygmUVFgTycjRXlPKCZWUWBPJyNLVE8oJmJRYE8nI0tSTygmbVFgTyw1O1pPKCZyUU1qTyw1PGVPKCZ5UWBPJyNHWU8oJ09RYE8nI0dZTygnVFFgTyw1PGVPKCddUWBPLDU8Z08oJ2VRYE8sNTtaTygnbVE/TXRPMUcxYE8oJ3RRYE8sNTx0TygneVFgTyw1PHRPKChPUWBPLDU8dk8oKFRRYE8sNTx2TygoWVFgTzFHMlJPKChfUWBPMUcwdU8oKGRRTWpPPDxLfU8oKGtRTWpPPDxLfU8oKHJRTWhPJyNGfE85YFFgTycjRntPQXVRYE8nI0VuTyEpW1FsTyw1O3RPITNvUWBPJyNHWU8hM29RYE8nI0dZTyEzb1FgTycjR1tPITNvUWBPJyNHW08hLFRRTWhPNysoY08hLFRRTWhPNysoY08lLnpRIWRPMUcyd08lLnpRIWRPMUcyd08hJnpRTWhPLDU9XU8hJnpRTWhPLDU9XVwiLFxuICBzdGF0ZURhdGE6IFwiKCl4fk8nfE9TJ31PU1RPUyhPUlF+T1BZT1FZT1NmT1khVk9hcU9kek9leU9sIVBPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfWE8haXVPIWxaTyFvWU8hcFlPIXFZTyFzdk8hdXdPIXh4TyF8XU8kV3xPJG5pTyVofU8laiFRTyVsIU9PJW0hT08lbiFPTyVxIVJPJXMhU08ldiFUTyV3IVRPJXkhVU8mVyFXTyZeIVhPJmAhWU8mYiFaTyZkIVtPJmchXU8mbSFeTyZzIV9PJnUhYE8mdyFhTyZ5IWJPJnshY08oVFNPKFZUTyhZVU8oYVZPKG9bT35PV3RPflBgT1BZT1FZT1NmT2Qhak9lIWlPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfIWVPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXUhZ08heCFoTyRXIWtPJG5pTyhUIWRPKFZUTyhZVU8oYVZPKG9bT35PYSF3T3Mhbk8hUyFvTyFiIXlPIWMhdk8hZCF2TyF8PFZPI1QhcE8jVSFwTyNWIXhPI1chcE8jWCFwTyNbIXpPI10hek8oVSFsTyhWVE8oWVVPKGUhbU8obyFzT35PKE8he09+T1BdWFJdWFtdWGFdWGpdWHJdWCFRXVghU11YIV1dWCFsXVghcF1YI1JdWCNTXVgjYF1YI2tmWCNuXVgjb11YI3BdWCNxXVgjcl1YI3NdWCN0XVgjdV1YI3ZdWCN4XVgjel1YI3tdWCRRXVgnel1YKGFdWChyXVgoeV1YKHpdWH5PIWclUlh+UChxT18hfU8oViNQTyhXIX1PKFgjUE9+T18jUU8oWCNQTyhZI1BPKFojUU9+T3gjU08hVSNUTyhiI1RPKGMjVk9+T1BZT1FZT1NmT2Qhak9lIWlPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfIWVPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXUhZ08heCFoTyRXIWtPJG5pTyhUPFpPKFZUTyhZVU8oYVZPKG9bT35PIVsjWk8hXSNXTyFZKGhQIVkodlB+UCt9TyFeI2NPflBgT1BZT1FZT1NmT2Qhak9lIWlPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfIWVPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXUhZ08heCFoTyRXIWtPJG5pTyhWVE8oWVVPKGFWTyhvW09+T3AjbU8hWyNpTyF8XU8jaSNsTyNqI2lPKFQ8W08hayhzUH5QLmlPIWwjb08oVCNuT35PIXgjc08hfF1PJWgjdE9+TyNrI3VPfk8hZyN2TyNrI3VPfk9QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hXSRfTyFsI3hPIXAkW08jUiRSTyNuJE9PI28kUE8jcCRQTyNxJFBPI3IkUU8jcyRSTyN0JFJPI3UkYk8jdiRTTyN4JFVPI3okV08jeyRYTyhhVk8ociRZTyh5I3xPKHojfU9+T2EoZlgneihmWCd3KGZYIWsoZlghWShmWCFfKGZYJWkoZlghZyhmWH5QMXFPI1MkZE8jYCRlTyRRJGVPUChnWFIoZ1hbKGdYaihnWHIoZ1ghUShnWCFTKGdYIV0oZ1ghbChnWCFwKGdYI1IoZ1gjbihnWCNvKGdYI3AoZ1gjcShnWCNyKGdYI3MoZ1gjdChnWCN1KGdYI3YoZ1gjeChnWCN6KGdYI3soZ1goYShnWChyKGdYKHkoZ1goeihnWCFfKGdYJWkoZ1h+T2EoZ1gneihnWCd3KGdYIVkoZ1ghayhnWHYoZ1ghZyhnWH5QNFVPI2AkZU9+TyRdJGhPJF8kZ08kZiRtT35PU2ZPIV8kbk8kaSRvTyRrJHFPfk9oJVZPaiVkT2slZE9wJVdPciVYT3MkdE90JHRPeiVZT3wlWk8hTyVdTyFTJHtPIV8kfE8haSViTyFsJHhPI2olY08kVyVgTyR0JV5PJHYlX08keSVhTyhUJHNPKFZUTyhZVU8oYSR1Tyh5JH1PKHolUE9nKF5Qfk9sJVtPflA3ZU8hbCVlT35PIVMlaE8hXyVpTyhUJWdPfk8hZyVtT35PYSVuTyd6JW5Pfk8hUSVyT35QJVtPKFUhbE9+UCVbTyVuJXZPflAlW09oJVZPIWwlZU8oVCVnTyhVIWxPfk9lJX1PIWwlZU8oVCVnT35PaiRST35PIV8mUE8oVCVnTyhVIWxPKFZUTyhZVU9gKVdQfk8hUSZTTyFsJlJPJWomVk8mVCZXT35QO1NPIXgjc09+TyVzJllPIVMpU1ghXylTWChUKVNYfk8oVCZaT35PbCFQTyF1JmBPJWohUU8lbCFPTyVtIU9PJW4hT08lcSFSTyVzIVNPJXYhVE8ldyFUT35PZCZlT2UmZE8heCZiTyVoJmNPJXsmYU9+UDxiT2QmaE9leU9sIVBPIV8mZ08hdSZgTyF4eE8hfF1PJWh9TyVsIU9PJW0hT08lbiFPTyVxIVJPJXMhU08ldiFUTyV3IVRPJXkhVU9+T2Ima08jYCZuTyVqJmlPKFUhbE9+UD1nTyFsJm9PIXUmc09+TyFsI29Pfk8hX1hPfk9hJW5PJ3gme08neiVuT35PYSVuTyd4J09PJ3olbk9+T2Elbk8neCdRTyd6JW5Pfk8nd11YIVldWHZdWCFrXVgmW11YIV9dWCVpXVghZ11YflAocU8hYidfTyFjJ1dPIWQnV08oVSFsTyhWVE8oWVVPfk9zJ1VPIVMnVE8hWydYTyhlJ1NPIV4oaVAhXih4UH5QQG5PbidiTyFfJ2BPKFQlZ09+T2UnZ08hbCVlTyhUJWdPfk8hUSZTTyFsJlJPfk9zIW5PIVMhb08hfDxWTyNUIXBPI1UhcE8jVyFwTyNYIXBPKFUhbE8oVlRPKFlVTyhlIW1PKG8hc09+TyFiJ21PIWMnbE8hZCdsTyNWIXBPI1snbk8jXSduT35QQllPYSVuT2glVk8hZyN2TyFsJWVPJ3olbk8ocidwT35PIXAndE8jYCdyT35QQ2hPcyFuTyFTIW9PKFZUTyhZVU8oZSFtTyhvIXNPfk8hX1hPcyhtWCFTKG1YIWIobVghYyhtWCFkKG1YIXwobVgjVChtWCNVKG1YI1YobVgjVyhtWCNYKG1YI1sobVgjXShtWChVKG1YKFYobVgoWShtWChlKG1YKG8obVh+TyFjJ2xPIWQnbE8oVSFsT35QRFdPKFAneE8oUSd4TyhSJ3pPfk9fIX1PKFYnfE8oVyF9TyhYJ3xPfk9fI1FPKFgnfE8oWSd8TyhaI1FPfk92KE9PflAlW094I1NPIVUjVE8oYiNUTyhjKFJPfk8hWyhUTyFZJ1dYIVknXlghXSdXWCFdJ15YflArfU8hXShWTyFZKGhYfk9QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hXShWTyFsI3hPIXAkW08jUiRSTyNuJE9PI28kUE8jcCRQTyNxJFBPI3IkUU8jcyRSTyN0JFJPI3UkYk8jdiRTTyN4JFVPI3okV08jeyRYTyhhVk8ociRZTyh5I3xPKHojfU9+TyFZKGhYflBIUk8hWShbT35PIVkodVghXSh1WCFnKHVYIWsodVgocih1WH5PI2AodVgjayNkWCFeKHVYflBKVU8jYChdTyFZKHdYIV0od1h+TyFdKF5PIVkodlh+TyFZKGFPfk8jYCRlT35QSlVPIV4oYk9+UGBPUiN6TyFRI3lPIVMje08hbCN4TyhhVk9QIW5hWyFuYWohbmFyIW5hIV0hbmEhcCFuYSNSIW5hI24hbmEjbyFuYSNwIW5hI3EhbmEjciFuYSNzIW5hI3QhbmEjdSFuYSN2IW5hI3ghbmEjeiFuYSN7IW5hKHIhbmEoeSFuYSh6IW5hfk9hIW5hJ3ohbmEndyFuYSFZIW5hIWshbmF2IW5hIV8hbmElaSFuYSFnIW5hflBLbE8hayhjT35PIWcjdk8jYChkTyhyJ3BPIV0odFhhKHRYJ3oodFh+TyFrKHRYflBOWE8hUyVoTyFfJWlPIXxdTyNpKGlPI2ooaE8oVCVnT35PIV0oak8hayhzWH5PIWsobE9+TyFTJWhPIV8laU8jaihoTyhUJWdPfk9QKGdYUihnWFsoZ1hqKGdYcihnWCFRKGdYIVMoZ1ghXShnWCFsKGdYIXAoZ1gjUihnWCNuKGdYI28oZ1gjcChnWCNxKGdYI3IoZ1gjcyhnWCN0KGdYI3UoZ1gjdihnWCN4KGdYI3ooZ1gjeyhnWChhKGdYKHIoZ1goeShnWCh6KGdYfk8hZyN2TyFrKGdYflAhIHVPUihuTyFRKG1PIWwjeE8jUyRkTyF8IXthIVMhe2F+TyF4IXthJWghe2EhXyF7YSNpIXthI2ohe2EoVCF7YX5QISN2TyF4KHJPfk9QWU9RWU9TZk9kIWpPZSFpT3BrT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hX1hPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXUhZ08heCFoTyRXIWtPJG5pTyhUIWRPKFZUTyhZVU8oYVZPKG9bT35PaCVWT3AlV09yJVhPcyR0T3QkdE96JVlPfCVaTyFPPHNPIVMke08hXyR8TyFpPlZPIWwkeE8jajx5TyRXJWBPJHQ8dU8kdjx3TyR5JWFPKFQodk8oVlRPKFlVTyhhJHVPKHkkfU8oeiVQT35PI2soeE9+TyFbKHpPIWsoa1B+UCVbTyhlKHxPKG9bT35PIVMpT08hbCN4TyhlKHxPKG9bT35PUDxVT1E8VU9TZk9kPlJPZSFpT3BrT3I8VU9za090a096a098PFVPIU88VU8hU1dPIVdrTyFYa08hXyFlTyFpPFhPIWxaTyFvPFVPIXA8VU8hcTxVTyFzPFlPIXU8XU8heCFoTyRXIWtPJG4+UE8oVCldTyhWVE8oWVVPKGFWTyhvW09+TyFdJF9PYSRxYSd6JHFhJ3ckcWEhayRxYSFZJHFhIV8kcWElaSRxYSFnJHFhfk9sKWRPflAhJnpPaCVWT3AlV09yJVhPcyR0T3QkdE96JVlPfCVaTyFPJV1PIVMke08hXyR8TyFpJWJPIWwkeE8jaiVjTyRXJWBPJHQlXk8kdiVfTyR5JWFPKFQodk8oVlRPKFlVTyhhJHVPKHkkfU8oeiVQT35PZyhwUH5QISxUTyFRKWlPIWcpaE8hXyReWCRaJF5YJF0kXlgkXyReWCRmJF5Yfk8hZyloTyFfKHtYJFooe1gkXSh7WCRfKHtYJGYoe1h+TyFRKWlPflAhLl5PIVEpaU8hXyh7WCRaKHtYJF0oe1gkXyh7WCRmKHtYfk8hXylrTyRaKW9PJF0pak8kXylqTyRmKXBPfk8hWylzT35QISlbTyRdJGhPJF8kZ08kZil3T35PbiR6WCFRJHpYI1MkelgneSR6WCh5JHpYKHokelh+T2dtWGckelhubVghXW1YI2BtWH5QITBTT3gpeU8oYil6TyhjKXxPfk9uKlZPIVEqT08neSpQTyh5JH1PKHolUE9+T2cpfU9+UCExV09nKldPfk9oJVZPciVYT3MkdE90JHRPeiVZT3wlWk8hTzxzTyFTKllPIV8qWk8haT5WTyFsJHhPI2o8eU8kVyVgTyR0PHVPJHY8d08keSVhTyhWVE8oWVVPKGEkdU8oeSR9Tyh6JVBPfk9wKmBPIVsqXk8oVCpYTyFrKU9QflAhMXVPI2sqYU9+TyFsKmJPfk9oJVZPcCVXT3IlWE9zJHRPdCR0T3olWU98JVpPIU88c08hUyR7TyFfJHxPIWk+Vk8hbCR4TyNqPHlPJFclYE8kdDx1TyR2PHdPJHklYU8oVCpkTyhWVE8oWVVPKGEkdU8oeSR9Tyh6JVBPfk8hWypnTyFZKVBQflAhM3RPcipzT3Mhbk8hUyppTyFiKnFPIWMqa08hZCprTyFsKmJPI1sqck8lYCptTyhVIWxPKFZUTyhZVU8oZSFtT35PIV4qcE9+UCE1aU8jUyRkT24oYFghUShgWCd5KGBYKHkoYFgoeihgWCFdKGBYI2AoYFh+T2coYFgkTyhgWH5QITZrT24qeE8jYCp3T2coX1ghXShfWH5PIV0qeU9nKF5Yfk9qJWRPayVkT2wlZE8oVCZaT2coXlB+T3MqfE9+T2cpfU8oVCZaT35PIWwrU09+TyhUKHZPfk9wK1dPIVMlaE8hWyNpTyFfJWlPIXxdTyNpI2xPI2ojaU8oVCVnTyFrKHNQfk8hZyN2TyNrK1hPfk8hUyVoTyFbK1pPIV0oXk8hXyVpTyhUJWdPIVkodlB+T3MnW08hUytdTyFbK1tPKFZUTyhZVU8oZSh8T35PIV4oeFB+UCE5fE8hXSteT2EpVFgneilUWH5PUCRbT1Ijek9bJGNPaiRST3IkYU8hUSN5TyFTI3tPIWwjeE8hcCRbTyNSJFJPI24kT08jbyRQTyNwJFBPI3EkUE8jciRRTyNzJFJPI3QkUk8jdSRiTyN2JFNPI3gkVU8jeiRXTyN7JFhPKGFWTyhyJFlPKHkjfE8oeiN9T35PYSFqYSFdIWphJ3ohamEndyFqYSFZIWphIWshamF2IWphIV8hamElaSFqYSFnIWphflAhOnRPUiN6TyFRI3lPIVMje08hbCN4TyhhVk9QIXJhWyFyYWohcmFyIXJhIV0hcmEhcCFyYSNSIXJhI24hcmEjbyFyYSNwIXJhI3EhcmEjciFyYSNzIXJhI3QhcmEjdSFyYSN2IXJhI3ghcmEjeiFyYSN7IXJhKHIhcmEoeSFyYSh6IXJhfk9hIXJhJ3ohcmEndyFyYSFZIXJhIWshcmF2IXJhIV8hcmElaSFyYSFnIXJhflAhPVtPUiN6TyFRI3lPIVMje08hbCN4TyhhVk9QIXRhWyF0YWohdGFyIXRhIV0hdGEhcCF0YSNSIXRhI24hdGEjbyF0YSNwIXRhI3EhdGEjciF0YSNzIXRhI3QhdGEjdSF0YSN2IXRhI3ghdGEjeiF0YSN7IXRhKHIhdGEoeSF0YSh6IXRhfk9hIXRhJ3ohdGEndyF0YSFZIXRhIWshdGF2IXRhIV8hdGElaSF0YSFnIXRhflAhP3JPaCVWT24rZ08hXydgTyVpK2ZPfk8hZytpT2EoXVghXyhdWCd6KF1YIV0oXVh+T2Elbk8hX1hPJ3olbk9+T2glVk8hbCVlT35PaCVWTyFsJWVPKFQlZ09+TyFnI3ZPI2soeE9+T2IrdE8lait1TyhUK3FPKFZUTyhZVU8hXilYUH5PIV0rdk9gKVdYfk9bK3pPfk9gK3tPfk8hXyZQTyhUJWdPKFUhbE9gKVdQfk8laixPT35QO1NPaCVWTyNgLFNPfk9oJVZPbixWTyFfJHxPfk8hXyxYT35PIVEsWk8hX1hPfk8lbiV2T35PIXgsYE9+T2UsZU9+T2IsZk8oVCNuTyhWVE8oWVVPIV4pVlB+T2UlfU9+TyVqIVFPKFQmWk9+UD1nT1ssa09gLGpPfk9QWU9RWU9TZk9kek9leU9wa09yWU9za090a096a098WU8hT1lPIVNXTyFXa08hWGtPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXh4TyF8XU8kbmlPJWh9TyhWVE8oWVVPKGFWTyhvW09+TyFfIWVPIXUhZ08kVyFrTyhUIWRPflAhRnlPYCxqT2Elbk8neiVuT35PUFlPUVlPU2ZPZCFqT2UhaU9wa09yWU9za090a096a098WU8hT1lPIVNXTyFXa08hWGtPIV8hZU8haXVPIWxaTyFvWU8hcFlPIXFZTyFzdk8heCFoTyRXIWtPJG5pTyhUIWRPKFZUTyhZVU8oYVZPKG9bT35PYSxwT2whT08hdXdPJWwhT08lbSFPTyVuIU9PflAhSWNPIWwmb09+TyZeLHZPfk8hXyx4T35PJm8sek8mcSx7T1AmbGFRJmxhUyZsYVkmbGFhJmxhZCZsYWUmbGFsJmxhcCZsYXImbGFzJmxhdCZsYXombGF8JmxhIU8mbGEhUyZsYSFXJmxhIVgmbGEhXyZsYSFpJmxhIWwmbGEhbyZsYSFwJmxhIXEmbGEhcyZsYSF1JmxhIXgmbGEhfCZsYSRXJmxhJG4mbGElaCZsYSVqJmxhJWwmbGElbSZsYSVuJmxhJXEmbGElcyZsYSV2JmxhJXcmbGEleSZsYSZXJmxhJl4mbGEmYCZsYSZiJmxhJmQmbGEmZyZsYSZtJmxhJnMmbGEmdSZsYSZ3JmxhJnkmbGEmeyZsYSd3JmxhKFQmbGEoViZsYShZJmxhKGEmbGEobyZsYSFeJmxhJmUmbGFiJmxhJmombGF+TyhULVFPfk9oIWVYIV0hUlghXiFSWCFnIVJYIWchZVghbCFlWCNgIVJYfk8hXSFlWCFeIWVYflAjIWlPIWctVk8jYC1VT2goalghXSNoWCFeI2hYIWcoalghbChqWH5PIV0oalghXihqWH5QIyNbT2glVk8hZy1YTyFsJWVPIV0hYVghXiFhWH5PcyFuTyFTIW9PKFZUTyhZVU8oZSFtT35PUDxVT1E8VU9TZk9kPlJPZSFpT3BrT3I8VU9za090a096a098PFVPIU88VU8hU1dPIVdrTyFYa08hXyFlTyFpPFhPIWxaTyFvPFVPIXA8VU8hcTxVTyFzPFlPIXU8XU8heCFoTyRXIWtPJG4+UE8oVlRPKFlVTyhhVk8ob1tPfk8oVD1RT35QIyRxTyFdLV1PIV4oaVh+TyFeLV9Pfk8hZy1WTyNgLVVPIV0jaFghXiNoWH5PIV0tYE8hXih4WH5PIV4tYk9+TyFjLWNPIWQtY08oVSFsT35QIyRgTyFeLWZPflAnX09uLWlPIV8nYE9+TyFZLW5Pfk9zIXthIWIhe2EhYyF7YSFkIXthI1Qhe2EjVSF7YSNWIXthI1che2EjWCF7YSNbIXthI10he2EoVSF7YShWIXthKFkhe2EoZSF7YShvIXthflAhI3ZPIXAtc08jYC1xT35QQ2hPIWMtdU8hZC11TyhVIWxPflBEV09hJW5PI2AtcU8neiVuT35PYSVuTyFnI3ZPI2AtcU8neiVuT35PYSVuTyFnI3ZPIXAtc08jYC1xTyd6JW5PKHIncE9+TyhQJ3hPKFEneE8oUi16T35Pdi17T35PIVknV2EhXSdXYX5QITp0TyFbLlBPIVknV1ghXSdXWH5QJVtPIV0oVk8hWShoYX5PIVkoaGF+UEhSTyFdKF5PIVkodmF+TyFTJWhPIVsuVE8hXyVpTyhUJWdPIVknXlghXSdeWH5PI2AuVk8hXSh0YSFrKHRhYSh0YSd6KHRhfk8hZyN2T35QIyx3TyFdKGpPIWsoc2F+TyFTJWhPIV8laU8jai5aTyhUJWdPfk9wLmBPIVMlaE8hWy5dTyFfJWlPIXxdTyNpLl9PI2ouXU8oVCVnTyFdJ2FYIWsnYVh+T1IuZE8hbCN4T35PaCVWT24uZ08hXydgTyVpLmZPfk9hI2NpIV0jY2kneiNjaSd3I2NpIVkjY2khayNjaXYjY2khXyNjaSVpI2NpIWcjY2l+UCE6dE9uPl1PIVEqT08neSpQTyh5JH1PKHolUE9+TyNrI19hYSNfYSNgI19hJ3ojX2EhXSNfYSFrI19hIV8jX2EhWSNfYX5QIy9zTyNrKGBYUChgWFIoYFhbKGBYYShgWGooYFhyKGBYIVMoYFghbChgWCFwKGBYI1IoYFgjbihgWCNvKGBYI3AoYFgjcShgWCNyKGBYI3MoYFgjdChgWCN1KGBYI3YoYFgjeChgWCN6KGBYI3soYFgneihgWChhKGBYKHIoYFghayhgWCFZKGBYJ3coYFh2KGBYIV8oYFglaShgWCFnKGBYflAhNmtPIV0udE8hayhrWH5QITp0TyFrLndPfk8hWS55T35PUCRbT1Ijek8hUSN5TyFTI3tPIWwjeE8hcCRbTyhhVk9bI21pYSNtaWojbWlyI21pIV0jbWkjUiNtaSNvI21pI3AjbWkjcSNtaSNyI21pI3MjbWkjdCNtaSN1I21pI3YjbWkjeCNtaSN6I21pI3sjbWkneiNtaShyI21pKHkjbWkoeiNtaSd3I21pIVkjbWkhayNtaXYjbWkhXyNtaSVpI21pIWcjbWl+TyNuI21pflAjM2NPI24kT09+UCMzY09QJFtPUiN6T3IkYU8hUSN5TyFTI3tPIWwjeE8hcCRbTyNuJE9PI28kUE8jcCRQTyNxJFBPKGFWT1sjbWlhI21paiNtaSFdI21pI1IjbWkjcyNtaSN0I21pI3UjbWkjdiNtaSN4I21pI3ojbWkjeyNtaSd6I21pKHIjbWkoeSNtaSh6I21pJ3cjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PI3IjbWl+UCM2UU8jciRRT35QIzZRT1AkW09SI3pPWyRjT2okUk9yJGFPIVEjeU8hUyN7TyFsI3hPIXAkW08jUiRSTyNuJE9PI28kUE8jcCRQTyNxJFBPI3IkUU8jcyRSTyN0JFJPI3UkYk8oYVZPYSNtaSFdI21pI3gjbWkjeiNtaSN7I21pJ3ojbWkociNtaSh5I21pKHojbWkndyNtaSFZI21pIWsjbWl2I21pIV8jbWklaSNtaSFnI21pfk8jdiNtaX5QIzhvT1AkW09SI3pPWyRjT2okUk9yJGFPIVEjeU8hUyN7TyFsI3hPIXAkW08jUiRSTyNuJE9PI28kUE8jcCRQTyNxJFBPI3IkUU8jcyRSTyN0JFJPI3UkYk8jdiRTTyhhVk8oeiN9T2EjbWkhXSNtaSN6I21pI3sjbWkneiNtaShyI21pKHkjbWkndyNtaSFZI21pIWsjbWl2I21pIV8jbWklaSNtaSFnI21pfk8jeCRVT35QIztWTyN4I21pflAjO1ZPI3YkU09+UCM4b09QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPI3YkU08jeCRVTyhhVk8oeSN8Tyh6I31PYSNtaSFdI21pI3sjbWkneiNtaShyI21pJ3cjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PI3ojbWl+UCM9e08jeiRXT35QIz17T1BdWFJdWFtdWGpdWHJdWCFRXVghU11YIWxdWCFwXVgjUl1YI1NdWCNgXVgja2ZYI25dWCNvXVgjcF1YI3FdWCNyXVgjc11YI3RdWCN1XVgjdl1YI3hdWCN6XVgje11YJFFdWChhXVgocl1YKHldWCh6XVghXV1YIV5dWH5PJE9dWH5QI0BqT1AkW09SI3pPWzxtT2o8Yk9yPGtPIVEjeU8hUyN7TyFsI3hPIXAkW08jUjxiTyNuPF9PI288YE8jcDxgTyNxPGBPI3I8YU8jczxiTyN0PGJPI3U8bE8jdjxjTyN4PGVPI3o8Z08jezxoTyhhVk8ociRZTyh5I3xPKHojfU9+TyRPLntPflAjQndPI1MkZE8jYDxuTyRRPG5PJE8oZ1ghXihnWH5QISB1T2EnZGEhXSdkYSd6J2RhJ3cnZGEhaydkYSFZJ2RhdidkYSFfJ2RhJWknZGEhZydkYX5QITp0T1sjbWlhI21paiNtaXIjbWkhXSNtaSNSI21pI3IjbWkjcyNtaSN0I21pI3UjbWkjdiNtaSN4I21pI3ojbWkjeyNtaSd6I21pKHIjbWkndyNtaSFZI21pIWsjbWl2I21pIV8jbWklaSNtaSFnI21pfk9QJFtPUiN6TyFRI3lPIVMje08hbCN4TyFwJFtPI24kT08jbyRQTyNwJFBPI3EkUE8oYVZPKHkjbWkoeiNtaX5QI0V5T24+XU8hUSpPTyd5KlBPKHkkfU8oeiVQT1AjbWlSI21pIVMjbWkhbCNtaSFwI21pI24jbWkjbyNtaSNwI21pI3EjbWkoYSNtaX5QI0V5TyFdL1BPZyhwWH5QITFXT2cvUk9+T2EkUGkhXSRQaSd6JFBpJ3ckUGkhWSRQaSFrJFBpdiRQaSFfJFBpJWkkUGkhZyRQaX5QITp0TyRdL1NPJF8vU09+TyRdL1RPJF8vVE9+TyFnKWhPI2AvVU8hXyRjWCRaJGNYJF0kY1gkXyRjWCRmJGNYfk8hWy9WT35PIV8pa08kWi9YTyRdKWpPJF8pak8kZi9ZT35PIV08aU8hXihmWH5QI0J3TyFeL1pPfk8hZyloTyRmKHtYfk8kZi9dT35Pdi9eT35QISZ6T3gpeU8oYil6TyhjL2FPfk8hUy9kT35PKHkkfU9uJWFhIVElYWEneSVhYSh6JWFhIV0lYWEjYCVhYX5PZyVhYSRPJWFhflAjTHtPKHolUE9uJWNhIVElY2EneSVjYSh5JWNhIV0lY2EjYCVjYX5PZyVjYSRPJWNhflAjTW5PIV1mWCFnZlgha2ZYIWskelgocmZYflAhMFNPcCVXTyFbL21PIV0oXk8oVC9sTyFZKHZQIVkpUFB+UCExdU9yKnNPIWIqcU8hYyprTyFkKmtPIWwqYk8jWypyTyVgKm1PKFUhbE8oVlRPKFlVT35Pczx9TyFTL25PIVsrW08hXipwTyhlPHxPIV4oeFB+UCQgW08hay9vT35QIy9zTyFdL3BPIWcjdk8ocidwTyFrKU9Yfk8hay91T35Pbm9YIVFvWCd5b1goeW9YKHpvWH5PIWcjdk8ha29YflAkI09PcC93TyFTJWhPIVsqXk8hXyVpTyhUJWdPIWspT1B+TyNrL3hPfk8hWSR6WCFdJHpYIWclUlh+UCEwU08hXS95TyFZKVBYflAjL3NPIWcve09+TyFZL31Pfk9wa08oVDBPT35QLmlPaCVWT3IwVE8hZyN2TyFsJWVPKHIncE9+TyFnK2lPfk9hJW5PIV0wWE8neiVuT35PIV4wWk9+UCE1aU8hYzBbTyFkMFtPKFUhbE9+UCMkYE9zIW5PIVMwXU8oVlRPKFlVTyhlIW1Pfk8jWzBfT35PZyVhYSFdJWFhI2AlYWEkTyVhYX5QITFXT2clY2EhXSVjYSNgJWNhJE8lY2F+UCExV09qJWRPayVkT2wlZE8oVCZaT2cnbVghXSdtWH5PIV0qeU9nKF5hfk9nMGhPfk9uMGpPI2AwaU9nKF9hIV0oX2F+T1Iwa08hUTBrTyFTMGxPI1MkZE9ufWEneX1hKHl9YSh6fWEhXX1hI2B9YX5PZ31hJE99YX5QJChjTyFRKk9PJ3kqUE9uJHNhKHkkc2EoeiRzYSFdJHNhI2Akc2F+T2ckc2EkTyRzYX5QJClfTyFRKk9PJ3kqUE9uJHVhKHkkdWEoeiR1YSFdJHVhI2AkdWF+T2ckdWEkTyR1YX5QJCpRTyNrMG9Pfk9nJVRhIV0lVGEjYCVUYSRPJVRhflAhMVdPIWcjdk9+TyNrMHJPfk8hXSteT2EpVGEneilUYX5PUiN6TyFRI3lPIVMje08hbCN4TyhhVk9QIXJpWyFyaWohcmlyIXJpIV0hcmkhcCFyaSNSIXJpI24hcmkjbyFyaSNwIXJpI3EhcmkjciFyaSNzIXJpI3QhcmkjdSFyaSN2IXJpI3ghcmkjeiFyaSN7IXJpKHIhcmkoeSFyaSh6IXJpfk9hIXJpJ3ohcmkndyFyaSFZIXJpIWshcml2IXJpIV8hcmklaSFyaSFnIXJpflAkK29PaCVWT3IlWE9zJHRPdCR0T3olWU98JVpPIU88c08hUyR7TyFfJHxPIWk+Vk8hbCR4TyNqPHlPJFclYE8kdDx1TyR2PHdPJHklYU8oVlRPKFlVTyhhJHVPKHkkfU8oeiVQT35PcDB7TyVdMHxPKFQwek9+UCQuVk8hZytpT2EoXWEhXyhdYSd6KF1hIV0oXWF+TyNrMVNPfk9bXVghXWZYIV5mWH5PIV0xVE8hXilYWH5PIV4xVk9+T1sxV09+T2IxWU8oVCtxTyhWVE8oWVVPfk8hXyZQTyhUJWdPYCd1WCFdJ3VYfk8hXSt2T2ApV2F+TyFrMV1PflAhOnRPWzFgT35PYDFhT35PI2AxZk9+T24xaU8hXyR8T35PKGUofE8hXilVUH5PaCVWT24xck8hXzFvTyVpMXFPfk9bMXxPIV0xek8hXilWWH5PIV4xfU9+T2AyUE9hJW5PJ3olbk9+TyhUI25PKFZUTyhZVU9+TyNTJGRPI2AkZU8kUSRlT1AoZ1hSKGdYWyhnWHIoZ1ghUShnWCFTKGdYIV0oZ1ghbChnWCFwKGdYI1IoZ1gjbihnWCNvKGdYI3AoZ1gjcShnWCNyKGdYI3MoZ1gjdChnWCN1KGdYI3YoZ1gjeChnWCN6KGdYI3soZ1goYShnWChyKGdYKHkoZ1goeihnWH5PajJTTyZbMlRPYShnWH5QJDNwT2oyU08jYCRlTyZbMlRPfk9hMlZPflAlW09hMlhPfk8mZTJbT1AmY2lRJmNpUyZjaVkmY2lhJmNpZCZjaWUmY2lsJmNpcCZjaXImY2lzJmNpdCZjaXomY2l8JmNpIU8mY2khUyZjaSFXJmNpIVgmY2khXyZjaSFpJmNpIWwmY2khbyZjaSFwJmNpIXEmY2khcyZjaSF1JmNpIXgmY2khfCZjaSRXJmNpJG4mY2klaCZjaSVqJmNpJWwmY2klbSZjaSVuJmNpJXEmY2klcyZjaSV2JmNpJXcmY2kleSZjaSZXJmNpJl4mY2kmYCZjaSZiJmNpJmQmY2kmZyZjaSZtJmNpJnMmY2kmdSZjaSZ3JmNpJnkmY2kmeyZjaSd3JmNpKFQmY2koViZjaShZJmNpKGEmY2kobyZjaSFeJmNpYiZjaSZqJmNpfk9iMmJPIV4yYE8majJhT35QYE8hX1hPIWwyZE9+TyZxLHtPUCZsaVEmbGlTJmxpWSZsaWEmbGlkJmxpZSZsaWwmbGlwJmxpciZsaXMmbGl0JmxpeiZsaXwmbGkhTyZsaSFTJmxpIVcmbGkhWCZsaSFfJmxpIWkmbGkhbCZsaSFvJmxpIXAmbGkhcSZsaSFzJmxpIXUmbGkheCZsaSF8JmxpJFcmbGkkbiZsaSVoJmxpJWombGklbCZsaSVtJmxpJW4mbGklcSZsaSVzJmxpJXYmbGkldyZsaSV5JmxpJlcmbGkmXiZsaSZgJmxpJmImbGkmZCZsaSZnJmxpJm0mbGkmcyZsaSZ1JmxpJncmbGkmeSZsaSZ7JmxpJ3cmbGkoVCZsaShWJmxpKFkmbGkoYSZsaShvJmxpIV4mbGkmZSZsaWImbGkmaiZsaX5PIVkyak9+TyFdIWFhIV4hYWF+UCNCd09zIW5PIVMhb08hWzJwTyhlIW1PIV0nWFghXidYWH5QQG5PIV0tXU8hXihpYX5PIV0nX1ghXidfWH5QITl8TyFdLWBPIV4oeGF+TyFeMndPflAnX09hJW5PI2AzUU8neiVuT35PYSVuTyFnI3ZPI2AzUU8neiVuT35PYSVuTyFnI3ZPIXAzVU8jYDNRTyd6JW5PKHIncE9+T2Elbk8neiVuT35QITp0TyFdJF9PdiRxYX5PIVknV2khXSdXaX5QITp0TyFdKFZPIVkoaGl+TyFdKF5PIVkodml+TyFZKHdpIV0od2l+UCE6dE8hXSh0aSFrKHRpYSh0aSd6KHRpflAhOnRPI2AzV08hXSh0aSFrKHRpYSh0aSd6KHRpfk8hXShqTyFrKHNpfk8hUyVoTyFfJWlPIXxdTyNpM11PI2ozW08oVCVnT35PIVMlaE8hXyVpTyNqM1tPKFQlZ09+T24zZE8hXydgTyVpM2NPfk9oJVZPbjNkTyFfJ2BPJWkzY09+TyNrJWFhUCVhYVIlYWFbJWFhYSVhYWolYWFyJWFhIVMlYWEhbCVhYSFwJWFhI1IlYWEjbiVhYSNvJWFhI3AlYWEjcSVhYSNyJWFhI3MlYWEjdCVhYSN1JWFhI3YlYWEjeCVhYSN6JWFhI3slYWEneiVhYShhJWFhKHIlYWEhayVhYSFZJWFhJ3clYWF2JWFhIV8lYWElaSVhYSFnJWFhflAjTHtPI2slY2FQJWNhUiVjYVslY2FhJWNhaiVjYXIlY2EhUyVjYSFsJWNhIXAlY2EjUiVjYSNuJWNhI28lY2EjcCVjYSNxJWNhI3IlY2EjcyVjYSN0JWNhI3UlY2EjdiVjYSN4JWNhI3olY2EjeyVjYSd6JWNhKGElY2EociVjYSFrJWNhIVklY2EndyVjYXYlY2EhXyVjYSVpJWNhIWclY2F+UCNNbk8jayVhYVAlYWFSJWFhWyVhYWElYWFqJWFhciVhYSFTJWFhIV0lYWEhbCVhYSFwJWFhI1IlYWEjbiVhYSNvJWFhI3AlYWEjcSVhYSNyJWFhI3MlYWEjdCVhYSN1JWFhI3YlYWEjeCVhYSN6JWFhI3slYWEneiVhYShhJWFhKHIlYWEhayVhYSFZJWFhJ3clYWEjYCVhYXYlYWEhXyVhYSVpJWFhIWclYWF+UCMvc08jayVjYVAlY2FSJWNhWyVjYWElY2FqJWNhciVjYSFTJWNhIV0lY2EhbCVjYSFwJWNhI1IlY2EjbiVjYSNvJWNhI3AlY2EjcSVjYSNyJWNhI3MlY2EjdCVjYSN1JWNhI3YlY2EjeCVjYSN6JWNhI3slY2EneiVjYShhJWNhKHIlY2EhayVjYSFZJWNhJ3clY2EjYCVjYXYlY2EhXyVjYSVpJWNhIWclY2F+UCMvc08ja31hUH1hW31hYX1han1hcn1hIWx9YSFwfWEjUn1hI259YSNvfWEjcH1hI3F9YSNyfWEjc31hI3R9YSN1fWEjdn1hI3h9YSN6fWEje31hJ3p9YShhfWEocn1hIWt9YSFZfWEnd31hdn1hIV99YSVpfWEhZ31hflAkKGNPI2skc2FQJHNhUiRzYVskc2FhJHNhaiRzYXIkc2EhUyRzYSFsJHNhIXAkc2EjUiRzYSNuJHNhI28kc2EjcCRzYSNxJHNhI3Ikc2EjcyRzYSN0JHNhI3Ukc2EjdiRzYSN4JHNhI3okc2EjeyRzYSd6JHNhKGEkc2EociRzYSFrJHNhIVkkc2EndyRzYXYkc2EhXyRzYSVpJHNhIWckc2F+UCQpX08jayR1YVAkdWFSJHVhWyR1YWEkdWFqJHVhciR1YSFTJHVhIWwkdWEhcCR1YSNSJHVhI24kdWEjbyR1YSNwJHVhI3EkdWEjciR1YSNzJHVhI3QkdWEjdSR1YSN2JHVhI3gkdWEjeiR1YSN7JHVhJ3okdWEoYSR1YShyJHVhIWskdWEhWSR1YSd3JHVhdiR1YSFfJHVhJWkkdWEhZyR1YX5QJCpRTyNrJVRhUCVUYVIlVGFbJVRhYSVUYWolVGFyJVRhIVMlVGEhXSVUYSFsJVRhIXAlVGEjUiVUYSNuJVRhI28lVGEjcCVUYSNxJVRhI3IlVGEjcyVUYSN0JVRhI3UlVGEjdiVUYSN4JVRhI3olVGEjeyVUYSd6JVRhKGElVGEociVUYSFrJVRhIVklVGEndyVUYSNgJVRhdiVUYSFfJVRhJWklVGEhZyVUYX5QIy9zT2EjY3EhXSNjcSd6I2NxJ3cjY3EhWSNjcSFrI2NxdiNjcSFfI2NxJWkjY3EhZyNjcX5QITp0TyFbM2xPIV0nWVghaydZWH5QJVtPIV0udE8hayhrYX5PIV0udE8hayhrYX5QITp0TyFZM29Pfk8kTyFuYSFeIW5hflBLbE8kTyFqYSFdIWphIV4hamF+UCNCd08kTyFyYSFeIXJhflAhPVtPJE8hdGEhXiF0YX5QIT9yT2cnXVghXSddWH5QISxUTyFdL1BPZyhwYX5PU2ZPIV80VE8kZDRVT35PIV40WU9+T3Y0Wk9+UCMvc09hJG1xIV0kbXEneiRtcSd3JG1xIVkkbXEhayRtcXYkbXEhXyRtcSVpJG1xIWckbXF+UCE6dE8hWTRdT35QISZ6TyFTNF5Pfk8hUSpPTyd5KlBPKHolUE9uJ2lhKHknaWEhXSdpYSNgJ2lhfk9nJ2lhJE8naWF+UCUtZk8hUSpPTyd5KlBPbidrYSh5J2thKHona2EhXSdrYSNgJ2thfk9nJ2thJE8na2F+UCUuWE8ociRZT35QIy9zTyFZZlghWSR6WCFdZlghXSR6WCFnJVJYI2BmWH5QITBTT3AlV08oVD1XT35QITF1T3A0Yk8hUyVoTyFbNGFPIV8laU8oVCVnTyFdJ2VYIWsnZVh+TyFdL3BPIWspT2F+TyFdL3BPIWcjdk8haylPYX5PIV0vcE8hZyN2TyhyJ3BPIWspT2F+T2ckfGkhXSR8aSNgJHxpJE8kfGl+UCExV08hWzRqTyFZJ2dYIV0nZ1h+UCEzdE8hXS95TyFZKVBhfk8hXS95TyFZKVBhflAjL3NPUF1YUl1YW11Yal1Ycl1YIVFdWCFTXVghWV1YIV1dWCFsXVghcF1YI1JdWCNTXVgjYF1YI2tmWCNuXVgjb11YI3BdWCNxXVgjcl1YI3NdWCN0XVgjdV1YI3ZdWCN4XVgjel1YI3tdWCRRXVgoYV1YKHJdWCh5XVgoel1Yfk9qJVlYIWclWVh+UCUyT09qNG9PIWcjdk9+T2glVk8hZyN2TyFsJWVPfk9oJVZPcjR0TyFsJWVPKHIncE9+T3I0eU8hZyN2TyhyJ3BPfk9zIW5PIVM0ek8oVlRPKFlVTyhlIW1Pfk8oeSR9T24lYWkhUSVhaSd5JWFpKHolYWkhXSVhaSNgJWFpfk9nJWFpJE8lYWl+UCU1b08oeiVQT24lY2khUSVjaSd5JWNpKHklY2khXSVjaSNgJWNpfk9nJWNpJE8lY2l+UCU2Yk9nKF9pIV0oX2l+UCExV08jYDVRT2coX2khXShfaX5QITFXTyFrNVZPfk9hJG9xIV0kb3EneiRvcSd3JG9xIVkkb3EhayRvcXYkb3EhXyRvcSVpJG9xIWckb3F+UCE6dE8hWTVaT35PIV01W08hXylRWH5QIy9zT2EkelghXyR6WCVeXVgneiR6WCFdJHpYflAhMFNPJV41X09hb1ghX29YJ3pvWCFdb1h+UCQjT09wNWBPKFQjbk9+TyVeNV9Pfk9iNWZPJWo1Z08oVCtxTyhWVE8oWVVPIV0ndFghXid0WH5PIV0xVE8hXilYYX5PWzVrT35PYDVsT35PWzVwT35PYSVuTyd6JW5PflAjL3NPIV01dU8jYDV3TyFeKVVYfk8hXjV4T35PcjZPT3Mhbk8hUyppTyFiIXlPIWMhdk8hZCF2TyF8PFZPI1QhcE8jVSFwTyNWIXBPI1chcE8jWCFwTyNbNX1PI10hek8oVSFsTyhWVE8oWVVPKGUhbU8obyFzT35PIV41fE9+UCU7ZU9uNlRPIV8xb08laTZTT35PaCVWT242VE8hXzFvTyVpNlNPfk9iNltPKFQjbk8oVlRPKFlVTyFdJ3NYIV4nc1h+TyFdMXpPIV4pVmF+TyhWVE8oWVVPKGU2Xk9+T2A2Yk9+T2o2ZU8mWzZmT35QTlhPIWs2Z09+UCVbT2E2aU9+T2E2aU9+UCVbT2IyYk8hXjZuTyZqMmFPflBgTyFnNnBPfk8hZzZyT2goamkhXShqaSFeKGppIWcoamkhbChqaXIoamkocihqaX5PIV0jaGkhXiNoaX5QI0J3TyNgNnNPIV0jaGkhXiNoaX5PIV0hYWkhXiFhaX5QI0J3T2Elbk8jYDZ8Tyd6JW5Pfk9hJW5PIWcjdk8jYDZ8Tyd6JW5Pfk8hXSh0cSFrKHRxYSh0cSd6KHRxflAhOnRPIV0oak8hayhzcX5PIVMlaE8hXyVpTyNqN1RPKFQlZ09+TyFfJ2BPJWk3V09+T243W08hXydgTyVpN1dPfk8jaydpYVAnaWFSJ2lhWydpYWEnaWFqJ2lhcidpYSFTJ2lhIWwnaWEhcCdpYSNSJ2lhI24naWEjbydpYSNwJ2lhI3EnaWEjcidpYSNzJ2lhI3QnaWEjdSdpYSN2J2lhI3gnaWEjeidpYSN7J2lhJ3onaWEoYSdpYShyJ2lhIWsnaWEhWSdpYSd3J2lhdidpYSFfJ2lhJWknaWEhZydpYX5QJS1mTyNrJ2thUCdrYVIna2FbJ2thYSdrYWona2FyJ2thIVMna2EhbCdrYSFwJ2thI1Ina2EjbidrYSNvJ2thI3Ana2EjcSdrYSNyJ2thI3Mna2EjdCdrYSN1J2thI3Yna2EjeCdrYSN6J2thI3sna2EneidrYShhJ2thKHIna2EhaydrYSFZJ2thJ3cna2F2J2thIV8na2ElaSdrYSFnJ2thflAlLlhPI2skfGlQJHxpUiR8aVskfGlhJHxpaiR8aXIkfGkhUyR8aSFdJHxpIWwkfGkhcCR8aSNSJHxpI24kfGkjbyR8aSNwJHxpI3EkfGkjciR8aSNzJHxpI3QkfGkjdSR8aSN2JHxpI3gkfGkjeiR8aSN7JHxpJ3okfGkoYSR8aShyJHxpIWskfGkhWSR8aSd3JHxpI2AkfGl2JHxpIV8kfGklaSR8aSFnJHxpflAjL3NPI2slYWlQJWFpUiVhaVslYWlhJWFpaiVhaXIlYWkhUyVhaSFsJWFpIXAlYWkjUiVhaSNuJWFpI28lYWkjcCVhaSNxJWFpI3IlYWkjcyVhaSN0JWFpI3UlYWkjdiVhaSN4JWFpI3olYWkjeyVhaSd6JWFpKGElYWkociVhaSFrJWFpIVklYWkndyVhaXYlYWkhXyVhaSVpJWFpIWclYWl+UCU1b08jayVjaVAlY2lSJWNpWyVjaWElY2lqJWNpciVjaSFTJWNpIWwlY2khcCVjaSNSJWNpI24lY2kjbyVjaSNwJWNpI3ElY2kjciVjaSNzJWNpI3QlY2kjdSVjaSN2JWNpI3glY2kjeiVjaSN7JWNpJ3olY2koYSVjaShyJWNpIWslY2khWSVjaSd3JWNpdiVjaSFfJWNpJWklY2khZyVjaX5QJTZiTyFdJ1lhIWsnWWF+UCE6dE8hXS50TyFrKGtpfk8kTyNjaSFdI2NpIV4jY2l+UCNCd09QJFtPUiN6TyFRI3lPIVMje08hbCN4TyFwJFtPKGFWT1sjbWlqI21pciNtaSNSI21pI28jbWkjcCNtaSNxI21pI3IjbWkjcyNtaSN0I21pI3UjbWkjdiNtaSN4I21pI3ojbWkjeyNtaSRPI21pKHIjbWkoeSNtaSh6I21pIV0jbWkhXiNtaX5PI24jbWl+UCVOZE8jbjxfT35QJU5kT1AkW09SI3pPcjxrTyFRI3lPIVMje08hbCN4TyFwJFtPI248X08jbzxgTyNwPGBPI3E8YE8oYVZPWyNtaWojbWkjUiNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJE8jbWkociNtaSh5I21pKHojbWkhXSNtaSFeI21pfk8jciNtaX5QJiFsTyNyPGFPflAmIWxPUCRbT1Ijek9bPG1PajxiT3I8a08hUSN5TyFTI3tPIWwjeE8hcCRbTyNSPGJPI248X08jbzxgTyNwPGBPI3E8YE8jcjxhTyNzPGJPI3Q8Yk8jdTxsTyhhVk8jeCNtaSN6I21pI3sjbWkkTyNtaShyI21pKHkjbWkoeiNtaSFdI21pIV4jbWl+TyN2I21pflAmJHRPUCRbT1Ijek9bPG1PajxiT3I8a08hUSN5TyFTI3tPIWwjeE8hcCRbTyNSPGJPI248X08jbzxgTyNwPGBPI3E8YE8jcjxhTyNzPGJPI3Q8Yk8jdTxsTyN2PGNPKGFWTyh6I31PI3ojbWkjeyNtaSRPI21pKHIjbWkoeSNtaSFdI21pIV4jbWl+TyN4PGVPflAmJnVPI3gjbWl+UCYmdU8jdjxjT35QJiR0T1AkW09SI3pPWzxtT2o8Yk9yPGtPIVEjeU8hUyN7TyFsI3hPIXAkW08jUjxiTyNuPF9PI288YE8jcDxgTyNxPGBPI3I8YU8jczxiTyN0PGJPI3U8bE8jdjxjTyN4PGVPKGFWTyh5I3xPKHojfU8jeyNtaSRPI21pKHIjbWkhXSNtaSFeI21pfk8jeiNtaX5QJilVTyN6PGdPflAmKVVPYSN8eSFdI3x5J3ojfHkndyN8eSFZI3x5IWsjfHl2I3x5IV8jfHklaSN8eSFnI3x5flAhOnRPWyNtaWojbWlyI21pI1IjbWkjciNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJE8jbWkociNtaSFdI21pIV4jbWl+T1AkW09SI3pPIVEjeU8hUyN7TyFsI3hPIXAkW08jbjxfTyNvPGBPI3A8YE8jcTxgTyhhVk8oeSNtaSh6I21pflAmLFFPbj5eTyFRKk9PJ3kqUE8oeSR9Tyh6JVBPUCNtaVIjbWkhUyNtaSFsI21pIXAjbWkjbiNtaSNvI21pI3AjbWkjcSNtaShhI21pflAmLFFPI1MkZE9QKGBYUihgWFsoYFhqKGBYbihgWHIoYFghUShgWCFTKGBYIWwoYFghcChgWCNSKGBYI24oYFgjbyhgWCNwKGBYI3EoYFgjcihgWCNzKGBYI3QoYFgjdShgWCN2KGBYI3goYFgjeihgWCN7KGBYJE8oYFgneShgWChhKGBYKHIoYFgoeShgWCh6KGBYIV0oYFghXihgWH5PJE8kUGkhXSRQaSFeJFBpflAjQndPJE8hcmkhXiFyaX5QJCtvT2cnXWEhXSddYX5QITFXTyFeN25Pfk8hXSdkYSFeJ2RhflAjQndPIVk3b09+UCMvc08hZyN2TyhyJ3BPIV0nZWEhaydlYX5PIV0vcE8haylPaX5PIV0vcE8hZyN2TyFrKU9pfk9nJHxxIV0kfHEjYCR8cSRPJHxxflAhMVdPIVknZ2EhXSdnYX5QIy9zTyFnN3ZPfk8hXS95TyFZKVBpflAjL3NPIV0veU8hWSlQaX5PIVk3eU9+T2glVk9yOE9PIWwlZU8ocidwT35PajhRTyFnI3ZPfk9yOFRPIWcjdk8ocidwT35PIVEqT08neSpQTyh6JVBPbidqYSh5J2phIV0namEjYCdqYX5PZydqYSRPJ2phflAmNVJPIVEqT08neSpQT24nbGEoeSdsYSh6J2xhIV0nbGEjYCdsYX5PZydsYSRPJ2xhflAmNXRPZyhfcSFdKF9xflAhMVdPI2A4Vk9nKF9xIV0oX3F+UCExV08hWThXT35PZyVPcSFdJU9xI2AlT3EkTyVPcX5QITFXT2Ekb3khXSRveSd6JG95J3ckb3khWSRveSFrJG95diRveSFfJG95JWkkb3khZyRveX5QITp0TyFnNnJPfk8hXTVbTyFfKVFhfk8hXydgT1AkVGFSJFRhWyRUYWokVGFyJFRhIVEkVGEhUyRUYSFdJFRhIWwkVGEhcCRUYSNSJFRhI24kVGEjbyRUYSNwJFRhI3EkVGEjciRUYSNzJFRhI3QkVGEjdSRUYSN2JFRhI3gkVGEjeiRUYSN7JFRhKGEkVGEociRUYSh5JFRhKHokVGF+TyVpN1dPflAmOGZPJV44W09hJVtpIV8lW2kneiVbaSFdJVtpfk9hI2N5IV0jY3kneiNjeSd3I2N5IVkjY3khayNjeXYjY3khXyNjeSVpI2N5IWcjY3l+UCE6dE9bOF5Pfk9iOGBPKFQrcU8oVlRPKFlVT35PIV0xVE8hXilYaX5PYDhkT35PKGUofE8hXSdwWCFeJ3BYfk8hXTV1TyFeKVVhfk8hXjhuT35QJTtlTyhvIXNPflAkJllPI1s4b09+TyFfMW9Pfk8hXzFvTyVpOHFPfk9uOHRPIV8xb08laThxT35PWzh5TyFdJ3NhIV4nc2F+TyFdMXpPIV4pVml+TyFrOH1Pfk8hazlPT35PIWs5Uk9+TyFrOVJPflAlW09hOVRPfk8hZzlVT35PIWs5Vk9+TyFdKHdpIV4od2l+UCNCd09hJW5PI2A5X08neiVuT35PIV0odHkhayh0eWEodHkneih0eX5QITp0TyFdKGpPIWsoc3l+TyVpOWJPflAmOGZPIV8nYE8laTliT35PI2skfHFQJHxxUiR8cVskfHFhJHxxaiR8cXIkfHEhUyR8cSFdJHxxIWwkfHEhcCR8cSNSJHxxI24kfHEjbyR8cSNwJHxxI3EkfHEjciR8cSNzJHxxI3QkfHEjdSR8cSN2JHxxI3gkfHEjeiR8cSN7JHxxJ3okfHEoYSR8cShyJHxxIWskfHEhWSR8cSd3JHxxI2AkfHF2JHxxIV8kfHElaSR8cSFnJHxxflAjL3NPI2snamFQJ2phUidqYVsnamFhJ2phaidqYXInamEhUydqYSFsJ2phIXAnamEjUidqYSNuJ2phI28namEjcCdqYSNxJ2phI3InamEjcydqYSN0J2phI3UnamEjdidqYSN4J2phI3onamEjeydqYSd6J2phKGEnamEocidqYSFrJ2phIVknamEndydqYXYnamEhXydqYSVpJ2phIWcnamF+UCY1Uk8jaydsYVAnbGFSJ2xhWydsYWEnbGFqJ2xhcidsYSFTJ2xhIWwnbGEhcCdsYSNSJ2xhI24nbGEjbydsYSNwJ2xhI3EnbGEjcidsYSNzJ2xhI3QnbGEjdSdsYSN2J2xhI3gnbGEjeidsYSN7J2xhJ3onbGEoYSdsYShyJ2xhIWsnbGEhWSdsYSd3J2xhdidsYSFfJ2xhJWknbGEhZydsYX5QJjV0TyNrJU9xUCVPcVIlT3FbJU9xYSVPcWolT3FyJU9xIVMlT3EhXSVPcSFsJU9xIXAlT3EjUiVPcSNuJU9xI28lT3EjcCVPcSNxJU9xI3IlT3EjcyVPcSN0JU9xI3UlT3EjdiVPcSN4JU9xI3olT3EjeyVPcSd6JU9xKGElT3EociVPcSFrJU9xIVklT3EndyVPcSNgJU9xdiVPcSFfJU9xJWklT3EhZyVPcX5QIy9zTyFdJ1lpIWsnWWl+UCE6dE8kTyNjcSFdI2NxIV4jY3F+UCNCd08oeSR9T1AlYWFSJWFhWyVhYWolYWFyJWFhIVMlYWEhbCVhYSFwJWFhI1IlYWEjbiVhYSNvJWFhI3AlYWEjcSVhYSNyJWFhI3MlYWEjdCVhYSN1JWFhI3YlYWEjeCVhYSN6JWFhI3slYWEkTyVhYShhJWFhKHIlYWEhXSVhYSFeJWFhfk9uJWFhIVElYWEneSVhYSh6JWFhflAmSXlPKHolUE9QJWNhUiVjYVslY2FqJWNhciVjYSFTJWNhIWwlY2EhcCVjYSNSJWNhI24lY2EjbyVjYSNwJWNhI3ElY2EjciVjYSNzJWNhI3QlY2EjdSVjYSN2JWNhI3glY2EjeiVjYSN7JWNhJE8lY2EoYSVjYShyJWNhIV0lY2EhXiVjYX5PbiVjYSFRJWNhJ3klY2EoeSVjYX5QJkxRT24+Xk8hUSpPTyd5KlBPKHolUE9+UCZJeU9uPl5PIVEqT08neSpQTyh5JH1PflAmTFFPUjBrTyFRMGtPIVMwbE8jUyRkT1B9YVt9YWp9YW59YXJ9YSFsfWEhcH1hI1J9YSNufWEjb31hI3B9YSNxfWEjcn1hI3N9YSN0fWEjdX1hI3Z9YSN4fWEjen1hI3t9YSRPfWEneX1hKGF9YShyfWEoeX1hKHp9YSFdfWEhXn1hfk8hUSpPTyd5KlBPUCRzYVIkc2FbJHNhaiRzYW4kc2FyJHNhIVMkc2EhbCRzYSFwJHNhI1Ikc2EjbiRzYSNvJHNhI3Akc2EjcSRzYSNyJHNhI3Mkc2EjdCRzYSN1JHNhI3Ykc2EjeCRzYSN6JHNhI3skc2EkTyRzYShhJHNhKHIkc2EoeSRzYSh6JHNhIV0kc2EhXiRzYX5PIVEqT08neSpQT1AkdWFSJHVhWyR1YWokdWFuJHVhciR1YSFTJHVhIWwkdWEhcCR1YSNSJHVhI24kdWEjbyR1YSNwJHVhI3EkdWEjciR1YSNzJHVhI3QkdWEjdSR1YSN2JHVhI3gkdWEjeiR1YSN7JHVhJE8kdWEoYSR1YShyJHVhKHkkdWEoeiR1YSFdJHVhIV4kdWF+T24+Xk8hUSpPTyd5KlBPKHkkfU8oeiVQT35PUCVUYVIlVGFbJVRhaiVUYXIlVGEhUyVUYSFsJVRhIXAlVGEjUiVUYSNuJVRhI28lVGEjcCVUYSNxJVRhI3IlVGEjcyVUYSN0JVRhI3UlVGEjdiVUYSN4JVRhI3olVGEjeyVUYSRPJVRhKGElVGEociVUYSFdJVRhIV4lVGF+UCcnVk8kTyRtcSFdJG1xIV4kbXF+UCNCd08kTyRvcSFdJG9xIV4kb3F+UCNCd08hXjlvT35PJE85cE9+UCExV08hZyN2TyFdJ2VpIWsnZWl+TyFnI3ZPKHIncE8hXSdlaSFrJ2Vpfk8hXS9wTyFrKU9xfk8hWSdnaSFdJ2dpflAjL3NPIV0veU8hWSlQcX5Pcjl3TyFnI3ZPKHIncE9+T1s5eU8hWTl4T35QIy9zTyFZOXhPfk9qOlBPIWcjdk9+T2coX3khXShfeX5QITFXTyFdJ25hIV8nbmF+UCMvc09hJVtxIV8lW3EneiVbcSFdJVtxflAjL3NPWzpVT35PIV0xVE8hXilYcX5PYDpZT35PI2A6Wk8hXSdwYSFeJ3Bhfk8hXTV1TyFeKVVpflAjQndPIVM6XU9+TyFfMW9PJWk6YE9+TyhWVE8oWVVPKGU6ZU9+TyFdMXpPIV4pVnF+TyFrOmhPfk8hazppT35PIWs6ak9+TyFrOmpPflAlW08jYDptTyFdI2h5IV4jaHl+TyFdI2h5IV4jaHl+UCNCd08laTpyT35QJjhmTyFfJ2BPJWk6ck9+TyRPI3x5IV0jfHkhXiN8eX5QI0J3T1AkfGlSJHxpWyR8aWokfGlyJHxpIVMkfGkhbCR8aSFwJHxpI1IkfGkjbiR8aSNvJHxpI3AkfGkjcSR8aSNyJHxpI3MkfGkjdCR8aSN1JHxpI3YkfGkjeCR8aSN6JHxpI3skfGkkTyR8aShhJHxpKHIkfGkhXSR8aSFeJHxpflAnJ1ZPIVEqT08neSpQTyh6JVBPUCdpYVInaWFbJ2lhaidpYW4naWFyJ2lhIVMnaWEhbCdpYSFwJ2lhI1InaWEjbidpYSNvJ2lhI3AnaWEjcSdpYSNyJ2lhI3MnaWEjdCdpYSN1J2lhI3YnaWEjeCdpYSN6J2lhI3snaWEkTydpYShhJ2lhKHInaWEoeSdpYSFdJ2lhIV4naWF+TyFRKk9PJ3kqUE9QJ2thUidrYVsna2FqJ2thbidrYXIna2EhUydrYSFsJ2thIXAna2EjUidrYSNuJ2thI28na2EjcCdrYSNxJ2thI3Ina2EjcydrYSN0J2thI3Una2EjdidrYSN4J2thI3ona2EjeydrYSRPJ2thKGEna2EocidrYSh5J2thKHona2EhXSdrYSFeJ2thfk8oeSR9T1AlYWlSJWFpWyVhaWolYWluJWFpciVhaSFRJWFpIVMlYWkhbCVhaSFwJWFpI1IlYWkjbiVhaSNvJWFpI3AlYWkjcSVhaSNyJWFpI3MlYWkjdCVhaSN1JWFpI3YlYWkjeCVhaSN6JWFpI3slYWkkTyVhaSd5JWFpKGElYWkociVhaSh6JWFpIV0lYWkhXiVhaX5PKHolUE9QJWNpUiVjaVslY2lqJWNpbiVjaXIlY2khUSVjaSFTJWNpIWwlY2khcCVjaSNSJWNpI24lY2kjbyVjaSNwJWNpI3ElY2kjciVjaSNzJWNpI3QlY2kjdSVjaSN2JWNpI3glY2kjeiVjaSN7JWNpJE8lY2kneSVjaShhJWNpKHIlY2koeSVjaSFdJWNpIV4lY2l+TyRPJG95IV0kb3khXiRveX5QI0J3TyRPI2N5IV0jY3khXiNjeX5QI0J3TyFnI3ZPIV0nZXEhaydlcX5PIV0vcE8haylPeX5PIVknZ3EhXSdncX5QIy9zT3I6fE8hZyN2TyhyJ3BPfk9bO1FPIVk7UE9+UCMvc08hWTtQT35PZyhfIVIhXShfIVJ+UCExV09hJVt5IV8lW3kneiVbeSFdJVt5flAjL3NPIV0xVE8hXilYeX5PIV01dU8hXilVcX5PKFQ7WE9+TyFfMW9PJWk7W09+TyFrO19Pfk8laTtkT35QJjhmT1AkfHFSJHxxWyR8cWokfHFyJHxxIVMkfHEhbCR8cSFwJHxxI1IkfHEjbiR8cSNvJHxxI3AkfHEjcSR8cSNyJHxxI3MkfHEjdCR8cSN1JHxxI3YkfHEjeCR8cSN6JHxxI3skfHEkTyR8cShhJHxxKHIkfHEhXSR8cSFeJHxxflAnJ1ZPIVEqT08neSpQTyh6JVBPUCdqYVInamFbJ2phaidqYW4namFyJ2phIVMnamEhbCdqYSFwJ2phI1InamEjbidqYSNvJ2phI3AnamEjcSdqYSNyJ2phI3MnamEjdCdqYSN1J2phI3YnamEjeCdqYSN6J2phI3snamEkTydqYShhJ2phKHInamEoeSdqYSFdJ2phIV4namF+TyFRKk9PJ3kqUE9QJ2xhUidsYVsnbGFqJ2xhbidsYXInbGEhUydsYSFsJ2xhIXAnbGEjUidsYSNuJ2xhI28nbGEjcCdsYSNxJ2xhI3InbGEjcydsYSN0J2xhI3UnbGEjdidsYSN4J2xhI3onbGEjeydsYSRPJ2xhKGEnbGEocidsYSh5J2xhKHonbGEhXSdsYSFeJ2xhfk9QJU9xUiVPcVslT3FqJU9xciVPcSFTJU9xIWwlT3EhcCVPcSNSJU9xI24lT3EjbyVPcSNwJU9xI3ElT3EjciVPcSNzJU9xI3QlT3EjdSVPcSN2JU9xI3glT3EjeiVPcSN7JU9xJE8lT3EoYSVPcShyJU9xIV0lT3EhXiVPcX5QJydWT2clZSFaIV0lZSFaI2AlZSFaJE8lZSFaflAhMVdPIVk7aE9+UCMvc09yO2lPIWcjdk8ocidwT35PWztrTyFZO2hPflAjL3NPIV0ncHEhXidwcX5QI0J3TyFdI2ghWiFeI2ghWn5QI0J3TyNrJWUhWlAlZSFaUiVlIVpbJWUhWmElZSFaaiVlIVpyJWUhWiFTJWUhWiFdJWUhWiFsJWUhWiFwJWUhWiNSJWUhWiNuJWUhWiNvJWUhWiNwJWUhWiNxJWUhWiNyJWUhWiNzJWUhWiN0JWUhWiN1JWUhWiN2JWUhWiN4JWUhWiN6JWUhWiN7JWUhWid6JWUhWihhJWUhWihyJWUhWiFrJWUhWiFZJWUhWid3JWUhWiNgJWUhWnYlZSFaIV8lZSFaJWklZSFaIWclZSFaflAjL3NPcjt0TyFnI3ZPKHIncE9+TyFZO3VPflAjL3NPcjt8TyFnI3ZPKHIncE9+TyFZO31PflAjL3NPUCVlIVpSJWUhWlslZSFaaiVlIVpyJWUhWiFTJWUhWiFsJWUhWiFwJWUhWiNSJWUhWiNuJWUhWiNvJWUhWiNwJWUhWiNxJWUhWiNyJWUhWiNzJWUhWiN0JWUhWiN1JWUhWiN2JWUhWiN4JWUhWiN6JWUhWiN7JWUhWiRPJWUhWihhJWUhWihyJWUhWiFdJWUhWiFeJWUhWn5QJydWT3I8UU8hZyN2TyhyJ3BPfk92KGZYflAxcU8hUSVyT35QISlbTyhVIWxPflAhKVtPIVlmWCFdZlgjYGZYflAlMk9PUF1YUl1YW11Yal1Ycl1YIVFdWCFTXVghXV1YIV1mWCFsXVghcF1YI1JdWCNTXVgjYF1YI2BmWCNrZlgjbl1YI29dWCNwXVgjcV1YI3JdWCNzXVgjdF1YI3VdWCN2XVgjeF1YI3pdWCN7XVgkUV1YKGFdWChyXVgoeV1YKHpdWH5PIWdmWCFrXVgha2ZYKHJmWH5QJ0xUT1A8VU9RPFVPU2ZPZD5ST2UhaU9wa09yPFVPc2tPdGtPemtPfDxVTyFPPFVPIVNXTyFXa08hWGtPIV9YTyFpPFhPIWxaTyFvPFVPIXA8VU8hcTxVTyFzPFlPIXU8XU8heCFoTyRXIWtPJG4+UE8oVCldTyhWVE8oWVVPKGFWTyhvW09+TyFdPGlPIV4kcWF+T2glVk9wJVdPciVYT3MkdE90JHRPeiVZT3wlWk8hTzx0TyFTJHtPIV8kfE8haT5XTyFsJHhPI2o8ek8kVyVgTyR0PHZPJHY8eE8keSVhTyhUKHZPKFZUTyhZVU8oYSR1Tyh5JH1PKHolUE9+T2wpZE9+UCgheU9yIWVYKHIhZVh+UCMhaU9yKGpYKHIoalh+UCMjW08hXl1YIV5mWH5QJ0xUTyFZZlghWSR6WCFdZlghXSR6WCNgZlh+UCEwU08jazxeT35PIWcjdk8jazxeT35PI2A8bk9+T2o8Yk9+TyNgPU9PIV0od1ghXih3WH5PI2A8bk8hXSh1WCFeKHVYfk8jaz1QT35PZz1ST35QITFXTyNrPVhPfk8jaz1ZT35PZz1STyhUJlpPfk8hZyN2TyNrPVpPfk8hZyN2TyNrPVBPfk8kTz1bT35QI0J3TyNrPV1Pfk8jaz1eT35PI2s9Y09+TyNrPWRPfk8jaz1lT35PI2s9Zk9+TyRPPWdPflAhMVdPJE89aE9+UCExV09sPXNPflA3ZU9rI1MjVCNVI1cjWCNbI2kjaiN1JG4kdCR2JHklXSVeJWglaSVqJXElcyV2JXcleSV7fihPVCNvIVgnfChVI3BzI24jcXIhUSd9JF0nfShUJF8oZX5cIixcbiAgZ290bzogXCIkOVkpXVBQUFBQUCleUFApYVApclArVy9dUFBQUDZtUFA3VFBQPVFQUFBAdFBBXlBBXlBQUEFeUENmUEFeUEFeUEFeUENqUENvUEReUElXUFBQSVtQUFBQSVtMX1BQUExlTVZQSVtQSVtQUCEgZUlbUFBQSVtQSVtQISNsSVtQISdTIShYIShiUCEpVSEpWSEpVSEsZ1BQUFBQUFAhLVchKFhQUCEtaCEvWVAhMmlJW0lbITJuITV6ITpoITpoIT5nUFBQIT5vSVtQUFBQUFBQUFAhQk9QIUNdUFBJWyFEblBJW1BJW0lbSVtJW0lbUElbIUZRUCFJW1AhTGJQIUxmIUxwIUx0IUx0UCFJWFAhTHghTHhQIyFPUCMhU0lbUElbIyFZIyVfQ2pBXlBBXlBBXkFeUCMmbEFeQV4jKU9BXiMrdkFeIy5TQV5BXiMuciMxVyMxVyMxXSMxZiMxVyMxcVBQIzFXUEFeIzJaQV4jNllBXkFeNm1QUFAjOl9QUFAjOngjOnhQIzp4UCM7YCM6eFBQIztmUCM7XVAjO10jO3kjO10jPGUjPGsjPG4pYVAjPHEpYVAjPHojPHojPHpQKWFQKWFQKWFQKWFQUClhUCM9USM9VFAjPVQpYVAjPVhQIz1bUClhUClhUClhUClhUClhUClhKWFQUCM9YiM9aCM9cyM9eSM+UCM+ViM+XSM+ayM+cSM+eyM/UiM/XSM/YyM/cyM/eSNAayNAfSNBVCNBWiNBaSNCTyNDcyNEUiNEWSNFdCNGUyNHdCNIUyNIWSNIYCNIZiNIcCNIdiNIfCNJVyNJaiNJcFBQUFBQUFBQUFBQI0l2UFBQUFBQUCNKayNNeCQgYiQgaSQgcVBQUCQnXVAkJ2YkKl8kMHgkMHskMU8kMX0kMlEkMlgkMmFQJDJnJDJqUCQzVyQzWyQ0UyQ1YiQ1ZyQ1fVBQJDZTJDZZJDZeJDZhJDZlJDZpJDdlJDd8JDhlJDhpJDhsJDhvJDh5JDh8JDlRJDlVUiF8Um9xT1hzdCFaI2QlbSZyJnQmdSZ3LHMseDJbMl9ZIXZRJ2AtZTFvNXtRJXR2USV8eVEmVHxRJmohVlMnVyFlLV1RJ2YhaVMnbCFyIXlVKmskfCpaKm9RK28lfVMrfCZWJldRLGQmZFEtYydfUS1tJ2dRLXUnbVEwWypxUTFiLE9RMXksZVI8ezxZJVNkT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mciZ0JnUmdyZ7J1QnYidyKFQoVihdKGQoeCh6KU8pfSppK1grXSxwLHMseC1pLXEuUC5WLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNsNHo2VDZlNmY2aTZ8OHQ5VDlfUyNxXTxWIXIpXyRaJG4nWClzLVUtWC9WMnA0VDV3NnM6WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TVStQJV08czx0USt0JlBRLGYmZ1EsbSZvUTB4K2dRMH0raVExWSt1UTJSLGtRM2AuZ1E1YDB8UTVmMVRRNlsxelE3WTNkUThgNWdSOWU3WydRa09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ1gnYidyKFQoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVi9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhMnAzUTNXM2QzbDRUNHo1dzZUNmU2ZjZpNnM2fDdbOHQ5VDlfOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+UyFTIW5RIXIhdiF5IXokfCdXJ18nYCdsJ20nbiprKm8qcSpyLV0tYy1lLXUwWzBfMW81ezV9JVskdGkjdiRiJGMkZCR4JHslTyVRJV4lXyVjKXkqUipUKlYqWSphKmcqdyp4K2YraSxTLFYuZi9QL2QvbS94L3kvezBgMGIwaTBqMG8xZjFpMXEzYzReNF80ajRvNVE1WzVfNlM3Vzd2OFE4VjhbOHE5YjlwOXk6UDpgOnI7UTtbO2Q7azxsPG08bzxwPHE8cjx1PHY8dzx4PHk8ej1TPVQ9VT1WPVg9WT1dPV49Xz1gPWE9Yj1jPWQ9Zz1oPlA+WD5ZPl0+XlEmWHxRJ1UhZVMnWyVpLWBRK3QmUFEsUCZXUSxmJmdRMG4rU1ExWSt1UTFfK3tRMlEsalEyUixrUTVmMVRRNW8xYVE2WzF6UTZfMXxRNmAyUFE4YDVnUThjNWxROHw2YlE6WDhkUTpmOHlRO1Y6WVI8fSpacm5PWHN0IVYhWiNkJW0maSZyJnQmdSZ3LHMseDJbMl9SLGgmayZ6Xk9QWFlzdHV2d3ohWiFgIWchaiFvI1MjZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ2IncihWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5SPlNbI11XWiNXI1onWChUIWIlam0jaCNpI2wkeCVlJWgoXihoKGkoaipZKl4qYitaK1srXixvLVYuVC5aLlsuXS5fL20vcDJkM1szXTRhNnI3VFEld3hRJXt5VyZRfCZWJlcsT1EmXyFUUSdjIWhRJ2UhaVEocSNzUytuJXwlfVErciZQUSxfJmJRLGMmZFMtbCdmJ2dRLmkoclExUitvUTFYK3VRMVordlExXit6UTF0LGBTMXgsZCxlUTJ8LW1RNWUxVFE1aTFXUTVuMWBRNloxeVE4XzVnUThiNWtROGY1cFE6VDheUjtUOlUhVSR6aSRkJU8lUSVeJV8lYypSKlQqYSp3KngvUC94MGAwYjBpMGowbzRfNVE4VjlwPlA+WD5ZIV4leXkhaSF1JXslfCV9J1YnZSdmJ2cnayd1KmorbitvLVktbC1tLXQwUjBVMVIydTJ8M1Q0cjRzNHY3fTl7UStoJXdRLFQmW1EsVyZdUSxiJmRRLmgocVExcyxfVTF3LGMsZCxlUTNlLmlRNlUxdFM2WTF4MXlROHg2WiNmPlQjdiRiJGMkeCR7KXkqVipZKmcrZitpLFMsVi5mL2QvbS95L3sxZjFpMXEzYzReNGo0bzVbNV82UzdXN3Y4UThbOHE5Yjl5OlA6YDpyO1E7WztkO2s8bzxxPHU8dzx5PVM9VT1YPV09Xz1hPWM9Zz5dPl5vPlU8bDxtPHA8cjx2PHg8ej1UPVY9WT1ePWA9Yj1kPWhXJVRpJVYqeT5QUyZbIVEmaVEmXSFSUSZeIVNVKn0lWyVkPXNSLFImWSVdJVNpI3YkYiRjJGQkeCR7JU8lUSVeJV8lYyl5KlIqVCpWKlkqYSpnKncqeCtmK2ksUyxWLmYvUC9kL20veC95L3swYDBiMGkwajBvMWYxaTFxM2M0XjRfNGo0bzVRNVs1XzZTN1c3djhROFY4WzhxOWI5cDl5OlA6YDpyO1E7WztkO2s8bDxtPG88cDxxPHI8dTx2PHc8eDx5PHo9Uz1UPVU9Vj1YPVk9XT1ePV89YD1hPWI9Yz1kPWc9aD5QPlg+WT5dPl5UKXokdSl7VitQJV08czx0VydbIWUlaSpaLWBTKH0jeSN6UStjJXJRK3kmU1MuYihtKG5RMWosWFE1VDBrUjhpNXUnUWtPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdYJ2IncihUKFYoXShkKHgoeilPKXMpfSppK1grXStnLHAscyx4LVUtWC1pLXEuUC5WLmcudC57L1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlMkaSReYyNZI2UlcSVzJXUoUyhZKHQoeSlSKVMpVClVKVYpVylYKVkpWilbKV4pYCliKWcpcStkK3gtWi14LX0uUy5VLnMudi56LnwufS9PL2IwcDJrMm4zTzNWM2szcDNxM3IzczN0M3UzdjN3M3gzeTN6M3szfDRQNFE0WDVYNWM2dTZ7N1E3YTdiN2s3bDhrOVg5XTlnOW05bjpvO1c7YDxXPXZUI1RWI1UnUmtPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdYJ2IncihUKFYoXShkKHgoeilPKXMpfSppK1grXStnLHAscyx4LVUtWC1pLXEuUC5WLmcudC57L1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNRJ1khZVIycS1dIVchblEhZSFyIXYheSF6JHwnVydfJ2AnbCdtJ24qWiprKm8qcSpyLV0tYy1lLXUwWzBfMW81ezV9UjFsLFpucU9Yc3QhWiNkJW0mciZ0JnUmdyxzLHgyWzJfUSZ5IV5RJ3YheFMocyN1PF5RK2wlelEsXSZfUSxeJmFRLWonZFEtdydvUy5yKHg9UFMwcStYPVpRMVArbVExbixbUTJjLHpRMmUse1EybS1XUTJ6LWtRMn0tb1M1WTByPWVRNWExUVM1ZDFTPWZRNnQyb1E2eDJ7UTZ9M1NROF01YlE5WTZ2UTlaNnlROV43T1I6bDlWJGQkXWMjWSNlJXMldShTKFkodCh5KVIpUylUKVUpVilXKVgpWSlaKVspXilgKWIpZylxK2QreC1aLXgtfS5TLlUucy52LnoufS9PL2IwcDJrMm4zTzNWM2szcDNxM3IzczN0M3UzdjN3M3gzeTN6M3szfDRQNFE0WDVYNWM2dTZ7N1E3YTdiN2s3bDhrOVg5XTlnOW05bjpvO1c7YDxXPXZTKG8jcCdpUSlQI3pTK2IlcS58Uy5jKG4ocFIzXi5kJ1FrT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnWCdiJ3IoVChWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TUyNxXTxWUSZ0IVhRJnUhWVEmdyFbUSZ4IV1SMlosdlEnYSFoUStlJXdRLWgnY1MuZShxK2hRMngtZ1czYi5oLmkwdzB5UTZ3MnlXN1UzXzNhM2U1XlU5YTdWN1g3WlU6cTljOWQ5ZlM7YjpwOnNRO3A7Y1I7eDtxVSF3USdgLWVUNXkxbzV7IVFfT1haYHN0IVYhWiNkI2glZSVtJmkmayZyJnQmdSZ3KGoscyx4LlsyWzJfXSFwUSFyJ2AtZTFvNXtUI3FdPFYlXntPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ2IncihUKFYoXShkKHgoeilPKX0qaStYK10rZyxwLHMseC1pLXEuUC5WLmcudC57L24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEzUTNXM2QzbDR6NlQ2ZTZmNmk2fDdbOHQ5VDlfUyh9I3kjelMuYihtKG4hcz1sJFokbidYKXMtVS1YL1YycDRUNXc2czpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNVJGZkKV8sbVMocCNwJ2lVKnYlUih3NE9VMG0rTy5uN2dRNV4weFE3VjNgUTlkN1lSOnM5ZW0hdFEhciF2IXkheidgJ2wnbSduLWUtdTFvNXs1fVEndCF1UyhmI2cyVVMtcydrJ3dRL3MqXVEwUipqUTNVLXZRNGYvdFE0cjBUUTRzMFVRNHgwXlE3cjRgUzd9NHQ0dlM4UjR5NHtROXI3c1E5djd5UTl7OE9ROlE4VFM6ezl3OXhTO2c6fDtQUztzO2g7aVM7ezt0O3VTPFA7fDt9UjxTPFFRI3diUSdzIXVTKGUjZzJVUyhnI20rV1ErWSVmUStqJXhRK3AmT1UtcidrJ3Qnd1EuVyhmVS9yKl0qYC93UTBTKmpRMFYqbFExTytrUTF1LGFTM1Itcy12UTNaLmBTNGUvcy90UTRuMFBTNHEwUjBeUTR1MFdRNlcxdlE3UDNVUzdxNGA0YlE3dTRmVTd8NHI0eDR7UThQNHdROHY2WFM5cTdyN3NROXU3eVE5fThSUTpPOFNROmM4d1E6eTlyUzp6OXY5eFE7UzpRUTteOmRTO2Y6eztQUztyO2c7aFM7ejtzO3VTPE87ezt9UTxSPFBRPFQ8U1E9bz1qUT17PXRSPXw9dVYhd1EnYC1lJV5hT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdiJ3IoVChWKF0oZCh4KHopTyl9KmkrWCtdK2cscCxzLHgtaS1xLlAuVi5nLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNkM2w0ejZUNmU2ZjZpNnw3Wzh0OVQ5X1Mjd3ohaiFyPWkkWiRuJ1gpcy1VLVgvVjJwNFQ1dzZzOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1I9bz5SJV5iT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdiJ3IoVChWKF0oZCh4KHopTyl9KmkrWCtdK2cscCxzLHgtaS1xLlAuVi5nLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNkM2w0ejZUNmU2ZjZpNnw3Wzh0OVQ5X1ElZmohXiV4eSFpIXUleyV8JX0nVidlJ2YnZydrJ3UqaituK28tWS1sLW0tdDBSMFUxUjJ1MnwzVDRyNHM0djd9OXtTJk96IWpRK2sleVEsYSZkVzF2LGIsYyxkLGVVNlgxdzF4MXlTOHc2WTZaUTpkOHghcj1qJFokbidYKXMtVS1YL1YycDRUNXc2czpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNRPXQ+UVI9dT5SJVFlT1BYWXN0dXZ3IVohYCFnIW8jUyNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mciZ0JnUmdyZ7J1QnYidyKFYoXShkKHgoeilPKX0qaStYK10rZyxwLHMseC1pLXEuUC5WLmcudC57L24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEzUTNXM2QzbDR6NlQ2ZTZmNmk2fDdbOHQ5VDlfWSNiV1ojVyNaKFQhYiVqbSNoI2kjbCR4JWUlaCheKGgoaShqKlkqXipiK1orWyteLG8tVi5ULlouWy5dLl8vbS9wMmQzWzNdNGE2cjdUUSxuJm8hcD1rJFokbilzLVUtWC9WMnA0VDV3NnM6WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TUj1uJ1hVJ10hZSVpKlpSMnMtYCVTZE9QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbSV0JlImayZuJnImdCZ1JncmeydUJ2IncihUKFYoXShkKHgoeilPKX0qaStYK10scCxzLHgtaS1xLlAuVi50LnsvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTNRM1czbDR6NlQ2ZTZmNmk2fDh0OVQ5XyFyKV8kWiRuJ1gpcy1VLVgvVjJwNFQ1dzZzOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1EsbSZvUTB4K2dRM2AuZ1E3WTNkUjllN1shYiRUYyNZJXEoUyhZKHQoeSlaKVspYClnK3gteC19LlMuVS5zLnYvYjBwM08zVjNrM3s1WDVjNns3UTdhOV06bzxXIVA8ZCleKXEtWi58MmsybjNwM3kzejRQNFg2dTdiN2s3bDhrOVg5ZzltOW47VztgPXYhZiRWYyNZJXEoUyhZKHQoeSlXKVgpWilbKWApZyt4LXgtfS5TLlUucy52L2IwcDNPM1YzazN7NVg1YzZ7N1E3YTldOm88VyFUPGYpXilxLVoufDJrMm4zcDN2M3czeTN6NFA0WDZ1N2I3azdsOGs5WDlnOW05bjtXO2A9diFeJFpjI1klcShTKFkodCh5KWApZyt4LXgtfS5TLlUucy52L2IwcDNPM1YzazN7NVg1YzZ7N1E3YTldOm88V1E0Xy9rej5TKV4pcS1aLnwyazJuM3A0UDRYNnU3YjdrN2w4azlYOWc5bTluO1c7YD12UT5YPlpSPlk+WydRa09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ1gnYidyKFQoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVi9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhMnAzUTNXM2QzbDRUNHo1dzZUNmU2ZjZpNnM2fDdbOHQ5VDlfOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1Mkb2gkcFI0VS9VJ1hnT1BXWFlaaHN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJHAlbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnWCdiJ3IoVChWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9VL1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNUJGtmJHFRJGlmUylqJGwpblIpdiRxVCRqZiRxVClsJGwpbidYaE9QV1hZWmhzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiRwJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ1gnYidyKFQoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVS9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TVCRvaCRwUSRyaFIpdSRwJV5qT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdiJ3IoVChWKF0oZCh4KHopTyl9KmkrWCtdK2cscCxzLHgtaS1xLlAuVi5nLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNkM2w0ejZUNmU2ZjZpNnw3Wzh0OVQ5XyFzPlEkWiRuJ1gpcy1VLVgvVjJwNFQ1dzZzOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+UyNnbE9QWFpzdCFaIWAhbyNTI2QjbyN7JG4lbSZrJm4mbyZyJnQmdSZ3JnsnVCdiKU8pcyppK10rZyxwLHMseC1pLmcvVi9uMF0wbDFyMlMyVDJWMlgyWzJfMmEzZDRUNHo2VDZlNmY2aTdbOHQ5VCFVJVJpJGQlTyVRJV4lXyVjKlIqVCphKncqeC9QL3gwYDBiMGkwajBvNF81UThWOXA+UD5YPlkjZih3I3YkYiRjJHgkeyl5KlYqWSpnK2YraSxTLFYuZi9kL20veS97MWYxaTFxM2M0XjRqNG81WzVfNlM3Vzd2OFE4WzhxOWI5eTpQOmA6cjtRO1s7ZDtrPG88cTx1PHc8eT1TPVU9WD1dPV89YT1jPWc+XT5eUStUJWFRL2MqT280TzxsPG08cDxyPHY8eDx6PVQ9Vj1ZPV49YD1iPWQ9aCFVJHlpJGQlTyVRJV4lXyVjKlIqVCphKncqeC9QL3gwYDBiMGkwajBvNF81UThWOXA+UD5YPllRKmMkelUqbCR8Kloqb1ErVSViUTBXKm0jZj1xI3YkYiRjJHgkeyl5KlYqWSpnK2YraSxTLFYuZi9kL20veS97MWYxaTFxM2M0XjRqNG81WzVfNlM3Vzd2OFE4WzhxOWI5eTpQOmA6cjtRO1s7ZDtrPG88cTx1PHc8eT1TPVU9WD1dPV89YT1jPWc+XT5ebj1yPGw8bTxwPHI8djx4PHo9VD1WPVk9Xj1gPWI9ZD1oUT13PlRRPXg+VVE9eT5WUj16PlchVSVSaSRkJU8lUSVeJV8lYypSKlQqYSp3KngvUC94MGAwYjBpMGowbzRfNVE4VjlwPlA+WD5ZI2YodyN2JGIkYyR4JHspeSpWKlkqZytmK2ksUyxWLmYvZC9tL3kvezFmMWkxcTNjNF40ajRvNVs1XzZTN1c3djhROFs4cTliOXk6UDpgOnI7UTtbO2Q7azxvPHE8dTx3PHk9Uz1VPVg9XT1fPWE9Yz1nPl0+Xm80TzxsPG08cDxyPHY8eDx6PVQ9Vj1ZPV49YD1iPWQ9aG5vT1hzdCFaI2QlbSZyJnQmdSZ3LHMseDJbMl9TKmYkeypZUS1SJ09RLVMnUVI0aS95JVslU2kjdiRiJGMkZCR4JHslTyVRJV4lXyVjKXkqUipUKlYqWSphKmcqdyp4K2YraSxTLFYuZi9QL2QvbS94L3kvezBgMGIwaTBqMG8xZjFpMXEzYzReNF80ajRvNVE1WzVfNlM3Vzd2OFE4VjhbOHE5YjlwOXk6UDpgOnI7UTtbO2Q7azxsPG08bzxwPHE8cjx1PHY8dzx4PHk8ej1TPVQ9VT1WPVg9WT1dPV49Xz1gPWE9Yj1jPWQ9Zz1oPlA+WD5ZPl0+XlEsVSZdUTFoLFdRNXMxZ1I4aDV0VipuJHwqWipvVSpuJHwqWipvVDV6MW81e1MwUCppL25RNHcwXVQ4UzR6Ol1RK2oleFEwVipsUTFPK2tRMXUsYVE2VzF2UTh2NlhROmM4d1I7XjpkIVUlT2kkZCVPJVElXiVfJWMqUipUKmEqdyp4L1AveDBgMGIwaTBqMG80XzVROFY5cD5QPlg+WXgqUiR2KWUqUyp1K1YvdjBkMGU0UjRnNVI1UzVXN3A4VTpSOng9cD19Pk9TMGAqdDBhI2Y8byN2JGIkYyR4JHspeSpWKlkqZytmK2ksUyxWLmYvZC9tL3kvezFmMWkxcTNjNF40ajRvNVs1XzZTN1c3djhROFs4cTliOXk6UDpgOnI7UTtbO2Q7azxvPHE8dTx3PHk9Uz1VPVg9XT1fPWE9Yz1nPl0+Xm48cDxsPG08cDxyPHY8eDx6PVQ9Vj1ZPV49YD1iPWQ9aCFkPVModSljKlsqZS5qLm0ucS9fL2svfDB2MWUzaDRbNGg0bDVyN103YDd3N3o4WDhaOXQ5fDpTOn07UjtlO2o7dj5aPltgPVQzfTdjN2Y3ajloOnQ6dzt5Uz1fLmwzaVQ9YDdlOWshVSVRaSRkJU8lUSVeJV8lYypSKlQqYSp3KngvUC94MGAwYjBpMGowbzRfNVE4VjlwPlA+WD5ZfCpUJHYpZSpVKnQrVi9nL3YwZDBlNFI0ZzR8NVI1UzVXN3A4VTpSOng9cD19Pk9TMGIqdTBjI2Y8cSN2JGIkYyR4JHspeSpWKlkqZytmK2ksUyxWLmYvZC9tL3kvezFmMWkxcTNjNF40ajRvNVs1XzZTN1c3djhROFs4cTliOXk6UDpgOnI7UTtbO2Q7azxvPHE8dTx3PHk9Uz1VPVg9XT1fPWE9Yz1nPl0+Xm48cjxsPG08cDxyPHY8eDx6PVQ9Vj1ZPV49YD1iPWQ9aCFoPVUodSljKlsqZS5rLmwucS9fL2svfDB2MWUzZjNoNFs0aDRsNXI3XTdeN2A3dzd6OFg4Wjl0OXw6Uzp9O1I7ZTtqO3Y+Wj5bZD1WM303ZDdlN2o5aDlpOnQ6dTp3O3lTPWEubTNqVD1iN2Y5bHJuT1hzdCFWIVojZCVtJmkmciZ0JnUmdyxzLHgyWzJfUSZmIVVSLHAmb3JuT1hzdCFWIVojZCVtJmkmciZ0JnUmdyxzLHgyWzJfUiZmIVVRLFkmXlIxZCxSc25PWHN0IVYhWiNkJW0maSZyJnQmdSZ3LHMseDJbMl9RMXAsX1M2UjFzMXRVOHA2UDZRNlVTOl84cjhzUztZOl46YVE7bTtaUjt3O25RJm0hVlIsaSZpUjZfMXxSOmY4eVcmUXwmViZXLE9SMVordlEmciFXUixzJnNSLHkmeFQyXSx4Ml9SLH0meVEsfCZ5UjJmLH1RJ3khe1IteSd5U3NPdFEjZFhUJXBzI2RRI09UUid7I09RI1JVUid9I1JRKXskdVIvYCl7USNVVlIoUSNVUSNYV1UoVyNYKFguUVEoWCNZUi5RKFlRLV4nWVIyci1eUS51KHlTM20udTNuUjNuLnZRLWUnYFIydi1lWSFyUSdgLWUxbzV7UidqIXJRL1EpZVI0Uy9RVSNfVyVoKllVKF8jXyhgLlJRKGAjYFIuUihaUS1hJ11SMnQtYXRgT1hzdCFWIVojZCVtJmkmayZyJnQmdSZ3LHMseDJbMl9TI2haJWVVI3JgI2guW1IuWyhqUShrI2pRLlgoZ1cuYShrLlgzWDdSUTNYLllSN1IzWVEpbiRsUi9XKW5RJHBoUil0JHBRJGBjVSlhJGAtfDxqUS18PFdSPGopcVEvcSpdVzRjL3E0ZDd0OXNVNGQvci9zL3RTN3Q0ZTRmUjlzN3UkZSpRJHYodSljKWUqWyplKnQqdStRK1IrVi5sLm0uby5wLnEvXy9nL2kvay92L3wwZDBlMHYxZTNmM2czaDN9NFI0WzRnNGg0bDR8NU81UjVTNVc1cjddN143XzdgN2U3ZjdoN2k3ajdwN3c3ejhVOFg4WjloOWk5ajl0OXw6UjpTOnQ6dTp2Onc6eDp9O1I7ZTtqO3Y7eT1wPX0+Tz5aPltRL3oqZVU0ay96NG03eFE0bS98Ujd4NGxTKm8kfCpaUjBZKm94KlMkdillKnQqdStWL3YwZDBlNFI0ZzVSNVM1VzdwOFU6Ujp4PXA9fT5PIWQuaih1KWMqWyplLmwubS5xL18vay98MHYxZTNoNFs0aDRsNXI3XTdgN3c3ejhYOFo5dDl8OlM6fTtSO2U7ajt2Plo+W1UvaCpTLmo3Y2E3YzN9N2U3ZjdqOWg6dDp3O3lRMGEqdFEzaS5sVTR9MGEzaTlrUjlrN2V8KlUkdillKnQqdStWL2cvdjBkMGU0UjRnNHw1UjVTNVc3cDhVOlI6eD1wPX0+TyFoLmsodSljKlsqZS5sLm0ucS9fL2svfDB2MWUzZjNoNFs0aDRsNXI3XTdeN2A3dzd6OFg4Wjl0OXw6Uzp9O1I7ZTtqO3Y+Wj5bVS9qKlUuazdkZTdkM303ZTdmN2o5aDlpOnQ6dTp3O3lRMGMqdVEzai5tVTVQMGMzajlsUjlsN2ZRKnolVVIwZyp6UTVdMHZSOFk1XVErXyVrUjB1K19RNXYxalM4ajV2OltSOls4a1EsWyZfUjFtLFtRNXsxb1I4bTV7UTF7LGZTNl0xezh6Ujh6Nl9RMVUrclc1aDFVNWo4YTpWUTVqMVhROGE1aVI6VjhiUSt3JlFSMVsrd1EyXyx4UjZtMl9Zck9Yc3QjZFEmdiFaUSthJW1RLHImclEsdCZ0USx1JnVRLHcmd1EyWSxzUzJdLHgyX1I2bDJbUSVvcFEmeiFfUSZ9IWFRJ1AhYlEnUiFjUSdxIXVRK2AlbFErbCV6USxRJlhRLGgmbVEtUCZ8Vy1wJ2sncyd0J3dRLXcnb1EwWCpuUTFQK21RMWMsUFMyTyxpLGxRMmctT1EyaC1SUTJpLVNRMn0tb1czUC1yLXMtdi14UTVhMVFRNW0xX1E1cTFlUTZWMXVRNmEyUVE2azJaVTZ6M08zUjNVUTZ9M1NROF01YlE4ZTVvUThnNXJROGw1elE4dTZXUTh7NmBTOVs2ezdQUTleN09ROlc4Y1E6Yjh2UTpnOHxROm45XVE7VTpYUTtdOmNRO2E6b1E7bDtWUjtvO15RJXp5USdkIWlRJ28hdVUrbSV7JXwlfVEtVydWVS1rJ2UnZidnUy1vJ2sndVEwUSpqUzFRK24rb1Eyby1ZUzJ7LWwtbVEzUy10UzRwMFIwVVE1YjFSUTZ2MnVRNnkyfFE3TzNUVTd7NHI0czR2UTl6N31SO085e1Mkd2k+UFIqeyVWVSVVaSVWPlBSMGYqeVEkdmlTKHUjditpUyljJGIkY1EpZSRkUSpbJHhTKmUkeypZUSp0JU9RKnUlUVErUSVeUStSJV9RK1YlY1EubDxvUS5tPHFRLm88dVEucDx3US5xPHlRL18peVEvZypSUS9pKlRRL2sqVlEvdiphUy98KmcvbVEwZCp3UTBlKnhsMHYrZixWLmYxaTFxM2M2UzdXOHE5YjpgOnI7WztkUTFlLFNRM2Y9U1EzZz1VUTNoPVhTM308bDxtUTRSL1BTNFsvZDReUTRnL3hRNGgveVE0bC97UTR8MGBRNU8wYlE1UjBpUTVTMGpRNVcwb1E1cjFmUTddPV1RN149X1E3Xz1hUTdgPWNRN2U8cFE3ZjxyUTdoPHZRN2k8eFE3ajx6UTdwNF9RN3c0alE3ejRvUThVNVFROFg1W1E4WjVfUTloPVlROWk9VFE5aj1WUTl0N3ZROXw4UVE6UjhWUTpTOFtROnQ9XlE6dT1gUTp2PWJROnc9ZFE6eDlwUTp9OXlRO1I6UFE7ZT1nUTtqO1FRO3Y7a1E7eT1oUT1wPlBRPX0+WFE+Tz5ZUT5aPl1SPls+XlErTyVdUS5uPHNSN2c8dG5wT1hzdCFaI2QlbSZyJnQmdSZ3LHMseDJbMl9RIWZQUyNmWiNvUSZ8IWBXJ2ghbyppMF00elEoUCNTUSlRI3tRKXIkblMsbCZrJm5RLHEmb1EtTyZ7Uy1UJ1QvblEtZydiUS54KU9RL1spc1EwcytdUTB5K2dRMlcscFEyeS1pUTNhLmdRNFcvVlE1VTBsUTZRMXJRNmMyU1E2ZDJUUTZoMlZRNmoyWFE2bzJhUTdaM2RRN200VFE4czZUUTlQNmVROVE2ZlE5UzZpUTlmN1tROmE4dFI6azlUI1tjT1BYWnN0IVohYCFvI2QjbyN7JW0mayZuJm8mciZ0JnUmdyZ7J1QnYilPKmkrXStnLHAscyx4LWkuZy9uMF0wbDFyMlMyVDJWMlgyWzJfMmEzZDR6NlQ2ZTZmNmk3Wzh0OVRRI1lXUSNlWVElcXVRJXN2UyV1dyFnUyhTI1coVlEoWSNaUSh0I3VRKHkjeFEpUiRPUSlTJFBRKVQkUVEpVSRSUSlWJFNRKVckVFEpWCRVUSlZJFZRKVokV1EpWyRYUSleJFpRKWAkX1EpYiRhUSlnJGVXKXEkbilzL1Y0VFErZCV0USt4JlJTLVonWDJwUS14J3JTLX0oVC5QUS5TKF1RLlUoZFEucyh4US52KHpRLno8VVEufDxYUS59PFlRL088XVEvYil9UTBwK1hRMmstVVEybi1YUTNPLXFRM1YuVlEzay50UTNwPF5RM3E8X1EzcjxgUTNzPGFRM3Q8YlEzdTxjUTN2PGRRM3c8ZVEzeDxmUTN5PGdRM3o8aFEzey57UTN8PGtRNFA8blE0UTx7UTRYPGlRNVgwclE1YzFTUTZ1PU9RNnszUVE3UTNXUTdhM2xRN2I9UFE3az1SUTdsPVpROGs1d1E5WDZzUTldNnxROWc9W1E5bT1lUTluPWZROm85X1E7VzpaUTtgOm1RPFcjU1I9dj5TUiNbV1InWiFlbCF0USFyIXYheSF6J2AnbCdtJ24tZS11MW81ezV9UydWIWUtXVUqaiR8Kloqb1MtWSdXJ19TMFUqaypxUTBeKnJRMnUtY1E0djBbUjR7MF9SKHsjeFEhZlFULWQnYC1lXSFxUSFyJ2AtZTFvNXtRI3BdUidpPFZSKWYkZFkhdVEnYC1lMW81e1EnayFyUyd1IXYheVMndyF6NX1TLXQnbCdtUS12J25SM1QtdVQja1olZVMjalolZVMla20sb1UoZyNoI2kjbFMuWShoKGlRLl4oalEwdCteUTNZLlpVM1ouWy5dLl9TN1MzWzNdUjlgN1RkI15XI1cjWiVoKFQoXipZK1ouVC9tciNnWm0jaCNpI2wlZShoKGkoaiteLlouWy5dLl8zWzNdN1RTKl0keCpiUS90Kl5RMlUsb1EybC1WUTRgL3BRNnEyZFE3czRhUTlXNnJUPW0nWCtbViNhVyVoKllVI2BXJWgqWVMoVSNXKF5VKFojWitaL21TLVsnWCtbVC5PKFQuVFYnXiFlJWkqWlEkbGZSKXgkcVQpbSRsKW5SNFYvVVQqXyR4KmJUKmgkeypZUTB3K2ZRMWcsVlEzXy5mUTV0MWlRNlAxcVE3WDNjUThyNlNROWM3V1E6XjhxUTpwOWJRO1o6YFE7YzpyUTtuO1tSO3E7ZG5xT1hzdCFaI2QlbSZyJnQmdSZ3LHMseDJbMl9RJmwhVlIsaCZpdG1PWHN0IVUhViFaI2QlbSZpJnImdCZ1Jncscyx4MlsyX1IsbyZvVCVsbSxvUjFrLFhSLGcmZ1EmVXxTK30mViZXUjFeLE9SK3MmUFQmcCFXJnNUJnEhVyZzVDJeLHgyX1wiLFxuICBub2RlTmFtZXM6IFwiXHUyNkEwIEFyaXRoT3AgQXJpdGhPcCA/LiBKU1hTdGFydFRhZyBMaW5lQ29tbWVudCBCbG9ja0NvbW1lbnQgU2NyaXB0IEhhc2hiYW5nIEV4cG9ydERlY2xhcmF0aW9uIGV4cG9ydCBTdGFyIGFzIFZhcmlhYmxlTmFtZSBTdHJpbmcgRXNjYXBlIGZyb20gOyBkZWZhdWx0IEZ1bmN0aW9uRGVjbGFyYXRpb24gYXN5bmMgZnVuY3Rpb24gVmFyaWFibGVEZWZpbml0aW9uID4gPCBUeXBlUGFyYW1MaXN0IGluIG91dCBjb25zdCBUeXBlRGVmaW5pdGlvbiBleHRlbmRzIFRoaXNUeXBlIHRoaXMgTGl0ZXJhbFR5cGUgQXJpdGhPcCBOdW1iZXIgQm9vbGVhbkxpdGVyYWwgVGVtcGxhdGVUeXBlIEludGVycG9sYXRpb25FbmQgSW50ZXJwb2xhdGlvbiBJbnRlcnBvbGF0aW9uU3RhcnQgTnVsbFR5cGUgbnVsbCBWb2lkVHlwZSB2b2lkIFR5cGVvZlR5cGUgdHlwZW9mIE1lbWJlckV4cHJlc3Npb24gLiBQcm9wZXJ0eU5hbWUgWyBUZW1wbGF0ZVN0cmluZyBFc2NhcGUgSW50ZXJwb2xhdGlvbiBzdXBlciBSZWdFeHAgXSBBcnJheUV4cHJlc3Npb24gU3ByZWFkICwgfSB7IE9iamVjdEV4cHJlc3Npb24gUHJvcGVydHkgYXN5bmMgZ2V0IHNldCBQcm9wZXJ0eURlZmluaXRpb24gQmxvY2sgOiBOZXdUYXJnZXQgbmV3IE5ld0V4cHJlc3Npb24gKSAoIEFyZ0xpc3QgVW5hcnlFeHByZXNzaW9uIGRlbGV0ZSBMb2dpY09wIEJpdE9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBBd2FpdEV4cHJlc3Npb24gYXdhaXQgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gQ2xhc3NFeHByZXNzaW9uIGNsYXNzIENsYXNzQm9keSBNZXRob2REZWNsYXJhdGlvbiBEZWNvcmF0b3IgQCBNZW1iZXJFeHByZXNzaW9uIFByaXZhdGVQcm9wZXJ0eU5hbWUgQ2FsbEV4cHJlc3Npb24gVHlwZUFyZ0xpc3QgQ29tcGFyZU9wIDwgZGVjbGFyZSBQcml2YWN5IHN0YXRpYyBhYnN0cmFjdCBvdmVycmlkZSBQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uIFByb3BlcnR5RGVjbGFyYXRpb24gcmVhZG9ubHkgYWNjZXNzb3IgT3B0aW9uYWwgVHlwZUFubm90YXRpb24gRXF1YWxzIFN0YXRpY0Jsb2NrIEZ1bmN0aW9uRXhwcmVzc2lvbiBBcnJvd0Z1bmN0aW9uIFBhcmFtTGlzdCBQYXJhbUxpc3QgQXJyYXlQYXR0ZXJuIE9iamVjdFBhdHRlcm4gUGF0dGVyblByb3BlcnR5IFByaXZhY3kgcmVhZG9ubHkgQXJyb3cgTWVtYmVyRXhwcmVzc2lvbiBCaW5hcnlFeHByZXNzaW9uIEFyaXRoT3AgQXJpdGhPcCBBcml0aE9wIEFyaXRoT3AgQml0T3AgQ29tcGFyZU9wIGluc3RhbmNlb2Ygc2F0aXNmaWVzIENvbXBhcmVPcCBCaXRPcCBCaXRPcCBCaXRPcCBMb2dpY09wIExvZ2ljT3AgQ29uZGl0aW9uYWxFeHByZXNzaW9uIExvZ2ljT3AgTG9naWNPcCBBc3NpZ25tZW50RXhwcmVzc2lvbiBVcGRhdGVPcCBQb3N0Zml4RXhwcmVzc2lvbiBDYWxsRXhwcmVzc2lvbiBJbnN0YW50aWF0aW9uRXhwcmVzc2lvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gRHluYW1pY0ltcG9ydCBpbXBvcnQgSW1wb3J0TWV0YSBKU1hFbGVtZW50IEpTWFNlbGZDbG9zZUVuZFRhZyBKU1hTZWxmQ2xvc2luZ1RhZyBKU1hJZGVudGlmaWVyIEpTWEJ1aWx0aW4gSlNYSWRlbnRpZmllciBKU1hOYW1lc3BhY2VkTmFtZSBKU1hNZW1iZXJFeHByZXNzaW9uIEpTWFNwcmVhZEF0dHJpYnV0ZSBKU1hBdHRyaWJ1dGUgSlNYQXR0cmlidXRlVmFsdWUgSlNYRXNjYXBlIEpTWEVuZFRhZyBKU1hPcGVuVGFnIEpTWEZyYWdtZW50VGFnIEpTWFRleHQgSlNYRXNjYXBlIEpTWFN0YXJ0Q2xvc2VUYWcgSlNYQ2xvc2VUYWcgUHJlZml4Q2FzdCA8IEFycm93RnVuY3Rpb24gVHlwZVBhcmFtTGlzdCBTZXF1ZW5jZUV4cHJlc3Npb24gSW5zdGFudGlhdGlvbkV4cHJlc3Npb24gS2V5b2ZUeXBlIGtleW9mIFVuaXF1ZVR5cGUgdW5pcXVlIEltcG9ydFR5cGUgSW5mZXJyZWRUeXBlIGluZmVyIFR5cGVOYW1lIFBhcmVudGhlc2l6ZWRUeXBlIEZ1bmN0aW9uU2lnbmF0dXJlIFBhcmFtTGlzdCBOZXdTaWduYXR1cmUgSW5kZXhlZFR5cGUgVHVwbGVUeXBlIExhYmVsIEFycmF5VHlwZSBSZWFkb25seVR5cGUgT2JqZWN0VHlwZSBNZXRob2RUeXBlIFByb3BlcnR5VHlwZSBJbmRleFNpZ25hdHVyZSBQcm9wZXJ0eURlZmluaXRpb24gQ2FsbFNpZ25hdHVyZSBUeXBlUHJlZGljYXRlIGFzc2VydHMgaXMgTmV3U2lnbmF0dXJlIG5ldyBVbmlvblR5cGUgTG9naWNPcCBJbnRlcnNlY3Rpb25UeXBlIExvZ2ljT3AgQ29uZGl0aW9uYWxUeXBlIFBhcmFtZXRlcml6ZWRUeXBlIENsYXNzRGVjbGFyYXRpb24gYWJzdHJhY3QgaW1wbGVtZW50cyB0eXBlIFZhcmlhYmxlRGVjbGFyYXRpb24gbGV0IHZhciB1c2luZyBUeXBlQWxpYXNEZWNsYXJhdGlvbiBJbnRlcmZhY2VEZWNsYXJhdGlvbiBpbnRlcmZhY2UgRW51bURlY2xhcmF0aW9uIGVudW0gRW51bUJvZHkgTmFtZXNwYWNlRGVjbGFyYXRpb24gbmFtZXNwYWNlIG1vZHVsZSBBbWJpZW50RGVjbGFyYXRpb24gZGVjbGFyZSBHbG9iYWxEZWNsYXJhdGlvbiBnbG9iYWwgQ2xhc3NEZWNsYXJhdGlvbiBDbGFzc0JvZHkgQW1iaWVudEZ1bmN0aW9uRGVjbGFyYXRpb24gRXhwb3J0R3JvdXAgVmFyaWFibGVOYW1lIFZhcmlhYmxlTmFtZSBJbXBvcnREZWNsYXJhdGlvbiBkZWZlciBJbXBvcnRHcm91cCBGb3JTdGF0ZW1lbnQgZm9yIEZvclNwZWMgRm9ySW5TcGVjIEZvck9mU3BlYyBvZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBXaXRoU3RhdGVtZW50IHdpdGggRG9TdGF0ZW1lbnQgZG8gSWZTdGF0ZW1lbnQgaWYgZWxzZSBTd2l0Y2hTdGF0ZW1lbnQgc3dpdGNoIFN3aXRjaEJvZHkgQ2FzZUxhYmVsIGNhc2UgRGVmYXVsdExhYmVsIFRyeVN0YXRlbWVudCB0cnkgQ2F0Y2hDbGF1c2UgY2F0Y2ggRmluYWxseUNsYXVzZSBmaW5hbGx5IFJldHVyblN0YXRlbWVudCByZXR1cm4gVGhyb3dTdGF0ZW1lbnQgdGhyb3cgQnJlYWtTdGF0ZW1lbnQgYnJlYWsgQ29udGludWVTdGF0ZW1lbnQgY29udGludWUgRGVidWdnZXJTdGF0ZW1lbnQgZGVidWdnZXIgTGFiZWxlZFN0YXRlbWVudCBFeHByZXNzaW9uU3RhdGVtZW50IFNpbmdsZUV4cHJlc3Npb24gU2luZ2xlQ2xhc3NJdGVtXCIsXG4gIG1heFRlcm06IDM4MCxcbiAgY29udGV4dDogdHJhY2tOZXdsaW5lLFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJpc29sYXRlXCIsIC04LDUsNiwxNCwzNywzOSw1MSw1Myw1NSxcIlwiXSxcbiAgICBbXCJncm91cFwiLCAtMjYsOSwxNywxOSw2OCwyMDcsMjExLDIxNSwyMTYsMjE4LDIyMSwyMjQsMjM0LDIzNywyNDMsMjQ1LDI0NywyNDksMjUyLDI1OCwyNjQsMjY2LDI2OCwyNzAsMjcyLDI3NCwyNzUsXCJTdGF0ZW1lbnRcIiwtMzQsMTMsMTQsMzIsMzUsMzYsNDIsNTEsNTQsNTUsNTcsNjIsNzAsNzIsNzYsODAsODIsODQsODUsMTEwLDExMSwxMjAsMTIxLDEzNiwxMzksMTQxLDE0MiwxNDMsMTQ0LDE0NSwxNDcsMTQ4LDE2NywxNjksMTcxLFwiRXhwcmVzc2lvblwiLC0yMywzMSwzMywzNyw0MSw0Myw0NSwxNzMsMTc1LDE3NywxNzgsMTgwLDE4MSwxODIsMTg0LDE4NSwxODYsMTg4LDE4OSwxOTAsMjAxLDIwMywyMDUsMjA2LFwiVHlwZVwiLC0zLDg4LDEwMywxMDksXCJDbGFzc0l0ZW1cIl0sXG4gICAgW1wib3BlbmVkQnlcIiwgMjMsXCI8XCIsMzgsXCJJbnRlcnBvbGF0aW9uU3RhcnRcIiw1NixcIltcIiw2MCxcIntcIiw3MyxcIihcIiwxNjAsXCJKU1hTdGFydENsb3NlVGFnXCJdLFxuICAgIFtcImNsb3NlZEJ5XCIsIC0yLDI0LDE2OCxcIj5cIiw0MCxcIkludGVycG9sYXRpb25FbmRcIiw1MCxcIl1cIiw2MSxcIn1cIiw3NCxcIilcIiwxNjUsXCJKU1hFbmRUYWdcIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtqc0hpZ2hsaWdodF0sXG4gIHNraXBwZWROb2RlczogWzAsNSw2LDI3OF0sXG4gIHJlcGVhdE5vZGVDb3VudDogMzcsXG4gIHRva2VuRGF0YTogXCIkRnEwN1tSIWJPWCVaWFkrZ1laLXlaWytnW10lWl1eLmNecCVacHErZ3FyL21yczNjc3Q6X3R1RXJ1dkpTdndMa3d4ISBZeHkhJ2l5eiEoc3p7ISl9e3whLHF8fSEuT30hTyEscSFPIVAhL1khUCFRITlqIVEhUiM6TyFSIVsjPF8hWyFdI0lfIV0hXiNKayFeIV8jS3UhXyFgJCFbIWAhYSQkdiFhIWIkKlQhYiFjJCxyIWMhfUVyIX0jTyQtfCNPI1AkL1cjUCNRJDRvI1EjUiQ1eSNSI1NFciNTI1QkN1cjVCNvJDhiI28jcCQ8ciNwI3EkPWgjcSNyJD54I3IjcyRAVSNzJGYlWiRmJGcrZyRnI0JZRXIjQlkjQlokQWAjQlokSVNFciRJUyRJXyRBYCRJXyRJfEVyJEl8JEl9JERrJEl9JEpPJERrJEpPJEpURXIkSlQkSlUkQWAkSlUkS1ZFciRLViRLVyRBYCRLVyZGVUVyJkZVJkZWJEFgJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFgP0hVT0VyKG4lZF8kaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJmomaFQkaSZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMmaiZ6UDs9YDwlbCZjJ3wnVV0kaSZqKFohYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFiKFNVKFohYk9ZJ31adyd9eCNPJ30jUDsnUyd9OydTOz1gKGY8JWxPJ30hYihpUDs9YDwlbCd9J3wob1A7PWA8JWwmfSdbKHldJGkmaihXcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocnApd1UoV3BPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylycCpeUDs9YDwlbClyJ1sqZFA7PWA8JWwociNTKm5YKFdwKFohYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcjUyteUDs9YDwlbCpnKG4rZFA7PWA8JWwlWjA3WytycSRpJmooV3AoWiFiJ3wwL2xPWCVaWFkrZ1laJmNaWytnW3AlWnBxK2dxciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcCRmJVokZiRnK2ckZyNCWSVaI0JZI0JaK2cjQlokSVMlWiRJUyRJXytnJElfJEpUJVokSlQkSlUrZyRKVSRLViVaJEtWJEtXK2ckS1cmRlUlWiZGVSZGVitnJkZWOydTJVo7J1M7PWArYTwlbD9IVCVaP0hUP0hVK2c/SFVPJVowN1suU1QoWCNTJGkmaid9MC9sTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMwN1subl8kaSZqKFdwKFohYid9MC9sT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVopM3AveGAkaSZqIXApLFEoV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMHohYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1cxVmAjdihDaCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMlghYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1cyZF8jdihDaCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQXQzbF8oVic6ZiRpJmooWiFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsoXjRyXyRpJmooWiFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsmejV2WCRpJmpPcjVxcnM2Y3MhXjVxIV4hXzZ5IV8jbzVxI28jcDZ5I3A7J1M1cTsnUzs9YDdoPCVsTzVxJno2alQkZGAkaSZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmNgNnxUT3I2eXJzN11zOydTNnk7J1M7PWA3YjwlbE82eWA3Yk8kZGBgN2VQOz1gPCVsNnkmejdrUDs9YDwlbDVxKF43d10kZGAkaSZqKFohYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFyOHVaKFohYk9ZOHBZWjZ5WnI4cHJzOWhzdzhwd3g2eXgjTzhwI08jUDZ5I1A7J1M4cDsnUzs9YDpSPCVsTzhwIXI5b1UkZGAoWiFiT1knfVp3J314I08nfSNQOydTJ307J1M7PWAoZjwlbE8nfSFyOlVQOz1gPCVsOHAoXjpbUDs9YDwlbDRrJTlbOmhoJGkmaihXcChaIWJPWSVaWVomY1pxJVpxcjxTcnMmfXN0JVp0dUNydXclWnd4KHJ4IV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DcihyPF9fV1MkaSZqKFdwKFohYk9ZPFNZWiZjWnI8U3JzPV5zdzxTd3hAbnghXjxTIV4hX0JtIV8jTzxTI08jUD5gI1AjbzxTI28jcEJtI3A7J1M8UzsnUzs9YENsPCVsTzxTKFE9Z11XUyRpJmooWiFiT1k9XllaJmNadz1ed3g+YHghXj1eIV4hXz9xIV8jTz1eI08jUD5gI1Ajbz1eI28jcD9xI3A7J1M9XjsnUzs9YEBoPCVsTz1eJm4+Z1hXUyRpJmpPWT5gWVomY1ohXj5gIV4hXz9TIV8jbz5gI28jcD9TI3A7J1M+YDsnUzs9YD9rPCVsTz5gUz9YU1dTT1k/U1o7J1M/UzsnUzs9YD9lPCVsTz9TUz9oUDs9YDwlbD9TJm4/blA7PWA8JWw+YCFmP3hXV1MoWiFiT1k/cVp3P3F3eD9TeCNPP3EjTyNQP1MjUDsnUz9xOydTOz1gQGI8JWxPP3EhZkBlUDs9YDwlbD9xKFFAa1A7PWA8JWw9XidgQHddV1MkaSZqKFdwT1lAbllaJmNackBucnM+YHMhXkBuIV4hX0FwIV8jT0BuI08jUD5gI1Ajb0BuI28jcEFwI3A7J1NAbjsnUzs9YEJnPCVsT0BudEF3V1dTKFdwT1lBcFpyQXBycz9TcyNPQXAjTyNQP1MjUDsnU0FwOydTOz1gQmE8JWxPQXB0QmRQOz1gPCVsQXAnYEJqUDs9YDwlbEBuI1dCdllXUyhXcChaIWJPWUJtWnJCbXJzP3Fzd0Jtd3hBcHgjT0JtI08jUD9TI1A7J1NCbTsnUzs9YENmPCVsT0JtI1dDaVA7PWA8JWxCbShyQ29QOz1gPCVsPFMlOVtDfWkkaSZqKG8lMWwoV3AoWiFiT1klWllaJmNaciVacnMmfXN0JVp0dUNydXclWnd4KHJ4IVElWiFRIVtDciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DciU5W0VvUDs9YDwlbENyMDdbRlJrJGkmaihXcChaIWIkXSN0KFQsMmooZSRJW09ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyK2RIUmskaSZqKFdwKFohYiRdI3RPWSVaWVomY1pyJVpycyZ9c3QlWnR1R3Z1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtHdiFbIV4lWiFeIV8qZyFfIWMlWiFjIX1HdiF9I08lWiNPI1AmYyNQI1IlWiNSI1NHdiNTI1QlWiNUI29HdiNvI3AqZyNwJGclWiRnOydTR3Y7J1M7PWBJdjwlbE9HditkSXlQOz1gPCVsR3YwN1tKUFA7PWA8JWxFcihLV0pfYCRpJmooV3AoWiFiI3AoQ2hPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLV0tsXyRpJmokUShDaChXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiwjeEx2YSh6K0pZJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3YlWnZ3TXt3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1dOV2AkaSZqI3ooQ2goV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQXQhIGNfKFknO1ckaSZqKFdwT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWInbCEhaV8kaSZqKFdwT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWImeiEjbVgkaSZqT3chI2h3eDZjeCFeISNoIV4hXyEkWSFfI28hI2gjbyNwISRZI3A7J1MhI2g7J1M7PWAhJHI8JWxPISNoYCEkXVRPdyEkWXd4N114OydTISRZOydTOz1gISRsPCVsTyEkWWAhJG9QOz1gPCVsISRZJnohJHVQOz1gPCVsISNoJ2whJVJdJGRgJGkmaihXcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ociFRISZQWihXcE9ZISV6WVohJFlaciElenJzISRZc3chJXp3eCEmcngjTyEleiNPI1AhJFkjUDsnUyElejsnUzs9YCEnXTwlbE8hJXohUSEmeVUkZGAoV3BPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylyIVEhJ2BQOz1gPCVsISV6J2whJ2ZQOz1gPCVsISFiLzV8ISd0XyFsLy5eJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMmVSEpT18hayFMZiRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVotIW4hKltiJGkmaihXcChaIWIoVSUmZiNxKENoT1klWllaJmNaciVacnMmfXN3JVp3eChyeHolWnp7IStkeyFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1chK29gJGkmaihXcChaIWIjbihDaE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKzt4ISx8YCRpJmooV3AoWiFicis0WU9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaLCRVIS5aXyFdK0pmJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA3WyEvZWMkaSZqKFdwKFohYiFRLjJeT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITBwIVAhUSVaIVEhWyEzWSFbIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMlfCEweWEkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEyTyFQIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMlfCEyWl8hWyFMXiRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQhM2VnJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbITNZIVshXiVaIV4hXypnIV8hZyVaIWchaCE0fCFoI08lWiNPI1AmYyNQI1IlWiNSI1MhM1kjUyNYJVojWCNZITR8I1kjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkITVWZyRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeHslWnt8ITZufH0lWn0hTyE2biFPIVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkITZ3YyRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbIThTIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyE4UyNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCE4X2MkaSZqKFdwKFohYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDdbITl1ZiRpJmooV3AoWiFiI28oQ2hPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3h6ITtaensjLX17IVAhO1ohUCFRIy9kIVEhXiE7WiFeIV8jKGkhXyFgIzdTIWAhYSM4aSFhIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaP08hO2ZiJGkmaihXcChaIWIhWDdgT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghTGN4IVAhO1ohUCFRIyZgIVEhXiE7WiFeIV8jKGkhXyF9ITtaIX0jTyMsZiNPI1AhRHkjUCNvITtaI28jcCMoaSNwOydTITtaOydTOz1gIy13PCVsTyE7Wj5eITx3YCRpJmooWiFiIVg3YE9ZITxuWVomY1p3ITxud3ghPXl4IVAhPG4hUCFRIUVxIVEhXiE8biFeIV8hR3IhXyF9ITxuIX0jTyFLUyNPI1AhRHkjUCNvITxuI28jcCFHciNwOydTITxuOydTOz1gIUxdPCVsTyE8bjx6IT5RXiRpJmohWDdgT1khPXlZWiZjWiFQIT15IVAhUSE+fCFRIV4hPXkhXiFfIUBjIV8hfSE9eSF9I08hQ1cjTyNQIUR5I1AjbyE9eSNvI3AhQGMjcDsnUyE9eTsnUzs9YCFFazwlbE8hPXk8eiE/VGQkaSZqIVg3YE8hXiZjIV8jVyZjI1cjWCE+fCNYI1omYyNaI1shPnwjWyNdJmMjXSNeIT58I14jYSZjI2EjYiE+fCNiI2cmYyNnI2ghPnwjaCNpJmMjaSNqIT58I2ojayE+fCNrI20mYyNtI24hPnwjbiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmM3YCFAaFghWDdgT1khQGNaIVAhQGMhUCFRIUFUIVEhfSFAYyF9I08hQXIjTyNQIUJxI1A7J1MhQGM7J1M7PWAhQ1E8JWxPIUBjN2AhQVlXIVg3YCNXI1ghQVQjWiNbIUFUI10jXiFBVCNhI2IhQVQjZyNoIUFUI2kjaiFBVCNqI2shQVQjbSNuIUFUN2AhQXVWT1khQXJaI08hQXIjTyNQIUJbI1AjUSFAYyNROydTIUFyOydTOz1gIUJrPCVsTyFBcjdgIUJfU09ZIUFyWjsnUyFBcjsnUzs9YCFCazwlbE8hQXI3YCFCblA7PWA8JWwhQXI3YCFCdFNPWSFAY1o7J1MhQGM7J1M7PWAhQ1E8JWxPIUBjN2AhQ1RQOz1gPCVsIUBjPHohQ11bJGkmak9ZIUNXWVomY1ohXiFDVyFeIV8hQXIhXyNPIUNXI08jUCFEUiNQI1EhPXkjUSNvIUNXI28jcCFBciNwOydTIUNXOydTOz1gIURzPCVsTyFDVzx6IURXWCRpJmpPWSFDV1laJmNaIV4hQ1chXiFfIUFyIV8jbyFDVyNvI3AhQXIjcDsnUyFDVzsnUzs9YCFEczwlbE8hQ1c8eiFEdlA7PWA8JWwhQ1c8eiFFT1gkaSZqT1khPXlZWiZjWiFeIT15IV4hXyFAYyFfI28hPXkjbyNwIUBjI3A7J1MhPXk7J1M7PWAhRWs8JWxPIT15PHohRW5QOz1gPCVsIT15Pl4hRXpsJGkmaihaIWIhWDdgT1kmfVlaJmNadyZ9d3gmY3ghXiZ9IV4hXyd9IV8jTyZ9I08jUCZjI1AjVyZ9I1cjWCFFcSNYI1omfSNaI1shRXEjWyNdJn0jXSNeIUVxI14jYSZ9I2EjYiFFcSNiI2cmfSNnI2ghRXEjaCNpJn0jaSNqIUVxI2ojayFFcSNrI20mfSNtI24hRXEjbiNvJn0jbyNwJ30jcDsnUyZ9OydTOz1gKGw8JWxPJn04ciFHeVooWiFiIVg3YE9ZIUdyWnchR3J3eCFAY3ghUCFHciFQIVEhSGwhUSF9IUdyIX0jTyFKVSNPI1AhQnEjUDsnUyFHcjsnUzs9YCFKfDwlbE8hR3I4ciFIc2UoWiFiIVg3YE9ZJ31adyd9eCNPJ30jUCNXJ30jVyNYIUhsI1gjWid9I1ojWyFIbCNbI10nfSNdI14hSGwjXiNhJ30jYSNiIUhsI2IjZyd9I2cjaCFIbCNoI2knfSNpI2ohSGwjaiNrIUhsI2sjbSd9I20jbiFIbCNuOydTJ307J1M7PWAoZjwlbE8nfThyIUpaWChaIWJPWSFKVVp3IUpVd3ghQXJ4I08hSlUjTyNQIUJbI1AjUSFHciNROydTIUpVOydTOz1gIUp2PCVsTyFKVThyIUp5UDs9YDwlbCFKVThyIUtQUDs9YDwlbCFHcj5eIUtaXiRpJmooWiFiT1khS1NZWiZjWnchS1N3eCFDV3ghXiFLUyFeIV8hSlUhXyNPIUtTI08jUCFEUiNQI1EhPG4jUSNvIUtTI28jcCFKVSNwOydTIUtTOydTOz1gIUxWPCVsTyFLUz5eIUxZUDs9YDwlbCFLUz5eIUxgUDs9YDwlbCE8bj1sIUxsYCRpJmooV3AhWDdgT1khTGNZWiZjWnIhTGNycyE9eXMhUCFMYyFQIVEhTW4hUSFeIUxjIV4hXyMgbyFfIX0hTGMhfSNPIyVQI08jUCFEeSNQI28hTGMjbyNwIyBvI3A7J1MhTGM7J1M7PWAjJlk8JWxPIUxjPWwhTXdsJGkmaihXcCFYN2BPWShyWVomY1pyKHJycyZjcyFeKHIhXiFfKXIhXyNPKHIjTyNQJmMjUCNXKHIjVyNYIU1uI1gjWihyI1ojWyFNbiNbI10ociNdI14hTW4jXiNhKHIjYSNiIU1uI2IjZyhyI2cjaCFNbiNoI2kociNpI2ohTW4jaiNrIU1uI2sjbShyI20jbiFNbiNuI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocjhRIyB2WihXcCFYN2BPWSMgb1pyIyBvcnMhQGNzIVAjIG8hUCFRIyFpIVEhfSMgbyF9I08jJFIjTyNQIUJxI1A7J1MjIG87J1M7PWAjJHk8JWxPIyBvOFEjIXBlKFdwIVg3YE9ZKXJacilycyNPKXIjUCNXKXIjVyNYIyFpI1gjWilyI1ojWyMhaSNbI10pciNdI14jIWkjXiNhKXIjYSNiIyFpI2IjZylyI2cjaCMhaSNoI2kpciNpI2ojIWkjaiNrIyFpI2sjbSlyI20jbiMhaSNuOydTKXI7J1M7PWAqWjwlbE8pcjhRIyRXWChXcE9ZIyRSWnIjJFJycyFBcnMjTyMkUiNPI1AhQlsjUCNRIyBvI1E7J1MjJFI7J1M7PWAjJHM8JWxPIyRSOFEjJHZQOz1gPCVsIyRSOFEjJHxQOz1gPCVsIyBvPWwjJVdeJGkmaihXcE9ZIyVQWVomY1pyIyVQcnMhQ1dzIV4jJVAhXiFfIyRSIV8jTyMlUCNPI1AhRFIjUCNRIUxjI1EjbyMlUCNvI3AjJFIjcDsnUyMlUDsnUzs9YCMmUzwlbE8jJVA9bCMmVlA7PWA8JWwjJVA9bCMmXVA7PWA8JWwhTGM/TyMma24kaSZqKFdwKFohYiFYN2BPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1clWiNXI1gjJmAjWCNaJVojWiNbIyZgI1sjXSVaI10jXiMmYCNeI2ElWiNhI2IjJmAjYiNnJVojZyNoIyZgI2gjaSVaI2kjaiMmYCNqI2sjJmAjayNtJVojbSNuIyZgI24jbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaOWQjKHJdKFdwKFohYiFYN2BPWSMoaVpyIyhpcnMhR3JzdyMoaXd4IyBveCFQIyhpIVAhUSMpayFRIX0jKGkhfSNPIytgI08jUCFCcSNQOydTIyhpOydTOz1gIyxgPCVsTyMoaTlkIyl0aChXcChaIWIhWDdgT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQI1cqZyNXI1gjKWsjWCNaKmcjWiNbIylrI1sjXSpnI10jXiMpayNeI2EqZyNhI2IjKWsjYiNnKmcjZyNoIylrI2gjaSpnI2kjaiMpayNqI2sjKWsjayNtKmcjbSNuIylrI247J1MqZzsnUzs9YCtaPCVsTypnOWQjK2daKFdwKFohYk9ZIytgWnIjK2BycyFKVXN3Iytgd3gjJFJ4I08jK2AjTyNQIUJbI1AjUSMoaSNROydTIytgOydTOz1gIyxZPCVsTyMrYDlkIyxdUDs9YDwlbCMrYDlkIyxjUDs9YDwlbCMoaT9PIyxvYCRpJmooV3AoWiFiT1kjLGZZWiZjWnIjLGZycyFLU3N3Iyxmd3gjJVB4IV4jLGYhXiFfIytgIV8jTyMsZiNPI1AhRFIjUCNRITtaI1EjbyMsZiNvI3AjK2AjcDsnUyMsZjsnUzs9YCMtcTwlbE8jLGY/TyMtdFA7PWA8JWwjLGY/TyMtelA7PWA8JWwhO1owN1sjLltiJGkmaihXcChaIWIoTzAvbCFYN2BPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3ghUCE7WiFQIVEjJmAhUSFeITtaIV4hXyMoaSFfIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaMDdbIy9vXyRpJmooV3AoWiFiVDAvbE9ZIy9kWVomY1pyIy9kcnMjMG5zdyMvZHd4IzRPeCFeIy9kIV4hXyM1fSFfI08jL2QjTyNQIzFwI1AjbyMvZCNvI3AjNX0jcDsnUyMvZDsnUzs9YCM2fDwlbE8jL2QwNmojMHddJGkmaihaIWJUMC9sT1kjMG5ZWiZjWncjMG53eCMxcHghXiMwbiFeIV8jM1IhXyNPIzBuI08jUCMxcCNQI28jMG4jbyNwIzNSI3A7J1MjMG47J1M7PWAjM3g8JWxPIzBuMDVXIzF3WCRpJmpUMC9sT1kjMXBZWiZjWiFeIzFwIV4hXyMyZCFfI28jMXAjbyNwIzJkI3A7J1MjMXA7J1M7PWAjMns8JWxPIzFwMC9sIzJpU1QwL2xPWSMyZFo7J1MjMmQ7J1M7PWAjMnU8JWxPIzJkMC9sIzJ4UDs9YDwlbCMyZDA1VyMzT1A7PWA8JWwjMXAwMU8jM1lXKFohYlQwL2xPWSMzUlp3IzNSd3gjMmR4I08jM1IjTyNQIzJkI1A7J1MjM1I7J1M7PWAjM3I8JWxPIzNSMDFPIzN1UDs9YDwlbCMzUjA2aiMze1A7PWA8JWwjMG4wNXgjNFhdJGkmaihXcFQwL2xPWSM0T1laJmNaciM0T3JzIzFwcyFeIzRPIV4hXyM1USFfI08jNE8jTyNQIzFwI1AjbyM0TyNvI3AjNVEjcDsnUyM0TzsnUzs9YCM1dzwlbE8jNE8wMF4jNVhXKFdwVDAvbE9ZIzVRWnIjNVFycyMyZHMjTyM1USNPI1AjMmQjUDsnUyM1UTsnUzs9YCM1cTwlbE8jNVEwMF4jNXRQOz1gPCVsIzVRMDV4IzV6UDs9YDwlbCM0TzAxcCM2V1koV3AoWiFiVDAvbE9ZIzV9WnIjNX1ycyMzUnN3IzV9d3gjNVF4I08jNX0jTyNQIzJkI1A7J1MjNX07J1M7PWAjNnY8JWxPIzV9MDFwIzZ5UDs9YDwlbCM1fTA3WyM3UFA7PWA8JWwjL2QpM2gjN2FiJGkmaiRRKENoKFdwKFohYiFYN2BPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3ghUCE7WiFQIVEjJmAhUSFeITtaIV4hXyMoaSFfIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaQXQjOHZiJFojdCRpJmooV3AoWiFiIVg3YE9ZITtaWVomY1pyITtacnMhPG5zdyE7Wnd4IUxjeCFQITtaIVAhUSMmYCFRIV4hO1ohXiFfIyhpIV8hfSE7WiF9I08jLGYjTyNQIUR5I1AjbyE7WiNvI3AjKGkjcDsnUyE7WjsnUzs9YCMtdzwlbE8hO1onQWQjOlpwJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITNZIVAhUSVaIVEhWyM8XyFbIV4lWiFeIV8qZyFfIWclWiFnIWghNHwhaCNPJVojTyNQJmMjUCNSJVojUiNTIzxfI1MjVSVaI1UjViM/aSNWI1glWiNYI1khNHwjWSNiJVojYiNjIz5fI2MjZCNCcSNkI2wlWiNsI20jRXMjbSNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjPGprJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITNZIVAhUSVaIVEhWyM8XyFbIV4lWiFeIV8qZyFfIWclWiFnIWghNHwhaCNPJVojTyNQJmMjUCNSJVojUiNTIzxfI1MjWCVaI1gjWSE0fCNZI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjPmpfJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjP3JkJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVIjQVEhUiFTI0FRIVMhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNBUSNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCNBXWYkaSZqKFdwKFohYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVIjQVEhUiFTI0FRIVMhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNBUSNTI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjQnpjJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVkjRFYhWSFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTI0RWI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0RiZSRpJmooV3AoWiFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWSNEViFZIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjRFYjUyNiJVojYiNjIz5fI2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0V8ZyRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbI0dlIVshXiVaIV4hXypnIV8hYyVaIWMhaSNHZSFpI08lWiNPI1AmYyNQI1IlWiNSI1MjR2UjUyNUJVojVCNaI0dlI1ojbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0dwaSRpJmooV3AoWiFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyNHZSFbIV4lWiFeIV8qZyFfIWMlWiFjIWkjR2UhaSNPJVojTyNQJmMjUCNSJVojUiNTI0dlI1MjVCVaI1QjWiNHZSNaI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoqKXgjSWxfIWckYiRpJmokTylMdihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWilbI0p2X2FsJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA0ZiNMU15oIylgI1ItPFUoV3AoWiFiJG43YE9ZKmdacipncnMnfXN3Kmd3eClyeCFQKmchUCFRI01PIVEhXipnIV4hXyNNdCFfIWAkIGYhYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcobiNNWFgkayZqKFdwKFohYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcoRWwjTX1aI3IoQ2goV3AoWiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4IV8qZyFfIWAjTnAhYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcoRWwjTnlYJFEoQ2goV3AoWiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyhFbCQgb1gjcyhDaChXcChaIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnKil4JCFnYSNgKiFZJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAweiFgIWEkI2whYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1skI3dfI2soQ2wkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKil4JCVWYWchKnIjcyhDaCRmI3wkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYCQmWyFgIWEkJ2YhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckJmdfI3MoQ2gkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXJCdxYSNyKENoJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgIWEkKHYhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckKVJgI3IoQ2gkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtkJCpgYShyKEN0JGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWElWiFhIWIkK2UhYiNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckK3BgJGkmaiN7KENoKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJSNgJCx9XyF8JElwJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA0ZiQuWF8hUzAsdiRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoobiQvXVokaSZqTyFeJDBPIV4hXyQwZiFfI2kkME8jaSNqJDBrI2ojbCQwTyNsI20kMl4jbSNvJDBPI28jcCQwZiNwOydTJDBPOydTOz1gJDRpPCVsTyQwTyhuJDBWVF8jUyRpJmpPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyNTJDBrT18jUyhuJDBwWyRpJmpPIVEmYyFRIVskMWYhWyFeJmMhXyFjJmMhYyFpJDFmIWkjVCZjI1QjWiQxZiNaI28mYyNvI3AkM3wjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQxa1okaSZqTyFRJmMhUSFbJDJeIVshXiZjIV8hYyZjIWMhaSQyXiFpI1QmYyNUI1okMl4jWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQyY1okaSZqTyFRJmMhUSFbJDNVIVshXiZjIV8hYyZjIWMhaSQzVSFpI1QmYyNUI1okM1UjWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQzWlokaSZqTyFRJmMhUSFbJDBPIVshXiZjIV8hYyZjIWMhaSQwTyFpI1QmYyNUI1okME8jWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMjUyQ0UFIhUSFbJDRZIWMhaSQ0WSNUI1okNFkjUyQ0XVMhUSFbJDRZIWMhaSQ0WSNUI1okNFkjcSNyJDBmKG4kNGxQOz1gPCVsJDBPIzFbJDR6XyFZIylsJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVyQ2VWAjeChDaCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVorO3AkN2NfJGkmaihXcChaIWIoYSs0UU9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDdbJDhxayRpJmooV3AoWiFiKFQsMmokXyN0KGUkSVtPWSVaWVomY1pyJVpycyZ9c3QlWnR1JDhidXclWnd4KHJ4fSVafSFPJDpmIU8hUSVaIVEhWyQ4YiFbIV4lWiFeIV8qZyFfIWMlWiFjIX0kOGIhfSNPJVojTyNQJmMjUCNSJVojUiNTJDhiI1MjVCVaI1QjbyQ4YiNvI3AqZyNwJGclWiRnOydTJDhiOydTOz1gJDxsPCVsTyQ4YitkJDpxayRpJmooV3AoWiFiJF8jdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHUkOmZ1dyVad3gocnh9JVp9IU8kOmYhTyFRJVohUSFbJDpmIVshXiVaIV4hXypnIV8hYyVaIWMhfSQ6ZiF9I08lWiNPI1AmYyNQI1IlWiNSI1MkOmYjUyNUJVojVCNvJDpmI28jcCpnI3AkZyVaJGc7J1MkOmY7J1M7PWAkPGY8JWxPJDpmK2QkPGlQOz1gPCVsJDpmMDdbJDxvUDs9YDwlbCQ4YiNKZiQ8e1ghXyNIYihXcChaIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnLCN4JD1zYSh5K0pZJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwI3EkK2UjcTsnUyVaOydTOz1gK2E8JWxPJVopPnYkP1ZfIV4oQ2R2QnIkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaP08kQGFfIXE3YCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVowN1skQXF8JGkmaihXcChaIWInfDAvbCRdI3QoVCwyaihlJElbT1glWlhZK2dZWiZjWlsrZ1twJVpwcStncXIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZiVaJGYkZytnJGcjQllFciNCWSNCWiRBYCNCWiRJU0VyJElTJElfJEFgJElfJEpURXIkSlQkSlUkQWAkSlUkS1ZFciRLViRLVyRBYCRLVyZGVUVyJkZVJkZWJEFgJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFgP0hVT0VyMDdbJER8ayRpJmooV3AoWiFiJ30wL2wkXSN0KFQsMmooZSRJW09ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyXCIsXG4gIHRva2VuaXplcnM6IFtub1NlbWljb2xvbiwgbm9TZW1pY29sb25UeXBlLCBvcGVyYXRvclRva2VuLCBqc3gsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgaW5zZXJ0U2VtaWNvbG9uLCBuZXcgTG9jYWxUb2tlbkdyb3VwKFwiJFN+UlJ0dVsjTyNQZyNTI1QjfH5fUCNvI3BifmdPeH5+alZPI2khUCNpI2ohVSNqI2whUCNsI20hcSNtOydTIVA7J1M7PWAjdjwlbE8hUH4hVU8hVX5+IVhTIVEhWyFlIWMhaSFlI1QjWiFlI28jcCNafiFoUiFRIVshcSFjIWkhcSNUI1ohcX4hdFIhUSFbIX0hYyFpIX0jVCNaIX1+I1FSIVEhWyFQIWMhaSFQI1QjWiFQfiNeUiFRIVsjZyFjIWkjZyNUI1ojZ34jalMhUSFbI2chYyFpI2cjVCNaI2cjcSNyIVB+I3lQOz1gPCVsIVB+JFJPKGN+flwiLCAxNDEsIDM0MCksIG5ldyBMb2NhbFRva2VuR3JvdXAoXCJqflJRWVpYentefl5PKFF+fmFQIVAhUWR+aU8oUn5+XCIsIDI1LCAzMjMpXSxcbiAgdG9wUnVsZXM6IHtcIlNjcmlwdFwiOlswLDddLFwiU2luZ2xlRXhwcmVzc2lvblwiOlsxLDI3Nl0sXCJTaW5nbGVDbGFzc0l0ZW1cIjpbMiwyNzddfSxcbiAgZGlhbGVjdHM6IHtqc3g6IDAsIHRzOiAxNTE3NX0sXG4gIGR5bmFtaWNQcmVjZWRlbmNlczoge1wiODBcIjoxLFwiODJcIjoxLFwiOTRcIjoxLFwiMTY5XCI6MSxcIjE5OVwiOjF9LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAzMjcsIGdldDogKHZhbHVlKSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfSx7dGVybTogMzQzLCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY193b3JkW3ZhbHVlXSB8fCAtMX0se3Rlcm06IDk1LCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19MZXNzVGhhblt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiAxNTIwMVxufSk7XG5cbmV4cG9ydCB7IHBhcnNlciB9O1xuIiwgImltcG9ydCB7IHBhcnNlciB9IGZyb20gJ0BsZXplci9qYXZhc2NyaXB0JztcbmltcG9ydCB7IHN5bnRheFRyZWUsIExSTGFuZ3VhZ2UsIGluZGVudE5vZGVQcm9wLCBjb250aW51ZWRJbmRlbnQsIGZsYXRJbmRlbnQsIGRlbGltaXRlZEluZGVudCwgZm9sZE5vZGVQcm9wLCBmb2xkSW5zaWRlLCBkZWZpbmVMYW5ndWFnZUZhY2V0LCBzdWJsYW5ndWFnZVByb3AsIExhbmd1YWdlU3VwcG9ydCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IEVkaXRvclNlbGVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHNuaXBwZXRDb21wbGV0aW9uLCBpZk5vdEluLCBjb21wbGV0ZUZyb21MaXN0IH0gZnJvbSAnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJztcbmltcG9ydCB7IE5vZGVXZWFrTWFwLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkEgY29sbGVjdGlvbiBvZiBKYXZhU2NyaXB0LXJlbGF0ZWRcbltzbmlwcGV0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc25pcHBldCkuXG4qL1xuY29uc3Qgc25pcHBldHMgPSBbXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZnVuY3Rpb24gJHtuYW1lfSgke3BhcmFtc30pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmb3IgKGxldCAke2luZGV4fSA9IDA7ICR7aW5kZXh9IDwgJHtib3VuZH07ICR7aW5kZXh9KyspIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZm9yXCIsXG4gICAgICAgIGRldGFpbDogXCJsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZm9yIChsZXQgJHtuYW1lfSBvZiAke2NvbGxlY3Rpb259KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImZvclwiLFxuICAgICAgICBkZXRhaWw6IFwib2YgbG9vcFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImRvIHtcXG5cXHQke31cXG59IHdoaWxlICgke30pXCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZG9cIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ3aGlsZSAoJHt9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcIndoaWxlXCIsXG4gICAgICAgIGRldGFpbDogXCJsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwidHJ5IHtcXG5cXHQke31cXG59IGNhdGNoICgke2Vycm9yfSkge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJ0cnlcIixcbiAgICAgICAgZGV0YWlsOiBcIi8gY2F0Y2ggYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpZiAoJHt9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImlmXCIsXG4gICAgICAgIGRldGFpbDogXCJibG9ja1wiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImlmICgke30pIHtcXG5cXHQke31cXG59IGVsc2Uge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJpZlwiLFxuICAgICAgICBkZXRhaWw6IFwiLyBlbHNlIGJsb2NrXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiY2xhc3MgJHtuYW1lfSB7XFxuXFx0Y29uc3RydWN0b3IoJHtwYXJhbXN9KSB7XFxuXFx0XFx0JHt9XFxuXFx0fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJjbGFzc1wiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImltcG9ydCB7JHtuYW1lc319IGZyb20gXFxcIiR7bW9kdWxlfVxcXCJcXG4ke31cIiwge1xuICAgICAgICBsYWJlbDogXCJpbXBvcnRcIixcbiAgICAgICAgZGV0YWlsOiBcIm5hbWVkXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaW1wb3J0ICR7bmFtZX0gZnJvbSBcXFwiJHttb2R1bGV9XFxcIlxcbiR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImltcG9ydFwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmYXVsdFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pXG5dO1xuLyoqXG5BIGNvbGxlY3Rpb24gb2Ygc25pcHBldCBjb21wbGV0aW9ucyBmb3IgVHlwZVNjcmlwdC4gSW5jbHVkZXMgdGhlXG5KYXZhU2NyaXB0IFtzbmlwcGV0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLWphdmFzY3JpcHQuc25pcHBldHMpLlxuKi9cbmNvbnN0IHR5cGVzY3JpcHRTbmlwcGV0cyA9IC8qQF9fUFVSRV9fKi9zbmlwcGV0cy5jb25jYXQoW1xuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImludGVyZmFjZSAke25hbWV9IHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaW50ZXJmYWNlXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwidHlwZSAke25hbWV9ID0gJHt0eXBlfVwiLCB7XG4gICAgICAgIGxhYmVsOiBcInR5cGVcIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJlbnVtICR7bmFtZX0ge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJlbnVtXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSlcbl0pO1xuXG5jb25zdCBjYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVdlYWtNYXAoKTtcbmNvbnN0IFNjb3BlTm9kZXMgPSAvKkBfX1BVUkVfXyovbmV3IFNldChbXG4gICAgXCJTY3JpcHRcIiwgXCJCbG9ja1wiLFxuICAgIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBcIkFycm93RnVuY3Rpb25cIiwgXCJNZXRob2REZWNsYXJhdGlvblwiLFxuICAgIFwiRm9yU3RhdGVtZW50XCJcbl0pO1xuZnVuY3Rpb24gZGVmSUQodHlwZSkge1xuICAgIHJldHVybiAobm9kZSwgZGVmKSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG5vZGUubm9kZS5nZXRDaGlsZChcIlZhcmlhYmxlRGVmaW5pdGlvblwiKTtcbiAgICAgICAgaWYgKGlkKVxuICAgICAgICAgICAgZGVmKGlkLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmNvbnN0IGZ1bmN0aW9uQ29udGV4dCA9IFtcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIl07XG5jb25zdCBnYXRoZXJDb21wbGV0aW9ucyA9IHtcbiAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJmdW5jdGlvblwiKSxcbiAgICBDbGFzc0RlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJjbGFzc1wiKSxcbiAgICBDbGFzc0V4cHJlc3Npb246ICgpID0+IHRydWUsXG4gICAgRW51bURlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJjb25zdGFudFwiKSxcbiAgICBUeXBlQWxpYXNEZWNsYXJhdGlvbjogLypAX19QVVJFX18qL2RlZklEKFwidHlwZVwiKSxcbiAgICBOYW1lc3BhY2VEZWNsYXJhdGlvbjogLypAX19QVVJFX18qL2RlZklEKFwibmFtZXNwYWNlXCIpLFxuICAgIFZhcmlhYmxlRGVmaW5pdGlvbihub2RlLCBkZWYpIHsgaWYgKCFub2RlLm1hdGNoQ29udGV4dChmdW5jdGlvbkNvbnRleHQpKVxuICAgICAgICBkZWYobm9kZSwgXCJ2YXJpYWJsZVwiKTsgfSxcbiAgICBUeXBlRGVmaW5pdGlvbihub2RlLCBkZWYpIHsgZGVmKG5vZGUsIFwidHlwZVwiKTsgfSxcbiAgICBfX3Byb3RvX186IG51bGxcbn07XG5mdW5jdGlvbiBnZXRTY29wZShkb2MsIG5vZGUpIHtcbiAgICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgbGV0IGNvbXBsZXRpb25zID0gW10sIHRvcCA9IHRydWU7XG4gICAgZnVuY3Rpb24gZGVmKG5vZGUsIHR5cGUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBkb2Muc2xpY2VTdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKTtcbiAgICAgICAgY29tcGxldGlvbnMucHVzaCh7IGxhYmVsOiBuYW1lLCB0eXBlIH0pO1xuICAgIH1cbiAgICBub2RlLmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKS5pdGVyYXRlKG5vZGUgPT4ge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICB0b3AgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgIGxldCBnYXRoZXIgPSBnYXRoZXJDb21wbGV0aW9uc1tub2RlLm5hbWVdO1xuICAgICAgICAgICAgaWYgKGdhdGhlciAmJiBnYXRoZXIobm9kZSwgZGVmKSB8fCBTY29wZU5vZGVzLmhhcyhub2RlLm5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnRvIC0gbm9kZS5mcm9tID4gODE5Mikge1xuICAgICAgICAgICAgLy8gQWxsb3cgY2FjaGluZyBmb3IgYmlnZ2VyIGludGVybmFsIG5vZGVzXG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGdldFNjb3BlKGRvYywgbm9kZS5ub2RlKSlcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKGMpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY2FjaGUuc2V0KG5vZGUsIGNvbXBsZXRpb25zKTtcbiAgICByZXR1cm4gY29tcGxldGlvbnM7XG59XG5jb25zdCBJZGVudGlmaWVyID0gL15bXFx3JFxceGExLVxcdWZmZmZdW1xcdyRcXGRcXHhhMS1cXHVmZmZmXSokLztcbmNvbnN0IGRvbnRDb21wbGV0ZSA9IFtcbiAgICBcIlRlbXBsYXRlU3RyaW5nXCIsIFwiU3RyaW5nXCIsIFwiUmVnRXhwXCIsXG4gICAgXCJMaW5lQ29tbWVudFwiLCBcIkJsb2NrQ29tbWVudFwiLFxuICAgIFwiVmFyaWFibGVEZWZpbml0aW9uXCIsIFwiVHlwZURlZmluaXRpb25cIiwgXCJMYWJlbFwiLFxuICAgIFwiUHJvcGVydHlEZWZpbml0aW9uXCIsIFwiUHJvcGVydHlOYW1lXCIsXG4gICAgXCJQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uXCIsIFwiUHJpdmF0ZVByb3BlcnR5TmFtZVwiLFxuICAgIFwiSlNYVGV4dFwiLCBcIkpTWEF0dHJpYnV0ZVZhbHVlXCIsIFwiSlNYT3BlblRhZ1wiLCBcIkpTWENsb3NlVGFnXCIsIFwiSlNYU2VsZkNsb3NpbmdUYWdcIixcbiAgICBcIi5cIiwgXCI/LlwiXG5dO1xuLyoqXG5Db21wbGV0aW9uIHNvdXJjZSB0aGF0IGxvb2tzIHVwIGxvY2FsbHkgZGVmaW5lZCBuYW1lcyBpblxuSmF2YVNjcmlwdCBjb2RlLlxuKi9cbmZ1bmN0aW9uIGxvY2FsQ29tcGxldGlvblNvdXJjZShjb250ZXh0KSB7XG4gICAgbGV0IGlubmVyID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTtcbiAgICBpZiAoZG9udENvbXBsZXRlLmluZGV4T2YoaW5uZXIubmFtZSkgPiAtMSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGlzV29yZCA9IGlubmVyLm5hbWUgPT0gXCJWYXJpYWJsZU5hbWVcIiB8fFxuICAgICAgICBpbm5lci50byAtIGlubmVyLmZyb20gPCAyMCAmJiBJZGVudGlmaWVyLnRlc3QoY29udGV4dC5zdGF0ZS5zbGljZURvYyhpbm5lci5mcm9tLCBpbm5lci50bykpO1xuICAgIGlmICghaXNXb3JkICYmICFjb250ZXh0LmV4cGxpY2l0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb3B0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IGlubmVyOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgaWYgKFNjb3BlTm9kZXMuaGFzKHBvcy5uYW1lKSlcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmNvbmNhdChnZXRTY29wZShjb250ZXh0LnN0YXRlLmRvYywgcG9zKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGZyb206IGlzV29yZCA/IGlubmVyLmZyb20gOiBjb250ZXh0LnBvcyxcbiAgICAgICAgdmFsaWRGb3I6IElkZW50aWZpZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gcGF0aEZvcihyZWFkLCBtZW1iZXIsIG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhdGggPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBvYmogPSBtZW1iZXIuZmlyc3RDaGlsZCwgcHJvcDtcbiAgICAgICAgaWYgKChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmoubmFtZSkgPT0gXCJWYXJpYWJsZU5hbWVcIikge1xuICAgICAgICAgICAgcGF0aC5wdXNoKHJlYWQob2JqKSk7XG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLnJldmVyc2UoKSwgbmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmoubmFtZSkgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgKChfYSA9IChwcm9wID0gb2JqLmxhc3RDaGlsZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PSBcIlByb3BlcnR5TmFtZVwiKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gocmVhZChwcm9wKSk7XG4gICAgICAgICAgICBtZW1iZXIgPSBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuSGVscGVyIGZ1bmN0aW9uIGZvciBkZWZpbmluZyBKYXZhU2NyaXB0IGNvbXBsZXRpb24gc291cmNlcy4gSXRcbnJldHVybnMgdGhlIGNvbXBsZXRhYmxlIG5hbWUgYW5kIG9iamVjdCBwYXRoIGZvciBhIGNvbXBsZXRpb25cbmNvbnRleHQsIG9yIG51bGwgaWYgbm8gbmFtZS9wcm9wZXJ0eSBjb21wbGV0aW9uIHNob3VsZCBoYXBwZW4gYXRcbnRoYXQgcG9zaXRpb24uIEZvciBleGFtcGxlLCB3aGVuIGNvbXBsZXRpbmcgYWZ0ZXIgYGEuYi5jYCBpdCB3aWxsXG5yZXR1cm4gYHtwYXRoOiBbXCJhXCIsIFwiYlwiXSwgbmFtZTogXCJjXCJ9YC4gV2hlbiBjb21wbGV0aW5nIGFmdGVyIGB4YFxuaXQgd2lsbCByZXR1cm4gYHtwYXRoOiBbXSwgbmFtZTogXCJ4XCJ9YC4gV2hlbiBub3QgaW4gYSBwcm9wZXJ0eSBvclxubmFtZSwgaXQgd2lsbCByZXR1cm4gbnVsbCBpZiBgY29udGV4dC5leHBsaWNpdGAgaXMgZmFsc2UsIGFuZFxuYHtwYXRoOiBbXSwgbmFtZTogXCJcIn1gIG90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBjb21wbGV0aW9uUGF0aChjb250ZXh0KSB7XG4gICAgbGV0IHJlYWQgPSAobm9kZSkgPT4gY29udGV4dC5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKTtcbiAgICBsZXQgaW5uZXIgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpO1xuICAgIGlmIChpbm5lci5uYW1lID09IFwiUHJvcGVydHlOYW1lXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhGb3IocmVhZCwgaW5uZXIucGFyZW50LCByZWFkKGlubmVyKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChpbm5lci5uYW1lID09IFwiLlwiIHx8IGlubmVyLm5hbWUgPT0gXCI/LlwiKSAmJiBpbm5lci5wYXJlbnQubmFtZSA9PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gcGF0aEZvcihyZWFkLCBpbm5lci5wYXJlbnQsIFwiXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb250Q29tcGxldGUuaW5kZXhPZihpbm5lci5uYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbm5lci5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIgfHwgaW5uZXIudG8gLSBpbm5lci5mcm9tIDwgMjAgJiYgSWRlbnRpZmllci50ZXN0KHJlYWQoaW5uZXIpKSkge1xuICAgICAgICByZXR1cm4geyBwYXRoOiBbXSwgbmFtZTogcmVhZChpbm5lcikgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5uZXIubmFtZSA9PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gcGF0aEZvcihyZWFkLCBpbm5lciwgXCJcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGV4dC5leHBsaWNpdCA/IHsgcGF0aDogW10sIG5hbWU6IFwiXCIgfSA6IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZW51bWVyYXRlUHJvcGVydHlDb21wbGV0aW9ucyhvYmosIHRvcCkge1xuICAgIGxldCBvcHRpb25zID0gW10sIHNlZW4gPSBuZXcgU2V0O1xuICAgIGZvciAobGV0IGRlcHRoID0gMDs7IGRlcHRoKyspIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBvZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgT2JqZWN0LmtleXMpKG9iaikpIHtcbiAgICAgICAgICAgIGlmICghL15bYS16QS1aXyRcXHhhYS1cXHVmZmRjXVtcXHckXFx4YWEtXFx1ZmZkY10qJC8udGVzdChuYW1lKSB8fCBzZWVuLmhhcyhuYW1lKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHNlZW4uYWRkKG5hbWUpO1xuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9ialtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIgPyAoL15bQS1aXS8udGVzdChuYW1lKSA/IFwiY2xhc3NcIiA6IHRvcCA/IFwiZnVuY3Rpb25cIiA6IFwibWV0aG9kXCIpXG4gICAgICAgICAgICAgICAgICAgIDogdG9wID8gXCJ2YXJpYWJsZVwiIDogXCJwcm9wZXJ0eVwiLFxuICAgICAgICAgICAgICAgIGJvb3N0OiAtZGVwdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICBvYmogPSBuZXh0O1xuICAgIH1cbn1cbi8qKlxuRGVmaW5lcyBhIFtjb21wbGV0aW9uIHNvdXJjZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvblNvdXJjZSkgdGhhdFxuY29tcGxldGVzIGZyb20gdGhlIGdpdmVuIHNjb3BlIG9iamVjdCAoZm9yIGV4YW1wbGUgYGdsb2JhbFRoaXNgKS5cbldpbGwgZW50ZXIgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IHdoZW4gY29tcGxldGluZyBwcm9wZXJ0aWVzIG9uXG5hIGRpcmVjdGx5LW5hbWVkIHBhdGguXG4qL1xuZnVuY3Rpb24gc2NvcGVDb21wbGV0aW9uU291cmNlKHNjb3BlKSB7XG4gICAgbGV0IGNhY2hlID0gbmV3IE1hcDtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IHBhdGggPSBjb21wbGV0aW9uUGF0aChjb250ZXh0KTtcbiAgICAgICAgaWYgKCFwYXRoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0YXJnZXQgPSBzY29wZTtcbiAgICAgICAgZm9yIChsZXQgc3RlcCBvZiBwYXRoLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtzdGVwXTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcHRpb25zID0gY2FjaGUuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIGNhY2hlLnNldCh0YXJnZXQsIG9wdGlvbnMgPSBlbnVtZXJhdGVQcm9wZXJ0eUNvbXBsZXRpb25zKHRhcmdldCwgIXBhdGgucGF0aC5sZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGNvbnRleHQucG9zIC0gcGF0aC5uYW1lLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB2YWxpZEZvcjogSWRlbnRpZmllclxuICAgICAgICB9O1xuICAgIH07XG59XG5cbi8qKlxuQSBsYW5ndWFnZSBwcm92aWRlciBiYXNlZCBvbiB0aGUgW0xlemVyIEphdmFTY3JpcHRcbnBhcnNlcl0oaHR0cHM6Ly9naXRodWIuY29tL2xlemVyLXBhcnNlci9qYXZhc2NyaXB0KSwgZXh0ZW5kZWQgd2l0aFxuaGlnaGxpZ2h0aW5nIGFuZCBpbmRlbnRhdGlvbiBpbmZvcm1hdGlvbi5cbiovXG5jb25zdCBqYXZhc2NyaXB0TGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovTFJMYW5ndWFnZS5kZWZpbmUoe1xuICAgIG5hbWU6IFwiamF2YXNjcmlwdFwiLFxuICAgIHBhcnNlcjogLypAX19QVVJFX18qL3BhcnNlci5jb25maWd1cmUoe1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgLypAX19QVVJFX18qL2luZGVudE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgSWZTdGF0ZW1lbnQ6IC8qQF9fUFVSRV9fKi9jb250aW51ZWRJbmRlbnQoeyBleGNlcHQ6IC9eXFxzKih7fGVsc2VcXGIpLyB9KSxcbiAgICAgICAgICAgICAgICBUcnlTdGF0ZW1lbnQ6IC8qQF9fUFVSRV9fKi9jb250aW51ZWRJbmRlbnQoeyBleGNlcHQ6IC9eXFxzKih7fGNhdGNoXFxifGZpbmFsbHlcXGIpLyB9KSxcbiAgICAgICAgICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBmbGF0SW5kZW50LFxuICAgICAgICAgICAgICAgIFN3aXRjaEJvZHk6IGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBjb250ZXh0LnRleHRBZnRlciwgY2xvc2VkID0gL15cXHMqXFx9Ly50ZXN0KGFmdGVyKSwgaXNDYXNlID0gL15cXHMqKGNhc2V8ZGVmYXVsdClcXGIvLnRlc3QoYWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBpc0Nhc2UgPyAxIDogMikgKiBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBCbG9jazogLypAX19QVVJFX18qL2RlbGltaXRlZEluZGVudCh7IGNsb3Npbmc6IFwifVwiIH0pLFxuICAgICAgICAgICAgICAgIEFycm93RnVuY3Rpb246IGN4ID0+IGN4LmJhc2VJbmRlbnQgKyBjeC51bml0LFxuICAgICAgICAgICAgICAgIFwiVGVtcGxhdGVTdHJpbmcgQmxvY2tDb21tZW50XCI6ICgpID0+IG51bGwsXG4gICAgICAgICAgICAgICAgXCJTdGF0ZW1lbnQgUHJvcGVydHlcIjogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCh7IGV4Y2VwdDogL15cXHMqey8gfSksXG4gICAgICAgICAgICAgICAgSlNYRWxlbWVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbG9zZWQgPSAvXlxccyo8XFwvLy50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQubGluZUluZGVudChjb250ZXh0Lm5vZGUuZnJvbSkgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBKU1hFc2NhcGUoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2xvc2VkID0gL1xccypcXH0vLnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5saW5lSW5kZW50KGNvbnRleHQubm9kZS5mcm9tKSArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiSlNYT3BlblRhZyBKU1hTZWxmQ2xvc2luZ1RhZ1wiKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29sdW1uKGNvbnRleHQubm9kZS5mcm9tKSArIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8qQF9fUFVSRV9fKi9mb2xkTm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBcIkJsb2NrIENsYXNzQm9keSBTd2l0Y2hCb2R5IEVudW1Cb2R5IE9iamVjdEV4cHJlc3Npb24gQXJyYXlFeHByZXNzaW9uIE9iamVjdFR5cGVcIjogZm9sZEluc2lkZSxcbiAgICAgICAgICAgICAgICBCbG9ja0NvbW1lbnQodHJlZSkgeyByZXR1cm4geyBmcm9tOiB0cmVlLmZyb20gKyAyLCB0bzogdHJlZS50byAtIDIgfTsgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgIH0pLFxuICAgIGxhbmd1YWdlRGF0YToge1xuICAgICAgICBjbG9zZUJyYWNrZXRzOiB7IGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIicsIFwiYFwiXSB9LFxuICAgICAgICBjb21tZW50VG9rZW5zOiB7IGxpbmU6IFwiLy9cIiwgYmxvY2s6IHsgb3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wiIH0gfSxcbiAgICAgICAgaW5kZW50T25JbnB1dDogL15cXHMqKD86Y2FzZSB8ZGVmYXVsdDp8XFx7fFxcfXw8XFwvKSQvLFxuICAgICAgICB3b3JkQ2hhcnM6IFwiJFwiXG4gICAgfVxufSk7XG5jb25zdCBqc3hTdWJsYW5ndWFnZSA9IHtcbiAgICB0ZXN0OiBub2RlID0+IC9eSlNYLy50ZXN0KG5vZGUubmFtZSksXG4gICAgZmFjZXQ6IC8qQF9fUFVSRV9fKi9kZWZpbmVMYW5ndWFnZUZhY2V0KHsgY29tbWVudFRva2VuczogeyBibG9jazogeyBvcGVuOiBcInsvKlwiLCBjbG9zZTogXCIqL31cIiB9IH0gfSlcbn07XG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgZm9yIFR5cGVTY3JpcHQuXG4qL1xuY29uc3QgdHlwZXNjcmlwdExhbmd1YWdlID0gLypAX19QVVJFX18qL2phdmFzY3JpcHRMYW5ndWFnZS5jb25maWd1cmUoeyBkaWFsZWN0OiBcInRzXCIgfSwgXCJ0eXBlc2NyaXB0XCIpO1xuLyoqXG5MYW5ndWFnZSBwcm92aWRlciBmb3IgSlNYLlxuKi9cbmNvbnN0IGpzeExhbmd1YWdlID0gLypAX19QVVJFX18qL2phdmFzY3JpcHRMYW5ndWFnZS5jb25maWd1cmUoe1xuICAgIGRpYWxlY3Q6IFwianN4XCIsXG4gICAgcHJvcHM6IFsvKkBfX1BVUkVfXyovc3VibGFuZ3VhZ2VQcm9wLmFkZChuID0+IG4uaXNUb3AgPyBbanN4U3VibGFuZ3VhZ2VdIDogdW5kZWZpbmVkKV1cbn0pO1xuLyoqXG5MYW5ndWFnZSBwcm92aWRlciBmb3IgSlNYICsgVHlwZVNjcmlwdC5cbiovXG5jb25zdCB0c3hMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9qYXZhc2NyaXB0TGFuZ3VhZ2UuY29uZmlndXJlKHtcbiAgICBkaWFsZWN0OiBcImpzeCB0c1wiLFxuICAgIHByb3BzOiBbLypAX19QVVJFX18qL3N1Ymxhbmd1YWdlUHJvcC5hZGQobiA9PiBuLmlzVG9wID8gW2pzeFN1Ymxhbmd1YWdlXSA6IHVuZGVmaW5lZCldXG59LCBcInR5cGVzY3JpcHRcIik7XG5sZXQga3dDb21wbGV0aW9uID0gKG5hbWUpID0+ICh7IGxhYmVsOiBuYW1lLCB0eXBlOiBcImtleXdvcmRcIiB9KTtcbmNvbnN0IGtleXdvcmRzID0gLypAX19QVVJFX18qL1wiYnJlYWsgY2FzZSBjb25zdCBjb250aW51ZSBkZWZhdWx0IGRlbGV0ZSBleHBvcnQgZXh0ZW5kcyBmYWxzZSBmaW5hbGx5IGluIGluc3RhbmNlb2YgbGV0IG5ldyByZXR1cm4gc3RhdGljIHN1cGVyIHN3aXRjaCB0aGlzIHRocm93IHRydWUgdHlwZW9mIHZhciB5aWVsZFwiLnNwbGl0KFwiIFwiKS5tYXAoa3dDb21wbGV0aW9uKTtcbmNvbnN0IHR5cGVzY3JpcHRLZXl3b3JkcyA9IC8qQF9fUFVSRV9fKi9rZXl3b3Jkcy5jb25jYXQoLypAX19QVVJFX18qL1tcImRlY2xhcmVcIiwgXCJpbXBsZW1lbnRzXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiXS5tYXAoa3dDb21wbGV0aW9uKSk7XG4vKipcbkphdmFTY3JpcHQgc3VwcG9ydC4gSW5jbHVkZXMgW3NuaXBwZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZy1qYXZhc2NyaXB0LnNuaXBwZXRzKVxuYW5kIGxvY2FsIHZhcmlhYmxlIGNvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gamF2YXNjcmlwdChjb25maWcgPSB7fSkge1xuICAgIGxldCBsYW5nID0gY29uZmlnLmpzeCA/IChjb25maWcudHlwZXNjcmlwdCA/IHRzeExhbmd1YWdlIDoganN4TGFuZ3VhZ2UpXG4gICAgICAgIDogY29uZmlnLnR5cGVzY3JpcHQgPyB0eXBlc2NyaXB0TGFuZ3VhZ2UgOiBqYXZhc2NyaXB0TGFuZ3VhZ2U7XG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29uZmlnLnR5cGVzY3JpcHQgPyB0eXBlc2NyaXB0U25pcHBldHMuY29uY2F0KHR5cGVzY3JpcHRLZXl3b3JkcykgOiBzbmlwcGV0cy5jb25jYXQoa2V5d29yZHMpO1xuICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdXBwb3J0KGxhbmcsIFtcbiAgICAgICAgamF2YXNjcmlwdExhbmd1YWdlLmRhdGEub2Yoe1xuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBpZk5vdEluKGRvbnRDb21wbGV0ZSwgY29tcGxldGVGcm9tTGlzdChjb21wbGV0aW9ucykpXG4gICAgICAgIH0pLFxuICAgICAgICBqYXZhc2NyaXB0TGFuZ3VhZ2UuZGF0YS5vZih7XG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IGxvY2FsQ29tcGxldGlvblNvdXJjZVxuICAgICAgICB9KSxcbiAgICAgICAgY29uZmlnLmpzeCA/IGF1dG9DbG9zZVRhZ3MgOiBbXSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGZpbmRPcGVuVGFnKG5vZGUpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJKU1hPcGVuVGFnXCIgfHwgbm9kZS5uYW1lID09IFwiSlNYU2VsZkNsb3NpbmdUYWdcIiB8fCBub2RlLm5hbWUgPT0gXCJKU1hGcmFnbWVudFRhZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJKU1hFc2NhcGVcIiB8fCAhbm9kZS5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnROYW1lKGRvYywgdHJlZSwgbWF4ID0gZG9jLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGNoID0gdHJlZSA9PT0gbnVsbCB8fCB0cmVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmVlLmZpcnN0Q2hpbGQ7IGNoOyBjaCA9IGNoLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChjaC5uYW1lID09IFwiSlNYSWRlbnRpZmllclwiIHx8IGNoLm5hbWUgPT0gXCJKU1hCdWlsdGluXCIgfHwgY2gubmFtZSA9PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIgfHxcbiAgICAgICAgICAgIGNoLm5hbWUgPT0gXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgICAgICAgICByZXR1cm4gZG9jLnNsaWNlU3RyaW5nKGNoLmZyb20sIE1hdGgubWluKGNoLnRvLCBtYXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5jb25zdCBhbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8qKlxuRXh0ZW5zaW9uIHRoYXQgd2lsbCBhdXRvbWF0aWNhbGx5IGluc2VydCBKU1ggY2xvc2UgdGFncyB3aGVuIGEgYD5gIG9yXG5gL2AgaXMgdHlwZWQuXG4qL1xuY29uc3QgYXV0b0Nsb3NlVGFncyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIHRleHQsIGRlZmF1bHRJbnNlcnQpID0+IHtcbiAgICBpZiAoKGFuZHJvaWQgPyB2aWV3LmNvbXBvc2luZyA6IHZpZXcuY29tcG9zaXRpb25TdGFydGVkKSB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5IHx8XG4gICAgICAgIGZyb20gIT0gdG8gfHwgKHRleHQgIT0gXCI+XCIgJiYgdGV4dCAhPSBcIi9cIikgfHxcbiAgICAgICAgIWphdmFzY3JpcHRMYW5ndWFnZS5pc0FjdGl2ZUF0KHZpZXcuc3RhdGUsIGZyb20sIC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBiYXNlID0gZGVmYXVsdEluc2VydCgpLCB7IHN0YXRlIH0gPSBiYXNlO1xuICAgIGxldCBjbG9zZVRhZ3MgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgeyBoZWFkIH0gPSByYW5nZSwgYXJvdW5kID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKGhlYWQgLSAxLCAtMSksIG5hbWU7XG4gICAgICAgIGlmIChhcm91bmQubmFtZSA9PSBcIkpTWFN0YXJ0VGFnXCIpXG4gICAgICAgICAgICBhcm91bmQgPSBhcm91bmQucGFyZW50O1xuICAgICAgICBpZiAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQgLSAxLCBoZWFkKSAhPSB0ZXh0IHx8IGFyb3VuZC5uYW1lID09IFwiSlNYQXR0cmlidXRlVmFsdWVcIiAmJiBhcm91bmQudG8gPiBoZWFkKSA7XG4gICAgICAgIGVsc2UgaWYgKHRleHQgPT0gXCI+XCIgJiYgYXJvdW5kLm5hbWUgPT0gXCJKU1hGcmFnbWVudFRhZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSwgY2hhbmdlczogeyBmcm9tOiBoZWFkLCBpbnNlcnQ6IGA8Lz5gIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09IFwiL1wiICYmIGFyb3VuZC5uYW1lID09IFwiSlNYU3RhcnRDbG9zZVRhZ1wiKSB7XG4gICAgICAgICAgICBsZXQgZW1wdHkgPSBhcm91bmQucGFyZW50LCBiYXNlID0gZW1wdHkucGFyZW50O1xuICAgICAgICAgICAgaWYgKGJhc2UgJiYgZW1wdHkuZnJvbSA9PSBoZWFkIC0gMiAmJlxuICAgICAgICAgICAgICAgICgobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgYmFzZS5maXJzdENoaWxkLCBoZWFkKSkgfHwgKChfYSA9IGJhc2UuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiSlNYRnJhZ21lbnRUYWdcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0ID0gYCR7bmFtZX0+YDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkICsgaW5zZXJ0Lmxlbmd0aCwgLTEpLCBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIGluc2VydCB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSBcIj5cIikge1xuICAgICAgICAgICAgbGV0IG9wZW5UYWcgPSBmaW5kT3BlblRhZyhhcm91bmQpO1xuICAgICAgICAgICAgaWYgKG9wZW5UYWcgJiYgb3BlblRhZy5uYW1lID09IFwiSlNYT3BlblRhZ1wiICYmXG4gICAgICAgICAgICAgICAgIS9eXFwvPz58XjxcXC8vLnRlc3Qoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQsIGhlYWQgKyAyKSkgJiZcbiAgICAgICAgICAgICAgICAobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgb3BlblRhZywgaGVhZCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlLCBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIGluc2VydDogYDwvJHtuYW1lfT5gIH0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgIH0pO1xuICAgIGlmIChjbG9zZVRhZ3MuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goW1xuICAgICAgICBiYXNlLFxuICAgICAgICBzdGF0ZS51cGRhdGUoY2xvc2VUYWdzLCB7IHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KVxuICAgIF0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbi8qKlxuQ29ubmVjdHMgYW4gW0VTTGludF0oaHR0cHM6Ly9lc2xpbnQub3JnLykgbGludGVyIHRvIENvZGVNaXJyb3Inc1xuW2xpbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludCkgaW50ZWdyYXRpb24uIGBlc2xpbnRgIHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiB0aGVcbltgTGludGVyYF0oaHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvZGV2ZWxvcGVyLWd1aWRlL25vZGVqcy1hcGkjbGludGVyKVxuY2xhc3MsIGFuZCBgY29uZmlnYCBhbiBvcHRpb25hbCBFU0xpbnQgY29uZmlndXJhdGlvbi4gVGhlIHJldHVyblxudmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIHRvIFtgbGludGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50LmxpbnRlcilcbnRvIGNyZWF0ZSBhIEphdmFTY3JpcHQgbGludGluZyBleHRlbnNpb24uXG5cbk5vdGUgdGhhdCBFU0xpbnQgdGFyZ2V0cyBub2RlLCBhbmQgaXMgdHJpY2t5IHRvIHJ1biBpbiB0aGVcbmJyb3dzZXIuIFRoZVxuW2VzbGludC1saW50ZXItYnJvd3NlcmlmeV0oaHR0cHM6Ly9naXRodWIuY29tL1V6aVRlY2gvZXNsaW50LWxpbnRlci1icm93c2VyaWZ5KVxucGFja2FnZSBtYXkgaGVscCB3aXRoIHRoYXQgKHNlZVxuW2V4YW1wbGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9VemlUZWNoL2VzbGludC1saW50ZXItYnJvd3NlcmlmeS9ibG9iL21hc3Rlci9leGFtcGxlL3NjcmlwdC5qcykpLlxuKi9cbmZ1bmN0aW9uIGVzTGludChlc2xpbnQsIGNvbmZpZykge1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHBhcnNlck9wdGlvbnM6IHsgZWNtYVZlcnNpb246IDIwMTksIHNvdXJjZVR5cGU6IFwibW9kdWxlXCIgfSxcbiAgICAgICAgICAgIGVudjogeyBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlLCBlczY6IHRydWUsIGVzMjAxNTogdHJ1ZSwgZXMyMDE3OiB0cnVlLCBlczIwMjA6IHRydWUgfSxcbiAgICAgICAgICAgIHJ1bGVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBlc2xpbnQuZ2V0UnVsZXMoKS5mb3JFYWNoKChkZXNjLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoKF9hID0gZGVzYy5tZXRhLmRvY3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWNvbW1lbmRlZClcbiAgICAgICAgICAgICAgICBjb25maWcucnVsZXNbbmFtZV0gPSAyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICh2aWV3KSA9PiB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgamF2YXNjcmlwdExhbmd1YWdlLmZpbmRSZWdpb25zKHN0YXRlKSkge1xuICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKSwgb2Zmc2V0ID0geyBsaW5lOiBmcm9tTGluZS5udW1iZXIgLSAxLCBjb2w6IGZyb20gLSBmcm9tTGluZS5mcm9tLCBwb3M6IGZyb20gfTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZXNsaW50LnZlcmlmeShzdGF0ZS5zbGljZURvYyhmcm9tLCB0byksIGNvbmZpZykpXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaCh0cmFuc2xhdGVEaWFnbm9zdGljKGQsIHN0YXRlLmRvYywgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXBQb3MobGluZSwgY29sLCBkb2MsIG9mZnNldCkge1xuICAgIHJldHVybiBkb2MubGluZShsaW5lICsgb2Zmc2V0LmxpbmUpLmZyb20gKyBjb2wgKyAobGluZSA9PSAxID8gb2Zmc2V0LmNvbCAtIDEgOiAtMSk7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVEaWFnbm9zdGljKGlucHV0LCBkb2MsIG9mZnNldCkge1xuICAgIGxldCBzdGFydCA9IG1hcFBvcyhpbnB1dC5saW5lLCBpbnB1dC5jb2x1bW4sIGRvYywgb2Zmc2V0KTtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBmcm9tOiBzdGFydCxcbiAgICAgICAgdG86IGlucHV0LmVuZExpbmUgIT0gbnVsbCAmJiBpbnB1dC5lbmRDb2x1bW4gIT0gMSA/IG1hcFBvcyhpbnB1dC5lbmRMaW5lLCBpbnB1dC5lbmRDb2x1bW4sIGRvYywgb2Zmc2V0KSA6IHN0YXJ0LFxuICAgICAgICBtZXNzYWdlOiBpbnB1dC5tZXNzYWdlLFxuICAgICAgICBzb3VyY2U6IGlucHV0LnJ1bGVJZCA/IFwiZXNsaW50OlwiICsgaW5wdXQucnVsZUlkIDogXCJlc2xpbnRcIixcbiAgICAgICAgc2V2ZXJpdHk6IGlucHV0LnNldmVyaXR5ID09IDEgPyBcIndhcm5pbmdcIiA6IFwiZXJyb3JcIixcbiAgICB9O1xuICAgIGlmIChpbnB1dC5maXgpIHtcbiAgICAgICAgbGV0IHsgcmFuZ2UsIHRleHQgfSA9IGlucHV0LmZpeCwgZnJvbSA9IHJhbmdlWzBdICsgb2Zmc2V0LnBvcyAtIHN0YXJ0LCB0byA9IHJhbmdlWzFdICsgb2Zmc2V0LnBvcyAtIHN0YXJ0O1xuICAgICAgICByZXN1bHQuYWN0aW9ucyA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJmaXhcIixcbiAgICAgICAgICAgICAgICBhcHBseSh2aWV3LCBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlczogeyBmcm9tOiBzdGFydCArIGZyb20sIHRvOiBzdGFydCArIHRvLCBpbnNlcnQ6IHRleHQgfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IGF1dG9DbG9zZVRhZ3MsIGNvbXBsZXRpb25QYXRoLCBlc0xpbnQsIGphdmFzY3JpcHQsIGphdmFzY3JpcHRMYW5ndWFnZSwganN4TGFuZ3VhZ2UsIGxvY2FsQ29tcGxldGlvblNvdXJjZSwgc2NvcGVDb21wbGV0aW9uU291cmNlLCBzbmlwcGV0cywgdHN4TGFuZ3VhZ2UsIHR5cGVzY3JpcHRMYW5ndWFnZSwgdHlwZXNjcmlwdFNuaXBwZXRzIH07XG4iLCAiaW1wb3J0IHsgcGFyc2VyLCBjb25maWd1cmVOZXN0aW5nIH0gZnJvbSAnQGxlemVyL2h0bWwnO1xuaW1wb3J0IHsgY3NzTGFuZ3VhZ2UsIGNzcyB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmctY3NzJztcbmltcG9ydCB7IGphdmFzY3JpcHRMYW5ndWFnZSwgdHlwZXNjcmlwdExhbmd1YWdlLCBqc3hMYW5ndWFnZSwgdHN4TGFuZ3VhZ2UsIGphdmFzY3JpcHQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5nLWphdmFzY3JpcHQnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgRWRpdG9yU2VsZWN0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgTFJMYW5ndWFnZSwgaW5kZW50Tm9kZVByb3AsIGZvbGROb2RlUHJvcCwgYnJhY2tldE1hdGNoaW5nSGFuZGxlLCBMYW5ndWFnZVN1cHBvcnQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5cbmNvbnN0IFRhcmdldHMgPSBbXCJfYmxhbmtcIiwgXCJfc2VsZlwiLCBcIl90b3BcIiwgXCJfcGFyZW50XCJdO1xuY29uc3QgQ2hhcnNldHMgPSBbXCJhc2NpaVwiLCBcInV0Zi04XCIsIFwidXRmLTE2XCIsIFwibGF0aW4xXCIsIFwibGF0aW4xXCJdO1xuY29uc3QgTWV0aG9kcyA9IFtcImdldFwiLCBcInBvc3RcIiwgXCJwdXRcIiwgXCJkZWxldGVcIl07XG5jb25zdCBFbmNzID0gW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl07XG5jb25zdCBCb29sID0gW1widHJ1ZVwiLCBcImZhbHNlXCJdO1xuY29uc3QgUyA9IHt9OyAvLyBFbXB0eSB0YWcgc3BlY1xuY29uc3QgVGFncyA9IHtcbiAgICBhOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBocmVmOiBudWxsLCBwaW5nOiBudWxsLCB0eXBlOiBudWxsLFxuICAgICAgICAgICAgbWVkaWE6IG51bGwsXG4gICAgICAgICAgICB0YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICBocmVmbGFuZzogbnVsbFxuICAgICAgICB9XG4gICAgfSxcbiAgICBhYmJyOiBTLFxuICAgIGFkZHJlc3M6IFMsXG4gICAgYXJlYToge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgYWx0OiBudWxsLCBjb29yZHM6IG51bGwsIGhyZWY6IG51bGwsIHRhcmdldDogbnVsbCwgcGluZzogbnVsbCxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLCBocmVmbGFuZzogbnVsbCwgdHlwZTogbnVsbCxcbiAgICAgICAgICAgIHNoYXBlOiBbXCJkZWZhdWx0XCIsIFwicmVjdFwiLCBcImNpcmNsZVwiLCBcInBvbHlcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYXJ0aWNsZTogUyxcbiAgICBhc2lkZTogUyxcbiAgICBhdWRpbzoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgc3JjOiBudWxsLCBtZWRpYWdyb3VwOiBudWxsLFxuICAgICAgICAgICAgY3Jvc3NvcmlnaW46IFtcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiXSxcbiAgICAgICAgICAgIHByZWxvYWQ6IFtcIm5vbmVcIiwgXCJtZXRhZGF0YVwiLCBcImF1dG9cIl0sXG4gICAgICAgICAgICBhdXRvcGxheTogW1wiYXV0b3BsYXlcIl0sXG4gICAgICAgICAgICBsb29wOiBbXCJsb29wXCJdLFxuICAgICAgICAgICAgY29udHJvbHM6IFtcImNvbnRyb2xzXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGI6IFMsXG4gICAgYmFzZTogeyBhdHRyczogeyBocmVmOiBudWxsLCB0YXJnZXQ6IFRhcmdldHMgfSB9LFxuICAgIGJkaTogUyxcbiAgICBiZG86IFMsXG4gICAgYmxvY2txdW90ZTogeyBhdHRyczogeyBjaXRlOiBudWxsIH0gfSxcbiAgICBib2R5OiBTLFxuICAgIGJyOiBTLFxuICAgIGJ1dHRvbjoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZm9ybTogbnVsbCwgZm9ybWFjdGlvbjogbnVsbCwgbmFtZTogbnVsbCwgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICAgICAgICBmb3JtZW5jdHlwZTogRW5jcyxcbiAgICAgICAgICAgIGZvcm1tZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBmb3Jtbm92YWxpZGF0ZTogW1wibm92YWxpZGF0ZVwiXSxcbiAgICAgICAgICAgIGZvcm10YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICB0eXBlOiBbXCJzdWJtaXRcIiwgXCJyZXNldFwiLCBcImJ1dHRvblwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW52YXM6IHsgYXR0cnM6IHsgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9IH0sXG4gICAgY2FwdGlvbjogUyxcbiAgICBjZW50ZXI6IFMsXG4gICAgY2l0ZTogUyxcbiAgICBjb2RlOiBTLFxuICAgIGNvbDogeyBhdHRyczogeyBzcGFuOiBudWxsIH0gfSxcbiAgICBjb2xncm91cDogeyBhdHRyczogeyBzcGFuOiBudWxsIH0gfSxcbiAgICBjb21tYW5kOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJjb21tYW5kXCIsIFwiY2hlY2tib3hcIiwgXCJyYWRpb1wiXSxcbiAgICAgICAgICAgIGxhYmVsOiBudWxsLCBpY29uOiBudWxsLCByYWRpb2dyb3VwOiBudWxsLCBjb21tYW5kOiBudWxsLCB0aXRsZTogbnVsbCxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IFtcImNoZWNrZWRcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogeyBhdHRyczogeyB2YWx1ZTogbnVsbCB9IH0sXG4gICAgZGF0YWdyaWQ6IHsgYXR0cnM6IHsgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLCBtdWx0aXBsZTogW1wibXVsdGlwbGVcIl0gfSB9LFxuICAgIGRhdGFsaXN0OiB7IGF0dHJzOiB7IGRhdGE6IG51bGwgfSB9LFxuICAgIGRkOiBTLFxuICAgIGRlbDogeyBhdHRyczogeyBjaXRlOiBudWxsLCBkYXRldGltZTogbnVsbCB9IH0sXG4gICAgZGV0YWlsczogeyBhdHRyczogeyBvcGVuOiBbXCJvcGVuXCJdIH0gfSxcbiAgICBkZm46IFMsXG4gICAgZGl2OiBTLFxuICAgIGRsOiBTLFxuICAgIGR0OiBTLFxuICAgIGVtOiBTLFxuICAgIGVtYmVkOiB7IGF0dHJzOiB7IHNyYzogbnVsbCwgdHlwZTogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9IH0sXG4gICAgZXZlbnRzb3VyY2U6IHsgYXR0cnM6IHsgc3JjOiBudWxsIH0gfSxcbiAgICBmaWVsZHNldDogeyBhdHRyczogeyBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sIGZvcm06IG51bGwsIG5hbWU6IG51bGwgfSB9LFxuICAgIGZpZ2NhcHRpb246IFMsXG4gICAgZmlndXJlOiBTLFxuICAgIGZvb3RlcjogUyxcbiAgICBmb3JtOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBhY3Rpb246IG51bGwsIG5hbWU6IG51bGwsXG4gICAgICAgICAgICBcImFjY2VwdC1jaGFyc2V0XCI6IENoYXJzZXRzLFxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBbXCJvblwiLCBcIm9mZlwiXSxcbiAgICAgICAgICAgIGVuY3R5cGU6IEVuY3MsXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBub3ZhbGlkYXRlOiBbXCJub3ZhbGlkYXRlXCJdLFxuICAgICAgICAgICAgdGFyZ2V0OiBUYXJnZXRzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGgxOiBTLCBoMjogUywgaDM6IFMsIGg0OiBTLCBoNTogUywgaDY6IFMsXG4gICAgaGVhZDoge1xuICAgICAgICBjaGlsZHJlbjogW1widGl0bGVcIiwgXCJiYXNlXCIsIFwibGlua1wiLCBcInN0eWxlXCIsIFwibWV0YVwiLCBcInNjcmlwdFwiLCBcIm5vc2NyaXB0XCIsIFwiY29tbWFuZFwiXVxuICAgIH0sXG4gICAgaGVhZGVyOiBTLFxuICAgIGhncm91cDogUyxcbiAgICBocjogUyxcbiAgICBodG1sOiB7XG4gICAgICAgIGF0dHJzOiB7IG1hbmlmZXN0OiBudWxsIH1cbiAgICB9LFxuICAgIGk6IFMsXG4gICAgaWZyYW1lOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzcmM6IG51bGwsIHNyY2RvYzogbnVsbCwgbmFtZTogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHNhbmRib3g6IFtcImFsbG93LXRvcC1uYXZpZ2F0aW9uXCIsIFwiYWxsb3ctc2FtZS1vcmlnaW5cIiwgXCJhbGxvdy1mb3Jtc1wiLCBcImFsbG93LXNjcmlwdHNcIl0sXG4gICAgICAgICAgICBzZWFtbGVzczogW1wic2VhbWxlc3NcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW1nOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBhbHQ6IG51bGwsIHNyYzogbnVsbCwgaXNtYXA6IG51bGwsIHVzZW1hcDogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luOiBbXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW5wdXQ6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGFsdDogbnVsbCwgZGlybmFtZTogbnVsbCwgZm9ybTogbnVsbCwgZm9ybWFjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGhlaWdodDogbnVsbCwgbGlzdDogbnVsbCwgbWF4OiBudWxsLCBtYXhsZW5ndGg6IG51bGwsIG1pbjogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IG51bGwsIHBhdHRlcm46IG51bGwsIHBsYWNlaG9sZGVyOiBudWxsLCBzaXplOiBudWxsLCBzcmM6IG51bGwsXG4gICAgICAgICAgICBzdGVwOiBudWxsLCB2YWx1ZTogbnVsbCwgd2lkdGg6IG51bGwsXG4gICAgICAgICAgICBhY2NlcHQ6IFtcImF1ZGlvLypcIiwgXCJ2aWRlby8qXCIsIFwiaW1hZ2UvKlwiXSxcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogW1wib25cIiwgXCJvZmZcIl0sXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IFtcImNoZWNrZWRcIl0sXG4gICAgICAgICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICAgICAgICBmb3JtZW5jdHlwZTogRW5jcyxcbiAgICAgICAgICAgIGZvcm1tZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBmb3Jtbm92YWxpZGF0ZTogW1wibm92YWxpZGF0ZVwiXSxcbiAgICAgICAgICAgIGZvcm10YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICBtdWx0aXBsZTogW1wibXVsdGlwbGVcIl0sXG4gICAgICAgICAgICByZWFkb25seTogW1wicmVhZG9ubHlcIl0sXG4gICAgICAgICAgICByZXF1aXJlZDogW1wicmVxdWlyZWRcIl0sXG4gICAgICAgICAgICB0eXBlOiBbXCJoaWRkZW5cIiwgXCJ0ZXh0XCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCIsIFwiZW1haWxcIiwgXCJwYXNzd29yZFwiLCBcImRhdGV0aW1lXCIsIFwiZGF0ZVwiLCBcIm1vbnRoXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWVrXCIsIFwidGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwibnVtYmVyXCIsIFwicmFuZ2VcIiwgXCJjb2xvclwiLCBcImNoZWNrYm94XCIsIFwicmFkaW9cIixcbiAgICAgICAgICAgICAgICBcImZpbGVcIiwgXCJzdWJtaXRcIiwgXCJpbWFnZVwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGluczogeyBhdHRyczogeyBjaXRlOiBudWxsLCBkYXRldGltZTogbnVsbCB9IH0sXG4gICAga2JkOiBTLFxuICAgIGtleWdlbjoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgY2hhbGxlbmdlOiBudWxsLCBmb3JtOiBudWxsLCBuYW1lOiBudWxsLFxuICAgICAgICAgICAgYXV0b2ZvY3VzOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICAgICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICAgICAgICBrZXl0eXBlOiBbXCJSU0FcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbGFiZWw6IHsgYXR0cnM6IHsgZm9yOiBudWxsLCBmb3JtOiBudWxsIH0gfSxcbiAgICBsZWdlbmQ6IFMsXG4gICAgbGk6IHsgYXR0cnM6IHsgdmFsdWU6IG51bGwgfSB9LFxuICAgIGxpbms6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGhyZWY6IG51bGwsIHR5cGU6IG51bGwsXG4gICAgICAgICAgICBocmVmbGFuZzogbnVsbCxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLFxuICAgICAgICAgICAgc2l6ZXM6IFtcImFsbFwiLCBcIjE2eDE2XCIsIFwiMTZ4MTYgMzJ4MzJcIiwgXCIxNngxNiAzMngzMiA2NHg2NFwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXA6IHsgYXR0cnM6IHsgbmFtZTogbnVsbCB9IH0sXG4gICAgbWFyazogUyxcbiAgICBtZW51OiB7IGF0dHJzOiB7IGxhYmVsOiBudWxsLCB0eXBlOiBbXCJsaXN0XCIsIFwiY29udGV4dFwiLCBcInRvb2xiYXJcIl0gfSB9LFxuICAgIG1ldGE6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgICAgICAgICBjaGFyc2V0OiBDaGFyc2V0cyxcbiAgICAgICAgICAgIG5hbWU6IFtcInZpZXdwb3J0XCIsIFwiYXBwbGljYXRpb24tbmFtZVwiLCBcImF1dGhvclwiLCBcImRlc2NyaXB0aW9uXCIsIFwiZ2VuZXJhdG9yXCIsIFwia2V5d29yZHNcIl0sXG4gICAgICAgICAgICBcImh0dHAtZXF1aXZcIjogW1wiY29udGVudC1sYW5ndWFnZVwiLCBcImNvbnRlbnQtdHlwZVwiLCBcImRlZmF1bHQtc3R5bGVcIiwgXCJyZWZyZXNoXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGVyOiB7IGF0dHJzOiB7IHZhbHVlOiBudWxsLCBtaW46IG51bGwsIGxvdzogbnVsbCwgaGlnaDogbnVsbCwgbWF4OiBudWxsLCBvcHRpbXVtOiBudWxsIH0gfSxcbiAgICBuYXY6IFMsXG4gICAgbm9zY3JpcHQ6IFMsXG4gICAgb2JqZWN0OiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLCB0eXBlOiBudWxsLCBuYW1lOiBudWxsLCB1c2VtYXA6IG51bGwsIGZvcm06IG51bGwsIHdpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICB0eXBlbXVzdG1hdGNoOiBbXCJ0eXBlbXVzdG1hdGNoXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9sOiB7IGF0dHJzOiB7IHJldmVyc2VkOiBbXCJyZXZlcnNlZFwiXSwgc3RhcnQ6IG51bGwsIHR5cGU6IFtcIjFcIiwgXCJhXCIsIFwiQVwiLCBcImlcIiwgXCJJXCJdIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbXCJsaVwiLCBcInNjcmlwdFwiLCBcInRlbXBsYXRlXCIsIFwidWxcIiwgXCJvbFwiXSB9LFxuICAgIG9wdGdyb3VwOiB7IGF0dHJzOiB7IGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSwgbGFiZWw6IG51bGwgfSB9LFxuICAgIG9wdGlvbjogeyBhdHRyczogeyBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sIGxhYmVsOiBudWxsLCBzZWxlY3RlZDogW1wic2VsZWN0ZWRcIl0sIHZhbHVlOiBudWxsIH0gfSxcbiAgICBvdXRwdXQ6IHsgYXR0cnM6IHsgZm9yOiBudWxsLCBmb3JtOiBudWxsLCBuYW1lOiBudWxsIH0gfSxcbiAgICBwOiBTLFxuICAgIHBhcmFtOiB7IGF0dHJzOiB7IG5hbWU6IG51bGwsIHZhbHVlOiBudWxsIH0gfSxcbiAgICBwcmU6IFMsXG4gICAgcHJvZ3Jlc3M6IHsgYXR0cnM6IHsgdmFsdWU6IG51bGwsIG1heDogbnVsbCB9IH0sXG4gICAgcTogeyBhdHRyczogeyBjaXRlOiBudWxsIH0gfSxcbiAgICBycDogUyxcbiAgICBydDogUyxcbiAgICBydWJ5OiBTLFxuICAgIHNhbXA6IFMsXG4gICAgc2NyaXB0OiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJ0ZXh0L2phdmFzY3JpcHRcIl0sXG4gICAgICAgICAgICBzcmM6IG51bGwsXG4gICAgICAgICAgICBhc3luYzogW1wiYXN5bmNcIl0sXG4gICAgICAgICAgICBkZWZlcjogW1wiZGVmZXJcIl0sXG4gICAgICAgICAgICBjaGFyc2V0OiBDaGFyc2V0c1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZWN0aW9uOiBTLFxuICAgIHNlbGVjdDoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZm9ybTogbnVsbCwgbmFtZTogbnVsbCwgc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGF1dG9mb2N1czogW1wiYXV0b2ZvY3VzXCJdLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLFxuICAgICAgICAgICAgbXVsdGlwbGU6IFtcIm11bHRpcGxlXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNsb3Q6IHsgYXR0cnM6IHsgbmFtZTogbnVsbCB9IH0sXG4gICAgc21hbGw6IFMsXG4gICAgc291cmNlOiB7IGF0dHJzOiB7IHNyYzogbnVsbCwgdHlwZTogbnVsbCwgbWVkaWE6IG51bGwgfSB9LFxuICAgIHNwYW46IFMsXG4gICAgc3Ryb25nOiBTLFxuICAgIHN0eWxlOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJ0ZXh0L2Nzc1wiXSxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLFxuICAgICAgICAgICAgc2NvcGVkOiBudWxsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN1YjogUyxcbiAgICBzdW1tYXJ5OiBTLFxuICAgIHN1cDogUyxcbiAgICB0YWJsZTogUyxcbiAgICB0Ym9keTogUyxcbiAgICB0ZDogeyBhdHRyczogeyBjb2xzcGFuOiBudWxsLCByb3dzcGFuOiBudWxsLCBoZWFkZXJzOiBudWxsIH0gfSxcbiAgICB0ZW1wbGF0ZTogUyxcbiAgICB0ZXh0YXJlYToge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZGlybmFtZTogbnVsbCwgZm9ybTogbnVsbCwgbWF4bGVuZ3RoOiBudWxsLCBuYW1lOiBudWxsLCBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgICAgIHJvd3M6IG51bGwsIGNvbHM6IG51bGwsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIHJlYWRvbmx5OiBbXCJyZWFkb25seVwiXSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJyZXF1aXJlZFwiXSxcbiAgICAgICAgICAgIHdyYXA6IFtcInNvZnRcIiwgXCJoYXJkXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRmb290OiBTLFxuICAgIHRoOiB7IGF0dHJzOiB7IGNvbHNwYW46IG51bGwsIHJvd3NwYW46IG51bGwsIGhlYWRlcnM6IG51bGwsIHNjb3BlOiBbXCJyb3dcIiwgXCJjb2xcIiwgXCJyb3dncm91cFwiLCBcImNvbGdyb3VwXCJdIH0gfSxcbiAgICB0aGVhZDogUyxcbiAgICB0aW1lOiB7IGF0dHJzOiB7IGRhdGV0aW1lOiBudWxsIH0gfSxcbiAgICB0aXRsZTogUyxcbiAgICB0cjogUyxcbiAgICB0cmFjazoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgc3JjOiBudWxsLCBsYWJlbDogbnVsbCwgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIGtpbmQ6IFtcInN1YnRpdGxlc1wiLCBcImNhcHRpb25zXCIsIFwiZGVzY3JpcHRpb25zXCIsIFwiY2hhcHRlcnNcIiwgXCJtZXRhZGF0YVwiXSxcbiAgICAgICAgICAgIHNyY2xhbmc6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdWw6IHsgY2hpbGRyZW46IFtcImxpXCIsIFwic2NyaXB0XCIsIFwidGVtcGxhdGVcIiwgXCJ1bFwiLCBcIm9sXCJdIH0sXG4gICAgdmFyOiBTLFxuICAgIHZpZGVvOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzcmM6IG51bGwsIHBvc3RlcjogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luOiBbXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIl0sXG4gICAgICAgICAgICBwcmVsb2FkOiBbXCJhdXRvXCIsIFwibWV0YWRhdGFcIiwgXCJub25lXCJdLFxuICAgICAgICAgICAgYXV0b3BsYXk6IFtcImF1dG9wbGF5XCJdLFxuICAgICAgICAgICAgbWVkaWFncm91cDogW1wibW92aWVcIl0sXG4gICAgICAgICAgICBtdXRlZDogW1wibXV0ZWRcIl0sXG4gICAgICAgICAgICBjb250cm9sczogW1wiY29udHJvbHNcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2JyOiBTXG59O1xuY29uc3QgR2xvYmFsQXR0cnMgPSB7XG4gICAgYWNjZXNza2V5OiBudWxsLFxuICAgIGNsYXNzOiBudWxsLFxuICAgIGNvbnRlbnRlZGl0YWJsZTogQm9vbCxcbiAgICBjb250ZXh0bWVudTogbnVsbCxcbiAgICBkaXI6IFtcImx0clwiLCBcInJ0bFwiLCBcImF1dG9cIl0sXG4gICAgZHJhZ2dhYmxlOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJhdXRvXCJdLFxuICAgIGRyb3B6b25lOiBbXCJjb3B5XCIsIFwibW92ZVwiLCBcImxpbmtcIiwgXCJzdHJpbmc6XCIsIFwiZmlsZTpcIl0sXG4gICAgaGlkZGVuOiBbXCJoaWRkZW5cIl0sXG4gICAgaWQ6IG51bGwsXG4gICAgaW5lcnQ6IFtcImluZXJ0XCJdLFxuICAgIGl0ZW1pZDogbnVsbCxcbiAgICBpdGVtcHJvcDogbnVsbCxcbiAgICBpdGVtcmVmOiBudWxsLFxuICAgIGl0ZW1zY29wZTogW1wiaXRlbXNjb3BlXCJdLFxuICAgIGl0ZW10eXBlOiBudWxsLFxuICAgIGxhbmc6IFtcImFyXCIsIFwiYm5cIiwgXCJkZVwiLCBcImVuLUdCXCIsIFwiZW4tVVNcIiwgXCJlc1wiLCBcImZyXCIsIFwiaGlcIiwgXCJpZFwiLCBcImphXCIsIFwicGFcIiwgXCJwdFwiLCBcInJ1XCIsIFwidHJcIiwgXCJ6aFwiXSxcbiAgICBzcGVsbGNoZWNrOiBCb29sLFxuICAgIGF1dG9jb3JyZWN0OiBCb29sLFxuICAgIGF1dG9jYXBpdGFsaXplOiBCb29sLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIHRhYmluZGV4OiBudWxsLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHRyYW5zbGF0ZTogW1wieWVzXCIsIFwibm9cIl0sXG4gICAgcmVsOiBbXCJzdHlsZXNoZWV0XCIsIFwiYWx0ZXJuYXRlXCIsIFwiYXV0aG9yXCIsIFwiYm9va21hcmtcIiwgXCJoZWxwXCIsIFwibGljZW5zZVwiLCBcIm5leHRcIiwgXCJub2ZvbGxvd1wiLCBcIm5vcmVmZXJyZXJcIiwgXCJwcmVmZXRjaFwiLCBcInByZXZcIiwgXCJzZWFyY2hcIiwgXCJ0YWdcIl0sXG4gICAgcm9sZTogLypAX19QVVJFX18qL1wiYWxlcnQgYXBwbGljYXRpb24gYXJ0aWNsZSBiYW5uZXIgYnV0dG9uIGNlbGwgY2hlY2tib3ggY29tcGxlbWVudGFyeSBjb250ZW50aW5mbyBkaWFsb2cgZG9jdW1lbnQgZmVlZCBmaWd1cmUgZm9ybSBncmlkIGdyaWRjZWxsIGhlYWRpbmcgaW1nIGxpc3QgbGlzdGJveCBsaXN0aXRlbSBtYWluIG5hdmlnYXRpb24gcmVnaW9uIHJvdyByb3dncm91cCBzZWFyY2ggc3dpdGNoIHRhYiB0YWJsZSB0YWJwYW5lbCB0ZXh0Ym94IHRpbWVyXCIuc3BsaXQoXCIgXCIpLFxuICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IG51bGwsXG4gICAgXCJhcmlhLWF0b21pY1wiOiBCb29sLFxuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogW1wiaW5saW5lXCIsIFwibGlzdFwiLCBcImJvdGhcIiwgXCJub25lXCJdLFxuICAgIFwiYXJpYS1idXN5XCI6IEJvb2wsXG4gICAgXCJhcmlhLWNoZWNrZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwibWl4ZWRcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6IG51bGwsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IG51bGwsXG4gICAgXCJhcmlhLWRpc2FibGVkXCI6IEJvb2wsXG4gICAgXCJhcmlhLWRyb3BlZmZlY3RcIjogbnVsbCxcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwidW5kZWZpbmVkXCJdLFxuICAgIFwiYXJpYS1mbG93dG9cIjogbnVsbCxcbiAgICBcImFyaWEtZ3JhYmJlZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLWhhc3BvcHVwXCI6IEJvb2wsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBCb29sLFxuICAgIFwiYXJpYS1pbnZhbGlkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcImdyYW1tYXJcIiwgXCJzcGVsbGluZ1wiXSxcbiAgICBcImFyaWEtbGFiZWxcIjogbnVsbCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBudWxsLFxuICAgIFwiYXJpYS1sZXZlbFwiOiBudWxsLFxuICAgIFwiYXJpYS1saXZlXCI6IFtcIm9mZlwiLCBcInBvbGl0ZVwiLCBcImFzc2VydGl2ZVwiXSxcbiAgICBcImFyaWEtbXVsdGlsaW5lXCI6IEJvb2wsXG4gICAgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiOiBCb29sLFxuICAgIFwiYXJpYS1vd25zXCI6IG51bGwsXG4gICAgXCJhcmlhLXBvc2luc2V0XCI6IG51bGwsXG4gICAgXCJhcmlhLXByZXNzZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwibWl4ZWRcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLXJlYWRvbmx5XCI6IEJvb2wsXG4gICAgXCJhcmlhLXJlbGV2YW50XCI6IG51bGwsXG4gICAgXCJhcmlhLXJlcXVpcmVkXCI6IEJvb2wsXG4gICAgXCJhcmlhLXNlbGVjdGVkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcInVuZGVmaW5lZFwiXSxcbiAgICBcImFyaWEtc2V0c2l6ZVwiOiBudWxsLFxuICAgIFwiYXJpYS1zb3J0XCI6IFtcImFzY2VuZGluZ1wiLCBcImRlc2NlbmRpbmdcIiwgXCJub25lXCIsIFwib3RoZXJcIl0sXG4gICAgXCJhcmlhLXZhbHVlbWF4XCI6IG51bGwsXG4gICAgXCJhcmlhLXZhbHVlbWluXCI6IG51bGwsXG4gICAgXCJhcmlhLXZhbHVlbm93XCI6IG51bGwsXG4gICAgXCJhcmlhLXZhbHVldGV4dFwiOiBudWxsXG59O1xuY29uc3QgZXZlbnRBdHRyaWJ1dGVzID0gLypAX19QVVJFX18qLyhcImJlZm9yZXVubG9hZCBjb3B5IGN1dCBkcmFnc3RhcnQgZHJhZ292ZXIgZHJhZ2xlYXZlIGRyYWdlbnRlciBkcmFnZW5kIFwiICtcbiAgICBcImRyYWcgcGFzdGUgZm9jdXMgYmx1ciBjaGFuZ2UgY2xpY2sgbG9hZCBtb3VzZWRvd24gbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcbiAgICBcIm1vdXNldXAga2V5ZG93biBrZXl1cCByZXNpemUgc2Nyb2xsIHVubG9hZFwiKS5zcGxpdChcIiBcIikubWFwKG4gPT4gXCJvblwiICsgbik7XG5mb3IgKGxldCBhIG9mIGV2ZW50QXR0cmlidXRlcylcbiAgICBHbG9iYWxBdHRyc1thXSA9IG51bGw7XG5jbGFzcyBTY2hlbWEge1xuICAgIGNvbnN0cnVjdG9yKGV4dHJhVGFncywgZXh0cmFBdHRycykge1xuICAgICAgICB0aGlzLnRhZ3MgPSB7IC4uLlRhZ3MsIC4uLmV4dHJhVGFncyB9O1xuICAgICAgICB0aGlzLmdsb2JhbEF0dHJzID0geyAuLi5HbG9iYWxBdHRycywgLi4uZXh0cmFBdHRycyB9O1xuICAgICAgICB0aGlzLmFsbFRhZ3MgPSBPYmplY3Qua2V5cyh0aGlzLnRhZ3MpO1xuICAgICAgICB0aGlzLmdsb2JhbEF0dHJOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuZ2xvYmFsQXR0cnMpO1xuICAgIH1cbn1cblNjaGVtYS5kZWZhdWx0ID0gLypAX19QVVJFX18qL25ldyBTY2hlbWE7XG5mdW5jdGlvbiBlbGVtZW50TmFtZShkb2MsIHRyZWUsIG1heCA9IGRvYy5sZW5ndGgpIHtcbiAgICBpZiAoIXRyZWUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIGxldCB0YWcgPSB0cmVlLmZpcnN0Q2hpbGQ7XG4gICAgbGV0IG5hbWUgPSB0YWcgJiYgdGFnLmdldENoaWxkKFwiVGFnTmFtZVwiKTtcbiAgICByZXR1cm4gbmFtZSA/IGRvYy5zbGljZVN0cmluZyhuYW1lLmZyb20sIE1hdGgubWluKG5hbWUudG8sIG1heCkpIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGZpbmRQYXJlbnRFbGVtZW50KHRyZWUsIHNraXAgPSBmYWxzZSkge1xuICAgIGZvciAoOyB0cmVlOyB0cmVlID0gdHJlZS5wYXJlbnQpXG4gICAgICAgIGlmICh0cmVlLm5hbWUgPT0gXCJFbGVtZW50XCIpIHtcbiAgICAgICAgICAgIGlmIChza2lwKVxuICAgICAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYWxsb3dlZENoaWxkcmVuKGRvYywgdHJlZSwgc2NoZW1hKSB7XG4gICAgbGV0IHBhcmVudEluZm8gPSBzY2hlbWEudGFnc1tlbGVtZW50TmFtZShkb2MsIGZpbmRQYXJlbnRFbGVtZW50KHRyZWUpKV07XG4gICAgcmV0dXJuIChwYXJlbnRJbmZvID09PSBudWxsIHx8IHBhcmVudEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudEluZm8uY2hpbGRyZW4pIHx8IHNjaGVtYS5hbGxUYWdzO1xufVxuZnVuY3Rpb24gb3BlblRhZ3MoZG9jLCB0cmVlKSB7XG4gICAgbGV0IG9wZW4gPSBbXTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBmaW5kUGFyZW50RWxlbWVudCh0cmVlKTsgcGFyZW50ICYmICFwYXJlbnQudHlwZS5pc1RvcDsgcGFyZW50ID0gZmluZFBhcmVudEVsZW1lbnQocGFyZW50LnBhcmVudCkpIHtcbiAgICAgICAgbGV0IHRhZ05hbWUgPSBlbGVtZW50TmFtZShkb2MsIHBhcmVudCk7XG4gICAgICAgIGlmICh0YWdOYW1lICYmIHBhcmVudC5sYXN0Q2hpbGQubmFtZSA9PSBcIkNsb3NlVGFnXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHRhZ05hbWUgJiYgb3Blbi5pbmRleE9mKHRhZ05hbWUpIDwgMCAmJiAodHJlZS5uYW1lID09IFwiRW5kVGFnXCIgfHwgdHJlZS5mcm9tID49IHBhcmVudC5maXJzdENoaWxkLnRvKSlcbiAgICAgICAgICAgIG9wZW4ucHVzaCh0YWdOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wZW47XG59XG5jb25zdCBpZGVudGlmaWVyID0gL15bOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC87XG5mdW5jdGlvbiBjb21wbGV0ZVRhZyhzdGF0ZSwgc2NoZW1hLCB0cmVlLCBmcm9tLCB0bykge1xuICAgIGxldCBlbmQgPSAvXFxzKj4vLnRlc3Qoc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgNSkpID8gXCJcIiA6IFwiPlwiO1xuICAgIGxldCBwYXJlbnQgPSBmaW5kUGFyZW50RWxlbWVudCh0cmVlLCB0cmVlLm5hbWUgPT0gXCJTdGFydFRhZ1wiIHx8IHRyZWUubmFtZSA9PSBcIlRhZ05hbWVcIik7XG4gICAgcmV0dXJuIHsgZnJvbSwgdG8sXG4gICAgICAgIG9wdGlvbnM6IGFsbG93ZWRDaGlsZHJlbihzdGF0ZS5kb2MsIHBhcmVudCwgc2NoZW1hKS5tYXAodGFnTmFtZSA9PiAoeyBsYWJlbDogdGFnTmFtZSwgdHlwZTogXCJ0eXBlXCIgfSkpLmNvbmNhdChvcGVuVGFncyhzdGF0ZS5kb2MsIHRyZWUpLm1hcCgodGFnLCBpKSA9PiAoeyBsYWJlbDogXCIvXCIgKyB0YWcsIGFwcGx5OiBcIi9cIiArIHRhZyArIGVuZCxcbiAgICAgICAgICAgIHR5cGU6IFwidHlwZVwiLCBib29zdDogOTkgLSBpIH0pKSksXG4gICAgICAgIHZhbGlkRm9yOiAvXlxcLz9bOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC8gfTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlQ2xvc2VUYWcoc3RhdGUsIHRyZWUsIGZyb20sIHRvKSB7XG4gICAgbGV0IGVuZCA9IC9cXHMqPi8udGVzdChzdGF0ZS5zbGljZURvYyh0bywgdG8gKyA1KSkgPyBcIlwiIDogXCI+XCI7XG4gICAgcmV0dXJuIHsgZnJvbSwgdG8sXG4gICAgICAgIG9wdGlvbnM6IG9wZW5UYWdzKHN0YXRlLmRvYywgdHJlZSkubWFwKCh0YWcsIGkpID0+ICh7IGxhYmVsOiB0YWcsIGFwcGx5OiB0YWcgKyBlbmQsIHR5cGU6IFwidHlwZVwiLCBib29zdDogOTkgLSBpIH0pKSxcbiAgICAgICAgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlU3RhcnRUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgcG9zKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXSwgbGV2ZWwgPSAwO1xuICAgIGZvciAobGV0IHRhZ05hbWUgb2YgYWxsb3dlZENoaWxkcmVuKHN0YXRlLmRvYywgdHJlZSwgc2NoZW1hKSlcbiAgICAgICAgb3B0aW9ucy5wdXNoKHsgbGFiZWw6IFwiPFwiICsgdGFnTmFtZSwgdHlwZTogXCJ0eXBlXCIgfSk7XG4gICAgZm9yIChsZXQgb3BlbiBvZiBvcGVuVGFncyhzdGF0ZS5kb2MsIHRyZWUpKVxuICAgICAgICBvcHRpb25zLnB1c2goeyBsYWJlbDogXCI8L1wiICsgb3BlbiArIFwiPlwiLCB0eXBlOiBcInR5cGVcIiwgYm9vc3Q6IDk5IC0gbGV2ZWwrKyB9KTtcbiAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MsIG9wdGlvbnMsIHZhbGlkRm9yOiAvXjxcXC8/WzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvIH07XG59XG5mdW5jdGlvbiBjb21wbGV0ZUF0dHJOYW1lKHN0YXRlLCBzY2hlbWEsIHRyZWUsIGZyb20sIHRvKSB7XG4gICAgbGV0IGVsdCA9IGZpbmRQYXJlbnRFbGVtZW50KHRyZWUpLCBpbmZvID0gZWx0ID8gc2NoZW1hLnRhZ3NbZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBlbHQpXSA6IG51bGw7XG4gICAgbGV0IGxvY2FsQXR0cnMgPSBpbmZvICYmIGluZm8uYXR0cnMgPyBPYmplY3Qua2V5cyhpbmZvLmF0dHJzKSA6IFtdO1xuICAgIGxldCBuYW1lcyA9IGluZm8gJiYgaW5mby5nbG9iYWxBdHRycyA9PT0gZmFsc2UgPyBsb2NhbEF0dHJzXG4gICAgICAgIDogbG9jYWxBdHRycy5sZW5ndGggPyBsb2NhbEF0dHJzLmNvbmNhdChzY2hlbWEuZ2xvYmFsQXR0ck5hbWVzKSA6IHNjaGVtYS5nbG9iYWxBdHRyTmFtZXM7XG4gICAgcmV0dXJuIHsgZnJvbSwgdG8sXG4gICAgICAgIG9wdGlvbnM6IG5hbWVzLm1hcChhdHRyTmFtZSA9PiAoeyBsYWJlbDogYXR0ck5hbWUsIHR5cGU6IFwicHJvcGVydHlcIiB9KSksXG4gICAgICAgIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG59XG5mdW5jdGlvbiBjb21wbGV0ZUF0dHJWYWx1ZShzdGF0ZSwgc2NoZW1hLCB0cmVlLCBmcm9tLCB0bykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbmFtZU5vZGUgPSAoX2EgPSB0cmVlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENoaWxkKFwiQXR0cmlidXRlTmFtZVwiKTtcbiAgICBsZXQgb3B0aW9ucyA9IFtdLCB0b2tlbiA9IHVuZGVmaW5lZDtcbiAgICBpZiAobmFtZU5vZGUpIHtcbiAgICAgICAgbGV0IGF0dHJOYW1lID0gc3RhdGUuc2xpY2VEb2MobmFtZU5vZGUuZnJvbSwgbmFtZU5vZGUudG8pO1xuICAgICAgICBsZXQgYXR0cnMgPSBzY2hlbWEuZ2xvYmFsQXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICBpZiAoIWF0dHJzKSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gZmluZFBhcmVudEVsZW1lbnQodHJlZSksIGluZm8gPSBlbHQgPyBzY2hlbWEudGFnc1tlbGVtZW50TmFtZShzdGF0ZS5kb2MsIGVsdCldIDogbnVsbDtcbiAgICAgICAgICAgIGF0dHJzID0gKGluZm8gPT09IG51bGwgfHwgaW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mby5hdHRycykgJiYgaW5mby5hdHRyc1thdHRyTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKS50b0xvd2VyQ2FzZSgpLCBxdW90ZVN0YXJ0ID0gJ1wiJywgcXVvdGVFbmQgPSAnXCInO1xuICAgICAgICAgICAgaWYgKC9eWydcIl0vLnRlc3QoYmFzZSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGJhc2VbMF0gPT0gJ1wiJyA/IC9eW15cIl0qJC8gOiAvXlteJ10qJC87XG4gICAgICAgICAgICAgICAgcXVvdGVTdGFydCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgcXVvdGVFbmQgPSBzdGF0ZS5zbGljZURvYyh0bywgdG8gKyAxKSA9PSBiYXNlWzBdID8gXCJcIiA6IGJhc2VbMF07XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2Uuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgZnJvbSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSAvXlteXFxzPD49J1wiXSokLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGF0dHJzKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7IGxhYmVsOiB2YWx1ZSwgYXBwbHk6IHF1b3RlU3RhcnQgKyB2YWx1ZSArIHF1b3RlRW5kLCB0eXBlOiBcImNvbnN0YW50XCIgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZnJvbSwgdG8sIG9wdGlvbnMsIHZhbGlkRm9yOiB0b2tlbiB9O1xufVxuZnVuY3Rpb24gaHRtbENvbXBsZXRpb25Gb3Ioc2NoZW1hLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgc3RhdGUsIHBvcyB9ID0gY29udGV4dCwgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MsIC0xKSwgYXJvdW5kID0gdHJlZS5yZXNvbHZlKHBvcyk7XG4gICAgZm9yIChsZXQgc2NhbiA9IHBvcywgYmVmb3JlOyBhcm91bmQgPT0gdHJlZSAmJiAoYmVmb3JlID0gdHJlZS5jaGlsZEJlZm9yZShzY2FuKSk7KSB7XG4gICAgICAgIGxldCBsYXN0ID0gYmVmb3JlLmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8ICFsYXN0LnR5cGUuaXNFcnJvciB8fCBsYXN0LmZyb20gPCBsYXN0LnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGFyb3VuZCA9IHRyZWUgPSBiZWZvcmU7XG4gICAgICAgIHNjYW4gPSBsYXN0LmZyb207XG4gICAgfVxuICAgIGlmICh0cmVlLm5hbWUgPT0gXCJUYWdOYW1lXCIpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUucGFyZW50ICYmIC9DbG9zZVRhZyQvLnRlc3QodHJlZS5wYXJlbnQubmFtZSkgPyBjb21wbGV0ZUNsb3NlVGFnKHN0YXRlLCB0cmVlLCB0cmVlLmZyb20sIHBvcylcbiAgICAgICAgICAgIDogY29tcGxldGVUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgdHJlZS5mcm9tLCBwb3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmVlLm5hbWUgPT0gXCJTdGFydFRhZ1wiIHx8IHRyZWUubmFtZSA9PSBcIkluY29tcGxldGVUYWdcIikge1xuICAgICAgICByZXR1cm4gY29tcGxldGVUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgcG9zLCBwb3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmVlLm5hbWUgPT0gXCJTdGFydENsb3NlVGFnXCIgfHwgdHJlZS5uYW1lID09IFwiSW5jb21wbGV0ZUNsb3NlVGFnXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlQ2xvc2VUYWcoc3RhdGUsIHRyZWUsIHBvcywgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJlZS5uYW1lID09IFwiT3BlblRhZ1wiIHx8IHRyZWUubmFtZSA9PSBcIlNlbGZDbG9zaW5nVGFnXCIgfHwgdHJlZS5uYW1lID09IFwiQXR0cmlidXRlTmFtZVwiKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZUF0dHJOYW1lKHN0YXRlLCBzY2hlbWEsIHRyZWUsIHRyZWUubmFtZSA9PSBcIkF0dHJpYnV0ZU5hbWVcIiA/IHRyZWUuZnJvbSA6IHBvcywgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJlZS5uYW1lID09IFwiSXNcIiB8fCB0cmVlLm5hbWUgPT0gXCJBdHRyaWJ1dGVWYWx1ZVwiIHx8IHRyZWUubmFtZSA9PSBcIlVucXVvdGVkQXR0cmlidXRlVmFsdWVcIikge1xuICAgICAgICByZXR1cm4gY29tcGxldGVBdHRyVmFsdWUoc3RhdGUsIHNjaGVtYSwgdHJlZSwgdHJlZS5uYW1lID09IFwiSXNcIiA/IHBvcyA6IHRyZWUuZnJvbSwgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dC5leHBsaWNpdCAmJiAoYXJvdW5kLm5hbWUgPT0gXCJFbGVtZW50XCIgfHwgYXJvdW5kLm5hbWUgPT0gXCJUZXh0XCIgfHwgYXJvdW5kLm5hbWUgPT0gXCJEb2N1bWVudFwiKSkge1xuICAgICAgICByZXR1cm4gY29tcGxldGVTdGFydFRhZyhzdGF0ZSwgc2NoZW1hLCB0cmVlLCBwb3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG5IVE1MIHRhZyBjb21wbGV0aW9uLiBPcGVucyBhbmQgY2xvc2VzIHRhZ3MgYW5kIGF0dHJpYnV0ZXMgaW4gYVxuY29udGV4dC1hd2FyZSB3YXkuXG4qL1xuZnVuY3Rpb24gaHRtbENvbXBsZXRpb25Tb3VyY2UoY29udGV4dCkge1xuICAgIHJldHVybiBodG1sQ29tcGxldGlvbkZvcihTY2hlbWEuZGVmYXVsdCwgY29udGV4dCk7XG59XG4vKipcbkNyZWF0ZSBhIGNvbXBsZXRpb24gc291cmNlIGZvciBIVE1MIGV4dGVuZGVkIHdpdGggYWRkaXRpb25hbCB0YWdzXG5vciBhdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIGh0bWxDb21wbGV0aW9uU291cmNlV2l0aChjb25maWcpIHtcbiAgICBsZXQgeyBleHRyYVRhZ3MsIGV4dHJhR2xvYmFsQXR0cmlidXRlczogZXh0cmFBdHRycyB9ID0gY29uZmlnO1xuICAgIGxldCBzY2hlbWEgPSBleHRyYUF0dHJzIHx8IGV4dHJhVGFncyA/IG5ldyBTY2hlbWEoZXh0cmFUYWdzLCBleHRyYUF0dHJzKSA6IFNjaGVtYS5kZWZhdWx0O1xuICAgIHJldHVybiAoY29udGV4dCkgPT4gaHRtbENvbXBsZXRpb25Gb3Ioc2NoZW1hLCBjb250ZXh0KTtcbn1cblxuY29uc3QganNvblBhcnNlciA9IC8qQF9fUFVSRV9fKi9qYXZhc2NyaXB0TGFuZ3VhZ2UucGFyc2VyLmNvbmZpZ3VyZSh7IHRvcDogXCJTaW5nbGVFeHByZXNzaW9uXCIgfSk7XG5jb25zdCBkZWZhdWx0TmVzdGluZyA9IFtcbiAgICB7IHRhZzogXCJzY3JpcHRcIixcbiAgICAgICAgYXR0cnM6IGF0dHJzID0+IGF0dHJzLnR5cGUgPT0gXCJ0ZXh0L3R5cGVzY3JpcHRcIiB8fCBhdHRycy5sYW5nID09IFwidHNcIixcbiAgICAgICAgcGFyc2VyOiB0eXBlc2NyaXB0TGFuZ3VhZ2UucGFyc2VyIH0sXG4gICAgeyB0YWc6IFwic2NyaXB0XCIsXG4gICAgICAgIGF0dHJzOiBhdHRycyA9PiBhdHRycy50eXBlID09IFwidGV4dC9iYWJlbFwiIHx8IGF0dHJzLnR5cGUgPT0gXCJ0ZXh0L2pzeFwiLFxuICAgICAgICBwYXJzZXI6IGpzeExhbmd1YWdlLnBhcnNlciB9LFxuICAgIHsgdGFnOiBcInNjcmlwdFwiLFxuICAgICAgICBhdHRyczogYXR0cnMgPT4gYXR0cnMudHlwZSA9PSBcInRleHQvdHlwZXNjcmlwdC1qc3hcIixcbiAgICAgICAgcGFyc2VyOiB0c3hMYW5ndWFnZS5wYXJzZXIgfSxcbiAgICB7IHRhZzogXCJzY3JpcHRcIixcbiAgICAgICAgYXR0cnMoYXR0cnMpIHtcbiAgICAgICAgICAgIHJldHVybiAvXihpbXBvcnRtYXB8c3BlY3VsYXRpb25ydWxlc3xhcHBsaWNhdGlvblxcLyguK1xcKyk/anNvbikkL2kudGVzdChhdHRycy50eXBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2VyOiBqc29uUGFyc2VyIH0sXG4gICAgeyB0YWc6IFwic2NyaXB0XCIsXG4gICAgICAgIGF0dHJzKGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gIWF0dHJzLnR5cGUgfHwgL14oPzp0ZXh0fGFwcGxpY2F0aW9uKVxcLyg/OngtKT8oPzpqYXZhfGVjbWEpc2NyaXB0JHxebW9kdWxlJHxeJC9pLnRlc3QoYXR0cnMudHlwZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlcjogamF2YXNjcmlwdExhbmd1YWdlLnBhcnNlciB9LFxuICAgIHsgdGFnOiBcInN0eWxlXCIsXG4gICAgICAgIGF0dHJzKGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFhdHRycy5sYW5nIHx8IGF0dHJzLmxhbmcgPT0gXCJjc3NcIikgJiYgKCFhdHRycy50eXBlIHx8IC9eKHRleHRcXC8pPyh4LSk/KHN0eWxlc2hlZXR8Y3NzKSQvaS50ZXN0KGF0dHJzLnR5cGUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2VyOiBjc3NMYW5ndWFnZS5wYXJzZXIgfVxuXTtcbmNvbnN0IGRlZmF1bHRBdHRycyA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBuYW1lOiBcInN0eWxlXCIsXG4gICAgICAgIHBhcnNlcjogLypAX19QVVJFX18qL2Nzc0xhbmd1YWdlLnBhcnNlci5jb25maWd1cmUoeyB0b3A6IFwiU3R5bGVzXCIgfSkgfVxuXS5jb25jYXQoLypAX19QVVJFX18qL2V2ZW50QXR0cmlidXRlcy5tYXAobmFtZSA9PiAoeyBuYW1lLCBwYXJzZXI6IGphdmFzY3JpcHRMYW5ndWFnZS5wYXJzZXIgfSkpKTtcbmNvbnN0IGh0bWxQbGFpbiA9IC8qQF9fUFVSRV9fKi9MUkxhbmd1YWdlLmRlZmluZSh7XG4gICAgbmFtZTogXCJodG1sXCIsXG4gICAgcGFyc2VyOiAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBFbGVtZW50KGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gL14oXFxzKikoPFxcLyk/Ly5leGVjKGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQubm9kZS50byA8PSBjb250ZXh0LnBvcyArIGFmdGVyWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5ub2RlLmZyb20pICsgKGFmdGVyWzJdID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIk9wZW5UYWcgQ2xvc2VUYWcgU2VsZkNsb3NpbmdUYWdcIihjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbHVtbihjb250ZXh0Lm5vZGUuZnJvbSkgKyBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBEb2N1bWVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnBvcyArIC9cXHMqLy5leGVjKGNvbnRleHQudGV4dEFmdGVyKVswXS5sZW5ndGggPCBjb250ZXh0Lm5vZGUudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kRWx0ID0gbnVsbCwgY2xvc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IGNvbnRleHQubm9kZTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGN1ci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC5uYW1lICE9IFwiRWxlbWVudFwiIHx8IGxhc3QudG8gIT0gY3VyLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRWx0ID0gY3VyID0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kRWx0ICYmICEoKGNsb3NlID0gZW5kRWx0Lmxhc3RDaGlsZCkgJiYgKGNsb3NlLm5hbWUgPT0gXCJDbG9zZVRhZ1wiIHx8IGNsb3NlLm5hbWUgPT0gXCJTZWxmQ2xvc2luZ1RhZ1wiKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5saW5lSW5kZW50KGVuZEVsdC5mcm9tKSArIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgRWxlbWVudChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZCwgbGFzdCA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0IHx8IGZpcnN0Lm5hbWUgIT0gXCJPcGVuVGFnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZmlyc3QudG8sIHRvOiBsYXN0Lm5hbWUgPT0gXCJDbG9zZVRhZ1wiID8gbGFzdC5mcm9tIDogbm9kZS50byB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLypAX19QVVJFX18qL2JyYWNrZXRNYXRjaGluZ0hhbmRsZS5hZGQoe1xuICAgICAgICAgICAgICAgIFwiT3BlblRhZyBDbG9zZVRhZ1wiOiBub2RlID0+IG5vZGUuZ2V0Q2hpbGQoXCJUYWdOYW1lXCIpXG4gICAgICAgICAgICB9KVxuICAgICAgICBdXG4gICAgfSksXG4gICAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgICAgIGNvbW1lbnRUb2tlbnM6IHsgYmxvY2s6IHsgb3BlbjogXCI8IS0tXCIsIGNsb3NlOiBcIi0tPlwiIH0gfSxcbiAgICAgICAgaW5kZW50T25JbnB1dDogL15cXHMqPFxcL1xcdytcXFckLyxcbiAgICAgICAgd29yZENoYXJzOiBcIi1fXCJcbiAgICB9XG59KTtcbi8qKlxuQSBsYW5ndWFnZSBwcm92aWRlciBiYXNlZCBvbiB0aGUgW0xlemVyIEhUTUxcbnBhcnNlcl0oaHR0cHM6Ly9naXRodWIuY29tL2xlemVyLXBhcnNlci9odG1sKSwgZXh0ZW5kZWQgd2l0aCB0aGVcbkphdmFTY3JpcHQgYW5kIENTUyBwYXJzZXJzIHRvIHBhcnNlIHRoZSBjb250ZW50IG9mIGA8c2NyaXB0PmAgYW5kXG5gPHN0eWxlPmAgdGFncy5cbiovXG5jb25zdCBodG1sTGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovaHRtbFBsYWluLmNvbmZpZ3VyZSh7XG4gICAgd3JhcDogLypAX19QVVJFX18qL2NvbmZpZ3VyZU5lc3RpbmcoZGVmYXVsdE5lc3RpbmcsIGRlZmF1bHRBdHRycylcbn0pO1xuLyoqXG5MYW5ndWFnZSBzdXBwb3J0IGZvciBIVE1MLCBpbmNsdWRpbmdcbltgaHRtbENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmctaHRtbC5odG1sQ29tcGxldGlvbikgYW5kIEphdmFTY3JpcHQgYW5kXG5DU1Mgc3VwcG9ydCBleHRlbnNpb25zLlxuKi9cbmZ1bmN0aW9uIGh0bWwoY29uZmlnID0ge30pIHtcbiAgICBsZXQgZGlhbGVjdCA9IFwiXCIsIHdyYXA7XG4gICAgaWYgKGNvbmZpZy5tYXRjaENsb3NpbmdUYWdzID09PSBmYWxzZSlcbiAgICAgICAgZGlhbGVjdCA9IFwibm9NYXRjaFwiO1xuICAgIGlmIChjb25maWcuc2VsZkNsb3NpbmdUYWdzID09PSB0cnVlKVxuICAgICAgICBkaWFsZWN0ID0gKGRpYWxlY3QgPyBkaWFsZWN0ICsgXCIgXCIgOiBcIlwiKSArIFwic2VsZkNsb3NpbmdcIjtcbiAgICBpZiAoY29uZmlnLm5lc3RlZExhbmd1YWdlcyAmJiBjb25maWcubmVzdGVkTGFuZ3VhZ2VzLmxlbmd0aCB8fFxuICAgICAgICBjb25maWcubmVzdGVkQXR0cmlidXRlcyAmJiBjb25maWcubmVzdGVkQXR0cmlidXRlcy5sZW5ndGgpXG4gICAgICAgIHdyYXAgPSBjb25maWd1cmVOZXN0aW5nKChjb25maWcubmVzdGVkTGFuZ3VhZ2VzIHx8IFtdKS5jb25jYXQoZGVmYXVsdE5lc3RpbmcpLCAoY29uZmlnLm5lc3RlZEF0dHJpYnV0ZXMgfHwgW10pLmNvbmNhdChkZWZhdWx0QXR0cnMpKTtcbiAgICBsZXQgbGFuZyA9IHdyYXAgPyBodG1sUGxhaW4uY29uZmlndXJlKHsgd3JhcCwgZGlhbGVjdCB9KSA6IGRpYWxlY3QgPyBodG1sTGFuZ3VhZ2UuY29uZmlndXJlKHsgZGlhbGVjdCB9KSA6IGh0bWxMYW5ndWFnZTtcbiAgICByZXR1cm4gbmV3IExhbmd1YWdlU3VwcG9ydChsYW5nLCBbXG4gICAgICAgIGh0bWxMYW5ndWFnZS5kYXRhLm9mKHsgYXV0b2NvbXBsZXRlOiBodG1sQ29tcGxldGlvblNvdXJjZVdpdGgoY29uZmlnKSB9KSxcbiAgICAgICAgY29uZmlnLmF1dG9DbG9zZVRhZ3MgIT09IGZhbHNlID8gYXV0b0Nsb3NlVGFncyA6IFtdLFxuICAgICAgICBqYXZhc2NyaXB0KCkuc3VwcG9ydCxcbiAgICAgICAgY3NzKCkuc3VwcG9ydFxuICAgIF0pO1xufVxuY29uc3Qgc2VsZkNsb3NlcnMgPSAvKkBfX1BVUkVfXyovbmV3IFNldCgvKkBfX1BVUkVfXyovXCJhcmVhIGJhc2UgYnIgY29sIGNvbW1hbmQgZW1iZWQgZnJhbWUgaHIgaW1nIGlucHV0IGtleWdlbiBsaW5rIG1ldGEgcGFyYW0gc291cmNlIHRyYWNrIHdiciBtZW51aXRlbVwiLnNwbGl0KFwiIFwiKSk7XG4vKipcbkV4dGVuc2lvbiB0aGF0IHdpbGwgYXV0b21hdGljYWxseSBpbnNlcnQgY2xvc2UgdGFncyB3aGVuIGEgYD5gIG9yXG5gL2AgaXMgdHlwZWQuXG4qL1xuY29uc3QgYXV0b0Nsb3NlVGFncyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIHRleHQsIGluc2VydFRyYW5zYWN0aW9uKSA9PiB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkgfHwgZnJvbSAhPSB0byB8fCAodGV4dCAhPSBcIj5cIiAmJiB0ZXh0ICE9IFwiL1wiKSB8fFxuICAgICAgICAhaHRtbExhbmd1YWdlLmlzQWN0aXZlQXQodmlldy5zdGF0ZSwgZnJvbSwgLTEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGJhc2UgPSBpbnNlcnRUcmFuc2FjdGlvbigpLCB7IHN0YXRlIH0gPSBiYXNlO1xuICAgIGxldCBjbG9zZVRhZ3MgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCBkaWRUeXBlID0gc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHJhbmdlLmZyb20gLSAxLCByYW5nZS50bykgPT0gdGV4dDtcbiAgICAgICAgbGV0IHsgaGVhZCB9ID0gcmFuZ2UsIGFmdGVyID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKGhlYWQsIC0xKSwgbmFtZTtcbiAgICAgICAgaWYgKGRpZFR5cGUgJiYgdGV4dCA9PSBcIj5cIiAmJiBhZnRlci5uYW1lID09IFwiRW5kVGFnXCIpIHtcbiAgICAgICAgICAgIGxldCB0YWcgPSBhZnRlci5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoKChfYiA9IChfYSA9IHRhZy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSAhPSBcIkNsb3NlVGFnXCIgJiZcbiAgICAgICAgICAgICAgICAobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgdGFnLnBhcmVudCwgaGVhZCkpICYmXG4gICAgICAgICAgICAgICAgIXNlbGZDbG9zZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGxldCB0byA9IGhlYWQgKyAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQsIGhlYWQgKyAxKSA9PT0gXCI+XCIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgbGV0IGluc2VydCA9IGA8LyR7bmFtZX0+YDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSwgY2hhbmdlczogeyBmcm9tOiBoZWFkLCB0bywgaW5zZXJ0IH0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaWRUeXBlICYmIHRleHQgPT0gXCIvXCIgJiYgYWZ0ZXIubmFtZSA9PSBcIkluY29tcGxldGVDbG9zZVRhZ1wiKSB7XG4gICAgICAgICAgICBsZXQgdGFnID0gYWZ0ZXIucGFyZW50O1xuICAgICAgICAgICAgaWYgKGFmdGVyLmZyb20gPT0gaGVhZCAtIDIgJiYgKChfYyA9IHRhZy5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5uYW1lKSAhPSBcIkNsb3NlVGFnXCIgJiZcbiAgICAgICAgICAgICAgICAobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgdGFnLCBoZWFkKSkgJiYgIXNlbGZDbG9zZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGxldCB0byA9IGhlYWQgKyAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQsIGhlYWQgKyAxKSA9PT0gXCI+XCIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgbGV0IGluc2VydCA9IGAke25hbWV9PmA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoaGVhZCArIGluc2VydC5sZW5ndGgsIC0xKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiBoZWFkLCB0bywgaW5zZXJ0IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKGNsb3NlVGFncy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaChbXG4gICAgICAgIGJhc2UsXG4gICAgICAgIHN0YXRlLnVwZGF0ZShjbG9zZVRhZ3MsIHtcbiAgICAgICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgfSlcbiAgICBdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG5leHBvcnQgeyBhdXRvQ2xvc2VUYWdzLCBodG1sLCBodG1sQ29tcGxldGlvblNvdXJjZSwgaHRtbENvbXBsZXRpb25Tb3VyY2VXaXRoLCBodG1sTGFuZ3VhZ2UgfTtcbiIsICJpbXBvcnQgeyBFZGl0b3JTZWxlY3Rpb24sIGNvdW50Q29sdW1uLCBQcmVjLCBFZGl0b3JTdGF0ZSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcsIGtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgZGVmaW5lTGFuZ3VhZ2VGYWNldCwgZm9sZE5vZGVQcm9wLCBpbmRlbnROb2RlUHJvcCwgbGFuZ3VhZ2VEYXRhUHJvcCwgZm9sZFNlcnZpY2UsIHN5bnRheFRyZWUsIExhbmd1YWdlLCBMYW5ndWFnZURlc2NyaXB0aW9uLCBQYXJzZUNvbnRleHQsIGluZGVudFVuaXQsIExhbmd1YWdlU3VwcG9ydCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IENvbXBsZXRpb25Db250ZXh0IH0gZnJvbSAnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJztcbmltcG9ydCB7IHBhcnNlciwgR0ZNLCBTdWJzY3JpcHQsIFN1cGVyc2NyaXB0LCBFbW9qaSwgTWFya2Rvd25QYXJzZXIsIHBhcnNlQ29kZSB9IGZyb20gJ0BsZXplci9tYXJrZG93bic7XG5pbXBvcnQgeyBodG1sLCBodG1sQ29tcGxldGlvblNvdXJjZSB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmctaHRtbCc7XG5pbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG5jb25zdCBkYXRhID0gLypAX19QVVJFX18qL2RlZmluZUxhbmd1YWdlRmFjZXQoeyBjb21tZW50VG9rZW5zOiB7IGJsb2NrOiB7IG9wZW46IFwiPCEtLVwiLCBjbG9zZTogXCItLT5cIiB9IH0gfSk7XG5jb25zdCBoZWFkaW5nUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbmNvbnN0IGNvbW1vbm1hcmsgPSAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgcHJvcHM6IFtcbiAgICAgICAgLypAX19QVVJFX18qL2ZvbGROb2RlUHJvcC5hZGQodHlwZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXR5cGUuaXMoXCJCbG9ja1wiKSB8fCB0eXBlLmlzKFwiRG9jdW1lbnRcIikgfHwgaXNIZWFkaW5nKHR5cGUpICE9IG51bGwgfHwgaXNMaXN0KHR5cGUpID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiAodHJlZSwgc3RhdGUpID0+ICh7IGZyb206IHN0YXRlLmRvYy5saW5lQXQodHJlZS5mcm9tKS50bywgdG86IHRyZWUudG8gfSk7XG4gICAgICAgIH0pLFxuICAgICAgICAvKkBfX1BVUkVfXyovaGVhZGluZ1Byb3AuYWRkKGlzSGVhZGluZyksXG4gICAgICAgIC8qQF9fUFVSRV9fKi9pbmRlbnROb2RlUHJvcC5hZGQoe1xuICAgICAgICAgICAgRG9jdW1lbnQ6ICgpID0+IG51bGxcbiAgICAgICAgfSksXG4gICAgICAgIC8qQF9fUFVSRV9fKi9sYW5ndWFnZURhdGFQcm9wLmFkZCh7XG4gICAgICAgICAgICBEb2N1bWVudDogZGF0YVxuICAgICAgICB9KVxuICAgIF1cbn0pO1xuZnVuY3Rpb24gaXNIZWFkaW5nKHR5cGUpIHtcbiAgICBsZXQgbWF0Y2ggPSAvXig/OkFUWHxTZXRleHQpSGVhZGluZyhcXGQpJC8uZXhlYyh0eXBlLm5hbWUpO1xuICAgIHJldHVybiBtYXRjaCA/ICttYXRjaFsxXSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzTGlzdCh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUubmFtZSA9PSBcIk9yZGVyZWRMaXN0XCIgfHwgdHlwZS5uYW1lID09IFwiQnVsbGV0TGlzdFwiO1xufVxuZnVuY3Rpb24gZmluZFNlY3Rpb25FbmQoaGVhZGVyTm9kZSwgbGV2ZWwpIHtcbiAgICBsZXQgbGFzdCA9IGhlYWRlck5vZGU7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dCA9IGxhc3QubmV4dFNpYmxpbmcsIGhlYWRpbmc7XG4gICAgICAgIGlmICghbmV4dCB8fCAoaGVhZGluZyA9IGlzSGVhZGluZyhuZXh0LnR5cGUpKSAhPSBudWxsICYmIGhlYWRpbmcgPD0gbGV2ZWwpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGFzdCA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBsYXN0LnRvO1xufVxuY29uc3QgaGVhZGVySW5kZW50ID0gLypAX19QVVJFX18qL2ZvbGRTZXJ2aWNlLm9mKChzdGF0ZSwgc3RhcnQsIGVuZCkgPT4ge1xuICAgIGZvciAobGV0IG5vZGUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIoZW5kLCAtMSk7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgICAgICBpZiAobm9kZS5mcm9tIDwgc3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGhlYWRpbmcgPSBub2RlLnR5cGUucHJvcChoZWFkaW5nUHJvcCk7XG4gICAgICAgIGlmIChoZWFkaW5nID09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHVwdG8gPSBmaW5kU2VjdGlvbkVuZChub2RlLCBoZWFkaW5nKTtcbiAgICAgICAgaWYgKHVwdG8gPiBlbmQpXG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBlbmQsIHRvOiB1cHRvIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufSk7XG5mdW5jdGlvbiBta0xhbmcocGFyc2VyKSB7XG4gICAgcmV0dXJuIG5ldyBMYW5ndWFnZShkYXRhLCBwYXJzZXIsIFtdLCBcIm1hcmtkb3duXCIpO1xufVxuLyoqXG5MYW5ndWFnZSBzdXBwb3J0IGZvciBzdHJpY3QgQ29tbW9uTWFyay5cbiovXG5jb25zdCBjb21tb25tYXJrTGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovbWtMYW5nKGNvbW1vbm1hcmspO1xuY29uc3QgZXh0ZW5kZWQgPSAvKkBfX1BVUkVfXyovY29tbW9ubWFyay5jb25maWd1cmUoW0dGTSwgU3Vic2NyaXB0LCBTdXBlcnNjcmlwdCwgRW1vamksIHtcbiAgICAgICAgcHJvcHM6IFtcbiAgICAgICAgICAgIC8qQF9fUFVSRV9fKi9mb2xkTm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBUYWJsZTogKHRyZWUsIHN0YXRlKSA9PiAoeyBmcm9tOiBzdGF0ZS5kb2MubGluZUF0KHRyZWUuZnJvbSkudG8sIHRvOiB0cmVlLnRvIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICBdXG4gICAgfV0pO1xuLyoqXG5MYW5ndWFnZSBzdXBwb3J0IGZvciBbR0ZNXShodHRwczovL2dpdGh1Yi5naXRodWIuY29tL2dmbS8pIHBsdXNcbnN1YnNjcmlwdCwgc3VwZXJzY3JpcHQsIGFuZCBlbW9qaSBzeW50YXguXG4qL1xuY29uc3QgbWFya2Rvd25MYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9ta0xhbmcoZXh0ZW5kZWQpO1xuZnVuY3Rpb24gZ2V0Q29kZVBhcnNlcihsYW5ndWFnZXMsIGRlZmF1bHRMYW5ndWFnZSkge1xuICAgIHJldHVybiAoaW5mbykgPT4ge1xuICAgICAgICBpZiAoaW5mbyAmJiBsYW5ndWFnZXMpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgICAgICAgICAvLyBTdHJpcCBhbnl0aGluZyBhZnRlciB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBpbmZvID0gL1xcUyovLmV4ZWMoaW5mbylbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhbmd1YWdlcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgZm91bmQgPSBsYW5ndWFnZXMoaW5mbyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm91bmQgPSBMYW5ndWFnZURlc2NyaXB0aW9uLm1hdGNoTGFuZ3VhZ2VOYW1lKGxhbmd1YWdlcywgaW5mbywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgaW5zdGFuY2VvZiBMYW5ndWFnZURlc2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5zdXBwb3J0ID8gZm91bmQuc3VwcG9ydC5sYW5ndWFnZS5wYXJzZXIgOiBQYXJzZUNvbnRleHQuZ2V0U2tpcHBpbmdQYXJzZXIoZm91bmQubG9hZCgpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5wYXJzZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMYW5ndWFnZSA/IGRlZmF1bHRMYW5ndWFnZS5wYXJzZXIgOiBudWxsO1xuICAgIH07XG59XG5cbmNsYXNzIENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGZyb20sIHRvLCBzcGFjZUJlZm9yZSwgc3BhY2VBZnRlciwgdHlwZSwgaXRlbSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc3BhY2VCZWZvcmUgPSBzcGFjZUJlZm9yZTtcbiAgICAgICAgdGhpcy5zcGFjZUFmdGVyID0gc3BhY2VBZnRlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICB9XG4gICAgYmxhbmsobWF4V2lkdGgsIHRyYWlsaW5nID0gdHJ1ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zcGFjZUJlZm9yZSArICh0aGlzLm5vZGUubmFtZSA9PSBcIkJsb2NrcXVvdGVcIiA/IFwiPlwiIDogXCJcIik7XG4gICAgICAgIGlmIChtYXhXaWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IG1heFdpZHRoKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIjtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy50byAtIHRoaXMuZnJvbSAtIHJlc3VsdC5sZW5ndGggLSB0aGlzLnNwYWNlQWZ0ZXIubGVuZ3RoOyBpID4gMDsgaS0tKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIjtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAodHJhaWxpbmcgPyB0aGlzLnNwYWNlQWZ0ZXIgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXJrZXIoZG9jLCBhZGQpIHtcbiAgICAgICAgbGV0IG51bWJlciA9IHRoaXMubm9kZS5uYW1lID09IFwiT3JkZXJlZExpc3RcIiA/IFN0cmluZygoK2l0ZW1OdW1iZXIodGhpcy5pdGVtLCBkb2MpWzJdICsgYWRkKSkgOiBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFjZUJlZm9yZSArIG51bWJlciArIHRoaXMudHlwZSArIHRoaXMuc3BhY2VBZnRlcjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0KG5vZGUsIGRvYykge1xuICAgIGxldCBub2RlcyA9IFtdLCBjb250ZXh0ID0gW107XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyOyBjdXIgPSBjdXIucGFyZW50KSB7XG4gICAgICAgIGlmIChjdXIubmFtZSA9PSBcIkZlbmNlZENvZGVcIilcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICBpZiAoY3VyLm5hbWUgPT0gXCJMaXN0SXRlbVwiIHx8IGN1ci5uYW1lID09IFwiQmxvY2txdW90ZVwiKVxuICAgICAgICAgICAgbm9kZXMucHVzaChjdXIpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXSwgbWF0Y2g7XG4gICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChub2RlLmZyb20pLCBzdGFydFBvcyA9IG5vZGUuZnJvbSAtIGxpbmUuZnJvbTtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PSBcIkJsb2NrcXVvdGVcIiAmJiAobWF0Y2ggPSAvXiAqPiggPykvLmV4ZWMobGluZS50ZXh0LnNsaWNlKHN0YXJ0UG9zKSkpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnB1c2gobmV3IENvbnRleHQobm9kZSwgc3RhcnRQb3MsIHN0YXJ0UG9zICsgbWF0Y2hbMF0ubGVuZ3RoLCBcIlwiLCBtYXRjaFsxXSwgXCI+XCIsIG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5hbWUgPT0gXCJMaXN0SXRlbVwiICYmIG5vZGUucGFyZW50Lm5hbWUgPT0gXCJPcmRlcmVkTGlzdFwiICYmXG4gICAgICAgICAgICAobWF0Y2ggPSAvXiggKilcXGQrKFsuKV0pKCAqKS8uZXhlYyhsaW5lLnRleHQuc2xpY2Uoc3RhcnRQb3MpKSkpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IG1hdGNoWzNdLCBsZW4gPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLnNsaWNlKDAsIGFmdGVyLmxlbmd0aCAtIDQpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5wdXNoKG5ldyBDb250ZXh0KG5vZGUucGFyZW50LCBzdGFydFBvcywgc3RhcnRQb3MgKyBsZW4sIG1hdGNoWzFdLCBhZnRlciwgbWF0Y2hbMl0sIG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5hbWUgPT0gXCJMaXN0SXRlbVwiICYmIG5vZGUucGFyZW50Lm5hbWUgPT0gXCJCdWxsZXRMaXN0XCIgJiZcbiAgICAgICAgICAgIChtYXRjaCA9IC9eKCAqKShbLSsqXSkoIHsxLDR9XFxbWyB4WF1cXF0pPyggKykvLmV4ZWMobGluZS50ZXh0LnNsaWNlKHN0YXJ0UG9zKSkpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBtYXRjaFs0XSwgbGVuID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGFmdGVyLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLnNsaWNlKDAsIGFmdGVyLmxlbmd0aCAtIDQpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHR5cGUgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIGlmIChtYXRjaFszXSlcbiAgICAgICAgICAgICAgICB0eXBlICs9IG1hdGNoWzNdLnJlcGxhY2UoL1t4WF0vLCAnICcpO1xuICAgICAgICAgICAgY29udGV4dC5wdXNoKG5ldyBDb250ZXh0KG5vZGUucGFyZW50LCBzdGFydFBvcywgc3RhcnRQb3MgKyBsZW4sIG1hdGNoWzFdLCBhZnRlciwgdHlwZSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gaXRlbU51bWJlcihpdGVtLCBkb2MpIHtcbiAgICByZXR1cm4gL14oXFxzKikoXFxkKykoPz1bLildKS8uZXhlYyhkb2Muc2xpY2VTdHJpbmcoaXRlbS5mcm9tLCBpdGVtLmZyb20gKyAxMCkpO1xufVxuZnVuY3Rpb24gcmVudW1iZXJMaXN0KGFmdGVyLCBkb2MsIGNoYW5nZXMsIG9mZnNldCA9IDApIHtcbiAgICBmb3IgKGxldCBwcmV2ID0gLTEsIG5vZGUgPSBhZnRlcjs7KSB7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJMaXN0SXRlbVwiKSB7XG4gICAgICAgICAgICBsZXQgbSA9IGl0ZW1OdW1iZXIobm9kZSwgZG9jKTtcbiAgICAgICAgICAgIGxldCBudW1iZXIgPSArbVsyXTtcbiAgICAgICAgICAgIGlmIChwcmV2ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyICE9IHByZXYgKyAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbm9kZS5mcm9tICsgbVsxXS5sZW5ndGgsIHRvOiBub2RlLmZyb20gKyBtWzBdLmxlbmd0aCwgaW5zZXJ0OiBTdHJpbmcocHJldiArIDIgKyBvZmZzZXQpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IG51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmRlbnQoY29udGVudCwgc3RhdGUpIHtcbiAgICBsZXQgYmxhbmsgPSAvXlsgXFx0XSovLmV4ZWMoY29udGVudClbMF0ubGVuZ3RoO1xuICAgIGlmICghYmxhbmsgfHwgc3RhdGUuZmFjZXQoaW5kZW50VW5pdCkgIT0gXCJcXHRcIilcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgbGV0IGNvbCA9IGNvdW50Q29sdW1uKGNvbnRlbnQsIDQsIGJsYW5rKTtcbiAgICBsZXQgc3BhY2UgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSBjb2w7IGkgPiAwOykge1xuICAgICAgICBpZiAoaSA+PSA0KSB7XG4gICAgICAgICAgICBzcGFjZSArPSBcIlxcdFwiO1xuICAgICAgICAgICAgaSAtPSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BhY2UgKz0gXCIgXCI7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlICsgY29udGVudC5zbGljZShibGFuayk7XG59XG4vKipcblJldHVybnMgYSBjb21tYW5kIGxpa2VcbltgaW5zZXJ0TmV3bGluZUNvbnRpbnVlTWFya3VwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLW1hcmtkb3duLmluc2VydE5ld2xpbmVDb250aW51ZU1hcmt1cCksXG5hbGxvd2luZyBmdXJ0aGVyIGNvbmZpZ3VyYXRpb24uXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUNvbnRpbnVlTWFya3VwQ29tbWFuZCA9IChjb25maWcgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCB7IGRvYyB9ID0gc3RhdGU7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgfHwgIW1hcmtkb3duTGFuZ3VhZ2UuaXNBY3RpdmVBdChzdGF0ZSwgcmFuZ2UuZnJvbSwgLTEpICYmICFtYXJrZG93bkxhbmd1YWdlLmlzQWN0aXZlQXQoc3RhdGUsIHJhbmdlLmZyb20sIDEpKVxuICAgICAgICAgICAgcmV0dXJuIGRvbnQgPSB7IHJhbmdlIH07XG4gICAgICAgIGxldCBwb3MgPSByYW5nZS5mcm9tLCBsaW5lID0gZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgY29udGV4dCA9IGdldENvbnRleHQodHJlZS5yZXNvbHZlSW5uZXIocG9zLCAtMSksIGRvYyk7XG4gICAgICAgIHdoaWxlIChjb250ZXh0Lmxlbmd0aCAmJiBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV0uZnJvbSA+IHBvcyAtIGxpbmUuZnJvbSlcbiAgICAgICAgICAgIGNvbnRleHQucG9wKCk7XG4gICAgICAgIGlmICghY29udGV4dC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZG9udCA9IHsgcmFuZ2UgfTtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaW5uZXIudG8gLSBpbm5lci5zcGFjZUFmdGVyLmxlbmd0aCA+IHBvcyAtIGxpbmUuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBkb250ID0geyByYW5nZSB9O1xuICAgICAgICBsZXQgZW1wdHlMaW5lID0gcG9zID49IChpbm5lci50byAtIGlubmVyLnNwYWNlQWZ0ZXIubGVuZ3RoKSAmJiAhL1xcUy8udGVzdChsaW5lLnRleHQuc2xpY2UoaW5uZXIudG8pKTtcbiAgICAgICAgLy8gRW1wdHkgbGluZSBpbiBsaXN0XG4gICAgICAgIGlmIChpbm5lci5pdGVtICYmIGVtcHR5TGluZSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gaW5uZXIubm9kZS5maXJzdENoaWxkLCBzZWNvbmQgPSBpbm5lci5ub2RlLmdldENoaWxkKFwiTGlzdEl0ZW1cIiwgXCJMaXN0SXRlbVwiKTtcbiAgICAgICAgICAgIC8vIE5vdCBzZWNvbmQgaXRlbSBvciBibGFuayBsaW5lIGJlZm9yZTogZGVsZXRlIGEgbGV2ZWwgb2YgbWFya3VwXG4gICAgICAgICAgICBpZiAoZmlyc3QudG8gPj0gcG9zIHx8IHNlY29uZCAmJiBzZWNvbmQudG8gPCBwb3MgfHxcbiAgICAgICAgICAgICAgICBsaW5lLmZyb20gPiAwICYmICEvW15cXHM+XS8udGVzdChkb2MubGluZUF0KGxpbmUuZnJvbSAtIDEpLnRleHQpIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLm5vblRpZ2h0TGlzdHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjb250ZXh0Lmxlbmd0aCA+IDEgPyBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBkZWxUbywgaW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lml0ZW0pIHsgLy8gUmUtYWRkIG1hcmtlciBmb3IgdGhlIGxpc3QgYXQgdGhlIG5leHQgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgZGVsVG8gPSBsaW5lLmZyb20gKyBuZXh0LmZyb207XG4gICAgICAgICAgICAgICAgICAgIGluc2VydCA9IG5leHQubWFya2VyKGRvYywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxUbyA9IGxpbmUuZnJvbSArIChuZXh0ID8gbmV4dC50byA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlcyA9IFt7IGZyb206IGRlbFRvLCB0bzogcG9zLCBpbnNlcnQgfV07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLm5vZGUubmFtZSA9PSBcIk9yZGVyZWRMaXN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHJlbnVtYmVyTGlzdChpbm5lci5pdGVtLCBkb2MsIGNoYW5nZXMsIC0yKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lm5vZGUubmFtZSA9PSBcIk9yZGVyZWRMaXN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHJlbnVtYmVyTGlzdChuZXh0Lml0ZW0sIGRvYywgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZGVsVG8gKyBpbnNlcnQubGVuZ3RoKSwgY2hhbmdlcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIE1vdmUgc2Vjb25kIGl0ZW0gZG93biwgbWFraW5nIHRpZ2h0IHR3by1pdGVtIGxpc3Qgbm9uLXRpZ2h0XG4gICAgICAgICAgICAgICAgbGV0IGluc2VydCA9IGJsYW5rTGluZShjb250ZXh0LCBzdGF0ZSwgbGluZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgaW5zZXJ0Lmxlbmd0aCArIDEpLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0OiBpbnNlcnQgKyBzdGF0ZS5saW5lQnJlYWsgfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbm5lci5ub2RlLm5hbWUgPT0gXCJCbG9ja3F1b3RlXCIgJiYgZW1wdHlMaW5lICYmIGxpbmUuZnJvbSkge1xuICAgICAgICAgICAgbGV0IHByZXZMaW5lID0gZG9jLmxpbmVBdChsaW5lLmZyb20gLSAxKSwgcXVvdGVkID0gLz5cXHMqJC8uZXhlYyhwcmV2TGluZS50ZXh0KTtcbiAgICAgICAgICAgIC8vIFR3byBhbGlnbmVkIGVtcHR5IHF1b3RlZCBsaW5lcyBpbiBhIHJvd1xuICAgICAgICAgICAgaWYgKHF1b3RlZCAmJiBxdW90ZWQuaW5kZXggPT0gaW5uZXIuZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlcyhbeyBmcm9tOiBwcmV2TGluZS5mcm9tICsgcXVvdGVkLmluZGV4LCB0bzogcHJldkxpbmUudG8gfSxcbiAgICAgICAgICAgICAgICAgICAgeyBmcm9tOiBsaW5lLmZyb20gKyBpbm5lci5mcm9tLCB0bzogbGluZS50byB9XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLm1hcChjaGFuZ2VzKSwgY2hhbmdlcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGlmIChpbm5lci5ub2RlLm5hbWUgPT0gXCJPcmRlcmVkTGlzdFwiKVxuICAgICAgICAgICAgcmVudW1iZXJMaXN0KGlubmVyLml0ZW0sIGRvYywgY2hhbmdlcyk7XG4gICAgICAgIGxldCBjb250aW51ZWQgPSBpbm5lci5pdGVtICYmIGlubmVyLml0ZW0uZnJvbSA8IGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IGluc2VydCA9IFwiXCI7XG4gICAgICAgIC8vIElmIG5vdCBkZWRlbnRlZFxuICAgICAgICBpZiAoIWNvbnRpbnVlZCB8fCAvXltcXHNcXGQuKVxcLSsqPl0qLy5leGVjKGxpbmUudGV4dClbMF0ubGVuZ3RoID49IGlubmVyLnRvKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IGNvbnRleHQubGVuZ3RoIC0gMTsgaSA8PSBlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnNlcnQgKz0gaSA9PSBlICYmICFjb250aW51ZWQgPyBjb250ZXh0W2ldLm1hcmtlcihkb2MsIDEpXG4gICAgICAgICAgICAgICAgICAgIDogY29udGV4dFtpXS5ibGFuayhpIDwgZSA/IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgNCwgY29udGV4dFtpICsgMV0uZnJvbSkgLSBpbnNlcnQubGVuZ3RoIDogbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZyb20gPSBwb3M7XG4gICAgICAgIHdoaWxlIChmcm9tID4gbGluZS5mcm9tICYmIC9cXHMvLnRlc3QobGluZS50ZXh0LmNoYXJBdChmcm9tIC0gbGluZS5mcm9tIC0gMSkpKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBpbnNlcnQgPSBub3JtYWxpemVJbmRlbnQoaW5zZXJ0LCBzdGF0ZSk7XG4gICAgICAgIGlmIChub25UaWdodExpc3QoaW5uZXIubm9kZSwgc3RhdGUuZG9jKSlcbiAgICAgICAgICAgIGluc2VydCA9IGJsYW5rTGluZShjb250ZXh0LCBzdGF0ZSwgbGluZSkgKyBzdGF0ZS5saW5lQnJlYWsgKyBpbnNlcnQ7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb20sIHRvOiBwb3MsIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgaW5zZXJ0IH0pO1xuICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgaW5zZXJ0Lmxlbmd0aCArIDEpLCBjaGFuZ2VzIH07XG4gICAgfSk7XG4gICAgaWYgKGRvbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuVGhpcyBjb21tYW5kLCB3aGVuIGludm9rZWQgaW4gTWFya2Rvd24gY29udGV4dCB3aXRoIGN1cnNvclxuc2VsZWN0aW9uKHMpLCB3aWxsIGNyZWF0ZSBhIG5ldyBsaW5lIHdpdGggdGhlIG1hcmt1cCBmb3JcbmJsb2NrcXVvdGVzIGFuZCBsaXN0cyB0aGF0IHdlcmUgYWN0aXZlIG9uIHRoZSBvbGQgbGluZS4gSWYgdGhlXG5jdXJzb3Igd2FzIGRpcmVjdGx5IGFmdGVyIHRoZSBlbmQgb2YgdGhlIG1hcmt1cCBmb3IgdGhlIG9sZCBsaW5lLFxudHJhaWxpbmcgd2hpdGVzcGFjZSBhbmQgbGlzdCBtYXJrZXJzIGFyZSByZW1vdmVkIGZyb20gdGhhdCBsaW5lLlxuXG5UaGUgY29tbWFuZCBkb2VzIG5vdGhpbmcgaW4gbm9uLU1hcmtkb3duIGNvbnRleHQsIHNvIGl0IHNob3VsZFxubm90IGJlIHVzZWQgYXMgdGhlIG9ubHkgYmluZGluZyBmb3IgRW50ZXIgKGV2ZW4gaW4gYSBNYXJrZG93blxuZG9jdW1lbnQsIEhUTUwgYW5kIGNvZGUgcmVnaW9ucyBtaWdodCB1c2UgYSBkaWZmZXJlbnQgbGFuZ3VhZ2UpLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmVDb250aW51ZU1hcmt1cCA9IC8qQF9fUFVSRV9fKi9pbnNlcnROZXdsaW5lQ29udGludWVNYXJrdXBDb21tYW5kKCk7XG5mdW5jdGlvbiBpc01hcmsobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5hbWUgPT0gXCJRdW90ZU1hcmtcIiB8fCBub2RlLm5hbWUgPT0gXCJMaXN0TWFya1wiO1xufVxuZnVuY3Rpb24gbm9uVGlnaHRMaXN0KG5vZGUsIGRvYykge1xuICAgIGlmIChub2RlLm5hbWUgIT0gXCJPcmRlcmVkTGlzdFwiICYmIG5vZGUubmFtZSAhPSBcIkJ1bGxldExpc3RcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZCwgc2Vjb25kID0gbm9kZS5nZXRDaGlsZChcIkxpc3RJdGVtXCIsIFwiTGlzdEl0ZW1cIik7XG4gICAgaWYgKCFzZWNvbmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbGluZTEgPSBkb2MubGluZUF0KGZpcnN0LnRvKSwgbGluZTIgPSBkb2MubGluZUF0KHNlY29uZC5mcm9tKTtcbiAgICBsZXQgZW1wdHkgPSAvXltcXHM+XSokLy50ZXN0KGxpbmUxLnRleHQpO1xuICAgIHJldHVybiBsaW5lMS5udW1iZXIgKyAoZW1wdHkgPyAwIDogMSkgPCBsaW5lMi5udW1iZXI7XG59XG5mdW5jdGlvbiBibGFua0xpbmUoY29udGV4dCwgc3RhdGUsIGxpbmUpIHtcbiAgICBsZXQgaW5zZXJ0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMCwgZSA9IGNvbnRleHQubGVuZ3RoIC0gMjsgaSA8PSBlOyBpKyspIHtcbiAgICAgICAgaW5zZXJ0ICs9IGNvbnRleHRbaV0uYmxhbmsoaSA8IGVcbiAgICAgICAgICAgID8gY291bnRDb2x1bW4obGluZS50ZXh0LCA0LCBjb250ZXh0W2kgKyAxXS5mcm9tKSAtIGluc2VydC5sZW5ndGhcbiAgICAgICAgICAgIDogbnVsbCwgaSA8IGUpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplSW5kZW50KGluc2VydCwgc3RhdGUpO1xufVxuZnVuY3Rpb24gY29udGV4dE5vZGVGb3JEZWxldGUodHJlZSwgcG9zKSB7XG4gICAgbGV0IG5vZGUgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIC0xKSwgc2NhbiA9IHBvcztcbiAgICBpZiAoaXNNYXJrKG5vZGUpKSB7XG4gICAgICAgIHNjYW4gPSBub2RlLmZyb207XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gICAgZm9yIChsZXQgcHJldjsgcHJldiA9IG5vZGUuY2hpbGRCZWZvcmUoc2Nhbik7KSB7XG4gICAgICAgIGlmIChpc01hcmsocHJldikpIHtcbiAgICAgICAgICAgIHNjYW4gPSBwcmV2LmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldi5uYW1lID09IFwiT3JkZXJlZExpc3RcIiB8fCBwcmV2Lm5hbWUgPT0gXCJCdWxsZXRMaXN0XCIpIHtcbiAgICAgICAgICAgIG5vZGUgPSBwcmV2Lmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHNjYW4gPSBub2RlLnRvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG4vKipcblRoaXMgY29tbWFuZCB3aWxsLCB3aGVuIGludm9rZWQgaW4gYSBNYXJrZG93biBjb250ZXh0IHdpdGggdGhlXG5jdXJzb3IgZGlyZWN0bHkgYWZ0ZXIgbGlzdCBvciBibG9ja3F1b3RlIG1hcmt1cCwgZGVsZXRlIG9uZSBsZXZlbFxub2YgbWFya3VwLiBXaGVuIHRoZSBtYXJrdXAgaXMgZm9yIGEgbGlzdCwgaXQgd2lsbCBiZSByZXBsYWNlZCBieVxuc3BhY2VzIG9uIHRoZSBmaXJzdCBpbnZvY2F0aW9uIChhIGZ1cnRoZXIgaW52b2NhdGlvbiB3aWxsIGRlbGV0ZVxudGhlIHNwYWNlcyksIHRvIG1ha2UgaXQgZWFzeSB0byBjb250aW51ZSBhIGxpc3QuXG5cbldoZW4gbm90IGFmdGVyIE1hcmtkb3duIGJsb2NrIG1hcmt1cCwgdGhpcyBjb21tYW5kIHdpbGwgcmV0dXJuXG5mYWxzZSwgc28gaXQgaXMgaW50ZW5kZWQgdG8gYmUgYm91bmQgYWxvbmdzaWRlIG90aGVyIGRlbGV0aW9uXG5jb21tYW5kcywgd2l0aCBhIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gdGhlIG1vcmUgZ2VuZXJpYyBjb21tYW5kcy5cbiovXG5jb25zdCBkZWxldGVNYXJrdXBCYWNrd2FyZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKTtcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmZyb20sIHsgZG9jIH0gPSBzdGF0ZTtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5ICYmIG1hcmtkb3duTGFuZ3VhZ2UuaXNBY3RpdmVBdChzdGF0ZSwgcmFuZ2UuZnJvbSkpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBnZXRDb250ZXh0KGNvbnRleHROb2RlRm9yRGVsZXRlKHRyZWUsIHBvcyksIGRvYyk7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbGV0IHNwYWNlRW5kID0gaW5uZXIudG8gLSBpbm5lci5zcGFjZUFmdGVyLmxlbmd0aCArIChpbm5lci5zcGFjZUFmdGVyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBleHRyYSB0cmFpbGluZyBzcGFjZSBhZnRlciBtYXJrdXBcbiAgICAgICAgICAgICAgICBpZiAocG9zIC0gbGluZS5mcm9tID4gc3BhY2VFbmQgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKHNwYWNlRW5kLCBwb3MgLSBsaW5lLmZyb20pKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS5mcm9tICsgc3BhY2VFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20gKyBzcGFjZUVuZCwgdG86IHBvcyB9IH07XG4gICAgICAgICAgICAgICAgaWYgKHBvcyAtIGxpbmUuZnJvbSA9PSBzcGFjZUVuZCAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGx5IHRoaXMgaWYgd2UncmUgb24gdGhlIGxpbmUgdGhhdCBoYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0cnVjdCdzIHN5bnRheCwgb3IgdGhlcmUncyBvbmx5IGluZGVudGF0aW9uIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgKCFpbm5lci5pdGVtIHx8IGxpbmUuZnJvbSA8PSBpbm5lci5pdGVtLmZyb20gfHwgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKDAsIGlubmVyLnRvKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGxpbmUuZnJvbSArIGlubmVyLmZyb207XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgYSBsaXN0IGl0ZW0gbWFya2VyIHdpdGggYmxhbmsgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLml0ZW0gJiYgaW5uZXIubm9kZS5mcm9tIDwgaW5uZXIuaXRlbS5mcm9tICYmIC9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKGlubmVyLmZyb20sIGlubmVyLnRvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnNlcnQgPSBpbm5lci5ibGFuayhjb3VudENvbHVtbihsaW5lLnRleHQsIDQsIGlubmVyLnRvKSAtIGNvdW50Q29sdW1uKGxpbmUudGV4dCwgNCwgaW5uZXIuZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBub3JtYWxpemVJbmRlbnQoaW5zZXJ0LCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzdGFydCArIGluc2VydC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogc3RhcnQsIHRvOiBsaW5lLmZyb20gKyBpbm5lci50bywgaW5zZXJ0IH0gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgb25lIGxldmVsIG9mIGluZGVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXJ0KSwgY2hhbmdlczogeyBmcm9tOiBzdGFydCwgdG86IHBvcyB9IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb250ID0geyByYW5nZSB9O1xuICAgIH0pO1xuICAgIGlmIChkb250KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJkZWxldGVcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbkEgc21hbGwga2V5bWFwIHdpdGggTWFya2Rvd24tc3BlY2lmaWMgYmluZGluZ3MuIEJpbmRzIEVudGVyIHRvXG5bYGluc2VydE5ld2xpbmVDb250aW51ZU1hcmt1cGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZy1tYXJrZG93bi5pbnNlcnROZXdsaW5lQ29udGludWVNYXJrdXApXG5hbmQgQmFja3NwYWNlIHRvXG5bYGRlbGV0ZU1hcmt1cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLW1hcmtkb3duLmRlbGV0ZU1hcmt1cEJhY2t3YXJkKS5cbiovXG5jb25zdCBtYXJrZG93bktleW1hcCA9IFtcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGluc2VydE5ld2xpbmVDb250aW51ZU1hcmt1cCB9LFxuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZU1hcmt1cEJhY2t3YXJkIH1cbl07XG5jb25zdCBodG1sTm9NYXRjaCA9IC8qQF9fUFVSRV9fKi9odG1sKHsgbWF0Y2hDbG9zaW5nVGFnczogZmFsc2UgfSk7XG4vKipcbk1hcmtkb3duIGxhbmd1YWdlIHN1cHBvcnQuXG4qL1xuZnVuY3Rpb24gbWFya2Rvd24oY29uZmlnID0ge30pIHtcbiAgICBsZXQgeyBjb2RlTGFuZ3VhZ2VzLCBkZWZhdWx0Q29kZUxhbmd1YWdlLCBhZGRLZXltYXAgPSB0cnVlLCBiYXNlOiB7IHBhcnNlciB9ID0gY29tbW9ubWFya0xhbmd1YWdlLCBjb21wbGV0ZUhUTUxUYWdzID0gdHJ1ZSwgcGFzdGVVUkxBc0xpbms6IHBhc3RlVVJMID0gdHJ1ZSwgaHRtbFRhZ0xhbmd1YWdlID0gaHRtbE5vTWF0Y2ggfSA9IGNvbmZpZztcbiAgICBpZiAoIShwYXJzZXIgaW5zdGFuY2VvZiBNYXJrZG93blBhcnNlcikpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQmFzZSBwYXJzZXIgcHJvdmlkZWQgdG8gYG1hcmtkb3duYCBzaG91bGQgYmUgYSBNYXJrZG93biBwYXJzZXJcIik7XG4gICAgbGV0IGV4dGVuc2lvbnMgPSBjb25maWcuZXh0ZW5zaW9ucyA/IFtjb25maWcuZXh0ZW5zaW9uc10gOiBbXTtcbiAgICBsZXQgc3VwcG9ydCA9IFtodG1sVGFnTGFuZ3VhZ2Uuc3VwcG9ydCwgaGVhZGVySW5kZW50XSwgZGVmYXVsdENvZGU7XG4gICAgaWYgKHBhc3RlVVJMKVxuICAgICAgICBzdXBwb3J0LnB1c2gocGFzdGVVUkxBc0xpbmspO1xuICAgIGlmIChkZWZhdWx0Q29kZUxhbmd1YWdlIGluc3RhbmNlb2YgTGFuZ3VhZ2VTdXBwb3J0KSB7XG4gICAgICAgIHN1cHBvcnQucHVzaChkZWZhdWx0Q29kZUxhbmd1YWdlLnN1cHBvcnQpO1xuICAgICAgICBkZWZhdWx0Q29kZSA9IGRlZmF1bHRDb2RlTGFuZ3VhZ2UubGFuZ3VhZ2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZmF1bHRDb2RlTGFuZ3VhZ2UpIHtcbiAgICAgICAgZGVmYXVsdENvZGUgPSBkZWZhdWx0Q29kZUxhbmd1YWdlO1xuICAgIH1cbiAgICBsZXQgY29kZVBhcnNlciA9IGNvZGVMYW5ndWFnZXMgfHwgZGVmYXVsdENvZGUgPyBnZXRDb2RlUGFyc2VyKGNvZGVMYW5ndWFnZXMsIGRlZmF1bHRDb2RlKSA6IHVuZGVmaW5lZDtcbiAgICBleHRlbnNpb25zLnB1c2gocGFyc2VDb2RlKHsgY29kZVBhcnNlciwgaHRtbFBhcnNlcjogaHRtbFRhZ0xhbmd1YWdlLmxhbmd1YWdlLnBhcnNlciB9KSk7XG4gICAgaWYgKGFkZEtleW1hcClcbiAgICAgICAgc3VwcG9ydC5wdXNoKFByZWMuaGlnaChrZXltYXAub2YobWFya2Rvd25LZXltYXApKSk7XG4gICAgbGV0IGxhbmcgPSBta0xhbmcocGFyc2VyLmNvbmZpZ3VyZShleHRlbnNpb25zKSk7XG4gICAgaWYgKGNvbXBsZXRlSFRNTFRhZ3MpXG4gICAgICAgIHN1cHBvcnQucHVzaChsYW5nLmRhdGEub2YoeyBhdXRvY29tcGxldGU6IGh0bWxUYWdDb21wbGV0aW9uIH0pKTtcbiAgICByZXR1cm4gbmV3IExhbmd1YWdlU3VwcG9ydChsYW5nLCBzdXBwb3J0KTtcbn1cbmZ1bmN0aW9uIGh0bWxUYWdDb21wbGV0aW9uKGNvbnRleHQpIHtcbiAgICBsZXQgeyBzdGF0ZSwgcG9zIH0gPSBjb250ZXh0LCBtID0gLzxbOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC8uZXhlYyhzdGF0ZS5zbGljZURvYyhwb3MgLSAyNSwgcG9zKSk7XG4gICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MsIC0xKTtcbiAgICB3aGlsZSAodHJlZSAmJiAhdHJlZS50eXBlLmlzVG9wKSB7XG4gICAgICAgIGlmICh0cmVlLm5hbWUgPT0gXCJDb2RlQmxvY2tcIiB8fCB0cmVlLm5hbWUgPT0gXCJGZW5jZWRDb2RlXCIgfHwgdHJlZS5uYW1lID09IFwiUHJvY2Vzc2luZ0luc3RydWN0aW9uQmxvY2tcIiB8fFxuICAgICAgICAgICAgdHJlZS5uYW1lID09IFwiQ29tbWVudEJsb2NrXCIgfHwgdHJlZS5uYW1lID09IFwiTGlua1wiIHx8IHRyZWUubmFtZSA9PSBcIkltYWdlXCIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdHJlZSA9IHRyZWUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBwb3MgLSBtWzBdLmxlbmd0aCwgdG86IHBvcyxcbiAgICAgICAgb3B0aW9uczogaHRtbFRhZ0NvbXBsZXRpb25zKCksXG4gICAgICAgIHZhbGlkRm9yOiAvXjxbOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC9cbiAgICB9O1xufVxubGV0IF90YWdDb21wbGV0aW9ucyA9IG51bGw7XG5mdW5jdGlvbiBodG1sVGFnQ29tcGxldGlvbnMoKSB7XG4gICAgaWYgKF90YWdDb21wbGV0aW9ucylcbiAgICAgICAgcmV0dXJuIF90YWdDb21wbGV0aW9ucztcbiAgICBsZXQgcmVzdWx0ID0gaHRtbENvbXBsZXRpb25Tb3VyY2UobmV3IENvbXBsZXRpb25Db250ZXh0KEVkaXRvclN0YXRlLmNyZWF0ZSh7IGV4dGVuc2lvbnM6IGh0bWxOb01hdGNoIH0pLCAwLCB0cnVlKSk7XG4gICAgcmV0dXJuIF90YWdDb21wbGV0aW9ucyA9IHJlc3VsdCA/IHJlc3VsdC5vcHRpb25zIDogW107XG59XG5jb25zdCBub25QbGFpblRleHQgPSAvY29kZXxob3Jpem9udGFscnVsZXxodG1sfGxpbmt8Y29tbWVudHxwcm9jZXNzaW5nfGVzY2FwZXxlbnRpdHl8aW1hZ2V8bWFya3x1cmwvaTtcbi8qKlxuQW4gZXh0ZW5zaW9uIHRoYXQgaW50ZXJjZXB0cyBwYXN0ZXMgd2hlbiB0aGUgcGFzdGVkIGNvbnRlbnQgbG9va3Ncbmxpa2UgYSBVUkwgYW5kIHRoZSBzZWxlY3Rpb24gaXMgbm9uLWVtcHR5IGFuZCBzZWxlY3RzIHJlZ3VsYXJcbnRleHQsIG1ha2luZyB0aGUgc2VsZWN0aW9uIGEgbGluayB3aXRoIHRoZSBwYXN0ZWQgVVJMIGFzIHRhcmdldC5cbiovXG5jb25zdCBwYXN0ZVVSTEFzTGluayA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIHBhc3RlOiAoZXZlbnQsIHZpZXcpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgeyBtYWluIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG1haW4uZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBsaW5rID0gKF9hID0gZXZlbnQuY2xpcGJvYXJkRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICBpZiAoIWxpbmsgfHwgIS9eKGh0dHBzPzpcXC9cXC98bWFpbHRvOnx4bXBwOnx3d3dcXC4pLy50ZXN0KGxpbmspKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoL153d3dcXC4vLnRlc3QobGluaykpXG4gICAgICAgICAgICBsaW5rID0gXCJodHRwczovL1wiICsgbGluaztcbiAgICAgICAgaWYgKCFtYXJrZG93bkxhbmd1YWdlLmlzQWN0aXZlQXQodmlldy5zdGF0ZSwgbWFpbi5mcm9tLCAxKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpLCBjcm9zc2VzTm9kZSA9IGZhbHNlO1xuICAgICAgICAvLyBWZXJpZnkgdGhhdCBubyBub2RlcyBhcmUgc3RhcnRlZC9lbmRlZCBiZXR3ZWVuIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgLy8gcG9pbnRzLCBhbmQgd2UncmUgbm90IGluc2lkZSBhbnkgbm9uLXBsYWluLXRleHQgY29uc3RydWN0LlxuICAgICAgICB0cmVlLml0ZXJhdGUoe1xuICAgICAgICAgICAgZnJvbTogbWFpbi5mcm9tLCB0bzogbWFpbi50byxcbiAgICAgICAgICAgIGVudGVyOiBub2RlID0+IHsgaWYgKG5vZGUuZnJvbSA+IG1haW4uZnJvbSB8fCBub25QbGFpblRleHQudGVzdChub2RlLm5hbWUpKVxuICAgICAgICAgICAgICAgIGNyb3NzZXNOb2RlID0gdHJ1ZTsgfSxcbiAgICAgICAgICAgIGxlYXZlOiBub2RlID0+IHsgaWYgKG5vZGUudG8gPCBtYWluLnRvKVxuICAgICAgICAgICAgICAgIGNyb3NzZXNOb2RlID0gdHJ1ZTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNyb3NzZXNOb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGNoYW5nZXM6IFt7IGZyb206IG1haW4uZnJvbSwgaW5zZXJ0OiBcIltcIiB9LCB7IGZyb206IG1haW4udG8sIGluc2VydDogYF0oJHtsaW5rfSlgIH1dLFxuICAgICAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnBhc3RlXCIsXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG5cbmV4cG9ydCB7IGNvbW1vbm1hcmtMYW5ndWFnZSwgZGVsZXRlTWFya3VwQmFja3dhcmQsIGluc2VydE5ld2xpbmVDb250aW51ZU1hcmt1cCwgaW5zZXJ0TmV3bGluZUNvbnRpbnVlTWFya3VwQ29tbWFuZCwgbWFya2Rvd24sIG1hcmtkb3duS2V5bWFwLCBtYXJrZG93bkxhbmd1YWdlLCBwYXN0ZVVSTEFzTGluayB9O1xuIiwgImltcG9ydCB7IEFubm90YXRpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBUcmFuc2FjdGlvbiwgQ2hhbmdlU2V0LCBDaGFuZ2VEZXNjLCBFZGl0b3JTZWxlY3Rpb24sIFN0YXRlRWZmZWN0LCBUZXh0LCBmaW5kQ2x1c3RlckJyZWFrLCBjb3VudENvbHVtbiwgQ2hhckNhdGVnb3J5IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldywgRGlyZWN0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBJbmRlbnRDb250ZXh0LCBnZXRJbmRlbnRhdGlvbiwgaW5kZW50U3RyaW5nLCBtYXRjaEJyYWNrZXRzLCBzeW50YXhUcmVlLCBnZXRJbmRlbnRVbml0LCBpbmRlbnRVbml0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgdXNlIGxpbmUgY29tbWVudHNcbmlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGxpbmcgYmFjayB0byBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCB0b2dnbGVDb21tZW50ID0gdGFyZ2V0ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5mcm9tKSwgY29uZmlnID0gZ2V0Q29uZmlnKHRhcmdldC5zdGF0ZSwgbGluZS5mcm9tKTtcbiAgICByZXR1cm4gY29uZmlnLmxpbmUgPyB0b2dnbGVMaW5lQ29tbWVudCh0YXJnZXQpIDogY29uZmlnLmJsb2NrID8gdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lKHRhcmdldCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBjb21tYW5kKGYsIG9wdGlvbikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGYob3B0aW9uLCBzdGF0ZSk7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh0cikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cblRoZSBsaW5lIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlTGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG4vKipcbkNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4qL1xuY29uc3QgbGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8pO1xuLyoqXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4qL1xuY29uc3QgbGluZVVuY29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuVGhlIGJsb2NrIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbi8qKlxuQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgYmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyk7XG4vKipcblVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgYmxvY2tVbmNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8pO1xuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgbGluZXMgYXJvdW5kIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZ1xuYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lID0gLypAX19QVVJFX18qL2NvbW1hbmQoKG8sIHMpID0+IGNoYW5nZUJsb2NrQ29tbWVudChvLCBzLCBzZWxlY3RlZExpbmVSYW5nZXMocykpLCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbmZ1bmN0aW9uIGdldENvbmZpZyhzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IGRhdGEgPSBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImNvbW1lbnRUb2tlbnNcIiwgcG9zLCAxKTtcbiAgICByZXR1cm4gZGF0YS5sZW5ndGggPyBkYXRhWzBdIDoge307XG59XG5jb25zdCBTZWFyY2hNYXJnaW4gPSA1MDtcbi8qKlxuRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gcmFuZ2UgaXMgYmxvY2stY29tbWVudGVkIGluIHRoZSBnaXZlblxuc3RhdGUuXG4qL1xuZnVuY3Rpb24gZmluZEJsb2NrQ29tbWVudChzdGF0ZSwgeyBvcGVuLCBjbG9zZSB9LCBmcm9tLCB0bykge1xuICAgIGxldCB0ZXh0QmVmb3JlID0gc3RhdGUuc2xpY2VEb2MoZnJvbSAtIFNlYXJjaE1hcmdpbiwgZnJvbSk7XG4gICAgbGV0IHRleHRBZnRlciA9IHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIFNlYXJjaE1hcmdpbik7XG4gICAgbGV0IHNwYWNlQmVmb3JlID0gL1xccyokLy5leGVjKHRleHRCZWZvcmUpWzBdLmxlbmd0aCwgc3BhY2VBZnRlciA9IC9eXFxzKi8uZXhlYyh0ZXh0QWZ0ZXIpWzBdLmxlbmd0aDtcbiAgICBsZXQgYmVmb3JlT2ZmID0gdGV4dEJlZm9yZS5sZW5ndGggLSBzcGFjZUJlZm9yZTtcbiAgICBpZiAodGV4dEJlZm9yZS5zbGljZShiZWZvcmVPZmYgLSBvcGVuLmxlbmd0aCwgYmVmb3JlT2ZmKSA9PSBvcGVuICYmXG4gICAgICAgIHRleHRBZnRlci5zbGljZShzcGFjZUFmdGVyLCBzcGFjZUFmdGVyICsgY2xvc2UubGVuZ3RoKSA9PSBjbG9zZSkge1xuICAgICAgICByZXR1cm4geyBvcGVuOiB7IHBvczogZnJvbSAtIHNwYWNlQmVmb3JlLCBtYXJnaW46IHNwYWNlQmVmb3JlICYmIDEgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gKyBzcGFjZUFmdGVyLCBtYXJnaW46IHNwYWNlQWZ0ZXIgJiYgMSB9IH07XG4gICAgfVxuICAgIGxldCBzdGFydFRleHQsIGVuZFRleHQ7XG4gICAgaWYgKHRvIC0gZnJvbSA8PSAyICogU2VhcmNoTWFyZ2luKSB7XG4gICAgICAgIHN0YXJ0VGV4dCA9IGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGFydFRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgU2VhcmNoTWFyZ2luKTtcbiAgICAgICAgZW5kVGV4dCA9IHN0YXRlLnNsaWNlRG9jKHRvIC0gU2VhcmNoTWFyZ2luLCB0byk7XG4gICAgfVxuICAgIGxldCBzdGFydFNwYWNlID0gL15cXHMqLy5leGVjKHN0YXJ0VGV4dClbMF0ubGVuZ3RoLCBlbmRTcGFjZSA9IC9cXHMqJC8uZXhlYyhlbmRUZXh0KVswXS5sZW5ndGg7XG4gICAgbGV0IGVuZE9mZiA9IGVuZFRleHQubGVuZ3RoIC0gZW5kU3BhY2UgLSBjbG9zZS5sZW5ndGg7XG4gICAgaWYgKHN0YXJ0VGV4dC5zbGljZShzdGFydFNwYWNlLCBzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgpID09IG9wZW4gJiZcbiAgICAgICAgZW5kVGV4dC5zbGljZShlbmRPZmYsIGVuZE9mZiArIGNsb3NlLmxlbmd0aCkgPT0gY2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gKyBzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAvXFxzLy50ZXN0KHN0YXJ0VGV4dC5jaGFyQXQoc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSkgPyAxIDogMCB9LFxuICAgICAgICAgICAgY2xvc2U6IHsgcG9zOiB0byAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogL1xccy8udGVzdChlbmRUZXh0LmNoYXJBdChlbmRPZmYgLSAxKSkgPyAxIDogMCB9IH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lUmFuZ2VzKHN0YXRlKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHIgb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgZnJvbUxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHIuZnJvbSk7XG4gICAgICAgIGxldCB0b0xpbmUgPSByLnRvIDw9IGZyb21MaW5lLnRvID8gZnJvbUxpbmUgOiBzdGF0ZS5kb2MubGluZUF0KHIudG8pO1xuICAgICAgICBpZiAodG9MaW5lLmZyb20gPiBmcm9tTGluZS5mcm9tICYmIHRvTGluZS5mcm9tID09IHIudG8pXG4gICAgICAgICAgICB0b0xpbmUgPSByLnRvID09IGZyb21MaW5lLnRvICsgMSA/IGZyb21MaW5lIDogc3RhdGUuZG9jLmxpbmVBdChyLnRvIC0gMSk7XG4gICAgICAgIGxldCBsYXN0ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdLnRvID4gZnJvbUxpbmUuZnJvbSlcbiAgICAgICAgICAgIHJhbmdlc1tsYXN0XS50byA9IHRvTGluZS50bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBmcm9tTGluZS5mcm9tICsgL15cXHMqLy5leGVjKGZyb21MaW5lLnRleHQpWzBdLmxlbmd0aCwgdG86IHRvTGluZS50byB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbi8vIFBlcmZvcm1zIHRvZ2dsZSwgY29tbWVudCBhbmQgdW5jb21tZW50IG9mIGJsb2NrIGNvbW1lbnRzIGluXG4vLyBsYW5ndWFnZXMgdGhhdCBzdXBwb3J0IHRoZW0uXG5mdW5jdGlvbiBjaGFuZ2VCbG9ja0NvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgIGxldCB0b2tlbnMgPSByYW5nZXMubWFwKHIgPT4gZ2V0Q29uZmlnKHN0YXRlLCByLmZyb20pLmJsb2NrKTtcbiAgICBpZiAoIXRva2Vucy5ldmVyeShjID0+IGMpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgY29tbWVudHMgPSByYW5nZXMubWFwKChyLCBpKSA9PiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB0b2tlbnNbaV0sIHIuZnJvbSwgci50bykpO1xuICAgIGlmIChvcHRpb24gIT0gMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyAmJiAhY29tbWVudHMuZXZlcnkoYyA9PiBjKSkge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBzdGF0ZS5jaGFuZ2VzKHJhbmdlcy5tYXAoKHJhbmdlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRzW2ldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7IGZyb206IHJhbmdlLmZyb20sIGluc2VydDogdG9rZW5zW2ldLm9wZW4gKyBcIiBcIiB9LCB7IGZyb206IHJhbmdlLnRvLCBpbnNlcnQ6IFwiIFwiICsgdG9rZW5zW2ldLmNsb3NlIH1dO1xuICAgICAgICAgICAgfSkpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBjb21tZW50cy5zb21lKGMgPT4gYykpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvbW1lbnQ7IGkgPCBjb21tZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21tZW50ID0gY29tbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV0sIHsgb3BlbiwgY2xvc2UgfSA9IGNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogb3Blbi5wb3MgLSB0b2tlbi5vcGVuLmxlbmd0aCwgdG86IG9wZW4ucG9zICsgb3Blbi5tYXJnaW4gfSwgeyBmcm9tOiBjbG9zZS5wb3MgLSBjbG9zZS5tYXJnaW4sIHRvOiBjbG9zZS5wb3MgKyB0b2tlbi5jbG9zZS5sZW5ndGggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBsaW5lIGNvbW1lbnRzLlxuZnVuY3Rpb24gY2hhbmdlTGluZUNvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxldCBwcmV2TGluZSA9IC0xO1xuICAgIHJhbmdlczogZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHJhbmdlcykge1xuICAgICAgICBsZXQgc3RhcnRJID0gbGluZXMubGVuZ3RoLCBtaW5JbmRlbnQgPSAxZTksIHRva2VuO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGdldENvbmZpZyhzdGF0ZSwgbGluZS5mcm9tKS5saW5lO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHJhbmdlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBwcmV2TGluZSAmJiAoZnJvbSA9PSB0byB8fCB0byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBwcmV2TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBlbXB0eSA9IGluZGVudCA9PSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWVudCA9IGxpbmUudGV4dC5zbGljZShpbmRlbnQsIGluZGVudCArIHRva2VuLmxlbmd0aCkgPT0gdG9rZW4gPyBpbmRlbnQgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50IDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBpbmRlbnQgPCBtaW5JbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGVudCA9IGluZGVudDtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgbGluZSwgY29tbWVudCwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluSW5kZW50IDwgMWU5KVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0STsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChsaW5lc1tpXS5pbmRlbnQgPCBsaW5lc1tpXS5saW5lLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBsaW5lc1tpXS5pbmRlbnQgPSBtaW5JbmRlbnQ7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT0gc3RhcnRJICsgMSlcbiAgICAgICAgICAgIGxpbmVzW3N0YXJ0SV0uc2luZ2xlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbiAhPSAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovICYmIGxpbmVzLnNvbWUobCA9PiBsLmNvbW1lbnQgPCAwICYmICghbC5lbXB0eSB8fCBsLnNpbmdsZSkpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZSB9IG9mIGxpbmVzKVxuICAgICAgICAgICAgaWYgKHNpbmdsZSB8fCAhZW1wdHkpXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsgaW5kZW50LCBpbnNlcnQ6IHRva2VuICsgXCIgXCIgfSk7XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBjaGFuZ2VTZXQsIHNlbGVjdGlvbjogc3RhdGUuc2VsZWN0aW9uLm1hcChjaGFuZ2VTZXQsIDEpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50ID49IDApKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgY29tbWVudCwgdG9rZW4gfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChjb21tZW50ID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGxpbmUuZnJvbSArIGNvbW1lbnQsIHRvID0gZnJvbSArIHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGluZS50ZXh0W3RvIC0gbGluZS5mcm9tXSA9PSBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgZnJvbUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuVHJhbnNhY3Rpb24gYW5ub3RhdGlvbiB0aGF0IHdpbGwgcHJldmVudCB0aGF0IHRyYW5zYWN0aW9uIGZyb21cbmJlaW5nIGNvbWJpbmVkIHdpdGggb3RoZXIgdHJhbnNhY3Rpb25zIGluIHRoZSB1bmRvIGhpc3RvcnkuIEdpdmVuXG5gXCJiZWZvcmVcImAsIGl0J2xsIHByZXZlbnQgbWVyZ2luZyB3aXRoIHByZXZpb3VzIHRyYW5zYWN0aW9ucy4gV2l0aFxuYFwiYWZ0ZXJcImAsIHN1YnNlcXVlbnQgdHJhbnNhY3Rpb25zIHdvbid0IGJlIGNvbWJpbmVkIHdpdGggdGhpc1xub25lLiBXaXRoIGBcImZ1bGxcImAsIHRoZSB0cmFuc2FjdGlvbiBpcyBpc29sYXRlZCBvbiBib3RoIHNpZGVzLlxuKi9cbmNvbnN0IGlzb2xhdGVIaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcblRoaXMgZmFjZXQgcHJvdmlkZXMgYSB3YXkgdG8gcmVnaXN0ZXIgZnVuY3Rpb25zIHRoYXQsIGdpdmVuIGFcbnRyYW5zYWN0aW9uLCBwcm92aWRlIGEgc2V0IG9mIGVmZmVjdHMgdGhhdCB0aGUgaGlzdG9yeSBzaG91bGRcbnN0b3JlIHdoZW4gaW52ZXJ0aW5nIHRoZSB0cmFuc2FjdGlvbi4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuaW50ZWdyYXRlIHNvbWUga2luZHMgb2YgZWZmZWN0cyBpbiB0aGUgaGlzdG9yeSwgc28gdGhhdCB0aGV5IGNhblxuYmUgdW5kb25lIChhbmQgcmVkb25lIGFnYWluKS5cbiovXG5jb25zdCBpbnZlcnRlZEVmZmVjdHMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBoaXN0b3J5Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIG1pbkRlcHRoOiAxMDAsXG4gICAgICAgICAgICBuZXdHcm91cERlbGF5OiA1MDAsXG4gICAgICAgICAgICBqb2luVG9FdmVudDogKF90LCBpc0FkamFjZW50KSA9PiBpc0FkamFjZW50LFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtaW5EZXB0aDogTWF0aC5tYXgsXG4gICAgICAgICAgICBuZXdHcm91cERlbGF5OiBNYXRoLm1pbixcbiAgICAgICAgICAgIGpvaW5Ub0V2ZW50OiAoYSwgYikgPT4gKHRyLCBhZGopID0+IGEodHIsIGFkaikgfHwgYih0ciwgYWRqKVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNvbnN0IGhpc3RvcnlGaWVsZF8gPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIEhpc3RvcnlTdGF0ZS5lbXB0eTtcbiAgICB9LFxuICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGhpc3RvcnlDb25maWcpO1xuICAgICAgICBsZXQgZnJvbUhpc3QgPSB0ci5hbm5vdGF0aW9uKGZyb21IaXN0b3J5KTtcbiAgICAgICAgaWYgKGZyb21IaXN0KSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IEhpc3RFdmVudC5mcm9tVHJhbnNhY3Rpb24odHIsIGZyb21IaXN0LnNlbGVjdGlvbiksIGZyb20gPSBmcm9tSGlzdC5zaWRlO1xuICAgICAgICAgICAgbGV0IG90aGVyID0gZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHN0YXRlLnVuZG9uZSA6IHN0YXRlLmRvbmU7XG4gICAgICAgICAgICBpZiAoaXRlbSlcbiAgICAgICAgICAgICAgICBvdGhlciA9IHVwZGF0ZUJyYW5jaChvdGhlciwgb3RoZXIubGVuZ3RoLCBjb25maWcubWluRGVwdGgsIGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG90aGVyID0gYWRkU2VsZWN0aW9uKG90aGVyLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gZnJvbUhpc3QucmVzdCA6IG90aGVyLCBmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gb3RoZXIgOiBmcm9tSGlzdC5yZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNvbGF0ZSA9IHRyLmFubm90YXRpb24oaXNvbGF0ZUhpc3RvcnkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYmVmb3JlXCIpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmlzb2xhdGUoKTtcbiAgICAgICAgaWYgKHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5KSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gIXRyLmNoYW5nZXMuZW1wdHkgPyBzdGF0ZS5hZGRNYXBwaW5nKHRyLmNoYW5nZXMuZGVzYykgOiBzdGF0ZTtcbiAgICAgICAgbGV0IGV2ZW50ID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0cik7XG4gICAgICAgIGxldCB0aW1lID0gdHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi50aW1lKSwgdXNlckV2ZW50ID0gdHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLCB0cik7XG4gICAgICAgIGVsc2UgaWYgKHRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYWRkU2VsZWN0aW9uKHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZy5uZXdHcm91cERlbGF5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImFmdGVyXCIpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmlzb2xhdGUoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgdG9KU09OKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHZhbHVlLmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSksIHVuZG9uZTogdmFsdWUudW5kb25lLm1hcChlID0+IGUudG9KU09OKCkpIH07XG4gICAgfSxcbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGpzb24uZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSwganNvbi51bmRvbmUubWFwKEhpc3RFdmVudC5mcm9tSlNPTikpO1xuICAgIH1cbn0pO1xuLyoqXG5DcmVhdGUgYSBoaXN0b3J5IGV4dGVuc2lvbiB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuKi9cbmZ1bmN0aW9uIGhpc3RvcnkoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBoaXN0b3J5RmllbGRfLFxuICAgICAgICBoaXN0b3J5Q29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIEVkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgICAgICAgICBiZWZvcmVpbnB1dChlLCB2aWV3KSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIgPyB1bmRvIDogZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIF07XG59XG4vKipcblRoZSBzdGF0ZSBmaWVsZCB1c2VkIHRvIHN0b3JlIHRoZSBoaXN0b3J5IGRhdGEuIFNob3VsZCBwcm9iYWJseVxub25seSBiZSB1c2VkIHdoZW4geW91IHdhbnQgdG9cbltzZXJpYWxpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSBvclxuW2Rlc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmZyb21KU09OKSBzdGF0ZSBvYmplY3RzIGluIGEgd2F5XG50aGF0IHByZXNlcnZlcyBoaXN0b3J5LlxuKi9cbmNvbnN0IGhpc3RvcnlGaWVsZCA9IGhpc3RvcnlGaWVsZF87XG5mdW5jdGlvbiBjbWQoc2lkZSwgc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh7IHN0YXRlLCBkaXNwYXRjaCB9KSB7XG4gICAgICAgIGlmICghc2VsZWN0aW9uICYmIHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaGlzdG9yeVN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RvcnlTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRyID0gaGlzdG9yeVN0YXRlLnBvcChzaWRlLCBzdGF0ZSwgc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5VbmRvIGEgc2luZ2xlIGdyb3VwIG9mIGhpc3RvcnkgZXZlbnRzLiBSZXR1cm5zIGZhbHNlIGlmIG5vIGdyb3VwXG53YXMgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHVuZG8gPSAvKkBfX1BVUkVfXyovY21kKDAgLyogQnJhbmNoTmFtZS5Eb25lICovLCBmYWxzZSk7XG4vKipcblJlZG8gYSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cCB3YXNcbmF2YWlsYWJsZS5cbiovXG5jb25zdCByZWRvID0gLypAX19QVVJFX18qL2NtZCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovLCBmYWxzZSk7XG4vKipcblVuZG8gYSBjaGFuZ2Ugb3Igc2VsZWN0aW9uIGNoYW5nZS5cbiovXG5jb25zdCB1bmRvU2VsZWN0aW9uID0gLypAX19QVVJFX18qL2NtZCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLywgdHJ1ZSk7XG4vKipcblJlZG8gYSBjaGFuZ2Ugb3Igc2VsZWN0aW9uIGNoYW5nZS5cbiovXG5jb25zdCByZWRvU2VsZWN0aW9uID0gLypAX19QVVJFX18qL2NtZCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovLCB0cnVlKTtcbmZ1bmN0aW9uIGRlcHRoKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGxldCBoaXN0U3RhdGUgPSBzdGF0ZS5maWVsZChoaXN0b3J5RmllbGRfLCBmYWxzZSk7XG4gICAgICAgIGlmICghaGlzdFN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gaGlzdFN0YXRlLmRvbmUgOiBoaXN0U3RhdGUudW5kb25lO1xuICAgICAgICByZXR1cm4gYnJhbmNoLmxlbmd0aCAtIChicmFuY2gubGVuZ3RoICYmICFicmFuY2hbMF0uY2hhbmdlcyA/IDEgOiAwKTtcbiAgICB9O1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgdW5kb0RlcHRoID0gLypAX19QVVJFX18qL2RlcHRoKDAgLyogQnJhbmNoTmFtZS5Eb25lICovKTtcbi8qKlxuVGhlIGFtb3VudCBvZiByZWRvYWJsZSBjaGFuZ2UgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmNvbnN0IHJlZG9EZXB0aCA9IC8qQF9fUFVSRV9fKi9kZXB0aCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovKTtcbi8vIEhpc3RvcnkgZXZlbnRzIHN0b3JlIGdyb3VwcyBvZiBjaGFuZ2VzIG9yIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlXG4vLyB1bmRvbmUvcmVkb25lIHRvZ2V0aGVyLlxuY2xhc3MgSGlzdEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgY2hhbmdlcyBpbiB0aGlzIGV2ZW50LiBOb3JtYWwgZXZlbnRzIGhvbGQgYXQgbGVhc3Qgb25lXG4gICAgLy8gY2hhbmdlIG9yIGVmZmVjdC4gQnV0IGl0IG1heSBiZSBuZWNlc3NhcnkgdG8gc3RvcmUgc2VsZWN0aW9uXG4gICAgLy8gZXZlbnRzIGJlZm9yZSB0aGUgZmlyc3QgY2hhbmdlLCBpbiB3aGljaCBjYXNlIGEgc3BlY2lhbCB0eXBlIG9mXG4gICAgLy8gaW5zdGFuY2UgaXMgY3JlYXRlZCB3aGljaCBkb2Vzbid0IGhvbGQgYW55IGNoYW5nZXMsIHdpdGhcbiAgICAvLyBjaGFuZ2VzID09IHN0YXJ0U2VsZWN0aW9uID09IHVuZGVmaW5lZFxuICAgIGNoYW5nZXMsIFxuICAgIC8vIFRoZSBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50XG4gICAgZWZmZWN0cywgXG4gICAgLy8gQWNjdW11bGF0ZWQgbWFwcGluZyAoZnJvbSBhZGRUb0hpc3Rvcnk9PWZhbHNlKSB0aGF0IHNob3VsZCBiZVxuICAgIC8vIGFwcGxpZWQgdG8gZXZlbnRzIGJlbG93IHRoaXMgb25lLlxuICAgIG1hcHBlZCwgXG4gICAgLy8gVGhlIHNlbGVjdGlvbiBiZWZvcmUgdGhpcyBldmVudFxuICAgIHN0YXJ0U2VsZWN0aW9uLCBcbiAgICAvLyBTdG9yZXMgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIgdGhpcyBldmVudCwgdG8gYmUgdXNlZCBmb3JcbiAgICAvLyBzZWxlY3Rpb24gdW5kby9yZWRvLlxuICAgIHNlbGVjdGlvbnNBZnRlcikge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLm1hcHBlZCA9IG1hcHBlZDtcbiAgICAgICAgdGhpcy5zdGFydFNlbGVjdGlvbiA9IHN0YXJ0U2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnNBZnRlciA9IHNlbGVjdGlvbnNBZnRlcjtcbiAgICB9XG4gICAgc2V0U2VsQWZ0ZXIoYWZ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodGhpcy5jaGFuZ2VzLCB0aGlzLmVmZmVjdHMsIHRoaXMubWFwcGVkLCB0aGlzLnN0YXJ0U2VsZWN0aW9uLCBhZnRlcik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzOiAoX2EgPSB0aGlzLmNoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKSxcbiAgICAgICAgICAgIG1hcHBlZDogKF9iID0gdGhpcy5tYXBwZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0pTT04oKSxcbiAgICAgICAgICAgIHN0YXJ0U2VsZWN0aW9uOiAoX2MgPSB0aGlzLnN0YXJ0U2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9KU09OKCksXG4gICAgICAgICAgICBzZWxlY3Rpb25zQWZ0ZXI6IHRoaXMuc2VsZWN0aW9uc0FmdGVyLm1hcChzID0+IHMudG9KU09OKCkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KGpzb24uY2hhbmdlcyAmJiBDaGFuZ2VTZXQuZnJvbUpTT04oanNvbi5jaGFuZ2VzKSwgW10sIGpzb24ubWFwcGVkICYmIENoYW5nZURlc2MuZnJvbUpTT04oanNvbi5tYXBwZWQpLCBqc29uLnN0YXJ0U2VsZWN0aW9uICYmIEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnN0YXJ0U2VsZWN0aW9uKSwganNvbi5zZWxlY3Rpb25zQWZ0ZXIubWFwKEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTikpO1xuICAgIH1cbiAgICAvLyBUaGlzIGRvZXMgbm90IGNoZWNrIGBhZGRUb0hpc3RvcnlgIGFuZCBzdWNoLCBpdCBhc3N1bWVzIHRoZVxuICAgIC8vIHRyYW5zYWN0aW9uIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhbiBpdGVtLiBSZXR1cm5zIG51bGwgd2hlblxuICAgIC8vIHRoZXJlIGFyZSBubyBjaGFuZ2VzIG9yIGVmZmVjdHMgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgIHN0YXRpYyBmcm9tVHJhbnNhY3Rpb24odHIsIHNlbGVjdGlvbikge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IG5vbmU7XG4gICAgICAgIGZvciAobGV0IGludmVydCBvZiB0ci5zdGFydFN0YXRlLmZhY2V0KGludmVydGVkRWZmZWN0cykpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBpbnZlcnQodHIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZWZmZWN0cyA9IGVmZmVjdHMuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlZmZlY3RzLmxlbmd0aCAmJiB0ci5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRyLmNoYW5nZXMuaW52ZXJ0KHRyLnN0YXJ0U3RhdGUuZG9jKSwgZWZmZWN0cywgdW5kZWZpbmVkLCBzZWxlY3Rpb24gfHwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIG5vbmUpO1xuICAgIH1cbiAgICBzdGF0aWMgc2VsZWN0aW9uKHNlbGVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodW5kZWZpbmVkLCBub25lLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgc2VsZWN0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQnJhbmNoKGJyYW5jaCwgdG8sIG1heExlbiwgbmV3RXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSB0byArIDEgPiBtYXhMZW4gKyAyMCA/IHRvIC0gbWF4TGVuIC0gMSA6IDA7XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZShzdGFydCwgdG8pO1xuICAgIG5ld0JyYW5jaC5wdXNoKG5ld0V2ZW50KTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuZnVuY3Rpb24gaXNBZGphY2VudChhLCBiKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBpc0FkamFjZW50ID0gZmFsc2U7XG4gICAgYS5pdGVyQ2hhbmdlZFJhbmdlcygoZiwgdCkgPT4gcmFuZ2VzLnB1c2goZiwgdCkpO1xuICAgIGIuaXRlckNoYW5nZWRSYW5nZXMoKF9mLCBfdCwgZiwgdCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tpKytdLCB0byA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgaWYgKHQgPj0gZnJvbSAmJiBmIDw9IHRvKVxuICAgICAgICAgICAgICAgIGlzQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQWRqYWNlbnQ7XG59XG5mdW5jdGlvbiBlcVNlbGVjdGlvblNoYXBlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5yYW5nZXMubGVuZ3RoID09IGIucmFuZ2VzLmxlbmd0aCAmJlxuICAgICAgICBhLnJhbmdlcy5maWx0ZXIoKHIsIGkpID0+IHIuZW1wdHkgIT0gYi5yYW5nZXNbaV0uZW1wdHkpLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIGNvbmMoYSwgYikge1xuICAgIHJldHVybiAhYS5sZW5ndGggPyBiIDogIWIubGVuZ3RoID8gYSA6IGEuY29uY2F0KGIpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuY29uc3QgTWF4U2VsZWN0aW9uc1BlckV2ZW50ID0gMjAwO1xuZnVuY3Rpb24gYWRkU2VsZWN0aW9uKGJyYW5jaCwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbSGlzdEV2ZW50LnNlbGVjdGlvbihbc2VsZWN0aW9uXSldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGxhc3RFdmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBzZWxzID0gbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5zbGljZShNYXRoLm1heCgwLCBsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIE1heFNlbGVjdGlvbnNQZXJFdmVudCkpO1xuICAgICAgICBpZiAoc2Vscy5sZW5ndGggJiYgc2Vsc1tzZWxzLmxlbmd0aCAtIDFdLmVxKHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICBzZWxzLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUJyYW5jaChicmFuY2gsIGJyYW5jaC5sZW5ndGggLSAxLCAxZTksIGxhc3RFdmVudC5zZXRTZWxBZnRlcihzZWxzKSk7XG4gICAgfVxufVxuLy8gQXNzdW1lcyB0aGUgdG9wIGl0ZW0gaGFzIG9uZSBvciBtb3JlIHNlbGVjdGlvbkFmdGVyIHZhbHVlc1xuZnVuY3Rpb24gcG9wU2VsZWN0aW9uKGJyYW5jaCkge1xuICAgIGxldCBsYXN0ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICBsZXQgbmV3QnJhbmNoID0gYnJhbmNoLnNsaWNlKCk7XG4gICAgbmV3QnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXSA9IGxhc3Quc2V0U2VsQWZ0ZXIobGFzdC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoMCwgbGFzdC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBuZXdCcmFuY2g7XG59XG4vLyBBZGQgYSBtYXBwaW5nIHRvIHRoZSB0b3AgZXZlbnQgaW4gdGhlIGdpdmVuIGJyYW5jaC4gSWYgdGhpcyBtYXBzXG4vLyBhd2F5IGFsbCB0aGUgY2hhbmdlcyBhbmQgZWZmZWN0cyBpbiB0aGF0IGl0ZW0sIGRyb3AgaXQgYW5kXG4vLyBwcm9wYWdhdGUgdGhlIG1hcHBpbmcgdG8gdGhlIG5leHQgaXRlbS5cbmZ1bmN0aW9uIGFkZE1hcHBpbmdUb0JyYW5jaChicmFuY2gsIG1hcHBpbmcpIHtcbiAgICBpZiAoIWJyYW5jaC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgbGV0IGxlbmd0aCA9IGJyYW5jaC5sZW5ndGgsIHNlbGVjdGlvbnMgPSBub25lO1xuICAgIHdoaWxlIChsZW5ndGgpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gbWFwRXZlbnQoYnJhbmNoW2xlbmd0aCAtIDFdLCBtYXBwaW5nLCBzZWxlY3Rpb25zKTtcbiAgICAgICAgaWYgKGV2ZW50LmNoYW5nZXMgJiYgIWV2ZW50LmNoYW5nZXMuZW1wdHkgfHwgZXZlbnQuZWZmZWN0cy5sZW5ndGgpIHsgLy8gRXZlbnQgc3Vydml2ZWQgbWFwcGluZ1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGJyYW5jaC5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0W2xlbmd0aCAtIDFdID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBEcm9wIHRoaXMgZXZlbnQsIHNpbmNlIHRoZXJlJ3Mgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGxlZnRcbiAgICAgICAgICAgIG1hcHBpbmcgPSBldmVudC5tYXBwZWQ7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIHNlbGVjdGlvbnMgPSBldmVudC5zZWxlY3Rpb25zQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGlvbnMubGVuZ3RoID8gW0hpc3RFdmVudC5zZWxlY3Rpb24oc2VsZWN0aW9ucyldIDogbm9uZTtcbn1cbmZ1bmN0aW9uIG1hcEV2ZW50KGV2ZW50LCBtYXBwaW5nLCBleHRyYVNlbGVjdGlvbnMpIHtcbiAgICBsZXQgc2VsZWN0aW9ucyA9IGNvbmMoZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCA/IGV2ZW50LnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLm1hcChtYXBwaW5nKSkgOiBub25lLCBleHRyYVNlbGVjdGlvbnMpO1xuICAgIC8vIENoYW5nZS1sZXNzIGV2ZW50cyBkb24ndCBzdG9yZSBtYXBwaW5ncyAodGhleSBhcmUgYWx3YXlzIHRoZSBsYXN0IGV2ZW50IGluIGEgYnJhbmNoKVxuICAgIGlmICghZXZlbnQuY2hhbmdlcylcbiAgICAgICAgcmV0dXJuIEhpc3RFdmVudC5zZWxlY3Rpb24oc2VsZWN0aW9ucyk7XG4gICAgbGV0IG1hcHBlZENoYW5nZXMgPSBldmVudC5jaGFuZ2VzLm1hcChtYXBwaW5nKSwgYmVmb3JlID0gbWFwcGluZy5tYXBEZXNjKGV2ZW50LmNoYW5nZXMsIHRydWUpO1xuICAgIGxldCBmdWxsTWFwcGluZyA9IGV2ZW50Lm1hcHBlZCA/IGV2ZW50Lm1hcHBlZC5jb21wb3NlRGVzYyhiZWZvcmUpIDogYmVmb3JlO1xuICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KG1hcHBlZENoYW5nZXMsIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZXZlbnQuZWZmZWN0cywgbWFwcGluZyksIGZ1bGxNYXBwaW5nLCBldmVudC5zdGFydFNlbGVjdGlvbi5tYXAoYmVmb3JlKSwgc2VsZWN0aW9ucyk7XG59XG5jb25zdCBqb2luYWJsZVVzZXJFdmVudCA9IC9eKGlucHV0XFwudHlwZXxkZWxldGUpKCR8XFwuKS87XG5jbGFzcyBIaXN0b3J5U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbmUsIHVuZG9uZSwgcHJldlRpbWUgPSAwLCBwcmV2VXNlckV2ZW50ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldlVzZXJFdmVudCA9IHByZXZVc2VyRXZlbnQ7XG4gICAgfVxuICAgIGlzb2xhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZUaW1lID8gbmV3IEhpc3RvcnlTdGF0ZSh0aGlzLmRvbmUsIHRoaXMudW5kb25lKSA6IHRoaXM7XG4gICAgfVxuICAgIGFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLCB0cikge1xuICAgICAgICBsZXQgZG9uZSA9IHRoaXMuZG9uZSwgbGFzdEV2ZW50ID0gZG9uZVtkb25lLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdEV2ZW50ICYmIGxhc3RFdmVudC5jaGFuZ2VzICYmICFsYXN0RXZlbnQuY2hhbmdlcy5lbXB0eSAmJiBldmVudC5jaGFuZ2VzICYmXG4gICAgICAgICAgICAoIXVzZXJFdmVudCB8fCBqb2luYWJsZVVzZXJFdmVudC50ZXN0KHVzZXJFdmVudCkpICYmXG4gICAgICAgICAgICAoKCFsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgY29uZmlnLm5ld0dyb3VwRGVsYXkgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuam9pblRvRXZlbnQodHIsIGlzQWRqYWNlbnQobGFzdEV2ZW50LmNoYW5nZXMsIGV2ZW50LmNoYW5nZXMpKSkgfHxcbiAgICAgICAgICAgICAgICAvLyBGb3IgY29tcG9zZSAoYnV0IG5vdCBjb21wb3NlLnN0YXJ0KSBldmVudHMsIGFsd2F5cyBqb2luIHdpdGggcHJldmlvdXMgZXZlbnRcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQgPT0gXCJpbnB1dC50eXBlLmNvbXBvc2VcIikpIHtcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGggLSAxLCBjb25maWcubWluRGVwdGgsIG5ldyBIaXN0RXZlbnQoZXZlbnQuY2hhbmdlcy5jb21wb3NlKGxhc3RFdmVudC5jaGFuZ2VzKSwgY29uYyhTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGV2ZW50LmVmZmVjdHMsIGxhc3RFdmVudC5jaGFuZ2VzKSwgbGFzdEV2ZW50LmVmZmVjdHMpLCBsYXN0RXZlbnQubWFwcGVkLCBsYXN0RXZlbnQuc3RhcnRTZWxlY3Rpb24sIG5vbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGgsIGNvbmZpZy5taW5EZXB0aCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGRvbmUsIG5vbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZFNlbGVjdGlvbihzZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgbmV3R3JvdXBEZWxheSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZG9uZS5sZW5ndGggPyB0aGlzLmRvbmVbdGhpcy5kb25lLmxlbmd0aCAtIDFdLnNlbGVjdGlvbnNBZnRlciA6IG5vbmU7XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgbmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgdXNlckV2ZW50ID09IHRoaXMucHJldlVzZXJFdmVudCAmJiB1c2VyRXZlbnQgJiYgL15zZWxlY3QoJHxcXC4pLy50ZXN0KHVzZXJFdmVudCkgJiZcbiAgICAgICAgICAgIGVxU2VsZWN0aW9uU2hhcGUobGFzdFtsYXN0Lmxlbmd0aCAtIDFdLCBzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZFNlbGVjdGlvbih0aGlzLmRvbmUsIHNlbGVjdGlvbiksIHRoaXMudW5kb25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoYWRkTWFwcGluZ1RvQnJhbmNoKHRoaXMuZG9uZSwgbWFwcGluZyksIGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLnVuZG9uZSwgbWFwcGluZyksIHRoaXMucHJldlRpbWUsIHRoaXMucHJldlVzZXJFdmVudCk7XG4gICAgfVxuICAgIHBvcChzaWRlLCBzdGF0ZSwgb25seVNlbGVjdGlvbikge1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHRoaXMuZG9uZSA6IHRoaXMudW5kb25lO1xuICAgICAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBldmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0sIHNlbGVjdGlvbiA9IGV2ZW50LnNlbGVjdGlvbnNBZnRlclswXSB8fFxuICAgICAgICAgICAgKGV2ZW50LnN0YXJ0U2VsZWN0aW9uID8gZXZlbnQuc3RhcnRTZWxlY3Rpb24ubWFwKGV2ZW50LmNoYW5nZXMuaW52ZXJ0ZWREZXNjLCAxKSA6IHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgIGlmIChvbmx5U2VsZWN0aW9uICYmIGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQuc2VsZWN0aW9uc0FmdGVyW2V2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZnJvbUhpc3Rvcnkub2YoeyBzaWRlLCByZXN0OiBwb3BTZWxlY3Rpb24oYnJhbmNoKSwgc2VsZWN0aW9uIH0pLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IFwic2VsZWN0LnVuZG9cIiA6IFwic2VsZWN0LnJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWV2ZW50LmNoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc3QgPSBicmFuY2gubGVuZ3RoID09IDEgPyBub25lIDogYnJhbmNoLnNsaWNlKDAsIGJyYW5jaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChldmVudC5tYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdCA9IGFkZE1hcHBpbmdUb0JyYW5jaChyZXN0LCBldmVudC5tYXBwZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgY2hhbmdlczogZXZlbnQuY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnN0YXJ0U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGV2ZW50LmVmZmVjdHMsXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdCwgc2VsZWN0aW9uIH0pLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJ1bmRvXCIgOiBcInJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5IaXN0b3J5U3RhdGUuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IEhpc3RvcnlTdGF0ZShub25lLCBub25lKTtcbi8qKlxuRGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSB1bmRvIGhpc3RvcnkuXG5cbi0gTW9kLXo6IFtgdW5kb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudW5kbykuXG4tIE1vZC15IChNb2QtU2hpZnQteiBvbiBtYWNPUykgKyBDdHJsLVNoaWZ0LXogb24gTGludXg6IFtgcmVkb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkbykuXG4tIE1vZC11OiBbYHVuZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG9TZWxlY3Rpb24pLlxuLSBBbHQtdSAoTW9kLVNoaWZ0LXUgb24gbWFjT1MpOiBbYHJlZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG9TZWxlY3Rpb24pLlxuKi9cbmNvbnN0IGhpc3RvcnlLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLXpcIiwgcnVuOiB1bmRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC15XCIsIG1hYzogXCJNb2QtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBsaW51eDogXCJDdHJsLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC11XCIsIHJ1bjogdW5kb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBbHQtdVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXVcIiwgcnVuOiByZWRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9XG5dO1xuXG5mdW5jdGlvbiB1cGRhdGVTZWwoc2VsLCBieSkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMubWFwKGJ5KSwgc2VsLm1haW5JbmRleCk7XG59XG5mdW5jdGlvbiBzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSk7XG59XG5mdW5jdGlvbiBtb3ZlU2VsKHsgc3RhdGUsIGRpc3BhdGNoIH0sIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCBob3cpO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uLCB0cnVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyByYW5nZS50byA6IHJhbmdlLmZyb20pO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuZnVuY3Rpb24gbHRyQXRDdXJzb3Iodmlldykge1xuICAgIHJldHVybiB2aWV3LnRleHREaXJlY3Rpb25BdCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpID09IERpcmVjdGlvbi5MVFI7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0ICh3aGljaCBpcyBiYWNrd2FyZCBpblxubGVmdC10by1yaWdodCB0ZXh0LCBmb3J3YXJkIGluIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckxlZnQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhclJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGJ5Q2hhckxvZ2ljYWwoc3RhdGUsIHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgbGV0IHBvcyA9IHJhbmdlLmhlYWQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgaWYgKHBvcyA9PSAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pKVxuICAgICAgICBwb3MgPSBmb3J3YXJkID8gTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgbGluZS50byArIDEpIDogTWF0aC5tYXgoMCwgbGluZS5mcm9tIC0gMSk7XG4gICAgZWxzZVxuICAgICAgICBwb3MgPSBsaW5lLmZyb20gKyBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkKTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gbW92ZUJ5Q2hhckxvZ2ljYWwodGFyZ2V0LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodGFyZ2V0LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IGJ5Q2hhckxvZ2ljYWwodGFyZ2V0LnN0YXRlLCByYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBmb3J3YXJkLCBpbiBsb2dpY2FsXG4obm9uLXRleHQtZGlyZWN0aW9uLWF3YXJlKSBzdHJpbmcgaW5kZXggb3JkZXIuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckZvcndhcmRMb2dpY2FsID0gdGFyZ2V0ID0+IG1vdmVCeUNoYXJMb2dpY2FsKHRhcmdldCwgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLCBpbiBsb2dpY2FsIHN0cmluZyBpbmRleFxub3JkZXIuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckJhY2t3YXJkTG9naWNhbCA9IHRhcmdldCA9PiBtb3ZlQnlDaGFyTG9naWNhbCh0YXJnZXQsIGZhbHNlKTtcbmZ1bmN0aW9uIGN1cnNvckJ5R3JvdXAodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGxlZnQgYWNyb3NzIG9uZSBncm91cCBvZiB3b3JkIG9yXG5ub24td29yZCAoYnV0IGFsc28gbm9uLXNwYWNlKSBjaGFyYWN0ZXJzLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JHcm91cFJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIHRvR3JvdXBTdGFydCh2aWV3LCBwb3MsIHN0YXJ0KSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKHN0YXJ0KSwgaW5pdGlhbCA9IGNhdCAhPSBDaGFyQ2F0ZWdvcnkuU3BhY2U7XG4gICAgcmV0dXJuIChuZXh0KSA9PiB7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KTtcbiAgICAgICAgaWYgKG5leHRDYXQgIT0gQ2hhckNhdGVnb3J5LlNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWwgJiYgbmV4dENhdCA9PSBjYXQ7XG4gICAgICAgIGluaXRpYWwgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG9uZSBncm91cCBmb3J3YXJkIGluIHRoZSBkZWZhdWx0IFdpbmRvd3Mgc3R5bGUsXG53aGVyZSBpdCBtb3ZlcyB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgZ3JvdXAuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBGb3J3YXJkV2luID0gdmlldyA9PiB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHlcbiAgICAgICAgPyB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIHRydWUsIHN0YXJ0ID0+IHRvR3JvdXBTdGFydCh2aWV3LCByYW5nZS5oZWFkLCBzdGFydCkpXG4gICAgICAgIDogcmFuZ2VFbmQocmFuZ2UsIHRydWUpKTtcbn07XG5jb25zdCBzZWdtZW50ZXIgPSB0eXBlb2YgSW50bCAhPSBcInVuZGVmaW5lZFwiICYmIEludGwuU2VnbWVudGVyID9cbiAgICAvKkBfX1BVUkVfXyovbmV3IChJbnRsLlNlZ21lbnRlcikodW5kZWZpbmVkLCB7IGdyYW51bGFyaXR5OiBcIndvcmRcIiB9KSA6IG51bGw7XG5mdW5jdGlvbiBtb3ZlQnlTdWJ3b3JkKHZpZXcsIHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5mcm9tKTtcbiAgICBsZXQgY2F0ID0gQ2hhckNhdGVnb3J5LlNwYWNlLCBwb3MgPSByYW5nZS5mcm9tLCBzdGVwcyA9IDA7XG4gICAgbGV0IGRvbmUgPSBmYWxzZSwgc2F3VXBwZXIgPSBmYWxzZSwgc2F3TG93ZXIgPSBmYWxzZTtcbiAgICBsZXQgc3RlcCA9IChuZXh0KSA9PiB7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IG5leHQubGVuZ3RoIDogLW5leHQubGVuZ3RoO1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dCksIGFoZWFkO1xuICAgICAgICBpZiAobmV4dENhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCAmJiBuZXh0LmNoYXJDb2RlQXQoMCkgPCAxMjggJiYgL1tcXFdfXS8udGVzdChuZXh0KSlcbiAgICAgICAgICAgIG5leHRDYXQgPSAtMTsgLy8gVHJlYXQgd29yZCBwdW5jdHVhdGlvbiBzcGVjaWFsbHlcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICBpZiAoY2F0ICE9IG5leHRDYXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjYXQgPT0gQ2hhckNhdGVnb3J5LldvcmQpIHtcbiAgICAgICAgICAgIGlmIChuZXh0LnRvTG93ZXJDYXNlKCkgPT0gbmV4dCkge1xuICAgICAgICAgICAgICAgIGlmICghZm9yd2FyZCAmJiBzYXdVcHBlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHNhd0xvd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhd0xvd2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzYXdVcHBlciAmJiBmb3J3YXJkICYmIGNhdGVnb3JpemUoYWhlYWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkICYmXG4gICAgICAgICAgICAgICAgICAgIGFoZWFkLnRvTG93ZXJDYXNlKCkgPT0gYWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBzYXdVcHBlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RlcHMrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBsZXQgZW5kID0gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkLCBzdGFydCA9PiB7XG4gICAgICAgIHN0ZXAoc3RhcnQpO1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICB9KTtcbiAgICBpZiAoc2VnbWVudGVyICYmIGNhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCAmJiBlbmQuZnJvbSA9PSByYW5nZS5mcm9tICsgc3RlcHMgKiAoZm9yd2FyZCA/IDEgOiAtMSkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihyYW5nZS5oZWFkLCBlbmQuaGVhZCksIHRvID0gTWF0aC5tYXgocmFuZ2UuaGVhZCwgZW5kLmhlYWQpO1xuICAgICAgICBsZXQgc2tpcHBlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAxICYmIC9bXFx1NEUwMC1cXHVmZmZmXS8udGVzdChza2lwcGVkKSkge1xuICAgICAgICAgICAgbGV0IHNlZ21lbnRzID0gQXJyYXkuZnJvbShzZWdtZW50ZXIuc2VnbWVudChza2lwcGVkKSk7XG4gICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgc2VnbWVudHNbMV0uaW5kZXgsIC0xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihlbmQuaGVhZCArIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLmluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JTdWJ3b3JkRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5U3Vid29yZCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5vZGUsIGJyYWNrZXRQcm9wKSB7XG4gICAgaWYgKG5vZGUudHlwZS5wcm9wKGJyYWNrZXRQcm9wKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGxlbiA9IG5vZGUudG8gLSBub2RlLmZyb207XG4gICAgcmV0dXJuIGxlbiAmJiAobGVuID4gMiB8fCAvW15cXHMsLjs6XS8udGVzdChzdGF0ZS5zbGljZURvYyhub2RlLmZyb20sIG5vZGUudG8pKSkgfHwgbm9kZS5maXJzdENoaWxkO1xufVxuZnVuY3Rpb24gbW92ZUJ5U3ludGF4KHN0YXRlLCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBwb3MgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIoc3RhcnQuaGVhZCk7XG4gICAgbGV0IGJyYWNrZXRQcm9wID0gZm9yd2FyZCA/IE5vZGVQcm9wLmNsb3NlZEJ5IDogTm9kZVByb3Aub3BlbmVkQnk7XG4gICAgLy8gU2NhbiBmb3J3YXJkIHRocm91Z2ggY2hpbGQgbm9kZXMgdG8gc2VlIGlmIHRoZXJlJ3MgYW4gaW50ZXJlc3RpbmdcbiAgICAvLyBub2RlIGFoZWFkLlxuICAgIGZvciAobGV0IGF0ID0gc3RhcnQuaGVhZDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gZm9yd2FyZCA/IHBvcy5jaGlsZEFmdGVyKGF0KSA6IHBvcy5jaGlsZEJlZm9yZShhdCk7XG4gICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoaW50ZXJlc3RpbmdOb2RlKHN0YXRlLCBuZXh0LCBicmFja2V0UHJvcCkpXG4gICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhdCA9IGZvcndhcmQgPyBuZXh0LnRvIDogbmV4dC5mcm9tO1xuICAgIH1cbiAgICBsZXQgYnJhY2tldCA9IHBvcy50eXBlLnByb3AoYnJhY2tldFByb3ApLCBtYXRjaCwgbmV3UG9zO1xuICAgIGlmIChicmFja2V0ICYmIChtYXRjaCA9IGZvcndhcmQgPyBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MuZnJvbSwgMSkgOiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MudG8sIC0xKSkgJiYgbWF0Y2gubWF0Y2hlZClcbiAgICAgICAgbmV3UG9zID0gZm9yd2FyZCA/IG1hdGNoLmVuZC50byA6IG1hdGNoLmVuZC5mcm9tO1xuICAgIGVsc2VcbiAgICAgICAgbmV3UG9zID0gZm9yd2FyZCA/IHBvcy50byA6IHBvcy5mcm9tO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5ld1BvcywgZm9yd2FyZCA/IC0xIDogMSk7XG59XG4vKipcbk1vdmUgdGhlIGN1cnNvciBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvclN5bnRheExlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvclN5bnRheFJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbmZ1bmN0aW9uIGN1cnNvckJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgbGV0IG1vdmVkID0gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCk7XG4gICAgICAgIHJldHVybiBtb3ZlZC5oZWFkICE9IHJhbmdlLmhlYWQgPyBtb3ZlZCA6IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICB9KTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVVcCA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yTGluZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIHBhZ2VJbmZvKHZpZXcpIHtcbiAgICBsZXQgc2VsZlNjcm9sbCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCA8IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbEhlaWdodCAtIDI7XG4gICAgbGV0IG1hcmdpblRvcCA9IDAsIG1hcmdpbkJvdHRvbSA9IDAsIGhlaWdodDtcbiAgICBpZiAoc2VsZlNjcm9sbCkge1xuICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygdmlldy5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMpKSB7XG4gICAgICAgICAgICBsZXQgbWFyZ2lucyA9IHNvdXJjZSh2aWV3KTtcbiAgICAgICAgICAgIGlmIChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMudG9wKVxuICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IE1hdGgubWF4KG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy50b3AsIG1hcmdpblRvcCk7XG4gICAgICAgICAgICBpZiAobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLmJvdHRvbSlcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBNYXRoLm1heChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMuYm90dG9tLCBtYXJnaW5Cb3R0b20pO1xuICAgICAgICB9XG4gICAgICAgIGhlaWdodCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCAtIG1hcmdpblRvcCAtIG1hcmdpbkJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhlaWdodCA9ICh2aWV3LmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdykuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiB7IG1hcmdpblRvcCwgbWFyZ2luQm90dG9tLCBzZWxmU2Nyb2xsLFxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KHZpZXcuZGVmYXVsdExpbmVIZWlnaHQsIGhlaWdodCAtIDUpIH07XG59XG5mdW5jdGlvbiBjdXJzb3JCeVBhZ2UodmlldywgZm9yd2FyZCkge1xuICAgIGxldCBwYWdlID0gcGFnZUluZm8odmlldyk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCwgcGFnZS5oZWlnaHQpXG4gICAgICAgICAgICA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0O1xuICAgIGlmIChwYWdlLnNlbGZTY3JvbGwpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gdmlldy5jb29yZHNBdFBvcyhzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgbGV0IHNjcm9sbFJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHNjcm9sbFJlY3QudG9wICsgcGFnZS5tYXJnaW5Ub3AsIHNjcm9sbEJvdHRvbSA9IHNjcm9sbFJlY3QuYm90dG9tIC0gcGFnZS5tYXJnaW5Cb3R0b207XG4gICAgICAgIGlmIChzdGFydFBvcyAmJiBzdGFydFBvcy50b3AgPiBzY3JvbGxUb3AgJiYgc3RhcnRQb3MuYm90dG9tIDwgc2Nyb2xsQm90dG9tKVxuICAgICAgICAgICAgZWZmZWN0ID0gRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhzZWxlY3Rpb24ubWFpbi5oZWFkLCB7IHk6IFwic3RhcnRcIiwgeU1hcmdpbjogc3RhcnRQb3MudG9wIC0gc2Nyb2xsVG9wIH0pO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSwgeyBlZmZlY3RzOiBlZmZlY3QgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgcGFnZSB1cC5cbiovXG5jb25zdCBjdXJzb3JQYWdlVXAgPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgcGFnZSBkb3duLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VEb3duID0gdmlldyA9PiBjdXJzb3JCeVBhZ2UodmlldywgdHJ1ZSk7XG5mdW5jdGlvbiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQoc3RhcnQuaGVhZCksIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQpO1xuICAgIGlmIChtb3ZlZC5oZWFkID09IHN0YXJ0LmhlYWQgJiYgbW92ZWQuaGVhZCAhPSAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pKVxuICAgICAgICBtb3ZlZCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkLCBmYWxzZSk7XG4gICAgaWYgKCFmb3J3YXJkICYmIG1vdmVkLmhlYWQgPT0gbGluZS5mcm9tICYmIGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGxldCBzcGFjZSA9IC9eXFxzKi8uZXhlYyh2aWV3LnN0YXRlLnNsaWNlRG9jKGxpbmUuZnJvbSwgTWF0aC5taW4obGluZS5mcm9tICsgMTAwLCBsaW5lLnRvKSkpWzBdLmxlbmd0aDtcbiAgICAgICAgaWYgKHNwYWNlICYmIHN0YXJ0LmhlYWQgIT0gbGluZS5mcm9tICsgc3BhY2UpXG4gICAgICAgICAgICBtb3ZlZCA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS5mcm9tICsgc3BhY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbW92ZWQ7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbmV4dCBsaW5lIHdyYXAgcG9pbnQsIG9yIHRvIHRoZSBlbmQgb2ZcbnRoZSBsaW5lIGlmIHRoZXJlIGlzbid0IG9uZSBsZWZ0IG9uIHRoaXMgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gcHJldmlvdXMgbGluZSB3cmFwIHBvaW50LCBvciBmYWlsaW5nIHRoYXQgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZS4gSWYgdGhlIGxpbmUgaXMgaW5kZW50ZWQsIGFuZCB0aGUgY3Vyc29yXG5pc24ndCBhbHJlYWR5IGF0IHRoZSBlbmQgb2YgdGhlIGluZGVudGF0aW9uLCB0aGlzIHdpbGwgbW92ZSB0byB0aGVcbmVuZCBvZiB0aGUgaW5kZW50YXRpb24gaW5zdGVhZCBvZiB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBmYWxzZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgd3JhcCBwb2ludCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB3cmFwIHBvaW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZVN0YXJ0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tLCAxKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVFbmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvLCAtMSkpO1xuZnVuY3Rpb24gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCBleHRlbmQpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZSwgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hpbmcgPSBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkLCAtMSlcbiAgICAgICAgICAgIHx8IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIDEpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCAtIDEsIDEpKVxuICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPCBzdGF0ZS5kb2MubGVuZ3RoICYmIG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQgKyAxLCAtMSkpO1xuICAgICAgICBpZiAoIW1hdGNoaW5nIHx8ICFtYXRjaGluZy5lbmQpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYXRjaGluZy5zdGFydC5mcm9tID09IHJhbmdlLmhlYWQgPyBtYXRjaGluZy5lbmQudG8gOiBtYXRjaGluZy5lbmQuZnJvbTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IsIGhlYWQpIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkKTtcbiAgICB9KTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBicmFja2V0IG1hdGNoaW5nIHRoZSBvbmUgaXQgaXMgY3VycmVudGx5XG5vbiwgaWYgYW55LlxuKi9cbmNvbnN0IGN1cnNvck1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuRXh0ZW5kIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSB0aGUgc2VsZWN0aW9uXG5oZWFkIGlzIGN1cnJlbnRseSBvbiwgaWYgYW55LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gZXh0ZW5kU2VsKHRhcmdldCwgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbCh0YXJnZXQuc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBoZWFkID0gaG93KHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IsIGhlYWQuaGVhZCwgaGVhZC5nb2FsQ29sdW1uLCBoZWFkLmJpZGlMZXZlbCB8fCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEodGFyZ2V0LnN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2goc2V0U2VsKHRhcmdldC5zdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZWxlY3RCeUNoYXIodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQsIHdoaWxlIGxlYXZpbmdcbnRoZSBhbmNob3IgaW4gcGxhY2UuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckxlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RDaGFyUmlnaHQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZC5cbiovXG5jb25zdCBzZWxlY3RDaGFyRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBmb3J3YXJkIGJ5IGxvZ2ljYWxcbihub24tZGlyZWN0aW9uIGF3YXJlKSBzdHJpbmcgaW5kZXggb3JkZXIuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckZvcndhcmRMb2dpY2FsID0gdGFyZ2V0ID0+IGV4dGVuZFNlbCh0YXJnZXQsIHJhbmdlID0+IGJ5Q2hhckxvZ2ljYWwodGFyZ2V0LnN0YXRlLCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkIGJ5IGxvZ2ljYWwgc3RyaW5nXG5pbmRleCBvcmRlci5cbiovXG5jb25zdCBzZWxlY3RDaGFyQmFja3dhcmRMb2dpY2FsID0gdGFyZ2V0ID0+IGV4dGVuZFNlbCh0YXJnZXQsIHJhbmdlID0+IGJ5Q2hhckxvZ2ljYWwodGFyZ2V0LnN0YXRlLCByYW5nZSwgZmFsc2UpKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5R3JvdXAodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwTGVmdCkgdG9cbnRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwTGVmdCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwUmlnaHQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgZm9yd2FyZC5cbiovXG5jb25zdCBzZWxlY3RHcm91cEZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RHcm91cEJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGZvcndhcmQgaW4gdGhlIGRlZmF1bHQgV2luZG93c1xuc3R5bGUsIHNraXBwaW5nIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBncm91cC5cbiovXG5jb25zdCBzZWxlY3RHcm91cEZvcndhcmRXaW4gPSB2aWV3ID0+IHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgdHJ1ZSwgc3RhcnQgPT4gdG9Hcm91cFN0YXJ0KHZpZXcsIHJhbmdlLmhlYWQsIHN0YXJ0KSkpO1xufTtcbmZ1bmN0aW9uIHNlbGVjdEJ5U3Vid29yZCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTdWJ3b3JkKHZpZXcsIHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgZm9yd2FyZC5cbiovXG5jb25zdCBzZWxlY3RTdWJ3b3JkRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgb3Igc3Vid29yZCBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RTdWJ3b3JkQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5U3Vid29yZCh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0U3ludGF4TGVmdCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdFN5bnRheFJpZ2h0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuZnVuY3Rpb24gc2VsZWN0QnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgdXAuXG4qL1xuY29uc3Qgc2VsZWN0TGluZVVwID0gdmlldyA9PiBzZWxlY3RCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVEb3duID0gdmlldyA9PiBzZWxlY3RCeUxpbmUodmlldywgdHJ1ZSk7XG5mdW5jdGlvbiBzZWxlY3RCeVBhZ2UodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCwgcGFnZUluZm8odmlldykuaGVpZ2h0KSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VVcCA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgZG93bi5cbiovXG5jb25zdCBzZWxlY3RQYWdlRG93biA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIHRydWUpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHByZXZpb3VzIGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGJvdW5kYXJ5IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBib3VuZGFyeSB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBzZWxlY3RMaW5lU3RhcnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVFbmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8pKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IDAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IGN1cnNvckRvY0VuZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdERvY1N0YXJ0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IsIGhlYWQ6IDAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSBlbnRpcmUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0QWxsID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IHsgYW5jaG9yOiAwLCBoZWFkOiBzdGF0ZS5kb2MubGVuZ3RoIH0sIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5FeHBhbmQgdGhlIHNlbGVjdGlvbiB0byBjb3ZlciBlbnRpcmUgbGluZXMuXG4qL1xuY29uc3Qgc2VsZWN0TGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkubWFwKCh7IGZyb20sIHRvIH0pID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCBNYXRoLm1pbih0byArIDEsIHN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcyksIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIG5leHQgc3ludGFjdGljIGNvbnN0cnVjdCB0aGF0IGlzIGxhcmdlciB0aGFuIHRoZVxuc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG9ubHkgd29yayBpbnNvZmFyIGFzIHRoZSBsYW5ndWFnZVxuW3Byb3ZpZGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlKSB5b3UgdXNlIGJ1aWxkcyB1cCBhIGZ1bGxcbnN5bnRheCB0cmVlLlxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudFN5bnRheCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKSwgc3RhY2sgPSB0cmVlLnJlc29sdmVTdGFjayhyYW5nZS5mcm9tLCAxKTtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgc3RhY2tCZWZvcmUgPSB0cmVlLnJlc29sdmVTdGFjayhyYW5nZS5mcm9tLCAtMSk7XG4gICAgICAgICAgICBpZiAoc3RhY2tCZWZvcmUubm9kZS5mcm9tID49IHN0YWNrLm5vZGUuZnJvbSAmJiBzdGFja0JlZm9yZS5ub2RlLnRvIDw9IHN0YWNrLm5vZGUudG8pXG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFja0JlZm9yZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjdXIgPSBzdGFjazsgY3VyOyBjdXIgPSBjdXIubmV4dCkge1xuICAgICAgICAgICAgbGV0IHsgbm9kZSB9ID0gY3VyO1xuICAgICAgICAgICAgaWYgKCgobm9kZS5mcm9tIDwgcmFuZ2UuZnJvbSAmJiBub2RlLnRvID49IHJhbmdlLnRvKSB8fFxuICAgICAgICAgICAgICAgIChub2RlLnRvID4gcmFuZ2UudG8gJiYgbm9kZS5mcm9tIDw9IHJhbmdlLmZyb20pKSAmJlxuICAgICAgICAgICAgICAgIGN1ci5uZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uobm9kZS50bywgbm9kZS5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBhZGRDdXJzb3JWZXJ0aWNhbGx5KHZpZXcsIGZvcndhcmQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCByYW5nZXMgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuaGVhZCk7XG4gICAgICAgIGlmIChmb3J3YXJkID8gbGluZS50byA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA6IGxpbmUuZnJvbSA+IDApXG4gICAgICAgICAgICBmb3IgKGxldCBjdXIgPSByYW5nZTs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB2aWV3Lm1vdmVWZXJ0aWNhbGx5KGN1ciwgZm9yd2FyZCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuaGVhZCA8IGxpbmUuZnJvbSB8fCBuZXh0LmhlYWQgPiBsaW5lLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmFuZ2VzLnNvbWUociA9PiByLmhlYWQgPT0gbmV4dC5oZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dC5oZWFkID09IGN1ci5oZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyYW5nZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaChzZXRTZWwoc3RhdGUsIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCByYW5nZXMubGVuZ3RoIC0gMSkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuRXhwYW5kIHRoZSBzZWxlY3Rpb24gYnkgYWRkaW5nIGEgY3Vyc29yIGFib3ZlIHRoZSBoZWFkcyBvZlxuY3VycmVudGx5IHNlbGVjdGVkIHJhbmdlcy5cbiovXG5jb25zdCBhZGRDdXJzb3JBYm92ZSA9IHZpZXcgPT4gYWRkQ3Vyc29yVmVydGljYWxseSh2aWV3LCBmYWxzZSk7XG4vKipcbkV4cGFuZCB0aGUgc2VsZWN0aW9uIGJ5IGFkZGluZyBhIGN1cnNvciBiZWxvdyB0aGUgaGVhZHMgb2ZcbmN1cnJlbnRseSBzZWxlY3RlZCByYW5nZXMuXG4qL1xuY29uc3QgYWRkQ3Vyc29yQmVsb3cgPSB2aWV3ID0+IGFkZEN1cnNvclZlcnRpY2FsbHkodmlldywgdHJ1ZSk7XG4vKipcblNpbXBsaWZ5IHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gV2hlbiBtdWx0aXBsZSByYW5nZXMgYXJlIHNlbGVjdGVkLFxucmVkdWNlIGl0IHRvIGl0cyBtYWluIHJhbmdlLiBPdGhlcndpc2UsIGlmIHRoZSBzZWxlY3Rpb24gaXNcbm5vbi1lbXB0eSwgY29udmVydCBpdCB0byBhIGN1cnNvciBzZWxlY3Rpb24uXG4qL1xuY29uc3Qgc2ltcGxpZnlTZWxlY3Rpb24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBjdXIgPSBzdGF0ZS5zZWxlY3Rpb24sIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgaWYgKGN1ci5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbY3VyLm1haW5dKTtcbiAgICBlbHNlIGlmICghY3VyLm1haW4uZW1wdHkpXG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW0VkaXRvclNlbGVjdGlvbi5jdXJzb3IoY3VyLm1haW4uaGVhZCldKTtcbiAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZGVsZXRlQnkodGFyZ2V0LCBieSkge1xuICAgIGlmICh0YXJnZXQuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZXZlbnQgPSBcImRlbGV0ZS5zZWxlY3Rpb25cIiwgeyBzdGF0ZSB9ID0gdGFyZ2V0O1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pIHtcbiAgICAgICAgICAgIGxldCB0b3dhcmRzID0gYnkocmFuZ2UpO1xuICAgICAgICAgICAgaWYgKHRvd2FyZHMgPCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5iYWNrd2FyZFwiO1xuICAgICAgICAgICAgICAgIHRvd2FyZHMgPSBza2lwQXRvbWljKHRhcmdldCwgdG93YXJkcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG93YXJkcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiZGVsZXRlLmZvcndhcmRcIjtcbiAgICAgICAgICAgICAgICB0b3dhcmRzID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvd2FyZHMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKGZyb20sIHRvd2FyZHMpO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgdG93YXJkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc2tpcEF0b21pYyh0YXJnZXQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgICAgIHRvID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0byA/IHsgcmFuZ2UgfSA6IHsgY2hhbmdlczogeyBmcm9tLCB0byB9LCByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tLCBmcm9tIDwgcmFuZ2UuaGVhZCA/IC0xIDogMSkgfTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdGFyZ2V0LmRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IGV2ZW50LFxuICAgICAgICBlZmZlY3RzOiBldmVudCA9PSBcImRlbGV0ZS5zZWxlY3Rpb25cIiA/IEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwiU2VsZWN0aW9uIGRlbGV0ZWRcIikpIDogdW5kZWZpbmVkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2tpcEF0b21pYyh0YXJnZXQsIHBvcywgZm9yd2FyZCkge1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFZGl0b3JWaWV3KVxuICAgICAgICBmb3IgKGxldCByYW5nZXMgb2YgdGFyZ2V0LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHRhcmdldCkpKVxuICAgICAgICAgICAgcmFuZ2VzLmJldHdlZW4ocG9zLCBwb3MsIChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgcG9zICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBmb3J3YXJkID8gdG8gOiBmcm9tO1xuICAgICAgICAgICAgfSk7XG4gICAgcmV0dXJuIHBvcztcbn1cbmNvbnN0IGRlbGV0ZUJ5Q2hhciA9ICh0YXJnZXQsIGZvcndhcmQsIGJ5SW5kZW50VW5pdCkgPT4gZGVsZXRlQnkodGFyZ2V0LCByYW5nZSA9PiB7XG4gICAgbGV0IHBvcyA9IHJhbmdlLmZyb20sIHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmVmb3JlLCB0YXJnZXRQb3M7XG4gICAgaWYgKGJ5SW5kZW50VW5pdCAmJiAhZm9yd2FyZCAmJiBwb3MgPiBsaW5lLmZyb20gJiYgcG9zIDwgbGluZS5mcm9tICsgMjAwICYmXG4gICAgICAgICEvW14gXFx0XS8udGVzdChiZWZvcmUgPSBsaW5lLnRleHQuc2xpY2UoMCwgcG9zIC0gbGluZS5mcm9tKSkpIHtcbiAgICAgICAgaWYgKGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMV0gPT0gXCJcXHRcIilcbiAgICAgICAgICAgIHJldHVybiBwb3MgLSAxO1xuICAgICAgICBsZXQgY29sID0gY291bnRDb2x1bW4oYmVmb3JlLCBzdGF0ZS50YWJTaXplKSwgZHJvcCA9IGNvbCAlIGdldEluZGVudFVuaXQoc3RhdGUpIHx8IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3AgJiYgYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxIC0gaV0gPT0gXCIgXCI7IGkrKylcbiAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICB0YXJnZXRQb3MgPSBwb3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXRQb3MgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgaWYgKHRhcmdldFBvcyA9PSBwb3MgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgIHRhcmdldFBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICBlbHNlIGlmICghZm9yd2FyZCAmJiAvW1xcdWZlMDAtXFx1ZmUwZl0vLnRlc3QobGluZS50ZXh0LnNsaWNlKHRhcmdldFBvcyAtIGxpbmUuZnJvbSwgcG9zIC0gbGluZS5mcm9tKSkpXG4gICAgICAgICAgICB0YXJnZXRQb3MgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgdGFyZ2V0UG9zIC0gbGluZS5mcm9tLCBmYWxzZSwgZmFsc2UpICsgbGluZS5mcm9tO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0UG9zO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgZm9yIGN1cnNvciBzZWxlY3Rpb25zLCB0aGUgY2hhcmFjdGVyIG9yXG5pbmRlbnRhdGlvbiB1bml0IGJlZm9yZSB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIGZhbHNlLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgdGhlIGNoYXJhY3RlciBiZWZvcmUgdGhlIGN1cnNvci4gRG9lcyBub3RcbmltcGxlbWVudCBhbnkgZXh0ZW5kZWQgYmVoYXZpb3IgbGlrZSBkZWxldGluZyB3aG9sZSBpbmRlbnRhdGlvblxudW5pdHMgaW4gb25lIGdvLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJCYWNrd2FyZFN0cmljdCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIGZhbHNlLCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyRm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIHRydWUsIGZhbHNlKTtcbmNvbnN0IGRlbGV0ZUJ5R3JvdXAgPSAodGFyZ2V0LCBmb3J3YXJkKSA9PiBkZWxldGVCeSh0YXJnZXQsIHJhbmdlID0+IHtcbiAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgZm9yIChsZXQgY2F0ID0gbnVsbDs7KSB7XG4gICAgICAgIGlmIChwb3MgPT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgaWYgKHBvcyA9PSByYW5nZS5oZWFkICYmIGxpbmUubnVtYmVyICE9IChmb3J3YXJkID8gc3RhdGUuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgICAgICAgICAgcG9zICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQpICsgbGluZS5mcm9tO1xuICAgICAgICBsZXQgbmV4dENoYXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4ocG9zLCBuZXh0KSAtIGxpbmUuZnJvbSwgTWF0aC5tYXgocG9zLCBuZXh0KSAtIGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0Q2hhcik7XG4gICAgICAgIGlmIChjYXQgIT0gbnVsbCAmJiBuZXh0Q2F0ICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dENoYXIgIT0gXCIgXCIgfHwgcG9zICE9IHJhbmdlLmhlYWQpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIGJhY2t3YXJkIHVudGlsIHRoZSBlbmQgb2YgdGhlIG5leHRcbltncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5R3JvdXApLCBvbmx5IHNraXBwaW5nIGdyb3VwcyBvZlxud2hpdGVzcGFjZSB3aGVuIHRoZXkgY29uc2lzdCBvZiBhIHNpbmdsZSBzcGFjZS5cbiovXG5jb25zdCBkZWxldGVHcm91cEJhY2t3YXJkID0gdGFyZ2V0ID0+IGRlbGV0ZUJ5R3JvdXAodGFyZ2V0LCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIGZvcndhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dCBncm91cC5cbiovXG5jb25zdCBkZWxldGVHcm91cEZvcndhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIHRydWUpO1xuLyoqXG5WYXJpYW50IG9mIFtgZGVsZXRlR3JvdXBGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEZvcndhcmQpXG50aGF0IHVzZXMgdGhlIFdpbmRvd3MgY29udmVudGlvbiBvZiBhbHNvIGRlbGV0aW5nIHRoZSB3aGl0ZXNwYWNlXG5hZnRlciBhIHdvcmQuXG4qL1xuY29uc3QgZGVsZXRlR3JvdXBGb3J3YXJkV2luID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIHRydWUsIHN0YXJ0ID0+IHRvR3JvdXBTdGFydCh2aWV3LCByYW5nZS5oZWFkLCBzdGFydCkpLmhlYWQpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgZW5kIG9mIHRoZSBsaW5lLiBJZiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IGF0IHRoZSBlbmQgb2YgdGhlXG5saW5lLCBkZWxldGUgdGhlIGxpbmUgYnJlYWsgYWZ0ZXIgaXQuXG4qL1xuY29uc3QgZGVsZXRlVG9MaW5lRW5kID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVFbmQgPSB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvO1xuICAgIHJldHVybiByYW5nZS5oZWFkIDwgbGluZUVuZCA/IGxpbmVFbmQgOiBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIHJhbmdlLmhlYWQgKyAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGJlZm9yZSBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVTdGFydCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb207XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPiBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1heCgwLCByYW5nZS5oZWFkIC0gMSk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lIG9yIHRoZSBuZXh0IGxpbmUgd3JhcCBiZWZvcmUgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZmFsc2UpLmhlYWQ7XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPiBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1heCgwLCByYW5nZS5oZWFkIC0gMSk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIGVuZCBvZiB0aGUgbGluZSBvciB0aGUgbmV4dCBsaW5lIHdyYXAgYWZ0ZXIgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCB0cnVlKS5oZWFkO1xuICAgIHJldHVybiByYW5nZS5oZWFkIDwgbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGVuZ3RoLCByYW5nZS5oZWFkICsgMSk7XG59KTtcbi8qKlxuRGVsZXRlIGFsbCB3aGl0ZXNwYWNlIGRpcmVjdGx5IGJlZm9yZSBhIGxpbmUgZW5kIGZyb20gdGhlXG5kb2N1bWVudC5cbiovXG5jb25zdCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gMCwgcHJldiA9IFwiXCIsIGl0ZXIgPSBzdGF0ZS5kb2MuaXRlcigpOzspIHtcbiAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyLmxpbmVCcmVhayB8fCBpdGVyLmRvbmUpIHtcbiAgICAgICAgICAgIGxldCB0cmFpbGluZyA9IHByZXYuc2VhcmNoKC9cXHMrJC8pO1xuICAgICAgICAgICAgaWYgKHRyYWlsaW5nID4gLTEpXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogcG9zIC0gKHByZXYubGVuZ3RoIC0gdHJhaWxpbmcpLCB0bzogcG9zIH0pO1xuICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHByZXYgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldiA9IGl0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGl0ZXIudmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgY2hhbmdlcywgdXNlckV2ZW50OiBcImRlbGV0ZVwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgZWFjaCBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCBhIGxpbmUgYnJlYWssIGxlYXZpbmcgdGhlIGN1cnNvclxub24gdGhlIGxpbmUgYmVmb3JlIHRoZSBicmVhay5cbiovXG5jb25zdCBzcGxpdExpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiXCIsIFwiXCJdKSB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSkgfTtcbiAgICB9KTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRmxpcCB0aGUgY2hhcmFjdGVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjdXJzb3IocykuXG4qL1xuY29uc3QgdHJhbnNwb3NlQ2hhcnMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgfHwgcmFuZ2UuZnJvbSA9PSAwIHx8IHJhbmdlLmZyb20gPT0gc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgIGxldCBwb3MgPSByYW5nZS5mcm9tLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgZnJvbSA9IHBvcyA9PSBsaW5lLmZyb20gPyBwb3MgLSAxIDogZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZmFsc2UpICsgbGluZS5mcm9tO1xuICAgICAgICBsZXQgdG8gPSBwb3MgPT0gbGluZS50byA/IHBvcyArIDEgOiBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCB0cnVlKSArIGxpbmUuZnJvbTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBzdGF0ZS5kb2Muc2xpY2UocG9zLCB0bykuYXBwZW5kKHN0YXRlLmRvYy5zbGljZShmcm9tLCBwb3MpKSB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pIH07XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwibW92ZS5jaGFyYWN0ZXJcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSB7XG4gICAgbGV0IGJsb2NrcyA9IFtdLCB1cHRvID0gLTE7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKSwgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5ICYmIHJhbmdlLnRvID09IGVuZExpbmUuZnJvbSlcbiAgICAgICAgICAgIGVuZExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvIC0gMSk7XG4gICAgICAgIGlmICh1cHRvID49IHN0YXJ0TGluZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHByZXYudG8gPSBlbmRMaW5lLnRvO1xuICAgICAgICAgICAgcHJldi5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9ja3MucHVzaCh7IGZyb206IHN0YXJ0TGluZS5mcm9tLCB0bzogZW5kTGluZS50bywgcmFuZ2VzOiBbcmFuZ2VdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwdG8gPSBlbmRMaW5lLm51bWJlciArIDE7XG4gICAgfVxuICAgIHJldHVybiBibG9ja3M7XG59XG5mdW5jdGlvbiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZvcndhcmQpIHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdLCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XG4gICAgICAgIGlmIChmb3J3YXJkID8gYmxvY2sudG8gPT0gc3RhdGUuZG9jLmxlbmd0aCA6IGJsb2NrLmZyb20gPT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbmV4dExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZvcndhcmQgPyBibG9jay50byArIDEgOiBibG9jay5mcm9tIC0gMSk7XG4gICAgICAgIGxldCBzaXplID0gbmV4dExpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCB0bzogbmV4dExpbmUudG8gfSwgeyBmcm9tOiBibG9jay5mcm9tLCBpbnNlcnQ6IG5leHRMaW5lLnRleHQgKyBzdGF0ZS5saW5lQnJlYWsgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCByIG9mIGJsb2NrLnJhbmdlcylcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgci5hbmNob3IgKyBzaXplKSwgTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgci5oZWFkICsgc2l6ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG5leHRMaW5lLmZyb20sIHRvOiBibG9jay5mcm9tIH0sIHsgZnJvbTogYmxvY2sudG8sIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgbmV4dExpbmUudGV4dCB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmFuY2hvciAtIHNpemUsIHIuaGVhZCAtIHNpemUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHN0YXRlLnNlbGVjdGlvbi5tYWluSW5kZXgpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwibW92ZS5saW5lXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIHVwIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lVXAgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIGRvd24gb25lIGxpbmUuXG4qL1xuY29uc3QgbW92ZUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZvcndhcmQpIHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay5mcm9tLCBpbnNlcnQ6IHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgKyBzdGF0ZS5saW5lQnJlYWsgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgfSk7XG4gICAgfVxuICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIGNoYW5nZXM6IGNoYW5nZVNldCxcbiAgICAgICAgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24ubWFwKGNoYW5nZVNldCwgZm9yd2FyZCA/IDEgOiAtMSksXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQuY29weWxpbmVcIlxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgdG9wIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgYm90dG9tIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSBzZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBkZWxldGVMaW5lID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZXMoc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGVsc2UgaWYgKHRvIDwgc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgfSkpO1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBkaXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodmlldy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCksIHBvcyA9IHZpZXcuY29vcmRzQXRQb3MocmFuZ2UuaGVhZCwgcmFuZ2UuYXNzb2MgfHwgMSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgIGRpc3QgPSAoYmxvY2suYm90dG9tICsgdmlldy5kb2N1bWVudFRvcCkgLSBwb3MuYm90dG9tICsgdmlldy5kZWZhdWx0TGluZUhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIHRydWUsIGRpc3QpO1xuICAgIH0pLm1hcChjaGFuZ2VzKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlcywgc2VsZWN0aW9uLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZS5saW5lXCIgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24oc3RhdGUubGluZUJyZWFrKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGFuZCB0aGUgc2FtZSBhbW91bnQgb2ZcbmluZGVudGF0aW9uIGFzIHRoZSBsaW5lIGFib3ZlLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmVLZWVwSW5kZW50ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCBpbmRlbnQgPSAvXlxccyovLmV4ZWMoc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKS50ZXh0KVswXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIGluZGVudCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGluZGVudC5sZW5ndGggKyAxKVxuICAgICAgICB9O1xuICAgIH0pLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIHBvcykge1xuICAgIGlmICgvXFwoXFwpfFxcW1xcXXxcXHtcXH0vLnRlc3Qoc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zICsgMSkpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MgfTtcbiAgICBsZXQgY29udGV4dCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MpO1xuICAgIGxldCBiZWZvcmUgPSBjb250ZXh0LmNoaWxkQmVmb3JlKHBvcyksIGFmdGVyID0gY29udGV4dC5jaGlsZEFmdGVyKHBvcyksIGNsb3NlZEJ5O1xuICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIgJiYgYmVmb3JlLnRvIDw9IHBvcyAmJiBhZnRlci5mcm9tID49IHBvcyAmJlxuICAgICAgICAoY2xvc2VkQnkgPSBiZWZvcmUudHlwZS5wcm9wKE5vZGVQcm9wLmNsb3NlZEJ5KSkgJiYgY2xvc2VkQnkuaW5kZXhPZihhZnRlci5uYW1lKSA+IC0xICYmXG4gICAgICAgIHN0YXRlLmRvYy5saW5lQXQoYmVmb3JlLnRvKS5mcm9tID09IHN0YXRlLmRvYy5saW5lQXQoYWZ0ZXIuZnJvbSkuZnJvbSAmJlxuICAgICAgICAhL1xcUy8udGVzdChzdGF0ZS5zbGljZURvYyhiZWZvcmUudG8sIGFmdGVyLmZyb20pKSlcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogYmVmb3JlLnRvLCB0bzogYWZ0ZXIuZnJvbSB9O1xuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgYW5kIGluZGVudCB0aGUgbmV3bHkgY3JlYXRlZFxubGluZShzKS4gSWYgdGhlIGN1cnJlbnQgbGluZSBjb25zaXN0cyBvbmx5IG9mIHdoaXRlc3BhY2UsIHRoaXNcbndpbGwgYWxzbyBkZWxldGUgdGhhdCB3aGl0ZXNwYWNlLiBXaGVuIHRoZSBjdXJzb3IgaXMgYmV0d2VlblxubWF0Y2hpbmcgYnJhY2tldHMsIGFuIGFkZGl0aW9uYWwgbmV3bGluZSB3aWxsIGJlIGluc2VydGVkIGFmdGVyXG50aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudChmYWxzZSk7XG4vKipcbkNyZWF0ZSBhIGJsYW5rLCBpbmRlbnRlZCBsaW5lIGJlbG93IHRoZSBjdXJyZW50IGxpbmUuXG4qL1xuY29uc3QgaW5zZXJ0QmxhbmtMaW5lID0gLypAX19QVVJFX18qL25ld2xpbmVBbmRJbmRlbnQodHJ1ZSk7XG5mdW5jdGlvbiBuZXdsaW5lQW5kSW5kZW50KGF0RW9mKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBsZXQgZXhwbG9kZSA9ICFhdEVvZiAmJiBmcm9tID09IHRvICYmIGlzQmV0d2VlbkJyYWNrZXRzKHN0YXRlLCBmcm9tKTtcbiAgICAgICAgICAgIGlmIChhdEVvZilcbiAgICAgICAgICAgICAgICBmcm9tID0gdG8gPSAodG8gPD0gbGluZS50byA/IGxpbmUgOiBzdGF0ZS5kb2MubGluZUF0KHRvKSkudG87XG4gICAgICAgICAgICBsZXQgY3ggPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBzaW11bGF0ZUJyZWFrOiBmcm9tLCBzaW11bGF0ZURvdWJsZUJyZWFrOiAhIWV4cGxvZGUgfSk7XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY3gsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGluZGVudCA9IGNvdW50Q29sdW1uKC9eXFxzKi8uZXhlYyhzdGF0ZS5kb2MubGluZUF0KGZyb20pLnRleHQpWzBdLCBzdGF0ZS50YWJTaXplKTtcbiAgICAgICAgICAgIHdoaWxlICh0byA8IGxpbmUudG8gJiYgL1xccy8udGVzdChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dKSlcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IGV4cGxvZGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+IGxpbmUuZnJvbSAmJiBmcm9tIDwgbGluZS5mcm9tICsgMTAwICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZSgwLCBmcm9tKSkpXG4gICAgICAgICAgICAgICAgZnJvbSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBbXCJcIiwgaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpXTtcbiAgICAgICAgICAgIGlmIChleHBsb2RlKVxuICAgICAgICAgICAgICAgIGluc2VydC5wdXNoKGluZGVudFN0cmluZyhzdGF0ZSwgY3gubGluZUluZGVudChsaW5lLmZyb20sIC0xKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKGluc2VydCkgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgMSArIGluc2VydFsxXS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIGYpIHtcbiAgICBsZXQgYXRMaW5lID0gLTE7XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSByYW5nZS5mcm9tOyBwb3MgPD0gcmFuZ2UudG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IGF0TGluZSAmJiAocmFuZ2UuZW1wdHkgfHwgcmFuZ2UudG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgZihsaW5lLCBjaGFuZ2VzLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgYXRMaW5lID0gbGluZS5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY2hhbmdlU2V0Lm1hcFBvcyhyYW5nZS5hbmNob3IsIDEpLCBjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmhlYWQsIDEpKSB9O1xuICAgIH0pO1xufVxuLyoqXG5BdXRvLWluZGVudCB0aGUgc2VsZWN0ZWQgbGluZXMuIFRoaXMgdXNlcyB0aGUgW2luZGVudGF0aW9uIHNlcnZpY2VcbmZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpIGFzIHNvdXJjZSBmb3IgYXV0by1pbmRlbnRcbmluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IGluZGVudFNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHVwZGF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdXBkYXRlZFtzdGFydF07XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPT0gbnVsbCA/IC0xIDogZm91bmQ7XG4gICAgICAgIH0gfSk7XG4gICAgbGV0IGNoYW5nZXMgPSBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMsIHJhbmdlKSA9PiB7XG4gICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBsaW5lLmZyb20pO1xuICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtIHx8IHJhbmdlLmZyb20gPCBsaW5lLmZyb20gKyBjdXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgdXNlckV2ZW50OiBcImluZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkFkZCBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIHRvIGFsbCBzZWxlY3RlZFxubGluZXMuXG4qL1xuY29uc3QgaW5kZW50TW9yZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcykgPT4ge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydDogc3RhdGUuZmFjZXQoaW5kZW50VW5pdCkgfSk7XG4gICAgfSksIHsgdXNlckV2ZW50OiBcImlucHV0LmluZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlbW92ZSBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIGZyb20gYWxsXG5zZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBpbmRlbnRMZXNzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGxldCBzcGFjZSA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBpZiAoIXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29sID0gY291bnRDb2x1bW4oc3BhY2UsIHN0YXRlLnRhYlNpemUpLCBrZWVwID0gMDtcbiAgICAgICAgbGV0IGluc2VydCA9IGluZGVudFN0cmluZyhzdGF0ZSwgTWF0aC5tYXgoMCwgY29sIC0gZ2V0SW5kZW50VW5pdChzdGF0ZSkpKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBzcGFjZS5sZW5ndGggJiYga2VlcCA8IGluc2VydC5sZW5ndGggJiYgc3BhY2UuY2hhckNvZGVBdChrZWVwKSA9PSBpbnNlcnQuY2hhckNvZGVBdChrZWVwKSlcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsga2VlcCwgdG86IGxpbmUuZnJvbSArIHNwYWNlLmxlbmd0aCwgaW5zZXJ0OiBpbnNlcnQuc2xpY2Uoa2VlcCkgfSk7XG4gICAgfSksIHsgdXNlckV2ZW50OiBcImRlbGV0ZS5kZWRlbnRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5FbmFibGVzIG9yIGRpc2FibGVzXG5bdGFiLWZvY3VzIG1vZGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnNldFRhYkZvY3VzTW9kZSkuIFdoaWxlIG9uLCB0aGlzXG5wcmV2ZW50cyB0aGUgZWRpdG9yJ3Mga2V5IGJpbmRpbmdzIGZyb20gY2FwdHVyaW5nIFRhYiBvclxuU2hpZnQtVGFiLCBtYWtpbmcgaXQgcG9zc2libGUgZm9yIHRoZSB1c2VyIHRvIG1vdmUgZm9jdXMgb3V0IG9mXG50aGUgZWRpdG9yIHdpdGggdGhlIGtleWJvYXJkLlxuKi9cbmNvbnN0IHRvZ2dsZVRhYkZvY3VzTW9kZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuc2V0VGFiRm9jdXNNb2RlKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5UZW1wb3JhcmlseSBlbmFibGVzIFt0YWItZm9jdXNcbm1vZGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnNldFRhYkZvY3VzTW9kZSkgZm9yIHR3byBzZWNvbmRzIG9yIHVudGlsXG5hbm90aGVyIGtleSBpcyBwcmVzc2VkLlxuKi9cbmNvbnN0IHRlbXBvcmFyaWx5U2V0VGFiRm9jdXNNb2RlID0gdmlldyA9PiB7XG4gICAgdmlldy5zZXRUYWJGb2N1c01vZGUoMjAwMCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JbnNlcnQgYSB0YWIgY2hhcmFjdGVyIGF0IHRoZSBjdXJzb3Igb3IsIGlmIHNvbWV0aGluZyBpcyBzZWxlY3RlZCxcbnVzZSBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIHRvIGluZGVudCB0aGUgZW50aXJlXG5zZWxlY3Rpb24uXG4qL1xuY29uc3QgaW5zZXJ0VGFiID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gIXIuZW1wdHkpKVxuICAgICAgICByZXR1cm4gaW5kZW50TW9yZSh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihcIlxcdFwiKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNvbnRhaW5pbmcgdGhlIEVtYWNzLXN0eWxlIGJpbmRpbmdzIHRoYXQgYXJlXG5hdmFpbGFibGUgb24gbWFjT1MgYnkgZGVmYXVsdC5cblxuIC0gQ3RybC1iOiBbYGN1cnNvckNoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyTGVmdCkgKFtgc2VsZWN0Q2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1mOiBbYGN1cnNvckNoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhclJpZ2h0KSAoW2BzZWxlY3RDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJSaWdodCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBDdHJsLW46IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDdHJsLWE6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1lOiBbYGN1cnNvckxpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVFbmQpIChbYHNlbGVjdExpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVFbmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWQ6IFtgZGVsZXRlQ2hhckZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJGb3J3YXJkKVxuIC0gQ3RybC1oOiBbYGRlbGV0ZUNoYXJCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckJhY2t3YXJkKVxuIC0gQ3RybC1rOiBbYGRlbGV0ZVRvTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlVG9MaW5lRW5kKVxuIC0gQ3RybC1BbHQtaDogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1vOiBbYHNwbGl0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRMaW5lKVxuIC0gQ3RybC10OiBbYHRyYW5zcG9zZUNoYXJzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50cmFuc3Bvc2VDaGFycylcbiAtIEN0cmwtdjogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pXG4gLSBBbHQtdjogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcClcbiovXG5jb25zdCBlbWFjc1N0eWxlS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtYlwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1mXCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1wXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1uXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkN0cmwtYVwiLCBydW46IGN1cnNvckxpbmVTdGFydCwgc2hpZnQ6IHNlbGVjdExpbmVTdGFydCB9LFxuICAgIHsga2V5OiBcIkN0cmwtZVwiLCBydW46IGN1cnNvckxpbmVFbmQsIHNoaWZ0OiBzZWxlY3RMaW5lRW5kIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1kXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWhcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWtcIiwgcnVuOiBkZWxldGVUb0xpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1oXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtb1wiLCBydW46IHNwbGl0TGluZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtdFwiLCBydW46IHRyYW5zcG9zZUNoYXJzIH0sXG4gICAgeyBrZXk6IFwiQ3RybC12XCIsIHJ1bjogY3Vyc29yUGFnZURvd24gfSxcbl07XG4vKipcbkFuIGFycmF5IG9mIGtleSBiaW5kaW5ncyBjbG9zZWx5IHN0aWNraW5nIHRvIHBsYXRmb3JtLXN0YW5kYXJkIG9yXG53aWRlbHkgdXNlZCBiaW5kaW5ncy4gKFRoaXMgaW5jbHVkZXMgdGhlIGJpbmRpbmdzIGZyb21cbltgZW1hY3NTdHlsZUtleW1hcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZW1hY3NTdHlsZUtleW1hcCksIHdpdGggdGhlaXIgYGtleWBcbnByb3BlcnR5IGNoYW5nZWQgdG8gYG1hY2AuKVxuXG4gLSBBcnJvd0xlZnQ6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBBcnJvd1JpZ2h0OiBbYGN1cnNvckNoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhclJpZ2h0KSAoW2BzZWxlY3RDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJSaWdodCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dMZWZ0IChBbHQtQXJyb3dMZWZ0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwTGVmdCkgKFtgc2VsZWN0R3JvdXBMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cExlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93UmlnaHQgKEFsdC1BcnJvd1JpZ2h0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cFJpZ2h0KSAoW2BzZWxlY3RHcm91cFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cFJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93TGVmdCAob24gbWFjT1MpOiBbYGN1cnNvckxpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVN0YXJ0KSAoW2BzZWxlY3RMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVTdGFydCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd1JpZ2h0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEFycm93VXA6IFtgY3Vyc29yTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lVXApIChbYHNlbGVjdExpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVVwKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dEb3duOiBbYGN1cnNvckxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRG93bikgKFtgc2VsZWN0TGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVEb3duKSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd0Rvd24gKG9uIG1hY09TKTogW2BjdXJzb3JEb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY0VuZCkgKFtgc2VsZWN0RG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NFbmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcCkgKFtgc2VsZWN0UGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlVXApIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZVVwOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIFBhZ2VEb3duOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxuIC0gSG9tZTogW2BjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCkgd2l0aCBTaGlmdClcbiAtIEVuZDogW2BjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkKSAoW2BzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1Ib21lIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY1N0YXJ0KSAoW2BzZWxlY3REb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUVuZCAoQ21kLUhvbWUgb24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEVudGVyIGFuZCBTaGlmdC1FbnRlcjogW2BpbnNlcnROZXdsaW5lQW5kSW5kZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnROZXdsaW5lQW5kSW5kZW50KVxuIC0gQ3RybC1hIChDbWQtYSBvbiBtYWNPUyk6IFtgc2VsZWN0QWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RBbGwpXG4gLSBCYWNrc3BhY2U6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBEZWxldGU6IFtgZGVsZXRlQ2hhckZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJGb3J3YXJkKVxuIC0gQ3RybC1CYWNrc3BhY2UgKEFsdC1CYWNrc3BhY2Ugb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLURlbGV0ZSAoQWx0LURlbGV0ZSBvbiBtYWNPUyk6IFtgZGVsZXRlR3JvdXBGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEZvcndhcmQpXG4gLSBDbWQtQmFja3NwYWNlIChtYWNPUyk6IFtgZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkKS5cbiAtIENtZC1EZWxldGUgKG1hY09TKTogW2BkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkKS5cbiovXG5jb25zdCBzdGFuZGFyZEtleW1hcCA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBrZXk6IFwiQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dMZWZ0XCIsIG1hYzogXCJBbHQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yR3JvdXBMZWZ0LCBzaGlmdDogc2VsZWN0R3JvdXBMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0LCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJBbHQtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckdyb3VwUmlnaHQsIHNoaWZ0OiBzZWxlY3RHcm91cFJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBcnJvd1VwXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yRG9jU3RhcnQsIHNoaWZ0OiBzZWxlY3REb2NTdGFydCB9LFxuICAgIHsgbWFjOiBcIkN0cmwtQXJyb3dVcFwiLCBydW46IGN1cnNvclBhZ2VVcCwgc2hpZnQ6IHNlbGVjdFBhZ2VVcCB9LFxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IGN1cnNvckxpbmVEb3duLCBzaGlmdDogc2VsZWN0TGluZURvd24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93RG93blwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsgbWFjOiBcIkN0cmwtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yUGFnZURvd24sIHNoaWZ0OiBzZWxlY3RQYWdlRG93biB9LFxuICAgIHsga2V5OiBcIlBhZ2VVcFwiLCBydW46IGN1cnNvclBhZ2VVcCwgc2hpZnQ6IHNlbGVjdFBhZ2VVcCB9LFxuICAgIHsga2V5OiBcIlBhZ2VEb3duXCIsIHJ1bjogY3Vyc29yUGFnZURvd24sIHNoaWZ0OiBzZWxlY3RQYWdlRG93biB9LFxuICAgIHsga2V5OiBcIkhvbWVcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1Ib21lXCIsIHJ1bjogY3Vyc29yRG9jU3RhcnQsIHNoaWZ0OiBzZWxlY3REb2NTdGFydCB9LFxuICAgIHsga2V5OiBcIkVuZFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1FbmRcIiwgcnVuOiBjdXJzb3JEb2NFbmQsIHNoaWZ0OiBzZWxlY3REb2NFbmQgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGluc2VydE5ld2xpbmVBbmRJbmRlbnQsIHNoaWZ0OiBpbnNlcnROZXdsaW5lQW5kSW5kZW50IH0sXG4gICAgeyBrZXk6IFwiTW9kLWFcIiwgcnVuOiBzZWxlY3RBbGwgfSxcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQsIHNoaWZ0OiBkZWxldGVDaGFyQmFja3dhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRGVsZXRlXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUJhY2tzcGFjZVwiLCBtYWM6IFwiQWx0LUJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUdyb3VwQmFja3dhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLURlbGV0ZVwiLCBtYWM6IFwiQWx0LURlbGV0ZVwiLCBydW46IGRlbGV0ZUdyb3VwRm9yd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJNb2QtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiTW9kLURlbGV0ZVwiLCBydW46IGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH1cbl0uY29uY2F0KC8qQF9fUFVSRV9fKi9lbWFjc1N0eWxlS2V5bWFwLm1hcChiID0+ICh7IG1hYzogYi5rZXksIHJ1bjogYi5ydW4sIHNoaWZ0OiBiLnNoaWZ0IH0pKSk7XG4vKipcblRoZSBkZWZhdWx0IGtleW1hcC4gSW5jbHVkZXMgYWxsIGJpbmRpbmdzIGZyb21cbltgc3RhbmRhcmRLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnN0YW5kYXJkS2V5bWFwKSBwbHVzIHRoZSBmb2xsb3dpbmc6XG5cbi0gQWx0LUFycm93TGVmdCAoQ3RybC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheExlZnQpIChbYHNlbGVjdFN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheExlZnQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1JpZ2h0IChDdHJsLUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhSaWdodCkgKFtgc2VsZWN0U3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheFJpZ2h0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dVcDogW2Btb3ZlTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZVVwKVxuLSBBbHQtQXJyb3dEb3duOiBbYG1vdmVMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVEb3duKVxuLSBTaGlmdC1BbHQtQXJyb3dVcDogW2Bjb3B5TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZVVwKVxuLSBTaGlmdC1BbHQtQXJyb3dEb3duOiBbYGNvcHlMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVEb3duKVxuLSBDdHJsLUFsdC1BcnJvd1VwIChDbWQtQWx0LUFycm93VXAgb24gbWFjT1MpOiBbYGFkZEN1cnNvckFib3ZlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5hZGRDdXJzb3JBYm92ZSkuXG4tIEN0cmwtQWx0LUFycm93RG93biAoQ21kLUFsdC1BcnJvd0Rvd24gb24gbWFjT1MpOiBbYGFkZEN1cnNvckJlbG93YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5hZGRDdXJzb3JCZWxvdykuXG4tIEVzY2FwZTogW2BzaW1wbGlmeVNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2ltcGxpZnlTZWxlY3Rpb24pXG4tIEN0cmwtRW50ZXIgKENtZC1FbnRlciBvbiBtYWNPUyk6IFtgaW5zZXJ0QmxhbmtMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnRCbGFua0xpbmUpXG4tIEFsdC1sIChDdHJsLWwgb24gbWFjT1MpOiBbYHNlbGVjdExpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmUpXG4tIEN0cmwtaSAoQ21kLWkgb24gbWFjT1MpOiBbYHNlbGVjdFBhcmVudFN5bnRheGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFyZW50U3ludGF4KVxuLSBDdHJsLVsgKENtZC1bIG9uIG1hY09TKTogW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKVxuLSBDdHJsLV0gKENtZC1dIG9uIG1hY09TKTogW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKVxuLSBDdHJsLUFsdC1cXFxcIChDbWQtQWx0LVxcXFwgb24gbWFjT1MpOiBbYGluZGVudFNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50U2VsZWN0aW9uKVxuLSBTaGlmdC1DdHJsLWsgKFNoaWZ0LUNtZC1rIG9uIG1hY09TKTogW2BkZWxldGVMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lKVxuLSBTaGlmdC1DdHJsLVxcXFwgKFNoaWZ0LUNtZC1cXFxcIG9uIG1hY09TKTogW2BjdXJzb3JNYXRjaGluZ0JyYWNrZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvck1hdGNoaW5nQnJhY2tldClcbi0gQ3RybC0vIChDbWQtLyBvbiBtYWNPUyk6IFtgdG9nZ2xlQ29tbWVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlQ29tbWVudCkuXG4tIFNoaWZ0LUFsdC1hOiBbYHRvZ2dsZUJsb2NrQ29tbWVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlQmxvY2tDb21tZW50KS5cbi0gQ3RybC1tIChBbHQtU2hpZnQtbSBvbiBtYWNPUyk6IFtgdG9nZ2xlVGFiRm9jdXNNb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVUYWJGb2N1c01vZGUpLlxuKi9cbmNvbnN0IGRlZmF1bHRLZXltYXAgPSAvKkBfX1BVUkVfXyovW1xuICAgIHsga2V5OiBcIkFsdC1BcnJvd0xlZnRcIiwgbWFjOiBcIkN0cmwtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yU3ludGF4TGVmdCwgc2hpZnQ6IHNlbGVjdFN5bnRheExlZnQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dSaWdodFwiLCBtYWM6IFwiQ3RybC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yU3ludGF4UmlnaHQsIHNoaWZ0OiBzZWxlY3RTeW50YXhSaWdodCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1VwXCIsIHJ1bjogbW92ZUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd1VwXCIsIHJ1bjogY29weUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd0Rvd25cIiwgcnVuOiBtb3ZlTGluZURvd24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dEb3duXCIsIHJ1bjogY29weUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFsdC1BcnJvd1VwXCIsIHJ1bjogYWRkQ3Vyc29yQWJvdmUgfSxcbiAgICB7IGtleTogXCJNb2QtQWx0LUFycm93RG93blwiLCBydW46IGFkZEN1cnNvckJlbG93IH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogc2ltcGxpZnlTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJNb2QtRW50ZXJcIiwgcnVuOiBpbnNlcnRCbGFua0xpbmUgfSxcbiAgICB7IGtleTogXCJBbHQtbFwiLCBtYWM6IFwiQ3RybC1sXCIsIHJ1bjogc2VsZWN0TGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1pXCIsIHJ1bjogc2VsZWN0UGFyZW50U3ludGF4LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1bXCIsIHJ1bjogaW5kZW50TGVzcyB9LFxuICAgIHsga2V5OiBcIk1vZC1dXCIsIHJ1bjogaW5kZW50TW9yZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BbHQtXFxcXFwiLCBydW46IGluZGVudFNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1rXCIsIHJ1bjogZGVsZXRlTGluZSB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1cXFxcXCIsIHJ1bjogY3Vyc29yTWF0Y2hpbmdCcmFja2V0IH0sXG4gICAgeyBrZXk6IFwiTW9kLS9cIiwgcnVuOiB0b2dnbGVDb21tZW50IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFcIiwgcnVuOiB0b2dnbGVCbG9ja0NvbW1lbnQgfSxcbiAgICB7IGtleTogXCJDdHJsLW1cIiwgbWFjOiBcIlNoaWZ0LUFsdC1tXCIsIHJ1bjogdG9nZ2xlVGFiRm9jdXNNb2RlIH0sXG5dLmNvbmNhdChzdGFuZGFyZEtleW1hcCk7XG4vKipcbkEgYmluZGluZyB0aGF0IGJpbmRzIFRhYiB0byBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIGFuZFxuU2hpZnQtVGFiIHRvIFtgaW5kZW50TGVzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TGVzcykuXG5QbGVhc2Ugc2VlIHRoZSBbVGFiIGV4YW1wbGVdKC4uLy4uL2V4YW1wbGVzL3RhYi8pIGJlZm9yZSB1c2luZ1xudGhpcy5cbiovXG5jb25zdCBpbmRlbnRXaXRoVGFiID0geyBrZXk6IFwiVGFiXCIsIHJ1bjogaW5kZW50TW9yZSwgc2hpZnQ6IGluZGVudExlc3MgfTtcblxuZXhwb3J0IHsgYWRkQ3Vyc29yQWJvdmUsIGFkZEN1cnNvckJlbG93LCBibG9ja0NvbW1lbnQsIGJsb2NrVW5jb21tZW50LCBjb3B5TGluZURvd24sIGNvcHlMaW5lVXAsIGN1cnNvckNoYXJCYWNrd2FyZCwgY3Vyc29yQ2hhckJhY2t3YXJkTG9naWNhbCwgY3Vyc29yQ2hhckZvcndhcmQsIGN1cnNvckNoYXJGb3J3YXJkTG9naWNhbCwgY3Vyc29yQ2hhckxlZnQsIGN1cnNvckNoYXJSaWdodCwgY3Vyc29yRG9jRW5kLCBjdXJzb3JEb2NTdGFydCwgY3Vyc29yR3JvdXBCYWNrd2FyZCwgY3Vyc29yR3JvdXBGb3J3YXJkLCBjdXJzb3JHcm91cEZvcndhcmRXaW4sIGN1cnNvckdyb3VwTGVmdCwgY3Vyc29yR3JvdXBSaWdodCwgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQsIGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQsIGN1cnNvckxpbmVCb3VuZGFyeUxlZnQsIGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0LCBjdXJzb3JMaW5lRG93biwgY3Vyc29yTGluZUVuZCwgY3Vyc29yTGluZVN0YXJ0LCBjdXJzb3JMaW5lVXAsIGN1cnNvck1hdGNoaW5nQnJhY2tldCwgY3Vyc29yUGFnZURvd24sIGN1cnNvclBhZ2VVcCwgY3Vyc29yU3Vid29yZEJhY2t3YXJkLCBjdXJzb3JTdWJ3b3JkRm9yd2FyZCwgY3Vyc29yU3ludGF4TGVmdCwgY3Vyc29yU3ludGF4UmlnaHQsIGRlZmF1bHRLZXltYXAsIGRlbGV0ZUNoYXJCYWNrd2FyZCwgZGVsZXRlQ2hhckJhY2t3YXJkU3RyaWN0LCBkZWxldGVDaGFyRm9yd2FyZCwgZGVsZXRlR3JvdXBCYWNrd2FyZCwgZGVsZXRlR3JvdXBGb3J3YXJkLCBkZWxldGVHcm91cEZvcndhcmRXaW4sIGRlbGV0ZUxpbmUsIGRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkLCBkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkLCBkZWxldGVUb0xpbmVFbmQsIGRlbGV0ZVRvTGluZVN0YXJ0LCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UsIGVtYWNzU3R5bGVLZXltYXAsIGhpc3RvcnksIGhpc3RvcnlGaWVsZCwgaGlzdG9yeUtleW1hcCwgaW5kZW50TGVzcywgaW5kZW50TW9yZSwgaW5kZW50U2VsZWN0aW9uLCBpbmRlbnRXaXRoVGFiLCBpbnNlcnRCbGFua0xpbmUsIGluc2VydE5ld2xpbmUsIGluc2VydE5ld2xpbmVBbmRJbmRlbnQsIGluc2VydE5ld2xpbmVLZWVwSW5kZW50LCBpbnNlcnRUYWIsIGludmVydGVkRWZmZWN0cywgaXNvbGF0ZUhpc3RvcnksIGxpbmVDb21tZW50LCBsaW5lVW5jb21tZW50LCBtb3ZlTGluZURvd24sIG1vdmVMaW5lVXAsIHJlZG8sIHJlZG9EZXB0aCwgcmVkb1NlbGVjdGlvbiwgc2VsZWN0QWxsLCBzZWxlY3RDaGFyQmFja3dhcmQsIHNlbGVjdENoYXJCYWNrd2FyZExvZ2ljYWwsIHNlbGVjdENoYXJGb3J3YXJkLCBzZWxlY3RDaGFyRm9yd2FyZExvZ2ljYWwsIHNlbGVjdENoYXJMZWZ0LCBzZWxlY3RDaGFyUmlnaHQsIHNlbGVjdERvY0VuZCwgc2VsZWN0RG9jU3RhcnQsIHNlbGVjdEdyb3VwQmFja3dhcmQsIHNlbGVjdEdyb3VwRm9yd2FyZCwgc2VsZWN0R3JvdXBGb3J3YXJkV2luLCBzZWxlY3RHcm91cExlZnQsIHNlbGVjdEdyb3VwUmlnaHQsIHNlbGVjdExpbmUsIHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgc2VsZWN0TGluZURvd24sIHNlbGVjdExpbmVFbmQsIHNlbGVjdExpbmVTdGFydCwgc2VsZWN0TGluZVVwLCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQsIHNlbGVjdFBhZ2VEb3duLCBzZWxlY3RQYWdlVXAsIHNlbGVjdFBhcmVudFN5bnRheCwgc2VsZWN0U3Vid29yZEJhY2t3YXJkLCBzZWxlY3RTdWJ3b3JkRm9yd2FyZCwgc2VsZWN0U3ludGF4TGVmdCwgc2VsZWN0U3ludGF4UmlnaHQsIHNpbXBsaWZ5U2VsZWN0aW9uLCBzcGxpdExpbmUsIHN0YW5kYXJkS2V5bWFwLCB0ZW1wb3JhcmlseVNldFRhYkZvY3VzTW9kZSwgdG9nZ2xlQmxvY2tDb21tZW50LCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUsIHRvZ2dsZUNvbW1lbnQsIHRvZ2dsZUxpbmVDb21tZW50LCB0b2dnbGVUYWJGb2N1c01vZGUsIHRyYW5zcG9zZUNoYXJzLCB1bmRvLCB1bmRvRGVwdGgsIHVuZG9TZWxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBzaG93RGlhbG9nLCBFZGl0b3JWaWV3LCBEZWNvcmF0aW9uLCBWaWV3UGx1Z2luLCBzaG93UGFuZWwsIHJ1blNjb3BlSGFuZGxlcnMsIGdldFBhbmVsIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBjb2RlUG9pbnRBdCwgZnJvbUNvZGVQb2ludCwgY29kZVBvaW50U2l6ZSwgRWRpdG9yU2VsZWN0aW9uLCBGYWNldCwgY29tYmluZUNvbmZpZywgQ2hhckNhdGVnb3J5LCBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgUmFuZ2VTZXRCdWlsZGVyLCBQcmVjLCBFZGl0b3JTdGF0ZSwgZmluZENsdXN0ZXJCcmVhayB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCBlbHQgZnJvbSAnY3JlbHQnO1xuXG5jb25zdCBiYXNpY05vcm1hbGl6ZSA9IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSA9PSBcImZ1bmN0aW9uXCJcbiAgICA/IHggPT4geC5ub3JtYWxpemUoXCJORktEXCIpIDogeCA9PiB4O1xuLyoqXG5BIHNlYXJjaCBjdXJzb3IgcHJvdmlkZXMgYW4gaXRlcmF0b3Igb3ZlciB0ZXh0IG1hdGNoZXMgaW4gYVxuZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VhcmNoQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IGN1cnNvci4gVGhlIHF1ZXJ5IGlzIHRoZSBzZWFyY2ggc3RyaW5nLCBgZnJvbWAgdG9cbiAgICBgdG9gIHByb3ZpZGVzIHRoZSByZWdpb24gdG8gc2VhcmNoLlxuICAgIFxuICAgIFdoZW4gYG5vcm1hbGl6ZWAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgY2FsbGVkLCBvbiBib3RoIHRoZSBxdWVyeVxuICAgIHN0cmluZyBhbmQgdGhlIGNvbnRlbnQgaXQgaXMgbWF0Y2hlZCBhZ2FpbnN0LCBiZWZvcmUgY29tcGFyaW5nLlxuICAgIFlvdSBjYW4sIGZvciBleGFtcGxlLCBjcmVhdGUgYSBjYXNlLWluc2Vuc2l0aXZlIHNlYXJjaCBieVxuICAgIHBhc3NpbmcgYHMgPT4gcy50b0xvd2VyQ2FzZSgpYC5cbiAgICBcbiAgICBUZXh0IGlzIGFsd2F5cyBub3JtYWxpemVkIHdpdGhcbiAgICBbYC5ub3JtYWxpemUoXCJORktEXCIpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL25vcm1hbGl6ZSlcbiAgICAod2hlbiBzdXBwb3J0ZWQpLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoLCBub3JtYWxpemUsIHRlc3QpIHtcbiAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IG1hdGNoIChvbmx5IGhvbGRzIGEgbWVhbmluZ2Z1bCB2YWx1ZSBhZnRlclxuICAgICAgICBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IubmV4dCkgaGFzIGJlZW4gY2FsbGVkIGFuZCB3aGVuXG4gICAgICAgIGBkb25lYCBpcyBmYWxzZSkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb206IDAsIHRvOiAwIH07XG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGl0ZXJhdGVkIHJlZ2lvbiBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gW107XG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgdGhpcy5idWZmZXJQb3MgPSAwO1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXJSYW5nZShmcm9tLCB0byk7XG4gICAgICAgIHRoaXMuYnVmZmVyU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZSA/IHggPT4gbm9ybWFsaXplKGJhc2ljTm9ybWFsaXplKHgpKSA6IGJhc2ljTm9ybWFsaXplO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5ub3JtYWxpemUocXVlcnkpO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJQb3MgPT0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ICs9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuaXRlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJQb3MgPSAwO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLml0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludEF0KHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlclBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIHRoZSBuZXh0IG1hdGNoLiBVcGRhdGVzIHRoZSBpdGVyYXRvcidzXG4gICAgW2B2YWx1ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci52YWx1ZSkgYW5kXG4gICAgW2Bkb25lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLmRvbmUpIHByb3BlcnRpZXMuIFNob3VsZCBiZSBjYWxsZWRcbiAgICBhdCBsZWFzdCBvbmNlIGJlZm9yZSB1c2luZyB0aGUgY3Vyc29yLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2hlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm1hdGNoZXMucG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRPdmVybGFwcGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYG5leHRgIG1ldGhvZCB3aWxsIGlnbm9yZSBtYXRjaGVzIHRoYXQgcGFydGlhbGx5IG92ZXJsYXAgYVxuICAgIHByZXZpb3VzIG1hdGNoLiBUaGlzIG1ldGhvZCBiZWhhdmVzIGxpa2UgYG5leHRgLCBidXQgaW5jbHVkZXNcbiAgICBzdWNoIG1hdGNoZXMuXG4gICAgKi9cbiAgICBuZXh0T3ZlcmxhcHBpbmcoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0ciA9IGZyb21Db2RlUG9pbnQobmV4dCksIHN0YXJ0ID0gdGhpcy5idWZmZXJTdGFydCArIHRoaXMuYnVmZmVyUG9zO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJQb3MgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIGxldCBub3JtID0gdGhpcy5ub3JtYWxpemUoc3RyKTtcbiAgICAgICAgICAgIGlmIChub3JtLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBub3JtLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2goY29kZSwgcG9zLCB0aGlzLmJ1ZmZlclBvcyArIHRoaXMuYnVmZmVyU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBub3JtLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gc3RhcnQgJiYgaSA8IHN0ci5sZW5ndGggJiYgc3RyLmNoYXJDb2RlQXQoaSkgPT0gY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaChjb2RlLCBwb3MsIGVuZCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF0Y2hlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5tYXRjaGVzW2ldLCBrZWVwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KGluZGV4KSA9PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucXVlcnkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHsgZnJvbTogdGhpcy5tYXRjaGVzW2kgKyAxXSwgdG86IGVuZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzW2ldKys7XG4gICAgICAgICAgICAgICAgICAgIGtlZXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2VlcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5LmNoYXJDb2RlQXQoMCkgPT0gY29kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHBvcywgdG86IGVuZCB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wdXNoKDEsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoICYmIHRoaXMudGVzdCAmJiAhdGhpcy50ZXN0KG1hdGNoLmZyb20sIG1hdGNoLnRvLCB0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJTdGFydCkpXG4gICAgICAgICAgICBtYXRjaCA9IG51bGw7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKVxuICAgIFNlYXJjaEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbmNvbnN0IGVtcHR5ID0geyBmcm9tOiAtMSwgdG86IC0xLCBtYXRjaDogLypAX19QVVJFX18qLy8uKi8uZXhlYyhcIlwiKSB9O1xuY29uc3QgYmFzZUZsYWdzID0gXCJnbVwiICsgKC94Ly51bmljb2RlID09IG51bGwgPyBcIlwiIDogXCJ1XCIpO1xuLyoqXG5UaGlzIGNsYXNzIGlzIHNpbWlsYXIgdG8gW2BTZWFyY2hDdXJzb3JgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IpXG5idXQgc2VhcmNoZXMgZm9yIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gaW5zdGVhZCBvZiBhIHBsYWluXG5zdHJpbmcuXG4qL1xuY2xhc3MgUmVnRXhwQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBjdXJzb3IgdGhhdCB3aWxsIHNlYXJjaCB0aGUgZ2l2ZW4gcmFuZ2UgaW4gdGhlIGdpdmVuXG4gICAgZG9jdW1lbnQuIGBxdWVyeWAgc2hvdWxkIGJlIHRoZSByYXcgcGF0dGVybiAoYXMgeW91J2QgcGFzcyBpdCB0b1xuICAgIGBuZXcgUmVnRXhwYCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgU2V0IHRvIGB0cnVlYCB3aGVuIHRoZSBjdXJzb3IgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoXG4gICAgICAgIHJhbmdlLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdpbGwgY29udGFpbiBhbiBvYmplY3Qgd2l0aCB0aGUgZXh0ZW50IG9mIHRoZSBtYXRjaCBhbmQgdGhlXG4gICAgICAgIG1hdGNoIG9iamVjdCB3aGVuIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlJlZ0V4cEN1cnNvci5uZXh0KVxuICAgICAgICBzdWNlc3NmdWxseSBmaW5kcyBhIG1hdGNoLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIGlmICgvXFxcXFtzV0Rucl18XFxufFxccnxcXFtcXF4vLnRlc3QocXVlcnkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aWxpbmVSZWdFeHBDdXJzb3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XG4gICAgICAgIHRoaXMudGVzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXN0O1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXIoKTtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHRleHQubGluZUF0KGZyb20pO1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHN0YXJ0TGluZS5mcm9tO1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLmdldExpbmUodGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgIH1cbiAgICBnZXRMaW5lKHNraXApIHtcbiAgICAgICAgdGhpcy5pdGVyLm5leHQoc2tpcCk7XG4gICAgICAgIGlmICh0aGlzLml0ZXIubGluZUJyZWFrKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA+IHRoaXMudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5jdXJMaW5lLnNsaWNlKDAsIHRoaXMudG8gLSB0aGlzLmN1ckxpbmVTdGFydCk7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCA+IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbWF0Y2gsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLnJlLmxhc3RJbmRleCA9IG9mZjtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2hQb3MgPD0gdGhpcy50byAmJiB0aGlzLnJlLmV4ZWModGhpcy5jdXJMaW5lKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5jdXJMaW5lU3RhcnQgKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGZyb20gPCB0byB8fCBmcm9tID4gdGhpcy52YWx1ZS50bykgJiYgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2ZmID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuY3VyTGluZVN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoIDwgdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGZsYXR0ZW5lZCA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLy8gUmV1c2FibGUgKHBhcnRpYWxseSkgZmxhdHRlbmVkIGRvY3VtZW50IHN0cmluZ3NcbmNsYXNzIEZsYXR0ZW5lZERvYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgc3RhdGljIGdldChkb2MsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSBmbGF0dGVuZWQuZ2V0KGRvYyk7XG4gICAgICAgIGlmICghY2FjaGVkIHx8IGNhY2hlZC5mcm9tID49IHRvIHx8IGNhY2hlZC50byA8PSBmcm9tKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKSk7XG4gICAgICAgICAgICBmbGF0dGVuZWQuc2V0KGRvYywgZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gZmxhdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLmZyb20gPT0gZnJvbSAmJiBjYWNoZWQudG8gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tOiBjYWNoZWRGcm9tIH0gPSBjYWNoZWQ7XG4gICAgICAgIGlmIChjYWNoZWRGcm9tID4gZnJvbSkge1xuICAgICAgICAgICAgdGV4dCA9IGRvYy5zbGljZVN0cmluZyhmcm9tLCBjYWNoZWRGcm9tKSArIHRleHQ7XG4gICAgICAgICAgICBjYWNoZWRGcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLnRvIDwgdG8pXG4gICAgICAgICAgICB0ZXh0ICs9IGRvYy5zbGljZVN0cmluZyhjYWNoZWQudG8sIHRvKTtcbiAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIG5ldyBGbGF0dGVuZWREb2MoY2FjaGVkRnJvbSwgdGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCB0ZXh0LnNsaWNlKGZyb20gLSBjYWNoZWRGcm9tLCB0byAtIGNhY2hlZEZyb20pKTtcbiAgICB9XG59XG5jbGFzcyBNdWx0aWxpbmVSZWdFeHBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGV4dCwgZnJvbSk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLnRlc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGVzdDtcbiAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0ZXh0LCBmcm9tLCB0aGlzLmNodW5rRW5kKGZyb20gKyA1MDAwIC8qIENodW5rLkJhc2UgKi8pKTtcbiAgICB9XG4gICAgY2h1bmtFbmQocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPj0gdGhpcy50byA/IHRoaXMudG8gOiB0aGlzLnRleHQubGluZUF0KHBvcykudG87XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBvZmYgPSB0aGlzLnJlLmxhc3RJbmRleCA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmZsYXQuZnJvbTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICAvLyBTa2lwIGVtcHR5IG1hdGNoZXMgZGlyZWN0bHkgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiAhbWF0Y2hbMF0gJiYgbWF0Y2guaW5kZXggPT0gb2ZmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmYgKyAxO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5mbGF0LmZyb20gKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbWF0Y2ggZ29lcyBhbG1vc3QgdG8gdGhlIGVuZCBvZiBhIG5vbmNvbXBsZXRlIGNodW5rLCB0cnlcbiAgICAgICAgICAgICAgICAvLyBhZ2Fpbiwgc2luY2UgaXQnbGwgbGlrZWx5IGJlIGFibGUgdG8gbWF0Y2ggbW9yZVxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5mbGF0LnRvID49IHRoaXMudG8gfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggPD0gdGhpcy5mbGF0LnRleHQubGVuZ3RoIC0gMTApICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy50ZXN0IHx8IHRoaXMudGVzdChmcm9tLCB0bywgbWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0aGlzLnRleHQsIHRvICsgKGZyb20gPT0gdG8gPyAxIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mbGF0LnRvID09IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR3JvdyB0aGUgZmxhdHRlbmVkIGRvY1xuICAgICAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0aGlzLnRleHQsIHRoaXMuZmxhdC5mcm9tLCB0aGlzLmNodW5rRW5kKHRoaXMuZmxhdC5mcm9tICsgdGhpcy5mbGF0LnRleHQubGVuZ3RoICogMikpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFJlZ0V4cEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IE11bHRpbGluZVJlZ0V4cEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG5mdW5jdGlvbiB2YWxpZFJlZ0V4cChzb3VyY2UpIHtcbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHNvdXJjZSwgYmFzZUZsYWdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9DaGFyRW5kKHRleHQsIHBvcykge1xuICAgIGlmIChwb3MgPj0gdGV4dC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgbGV0IGxpbmUgPSB0ZXh0LmxpbmVBdChwb3MpLCBuZXh0O1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRvICYmIChuZXh0ID0gbGluZS50ZXh0LmNoYXJDb2RlQXQocG9zIC0gbGluZS5mcm9tKSkgPj0gMHhEQzAwICYmIG5leHQgPCAweEUwMDApXG4gICAgICAgIHBvcysrO1xuICAgIHJldHVybiBwb3M7XG59XG5cbi8qKlxuQ29tbWFuZCB0aGF0IHNob3dzIGEgZGlhbG9nIGFza2luZyB0aGUgdXNlciBmb3IgYSBsaW5lIG51bWJlciwgYW5kXG53aGVuIGEgdmFsaWQgcG9zaXRpb24gaXMgcHJvdmlkZWQsIG1vdmVzIHRoZSBjdXJzb3IgdG8gdGhhdCBsaW5lLlxuXG5TdXBwb3J0cyBsaW5lIG51bWJlcnMsIHJlbGF0aXZlIGxpbmUgb2Zmc2V0cyBwcmVmaXhlZCB3aXRoIGArYCBvclxuYC1gLCBkb2N1bWVudCBwZXJjZW50YWdlcyBzdWZmaXhlZCB3aXRoIGAlYCwgYW5kIGFuIG9wdGlvbmFsXG5jb2x1bW4gcG9zaXRpb24gYnkgYWRkaW5nIGA6YCBhbmQgYSBzZWNvbmQgbnVtYmVyIGFmdGVyIHRoZSBsaW5lXG5udW1iZXIuXG4qL1xuY29uc3QgZ290b0xpbmUgPSB2aWV3ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldztcbiAgICBsZXQgbGluZSA9IFN0cmluZyhzdGF0ZS5kb2MubGluZUF0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkubnVtYmVyKTtcbiAgICBsZXQgeyBjbG9zZSwgcmVzdWx0IH0gPSBzaG93RGlhbG9nKHZpZXcsIHtcbiAgICAgICAgbGFiZWw6IHN0YXRlLnBocmFzZShcIkdvIHRvIGxpbmVcIiksXG4gICAgICAgIGlucHV0OiB7IHR5cGU6IFwidGV4dFwiLCBuYW1lOiBcImxpbmVcIiwgdmFsdWU6IGxpbmUgfSxcbiAgICAgICAgZm9jdXM6IHRydWUsXG4gICAgICAgIHN1Ym1pdExhYmVsOiBzdGF0ZS5waHJhc2UoXCJnb1wiKSxcbiAgICB9KTtcbiAgICByZXN1bHQudGhlbihmb3JtID0+IHtcbiAgICAgICAgbGV0IG1hdGNoID0gZm9ybSAmJiAvXihbKy1dKT8oXFxkKyk/KDpcXGQrKT8oJSk/JC8uZXhlYyhmb3JtLmVsZW1lbnRzW1wibGluZVwiXS52YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgbGV0IFssIHNpZ24sIGxuLCBjbCwgcGVyY2VudF0gPSBtYXRjaDtcbiAgICAgICAgbGV0IGNvbCA9IGNsID8gK2NsLnNsaWNlKDEpIDogMDtcbiAgICAgICAgbGV0IGxpbmUgPSBsbiA/ICtsbiA6IHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIGlmIChsbiAmJiBwZXJjZW50KSB7XG4gICAgICAgICAgICBsZXQgcGMgPSBsaW5lIC8gMTAwO1xuICAgICAgICAgICAgaWYgKHNpZ24pXG4gICAgICAgICAgICAgICAgcGMgPSBwYyAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIChzdGFydExpbmUubnVtYmVyIC8gc3RhdGUuZG9jLmxpbmVzKTtcbiAgICAgICAgICAgIGxpbmUgPSBNYXRoLnJvdW5kKHN0YXRlLmRvYy5saW5lcyAqIHBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsbiAmJiBzaWduKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZSAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvY0xpbmUgPSBzdGF0ZS5kb2MubGluZShNYXRoLm1heCgxLCBNYXRoLm1pbihzdGF0ZS5kb2MubGluZXMsIGxpbmUpKSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGRvY0xpbmUuZnJvbSArIE1hdGgubWF4KDAsIE1hdGgubWluKGNvbCwgZG9jTGluZS5sZW5ndGgpKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgZWZmZWN0czogW2Nsb3NlLCBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5mcm9tLCB7IHk6ICdjZW50ZXInIH0pXSxcbiAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucyA9IHtcbiAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiBmYWxzZSxcbiAgICBtaW5TZWxlY3Rpb25MZW5ndGg6IDEsXG4gICAgbWF4TWF0Y2hlczogMTAwLFxuICAgIHdob2xlV29yZHM6IGZhbHNlXG59O1xuY29uc3QgaGlnaGxpZ2h0Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKG9wdGlvbnMsIGRlZmF1bHRIaWdobGlnaHRPcHRpb25zLCB7XG4gICAgICAgICAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiLFxuICAgICAgICAgICAgbWluU2VsZWN0aW9uTGVuZ3RoOiBNYXRoLm1pbixcbiAgICAgICAgICAgIG1heE1hdGNoZXM6IE1hdGgubWluXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5UaGlzIGV4dGVuc2lvbiBoaWdobGlnaHRzIHRleHQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rpb24uIEl0IHVzZXNcbnRoZSBgXCJjbS1zZWxlY3Rpb25NYXRjaFwiYCBjbGFzcyBmb3IgdGhlIGhpZ2hsaWdodGluZy4gV2hlblxuYGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3JgIGlzIGVuYWJsZWQsIHRoZSB3b3JkIGF0IHRoZSBjdXJzb3Jcbml0c2VsZiB3aWxsIGJlIGhpZ2hsaWdodGVkIHdpdGggYFwiY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiYC5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKG9wdGlvbnMpIHtcbiAgICBsZXQgZXh0ID0gW2RlZmF1bHRUaGVtZSwgbWF0Y2hIaWdobGlnaHRlcl07XG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodENvbmZpZy5vZihvcHRpb25zKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbmNvbnN0IG1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaFwiIH0pO1xuY29uc3QgbWFpbk1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaCBjbS1zZWxlY3Rpb25NYXRjaC1tYWluXCIgfSk7XG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IG91dHNpZGUgdGhlIGdpdmVuIHBvc2l0aW9ucyBhcmUgbm9uLXdvcmQgY2hhcmFjdGVyc1xuZnVuY3Rpb24gaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20gLSAxLCBmcm9tKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICh0byA9PSBzdGF0ZS5kb2MubGVuZ3RoIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIDEpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG59XG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IGF0IHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIHdvcmQgY2hhcmFjdGVyc1xuZnVuY3Rpb24gaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmRcbiAgICAgICAgJiYgY2hlY2soc3RhdGUuc2xpY2VEb2ModG8gLSAxLCB0bykpID09IENoYXJDYXRlZ29yeS5Xb3JkO1xufVxuY29uc3QgbWF0Y2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChoaWdobGlnaHRDb25maWcpO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IHJhbmdlID0gc2VsLm1haW4sIHF1ZXJ5LCBjaGVjayA9IG51bGw7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgaWYgKCFjb25mLmhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgaWYgKCF3b3JkKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBjaGVjayA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2Mod29yZC5mcm9tLCB3b3JkLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSByYW5nZS50byAtIHJhbmdlLmZyb207XG4gICAgICAgICAgICBpZiAobGVuIDwgY29uZi5taW5TZWxlY3Rpb25MZW5ndGggfHwgbGVuID4gMjAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBpZiAoY29uZi53aG9sZVdvcmRzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50byk7IC8vIFRPRE86IGFsbG93IGFuZCBpbmNsdWRlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2U/XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICAgICAgaWYgKCEoaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bykgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIHJhbmdlLmZyb20sIHJhbmdlLnRvKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkZWNvID0gW107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCBwYXJ0LmZyb20sIHBhcnQudG8pO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2sgfHwgaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ICYmIGZyb20gPD0gcmFuZ2UuZnJvbSAmJiB0byA+PSByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY28ucHVzaChtYWluTWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyb20gPj0gcmFuZ2UudG8gfHwgdG8gPD0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY28ucHVzaChtYXRjaERlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY28ubGVuZ3RoID4gY29uZi5tYXhNYXRjaGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcbmNvbnN0IGRlZmF1bHRUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZmY3NzgwXCIgfSxcbiAgICBcIi5jbS1zZWFyY2hNYXRjaCAuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIiB9XG59KTtcbi8vIFNlbGVjdCB0aGUgd29yZHMgYXJvdW5kIHRoZSBjdXJzb3JzLlxuY29uc3Qgc2VsZWN0V29yZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBsZXQgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWxlY3Rpb24ucmFuZ2VzLm1hcChyYW5nZSA9PiBzdGF0ZS53b3JkQXQocmFuZ2UuaGVhZCkgfHwgRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkKSksIHNlbGVjdGlvbi5tYWluSW5kZXgpO1xuICAgIGlmIChuZXdTZWwuZXEoc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogbmV3U2VsIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBGaW5kIG5leHQgb2NjdXJyZW5jZSBvZiBxdWVyeSByZWxhdGl2ZSB0byBsYXN0IGN1cnNvci4gV3JhcCBhcm91bmRcbi8vIHRoZSBkb2N1bWVudCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBtYXRjaGVzLlxuZnVuY3Rpb24gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBxdWVyeSkge1xuICAgIGxldCB7IG1haW4sIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KG1haW4uaGVhZCksIGZ1bGxXb3JkID0gd29yZCAmJiB3b3JkLmZyb20gPT0gbWFpbi5mcm9tICYmIHdvcmQudG8gPT0gbWFpbi50bztcbiAgICBmb3IgKGxldCBjeWNsZWQgPSBmYWxzZSwgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvKTs7KSB7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGN5Y2xlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgMCwgTWF0aC5tYXgoMCwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS5mcm9tIC0gMSkpO1xuICAgICAgICAgICAgY3ljbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQgJiYgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gY3Vyc29yLnZhbHVlLmZyb20pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGZ1bGxXb3JkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQoY3Vyc29yLnZhbHVlLmZyb20pO1xuICAgICAgICAgICAgICAgIGlmICghd29yZCB8fCB3b3JkLmZyb20gIT0gY3Vyc29yLnZhbHVlLmZyb20gfHwgd29yZC50byAhPSBjdXJzb3IudmFsdWUudG8pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuU2VsZWN0IG5leHQgb2NjdXJyZW5jZSBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uIEV4cGFuZCBzZWxlY3Rpb25cbnRvIHRoZSBzdXJyb3VuZGluZyB3b3JkIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eS5cbiovXG5jb25zdCBzZWxlY3ROZXh0T2NjdXJyZW5jZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHsgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHJhbmdlcy5zb21lKHNlbCA9PiBzZWwuZnJvbSA9PT0gc2VsLnRvKSlcbiAgICAgICAgcmV0dXJuIHNlbGVjdFdvcmQoeyBzdGF0ZSwgZGlzcGF0Y2ggfSk7XG4gICAgbGV0IHNlYXJjaGVkVGV4dCA9IHN0YXRlLnNsaWNlRG9jKHJhbmdlc1swXS5mcm9tLCByYW5nZXNbMF0udG8pO1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiBzdGF0ZS5zbGljZURvYyhyLmZyb20sIHIudG8pICE9IHNlYXJjaGVkVGV4dCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcmFuZ2UgPSBmaW5kTmV4dE9jY3VycmVuY2Uoc3RhdGUsIHNlYXJjaGVkVGV4dCk7XG4gICAgaWYgKCFyYW5nZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogc3RhdGUuc2VsZWN0aW9uLmFkZFJhbmdlKEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5mcm9tLCByYW5nZS50byksIGZhbHNlKSxcbiAgICAgICAgZWZmZWN0czogRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhyYW5nZS50bylcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZWFyY2hDb25maWdGYWNldCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICB0b3A6IGZhbHNlLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgICAgICAgIHJlZ2V4cDogZmFsc2UsXG4gICAgICAgICAgICB3aG9sZVdvcmQ6IGZhbHNlLFxuICAgICAgICAgICAgY3JlYXRlUGFuZWw6IHZpZXcgPT4gbmV3IFNlYXJjaFBhbmVsKHZpZXcpLFxuICAgICAgICAgICAgc2Nyb2xsVG9NYXRjaDogcmFuZ2UgPT4gRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhyYW5nZSlcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcbkFkZCBzZWFyY2ggc3RhdGUgdG8gdGhlIGVkaXRvciBjb25maWd1cmF0aW9uLCBhbmQgb3B0aW9uYWxseVxuY29uZmlndXJlIHRoZSBzZWFyY2ggZXh0ZW5zaW9uLlxuKFtgb3BlblNlYXJjaFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2gub3BlblNlYXJjaFBhbmVsKSB3aWxsIGF1dG9tYXRpY2FsbHlcbmVuYWJsZSB0aGlzIGlmIGl0IGlzbid0IGFscmVhZHkgb24pLlxuKi9cbmZ1bmN0aW9uIHNlYXJjaChjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3NlYXJjaENvbmZpZ0ZhY2V0Lm9mKGNvbmZpZyksIHNlYXJjaEV4dGVuc2lvbnNdIDogc2VhcmNoRXh0ZW5zaW9ucztcbn1cbi8qKlxuQSBzZWFyY2ggcXVlcnkuIFBhcnQgb2YgdGhlIGVkaXRvcidzIHNlYXJjaCBzdGF0ZS5cbiovXG5jbGFzcyBTZWFyY2hRdWVyeSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcXVlcnkgb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gY29uZmlnLnNlYXJjaDtcbiAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID0gISFjb25maWcuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5saXRlcmFsID0gISFjb25maWcubGl0ZXJhbDtcbiAgICAgICAgdGhpcy5yZWdleHAgPSAhIWNvbmZpZy5yZWdleHA7XG4gICAgICAgIHRoaXMucmVwbGFjZSA9IGNvbmZpZy5yZXBsYWNlIHx8IFwiXCI7XG4gICAgICAgIHRoaXMudmFsaWQgPSAhIXRoaXMuc2VhcmNoICYmICghdGhpcy5yZWdleHAgfHwgdmFsaWRSZWdFeHAodGhpcy5zZWFyY2gpKTtcbiAgICAgICAgdGhpcy51bnF1b3RlZCA9IHRoaXMudW5xdW90ZSh0aGlzLnNlYXJjaCk7XG4gICAgICAgIHRoaXMud2hvbGVXb3JkID0gISFjb25maWcud2hvbGVXb3JkO1xuICAgICAgICB0aGlzLnRlc3QgPSBjb25maWcudGVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1bnF1b3RlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbCA/IHRleHQgOlxuICAgICAgICAgICAgdGV4dC5yZXBsYWNlKC9cXFxcKFtucnRcXFxcXSkvZywgKF8sIGNoKSA9PiBjaCA9PSBcIm5cIiA/IFwiXFxuXCIgOiBjaCA9PSBcInJcIiA/IFwiXFxyXCIgOiBjaCA9PSBcInRcIiA/IFwiXFx0XCIgOiBcIlxcXFxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBxdWVyeSB0byBhbm90aGVyIHF1ZXJ5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoID09IG90aGVyLnNlYXJjaCAmJiB0aGlzLnJlcGxhY2UgPT0gb3RoZXIucmVwbGFjZSAmJlxuICAgICAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID09IG90aGVyLmNhc2VTZW5zaXRpdmUgJiYgdGhpcy5yZWdleHAgPT0gb3RoZXIucmVnZXhwICYmXG4gICAgICAgICAgICB0aGlzLndob2xlV29yZCA9PSBvdGhlci53aG9sZVdvcmQgJiYgdGhpcy50ZXN0ID09IG90aGVyLnRlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyBuZXcgUmVnRXhwUXVlcnkodGhpcykgOiBuZXcgU3RyaW5nUXVlcnkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIHNlYXJjaCBjdXJzb3IgZm9yIHRoaXMgcXVlcnksIHNlYXJjaGluZyB0aHJvdWdoIHRoZSBnaXZlblxuICAgIHJhbmdlIGluIHRoZSBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldEN1cnNvcihzdGF0ZSwgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGxldCBzdCA9IHN0YXRlLmRvYyA/IHN0YXRlIDogRWRpdG9yU3RhdGUuY3JlYXRlKHsgZG9jOiBzdGF0ZSB9KTtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHN0LmRvYy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IHJlZ2V4cEN1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pIDogc3RyaW5nQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcFN0cmluZ1Rlc3QodGVzdCwgc3RhdGUsIGlubmVyKSB7XG4gICAgcmV0dXJuIChmcm9tLCB0bywgYnVmZmVyLCBidWZmZXJQb3MpID0+IHtcbiAgICAgICAgaWYgKGlubmVyICYmICFpbm5lcihmcm9tLCB0bywgYnVmZmVyLCBidWZmZXJQb3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbWF0Y2ggPSBmcm9tID49IGJ1ZmZlclBvcyAmJiB0byA8PSBidWZmZXJQb3MgKyBidWZmZXIubGVuZ3RoXG4gICAgICAgICAgICA/IGJ1ZmZlci5zbGljZShmcm9tIC0gYnVmZmVyUG9zLCB0byAtIGJ1ZmZlclBvcylcbiAgICAgICAgICAgIDogc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRlc3QobWF0Y2gsIHN0YXRlLCBmcm9tLCB0byk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0cmluZ0N1cnNvcihzcGVjLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdGVzdDtcbiAgICBpZiAoc3BlYy53aG9sZVdvcmQpXG4gICAgICAgIHRlc3QgPSBzdHJpbmdXb3JkVGVzdChzdGF0ZS5kb2MsIHN0YXRlLmNoYXJDYXRlZ29yaXplcihzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSk7XG4gICAgaWYgKHNwZWMudGVzdClcbiAgICAgICAgdGVzdCA9IHdyYXBTdHJpbmdUZXN0KHNwZWMudGVzdCwgc3RhdGUsIHRlc3QpO1xuICAgIHJldHVybiBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy51bnF1b3RlZCwgZnJvbSwgdG8sIHNwZWMuY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IHggPT4geC50b0xvd2VyQ2FzZSgpLCB0ZXN0KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1dvcmRUZXN0KGRvYywgY2F0ZWdvcml6ZXIpIHtcbiAgICByZXR1cm4gKGZyb20sIHRvLCBidWYsIGJ1ZlBvcykgPT4ge1xuICAgICAgICBpZiAoYnVmUG9zID4gZnJvbSB8fCBidWZQb3MgKyBidWYubGVuZ3RoIDwgdG8pIHtcbiAgICAgICAgICAgIGJ1ZlBvcyA9IE1hdGgubWF4KDAsIGZyb20gLSAyKTtcbiAgICAgICAgICAgIGJ1ZiA9IGRvYy5zbGljZVN0cmluZyhidWZQb3MsIE1hdGgubWluKGRvYy5sZW5ndGgsIHRvICsgMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIGZyb20gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKGJ1ZiwgZnJvbSAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJBZnRlcihidWYsIHRvIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQmVmb3JlKGJ1ZiwgdG8gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG4gICAgfTtcbn1cbmNsYXNzIFN0cmluZ1F1ZXJ5IGV4dGVuZHMgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKHNwZWMpO1xuICAgIH1cbiAgICBuZXh0TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpLm5leHRPdmVybGFwcGluZygpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBjdXJGcm9tICsgdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCk7XG4gICAgICAgICAgICBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgZW5kKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgfHwgY3Vyc29yLnZhbHVlLmZyb20gPT0gY3VyRnJvbSAmJiBjdXJzb3IudmFsdWUudG8gPT0gY3VyVG8gPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICAvLyBTZWFyY2hpbmcgaW4gcmV2ZXJzZSBpcywgcmF0aGVyIHRoYW4gaW1wbGVtZW50aW5nIGFuIGludmVydGVkIHNlYXJjaFxuICAgIC8vIGN1cnNvciwgZG9uZSBieSBzY2FubmluZyBjaHVuayBhZnRlciBjaHVuayBmb3J3YXJkLlxuICAgIHByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRvOzspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGZyb20sIHBvcyAtIDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLyAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBzdGFydCwgcG9zKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dE92ZXJsYXBwaW5nKCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHBvcyAtPSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIDAsIGN1ckZyb20pO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgZm91bmQgPSB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIE1hdGgubWF4KDAsIGN1clRvIC0gdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCksIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZm91bmQgJiYgKGZvdW5kLmZyb20gIT0gY3VyRnJvbSB8fCBmb3VuZC50byAhPSBjdXJUbykgPyBmb3VuZCA6IG51bGw7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KF9yZXN1bHQpIHsgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlKTsgfVxuICAgIG1hdGNoQWxsKHN0YXRlLCBsaW1pdCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIHN0YXRlLmRvYy5sZW5ndGgpLCByYW5nZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBoaWdobGlnaHQoc3RhdGUsIGZyb20sIHRvLCBhZGQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBNYXRoLm1heCgwLCBmcm9tIC0gdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCksIE1hdGgubWluKHRvICsgdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCwgc3RhdGUuZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwUmVnZXhwVGVzdCh0ZXN0LCBzdGF0ZSwgaW5uZXIpIHtcbiAgICByZXR1cm4gKGZyb20sIHRvLCBtYXRjaCkgPT4ge1xuICAgICAgICByZXR1cm4gKCFpbm5lciB8fCBpbm5lcihmcm9tLCB0bywgbWF0Y2gpKSAmJiB0ZXN0KG1hdGNoWzBdLCBzdGF0ZSwgZnJvbSwgdG8pO1xuICAgIH07XG59XG5mdW5jdGlvbiByZWdleHBDdXJzb3Ioc3BlYywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHRlc3Q7XG4gICAgaWYgKHNwZWMud2hvbGVXb3JkKVxuICAgICAgICB0ZXN0ID0gcmVnZXhwV29yZFRlc3Qoc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKTtcbiAgICBpZiAoc3BlYy50ZXN0KVxuICAgICAgICB0ZXN0ID0gd3JhcFJlZ2V4cFRlc3Qoc3BlYy50ZXN0LCBzdGF0ZSwgdGVzdCk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHBDdXJzb3Ioc3RhdGUuZG9jLCBzcGVjLnNlYXJjaCwgeyBpZ25vcmVDYXNlOiAhc3BlYy5jYXNlU2Vuc2l0aXZlLCB0ZXN0IH0sIGZyb20sIHRvKTtcbn1cbmZ1bmN0aW9uIGNoYXJCZWZvcmUoc3RyLCBpbmRleCkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoZmluZENsdXN0ZXJCcmVhayhzdHIsIGluZGV4LCBmYWxzZSksIGluZGV4KTtcbn1cbmZ1bmN0aW9uIGNoYXJBZnRlcihzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZShpbmRleCwgZmluZENsdXN0ZXJCcmVhayhzdHIsIGluZGV4KSk7XG59XG5mdW5jdGlvbiByZWdleHBXb3JkVGVzdChjYXRlZ29yaXplcikge1xuICAgIHJldHVybiAoX2Zyb20sIF90bywgbWF0Y2gpID0+ICFtYXRjaFswXS5sZW5ndGggfHxcbiAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJBZnRlcihtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQmVmb3JlKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKTtcbn1cbmNsYXNzIFJlZ0V4cFF1ZXJ5IGV4dGVuZHMgUXVlcnlUeXBlIHtcbiAgICBuZXh0TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpLm5leHQoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxuICAgICAgICAgICAgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIGN1ckZyb20pLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcbiAgICB9XG4gICAgcHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgc2l6ZSA9IDE7OyBzaXplKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGZyb20sIHRvIC0gc2l6ZSAqIDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLyk7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIHN0YXJ0LCB0byksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlICYmIChzdGFydCA9PSBmcm9tIHx8IHJhbmdlLmZyb20gPiBzdGFydCArIDEwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIDAsIGN1ckZyb20pIHx8XG4gICAgICAgICAgICB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0UmVwbGFjZW1lbnQocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZSkucmVwbGFjZSgvXFwkKFskJl18XFxkKykvZywgKG0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpID09IFwiJlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQubWF0Y2hbMF07XG4gICAgICAgICAgICBpZiAoaSA9PSBcIiRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgICBmb3IgKGxldCBsID0gaS5sZW5ndGg7IGwgPiAwOyBsLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgbiA9ICtpLnNsaWNlKDAsIGwpO1xuICAgICAgICAgICAgICAgIGlmIChuID4gMCAmJiBuIDwgcmVzdWx0Lm1hdGNoLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXRjaFtuXSArIGkuc2xpY2UobCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1hdGNoQWxsKHN0YXRlLCBsaW1pdCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIHN0YXRlLmRvYy5sZW5ndGgpLCByYW5nZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBoaWdobGlnaHQoc3RhdGUsIGZyb20sIHRvLCBhZGQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBNYXRoLm1heCgwLCBmcm9tIC0gMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pLCBNYXRoLm1pbih0byArIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovLCBzdGF0ZS5kb2MubGVuZ3RoKSk7XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgYWRkKGN1cnNvci52YWx1ZS5mcm9tLCBjdXJzb3IudmFsdWUudG8pO1xuICAgIH1cbn1cbi8qKlxuQSBzdGF0ZSBlZmZlY3QgdGhhdCB1cGRhdGVzIHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeS4gTm90ZSB0aGF0XG50aGlzIG9ubHkgaGFzIGFuIGVmZmVjdCBpZiB0aGUgc2VhcmNoIHN0YXRlIGhhcyBiZWVuIGluaXRpYWxpemVkXG4oYnkgaW5jbHVkaW5nIFtgc2VhcmNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guc2VhcmNoKSBpbiB5b3VyIGNvbmZpZ3VyYXRpb24gb3JcbmJ5IHJ1bm5pbmcgW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpIGF0IGxlYXN0XG5vbmNlKS5cbiovXG5jb25zdCBzZXRTZWFyY2hRdWVyeSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHRvZ2dsZVBhbmVsID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3Qgc2VhcmNoU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlYXJjaFN0YXRlKGRlZmF1bHRRdWVyeShzdGF0ZSkuY3JlYXRlKCksIG51bGwpO1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWFyY2hRdWVyeSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUoZWZmZWN0LnZhbHVlLmNyZWF0ZSgpLCB2YWx1ZS5wYW5lbCk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXModG9nZ2xlUGFuZWwpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFNlYXJjaFN0YXRlKHZhbHVlLnF1ZXJ5LCBlZmZlY3QudmFsdWUgPyBjcmVhdGVTZWFyY2hQYW5lbCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbC5wYW5lbClcbn0pO1xuLyoqXG5HZXQgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5IGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGdldFNlYXJjaFF1ZXJ5KHN0YXRlKSB7XG4gICAgbGV0IGN1clN0YXRlID0gc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gY3VyU3RhdGUgPyBjdXJTdGF0ZS5xdWVyeS5zcGVjIDogZGVmYXVsdFF1ZXJ5KHN0YXRlKTtcbn1cbi8qKlxuUXVlcnkgd2hldGhlciB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gaW4gdGhlIGdpdmVuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiBzZWFyY2hQYW5lbE9wZW4oc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFuZWwpICE9IG51bGw7XG59XG5jbGFzcyBTZWFyY2hTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IocXVlcnksIHBhbmVsKSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5wYW5lbCA9IHBhbmVsO1xuICAgIH1cbn1cbmNvbnN0IG1hdGNoTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWFyY2hNYXRjaFwiIH0pLCBzZWxlY3RlZE1hdGNoTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWFyY2hNYXRjaCBjbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiIH0pO1xuY29uc3Qgc2VhcmNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodChzdGF0ZSk7XG4gICAgfVxuICAgIGhpZ2hsaWdodCh7IHF1ZXJ5LCBwYW5lbCB9KSB7XG4gICAgICAgIGlmICghcGFuZWwgfHwgIXF1ZXJ5LnNwZWMudmFsaWQpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHJhbmdlcyA9IHZpZXcudmlzaWJsZVJhbmdlcywgbCA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGwgLSAxICYmIHRvID4gcmFuZ2VzW2kgKyAxXS5mcm9tIC0gMiAqIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovKVxuICAgICAgICAgICAgICAgIHRvID0gcmFuZ2VzWysraV0udG87XG4gICAgICAgICAgICBxdWVyeS5oaWdobGlnaHQodmlldy5zdGF0ZSwgZnJvbSwgdG8sIChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gci5mcm9tID09IGZyb20gJiYgci50byA9PSB0byk7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIHNlbGVjdGVkID8gc2VsZWN0ZWRNYXRjaE1hcmsgOiBtYXRjaE1hcmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuZnVuY3Rpb24gc2VhcmNoQ29tbWFuZChmKSB7XG4gICAgcmV0dXJuIHZpZXcgPT4ge1xuICAgICAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZSAmJiBzdGF0ZS5xdWVyeS5zcGVjLnZhbGlkID8gZih2aWV3LCBzdGF0ZSkgOiBvcGVuU2VhcmNoUGFuZWwodmlldyk7XG4gICAgfTtcbn1cbi8qKlxuT3BlbiB0aGUgc2VhcmNoIHBhbmVsIGlmIGl0IGlzbid0IGFscmVhZHkgb3BlbiwgYW5kIG1vdmUgdGhlXG5zZWxlY3Rpb24gdG8gdGhlIGZpcnN0IG1hdGNoIGFmdGVyIHRoZSBjdXJyZW50IG1haW4gc2VsZWN0aW9uLlxuV2lsbCB3cmFwIGFyb3VuZCB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50IHdoZW4gaXQgcmVhY2hlcyB0aGVcbmVuZC5cbiovXG5jb25zdCBmaW5kTmV4dCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyB0byB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaCh2aWV3LnN0YXRlLCB0bywgdG8pO1xuICAgIGlmICghbmV4dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5leHQuZnJvbSwgbmV4dC50byk7XG4gICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIGVmZmVjdHM6IFthbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpLCBjb25maWcuc2Nyb2xsVG9NYXRjaChzZWxlY3Rpb24ubWFpbiwgdmlldyldLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaFwiXG4gICAgfSk7XG4gICAgc2VsZWN0U2VhcmNoSW5wdXQodmlldyk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBwcmV2aW91cyBpbnN0YW5jZSBvZiB0aGUgc2VhcmNoIHF1ZXJ5LFxuYmVmb3JlIHRoZSBjdXJyZW50IG1haW4gc2VsZWN0aW9uLiBXaWxsIHdyYXAgcGFzdCB0aGUgc3RhcnRcbm9mIHRoZSBkb2N1bWVudCB0byBzdGFydCBzZWFyY2hpbmcgYXQgdGhlIGVuZCBhZ2Fpbi5cbiovXG5jb25zdCBmaW5kUHJldmlvdXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHByZXYgPSBxdWVyeS5wcmV2TWF0Y2goc3RhdGUsIGZyb20sIGZyb20pO1xuICAgIGlmICghcHJldilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKHByZXYuZnJvbSwgcHJldi50byk7XG4gICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIGVmZmVjdHM6IFthbm5vdW5jZU1hdGNoKHZpZXcsIHByZXYpLCBjb25maWcuc2Nyb2xsVG9NYXRjaChzZWxlY3Rpb24ubWFpbiwgdmlldyldLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaFwiXG4gICAgfSk7XG4gICAgc2VsZWN0U2VhcmNoSW5wdXQodmlldyk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeS5cbiovXG5jb25zdCBzZWxlY3RNYXRjaGVzID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCByYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3LnN0YXRlLCAxMDAwKTtcbiAgICBpZiAoIXJhbmdlcyB8fCAhcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLm1hcChyID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmZyb20sIHIudG8pKSksXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoLm1hdGNoZXNcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dC5cbiovXG5jb25zdCBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwucmFuZ2VzLmxlbmd0aCA+IDEgfHwgc2VsLm1haW4uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBmcm9tLCB0byB9ID0gc2VsLm1haW47XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBtYWluID0gMDtcbiAgICBmb3IgKGxldCBjdXIgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKTsgIWN1ci5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY3VyLnZhbHVlLmZyb20gPT0gZnJvbSlcbiAgICAgICAgICAgIG1haW4gPSByYW5nZXMubGVuZ3RoO1xuICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY3VyLnZhbHVlLmZyb20sIGN1ci52YWx1ZS50bykpO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBtYWluKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgY3VycmVudCBtYXRjaCBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxuKi9cbmNvbnN0IHJlcGxhY2VOZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbWF0Y2ggPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUsIGZyb20sIGZyb20pO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbmV4dCA9IG1hdGNoO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHNlbGVjdGlvbiwgcmVwbGFjZW1lbnQ7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBpZiAobmV4dC5mcm9tID09IGZyb20gJiYgbmV4dC50byA9PSB0bykge1xuICAgICAgICByZXBsYWNlbWVudCA9IHN0YXRlLnRvVGV4dChxdWVyeS5nZXRSZXBsYWNlbWVudChuZXh0KSk7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG5leHQuZnJvbSwgdG86IG5leHQudG8sIGluc2VydDogcmVwbGFjZW1lbnQgfSk7XG4gICAgICAgIG5leHQgPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUsIG5leHQuZnJvbSwgbmV4dC50byk7XG4gICAgICAgIGVmZmVjdHMucHVzaChFZGl0b3JWaWV3LmFubm91bmNlLm9mKHN0YXRlLnBocmFzZShcInJlcGxhY2VkIG1hdGNoIG9uIGxpbmUgJFwiLCBzdGF0ZS5kb2MubGluZUF0KGZyb20pLm51bWJlcikgKyBcIi5cIikpO1xuICAgIH1cbiAgICBsZXQgY2hhbmdlU2V0ID0gdmlldy5zdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgIGlmIChuZXh0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV4dC5mcm9tLCBuZXh0LnRvKS5tYXAoY2hhbmdlU2V0KTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKGFubm91bmNlTWF0Y2godmlldywgbmV4dCkpO1xuICAgICAgICBlZmZlY3RzLnB1c2goc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpLnNjcm9sbFRvTWF0Y2goc2VsZWN0aW9uLm1haW4sIHZpZXcpKTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXM6IGNoYW5nZVNldCxcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucmVwbGFjZVwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuUmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzZWFyY2ggcXVlcnkgd2l0aCB0aGUgZ2l2ZW5cbnJlcGxhY2VtZW50LlxuKi9cbmNvbnN0IHJlcGxhY2VBbGwgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHF1ZXJ5Lm1hdGNoQWxsKHZpZXcuc3RhdGUsIDFlOSkubWFwKG1hdGNoID0+IHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IG1hdGNoO1xuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgaW5zZXJ0OiBxdWVyeS5nZXRSZXBsYWNlbWVudChtYXRjaCkgfTtcbiAgICB9KTtcbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFubm91bmNlVGV4dCA9IHZpZXcuc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgJCBtYXRjaGVzXCIsIGNoYW5nZXMubGVuZ3RoKSArIFwiLlwiO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBlZmZlY3RzOiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGFubm91bmNlVGV4dCksXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlLmFsbFwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhbmVsKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkuY3JlYXRlUGFuZWwodmlldyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0UXVlcnkoc3RhdGUsIGZhbGxiYWNrKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHNlbFRleHQgPSBzZWwuZW1wdHkgfHwgc2VsLnRvID4gc2VsLmZyb20gKyAxMDAgPyBcIlwiIDogc3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIHNlbC50byk7XG4gICAgaWYgKGZhbGxiYWNrICYmICFzZWxUZXh0KVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgbGV0IGNvbmZpZyA9IHN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICByZXR1cm4gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgc2VhcmNoOiAoKF9hID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbmZpZy5saXRlcmFsKSA/IHNlbFRleHQgOiBzZWxUZXh0LnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlOiAoX2IgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2suY2FzZVNlbnNpdGl2ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uZmlnLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgIGxpdGVyYWw6IChfYyA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb25maWcubGl0ZXJhbCxcbiAgICAgICAgcmVnZXhwOiAoX2QgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2sucmVnZXhwKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBjb25maWcucmVnZXhwLFxuICAgICAgICB3aG9sZVdvcmQ6IChfZSA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay53aG9sZVdvcmQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGNvbmZpZy53aG9sZVdvcmRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNlYXJjaElucHV0KHZpZXcpIHtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgcmV0dXJuIHBhbmVsICYmIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiW21haW4tZmllbGRdXCIpO1xufVxuZnVuY3Rpb24gc2VsZWN0U2VhcmNoSW5wdXQodmlldykge1xuICAgIGxldCBpbnB1dCA9IGdldFNlYXJjaElucHV0KHZpZXcpO1xuICAgIGlmIChpbnB1dCAmJiBpbnB1dCA9PSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudClcbiAgICAgICAgaW5wdXQuc2VsZWN0KCk7XG59XG4vKipcbk1ha2Ugc3VyZSB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gYW5kIGZvY3VzZWQuXG4qL1xuY29uc3Qgb3BlblNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5wYW5lbCkge1xuICAgICAgICBsZXQgc2VhcmNoSW5wdXQgPSBnZXRTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICAgICAgaWYgKHNlYXJjaElucHV0ICYmIHNlYXJjaElucHV0ICE9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSBkZWZhdWx0UXVlcnkodmlldy5zdGF0ZSwgc3RhdGUucXVlcnkuc3BlYyk7XG4gICAgICAgICAgICBpZiAocXVlcnkudmFsaWQpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlYXJjaFF1ZXJ5Lm9mKHF1ZXJ5KSB9KTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBzZWFyY2hJbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB0b2dnbGVQYW5lbC5vZih0cnVlKSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA/IHNldFNlYXJjaFF1ZXJ5Lm9mKGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKSkgOiBTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2Yoc2VhcmNoRXh0ZW5zaW9ucylcbiAgICAgICAgICAgIF0gfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ2xvc2UgdGhlIHNlYXJjaCBwYW5lbC5cbiovXG5jb25zdCBjbG9zZVNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLnBhbmVsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xuICAgIGlmIChwYW5lbCAmJiBwYW5lbC5kb20uY29udGFpbnModmlldy5yb290LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRvZ2dsZVBhbmVsLm9mKGZhbHNlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkRlZmF1bHQgc2VhcmNoLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBNb2QtZjogW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpXG4gLSBGMywgTW9kLWc6IFtgZmluZE5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5maW5kTmV4dClcbiAtIFNoaWZ0LUYzLCBTaGlmdC1Nb2QtZzogW2BmaW5kUHJldmlvdXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5maW5kUHJldmlvdXMpXG4gLSBNb2QtQWx0LWc6IFtgZ290b0xpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5nb3RvTGluZSlcbiAtIE1vZC1kOiBbYHNlbGVjdE5leHRPY2N1cnJlbmNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guc2VsZWN0TmV4dE9jY3VycmVuY2UpXG4qL1xuY29uc3Qgc2VhcmNoS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIk1vZC1mXCIsIHJ1bjogb3BlblNlYXJjaFBhbmVsLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIgfSxcbiAgICB7IGtleTogXCJGM1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLWdcIiwgcnVuOiBmaW5kTmV4dCwgc2hpZnQ6IGZpbmRQcmV2aW91cywgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsb3NlU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIk1vZC1TaGlmdC1sXCIsIHJ1bjogc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyB9LFxuICAgIHsga2V5OiBcIk1vZC1BbHQtZ1wiLCBydW46IGdvdG9MaW5lIH0sXG4gICAgeyBrZXk6IFwiTW9kLWRcIiwgcnVuOiBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbl07XG5jbGFzcyBTZWFyY2hQYW5lbCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnF1ZXJ5ID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkucXVlcnkuc3BlYztcbiAgICAgICAgdGhpcy5jb21taXQgPSB0aGlzLmNvbW1pdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHF1ZXJ5LnNlYXJjaCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIkZpbmRcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwic2VhcmNoXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgXCJtYWluLWZpZWxkXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVwbGFjZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHF1ZXJ5LnJlcGxhY2UsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcGhyYXNlKHZpZXcsIFwiUmVwbGFjZVwiKSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXG4gICAgICAgICAgICBuYW1lOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXQsXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYXNlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcImNhc2VcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcInJlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkucmVnZXhwLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndvcmRGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwid29yZFwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5Lndob2xlV29yZCxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gYnV0dG9uKG5hbWUsIG9uY2xpY2ssIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbHQoXCJidXR0b25cIiwgeyBjbGFzczogXCJjbS1idXR0b25cIiwgbmFtZSwgb25jbGljaywgdHlwZTogXCJidXR0b25cIiB9LCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbSA9IGVsdChcImRpdlwiLCB7IG9ua2V5ZG93bjogKGUpID0+IHRoaXMua2V5ZG93bihlKSwgY2xhc3M6IFwiY20tc2VhcmNoXCIgfSwgW1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hGaWVsZCxcbiAgICAgICAgICAgIGJ1dHRvbihcIm5leHRcIiwgKCkgPT4gZmluZE5leHQodmlldyksIFtwaHJhc2UodmlldywgXCJuZXh0XCIpXSksXG4gICAgICAgICAgICBidXR0b24oXCJwcmV2XCIsICgpID0+IGZpbmRQcmV2aW91cyh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInByZXZpb3VzXCIpXSksXG4gICAgICAgICAgICBidXR0b24oXCJzZWxlY3RcIiwgKCkgPT4gc2VsZWN0TWF0Y2hlcyh2aWV3KSwgW3BocmFzZSh2aWV3LCBcImFsbFwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMuY2FzZUZpZWxkLCBwaHJhc2UodmlldywgXCJtYXRjaCBjYXNlXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy5yZUZpZWxkLCBwaHJhc2UodmlldywgXCJyZWdleHBcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLndvcmRGaWVsZCwgcGhyYXNlKHZpZXcsIFwiYnkgd29yZFwiKV0pLFxuICAgICAgICAgICAgLi4udmlldy5zdGF0ZS5yZWFkT25seSA/IFtdIDogW1xuICAgICAgICAgICAgICAgIGVsdChcImJyXCIpLFxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUZpZWxkLFxuICAgICAgICAgICAgICAgIGJ1dHRvbihcInJlcGxhY2VcIiwgKCkgPT4gcmVwbGFjZU5leHQodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlXCIpXSksXG4gICAgICAgICAgICAgICAgYnV0dG9uKFwicmVwbGFjZUFsbFwiLCAoKSA9PiByZXBsYWNlQWxsKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicmVwbGFjZSBhbGxcIildKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IGNsb3NlU2VhcmNoUGFuZWwodmlldyksXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcImNsb3NlXCIpLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgICAgICAgICAgIH0sIFtcIlx1MDBEN1wiXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgICAgIHNlYXJjaDogdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IHRoaXMuY2FzZUZpZWxkLmNoZWNrZWQsXG4gICAgICAgICAgICByZWdleHA6IHRoaXMucmVGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiB0aGlzLndvcmRGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlRmllbGQudmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXF1ZXJ5LmVxKHRoaXMucXVlcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWFyY2hRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChydW5TY29wZUhhbmRsZXJzKHRoaXMudmlldywgZSwgXCJzZWFyY2gtcGFuZWxcIikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5zZWFyY2hGaWVsZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgKGUuc2hpZnRLZXkgPyBmaW5kUHJldmlvdXMgOiBmaW5kTmV4dCkodGhpcy52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5yZXBsYWNlRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlcGxhY2VOZXh0KHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSAmJiAhZWZmZWN0LnZhbHVlLmVxKHRoaXMucXVlcnkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSA9IHF1ZXJ5LnNlYXJjaDtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQudmFsdWUgPSBxdWVyeS5yZXBsYWNlO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZC5jaGVja2VkID0gcXVlcnkuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5yZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5yZWdleHA7XG4gICAgICAgIHRoaXMud29yZEZpZWxkLmNoZWNrZWQgPSBxdWVyeS53aG9sZVdvcmQ7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnNlbGVjdCgpO1xuICAgIH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gODA7IH1cbiAgICBnZXQgdG9wKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS50b3A7IH1cbn1cbmZ1bmN0aW9uIHBocmFzZSh2aWV3LCBwaHJhc2UpIHsgcmV0dXJuIHZpZXcuc3RhdGUucGhyYXNlKHBocmFzZSk7IH1cbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XG5jb25zdCBCcmVhayA9IC9bXFxzXFwuLDo7PyFdLztcbmZ1bmN0aW9uIGFubm91bmNlTWF0Y2godmlldywgeyBmcm9tLCB0byB9KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIGxpbmVFbmQgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgZnJvbSAtIEFubm91bmNlTWFyZ2luKSwgZW5kID0gTWF0aC5taW4obGluZUVuZCwgdG8gKyBBbm5vdW5jZU1hcmdpbik7XG4gICAgbGV0IHRleHQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdGFydCAhPSBsaW5lLmZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbm5vdW5jZU1hcmdpbjsgaSsrKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSArIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgIT0gbGluZUVuZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID4gdGV4dC5sZW5ndGggLSBBbm5vdW5jZU1hcmdpbjsgaS0tKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSAtIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKFwiY3VycmVudCBtYXRjaFwiKX0uICR7dGV4dH0gJHt2aWV3LnN0YXRlLnBocmFzZShcIm9uIGxpbmVcIil9ICR7bGluZS5udW1iZXJ9LmApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1zZWFyY2hcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCI0cHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBpbnB1dCwgJiBidXR0b24sICYgbGFiZWxcIjoge1xuICAgICAgICAgICAgbWFyZ2luOiBcIi4yZW0gLjZlbSAuMmVtIDBcIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXRbdHlwZT1jaGVja2JveF1cIjoge1xuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLjJlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogXCI4MCVcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwZmZmZjhhXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNmEwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmYwMGZmOGFcIiB9XG59KTtcbmNvbnN0IHNlYXJjaEV4dGVuc2lvbnMgPSBbXG4gICAgc2VhcmNoU3RhdGUsXG4gICAgLypAX19QVVJFX18qL1ByZWMubG93KHNlYXJjaEhpZ2hsaWdodGVyKSxcbiAgICBiYXNlVGhlbWVcbl07XG5cbmV4cG9ydCB7IFJlZ0V4cEN1cnNvciwgU2VhcmNoQ3Vyc29yLCBTZWFyY2hRdWVyeSwgY2xvc2VTZWFyY2hQYW5lbCwgZmluZE5leHQsIGZpbmRQcmV2aW91cywgZ2V0U2VhcmNoUXVlcnksIGdvdG9MaW5lLCBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzLCBvcGVuU2VhcmNoUGFuZWwsIHJlcGxhY2VBbGwsIHJlcGxhY2VOZXh0LCBzZWFyY2gsIHNlYXJjaEtleW1hcCwgc2VhcmNoUGFuZWxPcGVuLCBzZWxlY3RNYXRjaGVzLCBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcywgc2V0U2VhcmNoUXVlcnkgfTtcbiIsICJpbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBIaWdobGlnaHRTdHlsZSwgc3ludGF4SGlnaGxpZ2h0aW5nIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBVc2luZyBodHRwczovL2dpdGh1Yi5jb20vb25lLWRhcmsvdnNjb2RlLW9uZS1kYXJrLXRoZW1lLyBhcyByZWZlcmVuY2UgZm9yIHRoZSBjb2xvcnNcbmNvbnN0IGNoYWxreSA9IFwiI2U1YzA3YlwiLCBjb3JhbCA9IFwiI2UwNmM3NVwiLCBjeWFuID0gXCIjNTZiNmMyXCIsIGludmFsaWQgPSBcIiNmZmZmZmZcIiwgaXZvcnkgPSBcIiNhYmIyYmZcIiwgc3RvbmUgPSBcIiM3ZDg3OTlcIiwgLy8gQnJpZ2h0ZW5lZCBjb21wYXJlZCB0byBvcmlnaW5hbCB0byBpbmNyZWFzZSBjb250cmFzdFxubWFsaWJ1ID0gXCIjNjFhZmVmXCIsIHNhZ2UgPSBcIiM5OGMzNzlcIiwgd2hpc2tleSA9IFwiI2QxOWE2NlwiLCB2aW9sZXQgPSBcIiNjNjc4ZGRcIiwgZGFya0JhY2tncm91bmQgPSBcIiMyMTI1MmJcIiwgaGlnaGxpZ2h0QmFja2dyb3VuZCA9IFwiIzJjMzEzYVwiLCBiYWNrZ3JvdW5kID0gXCIjMjgyYzM0XCIsIHRvb2x0aXBCYWNrZ3JvdW5kID0gXCIjMzUzYTQyXCIsIHNlbGVjdGlvbiA9IFwiIzNFNDQ1MVwiLCBjdXJzb3IgPSBcIiM1MjhiZmZcIjtcbi8qKlxuVGhlIGNvbG9ycyB1c2VkIGluIHRoZSB0aGVtZSwgYXMgQ1NTIGNvbG9yIHN0cmluZ3MuXG4qL1xuY29uc3QgY29sb3IgPSB7XG4gICAgY2hhbGt5LFxuICAgIGNvcmFsLFxuICAgIGN5YW4sXG4gICAgaW52YWxpZCxcbiAgICBpdm9yeSxcbiAgICBzdG9uZSxcbiAgICBtYWxpYnUsXG4gICAgc2FnZSxcbiAgICB3aGlza2V5LFxuICAgIHZpb2xldCxcbiAgICBkYXJrQmFja2dyb3VuZCxcbiAgICBoaWdobGlnaHRCYWNrZ3JvdW5kLFxuICAgIGJhY2tncm91bmQsXG4gICAgdG9vbHRpcEJhY2tncm91bmQsXG4gICAgc2VsZWN0aW9uLFxuICAgIGN1cnNvclxufTtcbi8qKlxuVGhlIGVkaXRvciB0aGVtZSBzdHlsZXMgZm9yIE9uZSBEYXJrLlxuKi9cbmNvbnN0IG9uZURhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHtcbiAgICBcIiZcIjoge1xuICAgICAgICBjb2xvcjogaXZvcnksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIGNhcmV0Q29sb3I6IGN1cnNvclxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7IGJvcmRlckxlZnRDb2xvcjogY3Vyc29yIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmQsIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kLCAuY20tY29udGVudCA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogc2VsZWN0aW9uIH0sXG4gICAgXCIuY20tcGFuZWxzXCI6IHsgYmFja2dyb3VuZENvbG9yOiBkYXJrQmFja2dyb3VuZCwgY29sb3I6IGl2b3J5IH0sXG4gICAgXCIuY20tcGFuZWxzLmNtLXBhbmVscy10b3BcIjogeyBib3JkZXJCb3R0b206IFwiMnB4IHNvbGlkIGJsYWNrXCIgfSxcbiAgICBcIi5jbS1wYW5lbHMuY20tcGFuZWxzLWJvdHRvbVwiOiB7IGJvcmRlclRvcDogXCIycHggc29saWQgYmxhY2tcIiB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM3MmExZmY1OVwiLFxuICAgICAgICBvdXRsaW5lOiBcIjFweCBzb2xpZCAjNDU3ZGZmXCJcbiAgICB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM2MTk5ZmYyZlwiXG4gICAgfSxcbiAgICBcIi5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM2Njk5ZmYwYlwiIH0sXG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2FhZmU2NjFhXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0LCAmLmNtLWZvY3VzZWQgLmNtLW5vbm1hdGNoaW5nQnJhY2tldFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjYmFkMGY4NDdcIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZCxcbiAgICAgICAgY29sb3I6IHN0b25lLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIi5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBoaWdobGlnaHRCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICBcIi5jbS1mb2xkUGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgY29sb3I6IFwiI2RkZFwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b29sdGlwQmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcCAuY20tdG9vbHRpcC1hcnJvdzpiZWZvcmVcIjoge1xuICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93OmFmdGVyXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wQ29sb3I6IHRvb2x0aXBCYWNrZ3JvdW5kLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogdG9vbHRpcEJhY2tncm91bmRcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWwgPiBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgICAgICAgICBjb2xvcjogaXZvcnlcbiAgICAgICAgfVxuICAgIH1cbn0sIHsgZGFyazogdHJ1ZSB9KTtcbi8qKlxuVGhlIGhpZ2hsaWdodGluZyBzdHlsZSBmb3IgY29kZSBpbiB0aGUgT25lIERhcmsgdGhlbWUuXG4qL1xuY29uc3Qgb25lRGFya0hpZ2hsaWdodFN0eWxlID0gLypAX19QVVJFX18qL0hpZ2hsaWdodFN0eWxlLmRlZmluZShbXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCxcbiAgICAgICAgY29sb3I6IHZpb2xldCB9LFxuICAgIHsgdGFnOiBbdGFncy5uYW1lLCB0YWdzLmRlbGV0ZWQsIHRhZ3MuY2hhcmFjdGVyLCB0YWdzLnByb3BlcnR5TmFtZSwgdGFncy5tYWNyb05hbWVdLFxuICAgICAgICBjb2xvcjogY29yYWwgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmZ1bmN0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgdGFncy5sYWJlbE5hbWVdLFxuICAgICAgICBjb2xvcjogbWFsaWJ1IH0sXG4gICAgeyB0YWc6IFt0YWdzLmNvbG9yLCAvKkBfX1BVUkVfXyovdGFncy5jb25zdGFudCh0YWdzLm5hbWUpLCAvKkBfX1BVUkVfXyovdGFncy5zdGFuZGFyZCh0YWdzLm5hbWUpXSxcbiAgICAgICAgY29sb3I6IHdoaXNrZXkgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5uYW1lKSwgdGFncy5zZXBhcmF0b3JdLFxuICAgICAgICBjb2xvcjogaXZvcnkgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MuY2xhc3NOYW1lLCB0YWdzLm51bWJlciwgdGFncy5jaGFuZ2VkLCB0YWdzLmFubm90YXRpb24sIHRhZ3MubW9kaWZpZXIsIHRhZ3Muc2VsZiwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogY2hhbGt5IH0sXG4gICAgeyB0YWc6IFt0YWdzLm9wZXJhdG9yLCB0YWdzLm9wZXJhdG9yS2V5d29yZCwgdGFncy51cmwsIHRhZ3MuZXNjYXBlLCB0YWdzLnJlZ2V4cCwgdGFncy5saW5rLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBjeWFuIH0sXG4gICAgeyB0YWc6IFt0YWdzLm1ldGEsIHRhZ3MuY29tbWVudF0sXG4gICAgICAgIGNvbG9yOiBzdG9uZSB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICBjb2xvcjogc3RvbmUsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgICAgIGNvbG9yOiBjb3JhbCB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpXSxcbiAgICAgICAgY29sb3I6IHdoaXNrZXkgfSxcbiAgICB7IHRhZzogW3RhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLCB0YWdzLnN0cmluZywgdGFncy5pbnNlcnRlZF0sXG4gICAgICAgIGNvbG9yOiBzYWdlIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IGludmFsaWQgfSxcbl0pO1xuLyoqXG5FeHRlbnNpb24gdG8gZW5hYmxlIHRoZSBPbmUgRGFyayB0aGVtZSAoYm90aCB0aGUgZWRpdG9yIHRoZW1lIGFuZFxudGhlIGhpZ2hsaWdodCBzdHlsZSkuXG4qL1xuY29uc3Qgb25lRGFyayA9IFtvbmVEYXJrVGhlbWUsIC8qQF9fUFVSRV9fKi9zeW50YXhIaWdobGlnaHRpbmcob25lRGFya0hpZ2hsaWdodFN0eWxlKV07XG5cbmV4cG9ydCB7IGNvbG9yLCBvbmVEYXJrLCBvbmVEYXJrSGlnaGxpZ2h0U3R5bGUsIG9uZURhcmtUaGVtZSB9O1xuIl0sCiAgIm1hcHBpbmdzIjogIjtBQUVBLElBQUksWUFBWSxDQUFDO0FBQWpCLElBQW9CLFVBQVUsQ0FBQztBQUFBLENBRTdCLE1BQU07QUFPTixNQUFJLFVBQVUsaXpDQUFpekMsTUFBTSxHQUFHLEVBQUUsSUFBSSxPQUFLLElBQUksU0FBUyxHQUFHLEVBQUUsSUFBSSxDQUFDO0FBQzEyQyxXQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxRQUFRLFFBQVE7QUFDekMsS0FBQyxJQUFJLElBQUksVUFBVSxXQUFXLEtBQUssSUFBSSxJQUFJLFFBQVEsQ0FBQyxDQUFDO0FBQ3pELEdBQUc7QUFFSSxTQUFTLGdCQUFnQixNQUFNO0FBQ3BDLE1BQUksT0FBTyxJQUFLLFFBQU87QUFDdkIsV0FBUyxPQUFPLEdBQUcsS0FBSyxVQUFVLFlBQVU7QUFDMUMsUUFBSSxNQUFPLE9BQU8sTUFBTztBQUN6QixRQUFJLE9BQU8sVUFBVSxHQUFHLEVBQUcsTUFBSztBQUFBLGFBQ3ZCLFFBQVEsUUFBUSxHQUFHLEVBQUcsUUFBTyxNQUFNO0FBQUEsUUFDdkMsUUFBTztBQUNaLFFBQUksUUFBUSxHQUFJLFFBQU87QUFBQSxFQUN6QjtBQUNGO0FBRUEsU0FBUyxvQkFBb0IsTUFBTTtBQUNqQyxTQUFPLFFBQVEsVUFBVyxRQUFRO0FBQ3BDO0FBU0EsSUFBTSxNQUFNO0FBRUwsU0FBUyxpQkFBaUIsS0FBSyxLQUFLLFVBQVUsTUFBTSxtQkFBbUIsTUFBTTtBQUNs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LFVBQVUsQ0FBQyxjQUEyQixtQ0FBbUIscUJBQXFCLENBQUM7IiwKICAibmFtZXMiOiBbInN0cmluZyIsICJhZGQiLCAidG9wIiwgIm51bWJlciIsICJmaW5kQ2x1c3RlckJyZWFrIiwgInN1cnJvZ2F0ZUxvdyIsICJzdXJyb2dhdGVIaWdoIiwgImNvZGVQb2ludEF0IiwgImNvZGVQb2ludFNpemUiLCAiTWFwTW9kZSIsICJkb2MiLCAicHJvY2VzcyIsICJpbnNlcnQiLCAiaSIsICJ2YWx1ZXMiLCAic2VsZWN0aW9uIiwgImNvbXBhcmUiLCAiY29uZmlnIiwgIl9hIiwgImlkIiwgInByZWMiLCAiY29udGVudCIsICJiYXNlIiwgInNjcm9sbEludG9WaWV3IiwgIkNoYXJDYXRlZ29yeSIsICJyZXF1aXJlIiwgInBocmFzZSIsICJuYW1lIiwgImRlZmF1bHRzIiwgImN1ciIsICJjdXJzb3IiLCAibGF5ZXIiLCAic3BlYyIsICJpZCIsICJkb2MiLCAibmFtZSIsICJlbHQiLCAibmFtZSIsICJpZSIsICJuYW1lIiwgIkJsb2NrVHlwZSIsICJzZWxlY3Rpb24iLCAiZWx0IiwgImRvYyIsICJjdXIiLCAidG9wIiwgInJlY3QiLCAiRGlyZWN0aW9uIiwgInJlcGxhY2UiLCAidHlwZSIsICJfYSIsICJmaW5kQ2x1c3RlckJyZWFrIiwgInZhbHVlcyIsICJ0IiwgImlkIiwgImFkZCIsICJwb3MiLCAiZmxhdHRlbiIsICJkaXN0IiwgImNhY2hlIiwgImJsb2NrV3JhcHBlcnMiLCAibWFya3MiLCAidGlsZSIsICJkZWNvcmF0aW9ucyIsICJmcm9tIiwgInRvIiwgImN1cnNvciIsICJvZmZzZXQiLCAidGV4dEhlaWdodCIsICJpIiwgImNvbnRlbnQiLCAic2Nyb2xsSW50b1ZpZXciLCAiYmFzZSIsICJoYW5kbGVycyIsICJvYnNlcnZlcnMiLCAiaW5zZXJ0IiwgImV2ZW50IiwgImRhdGEiLCAiUXVlcnlUeXBlIiwgIkRlY29yYXRpb25Db21wYXJhdG9yIiwgImdhcCIsICJrZXkiLCAidmlldyIsICJjb25maWciLCAic2hpZnQiLCAibWV0YSIsICJjb21tYW5kIiwgImNvZGVQb2ludEF0IiwgImNvZGVQb2ludFNpemUiLCAiY21kIiwgInBpZWNlcyIsICJsYXllciIsICJjdXJzb3IiLCAicG9zIiwgIl9hIiwgImRvYyIsICJjb25maWciLCAiYWRkIiwgImZyb20iLCAidG8iLCAiZGVjbyIsICJtIiwgImNvZGVQb2ludEF0IiwgImV2ZW50IiwgImN1ciIsICJfYSIsICJ0IiwgImkiLCAidmFsdWVzIiwgIl9hIiwgImNvbmZpZyIsICJ0IiwgInNwYWNlIiwgInRvcCIsICJlbHQiLCAidG9wIiwgImNvbmZpZyIsICJ2aWV3IiwgImNvbmZpZyIsICJjb250ZW50IiwgInZhbHVlcyIsICJndXR0ZXIiLCAiY3VyIiwgImd1dHRlcnMiLCAiYXNBcnJheSIsICJjdXJzb3IiLCAibWFya2VyIiwgImVsdCIsICJhZGQiLCAiZXZlbnQiLCAibnVtYmVyIiwgIm1hcmtzIiwgIlJhbmdlIiwgImNvbmZpZyIsICJwYXJzZXIiLCAibmFtZSIsICJpZCIsICJ0eXBlcyIsICJhZGQiLCAiSXRlck1vZGUiLCAiY3Vyc29yIiwgImRhdGEiLCAiX2EiLCAibW91bnRlZCIsICJjdXIiLCAiY2FjaGUiLCAiY2hpbGRyZW4iLCAicG9zaXRpb25zIiwgIm5vZGUiLCAiYnVmZmVyIiwgImNvbnRleHRIYXNoIiwgImxlbmd0aCIsICJsb29rQWhlYWQiLCAiYmFzZSIsICJwYWlyIiwgIm5vZGVTaXplIiwgIm5vZGVTdGFydCIsICJmcm9tIiwgInRvIiwgInN0cmluZyIsICJkb25lIiwgImlubmVyIiwgInIiLCAicG9zIiwgIm5hbWUiLCAiYmFzZSIsICJ0IiwgInNhbWVBcnJheSIsICJjb25maWciLCAidGFncyIsICJjdXIiLCAiY3Vyc29yIiwgImhhc0NoaWxkIiwgInJhbmdlRnJvbSIsICJyYW5nZVRvIiwgIm5hbWUiLCAidmFsdWVzIiwgImRhdGEiLCAicGFyc2VyIiwgIm5hbWUiLCAidG9wIiwgImJhc2UiLCAiZG9jIiwgInBhcnNlciIsICJfYSIsICJsYW5ndWFnZSIsICJuYW1lIiwgInZhbHVlcyIsICJhZGQiLCAiY3VyIiwgImJhc2UiLCAibGluZUVuZCIsICJzcGFjZSIsICJjbG9zaW5nIiwgImRvYyIsICJoZWFkIiwgImxpbmUiLCAiX2EiLCAiZnJvbSIsICJ0byIsICJ2YWx1ZXMiLCAiY29uZmlnIiwgImJhc2VUaGVtZSQxIiwgIl9hIiwgImZyb20iLCAidG8iLCAiYmFzZVRoZW1lIiwgImRlY29yYXRpb25zIiwgImNvbmZpZyIsICJjdXIiLCAiY3Vyc29yIiwgImJyYWNrZXQiLCAicG9zIiwgIm5hbWUiLCAibmFtZSIsICJ0IiwgInR5cGVzIiwgInNjb3JlIiwgIl9hIiwgImNvZGVQb2ludEF0IiwgImNvZGVQb2ludFNpemUiLCAic3BhY2UiLCAiY29uZmlnIiwgImNvbnRlbnQiLCAib2ZmIiwgImFwcGx5Q29tcGxldGlvbiIsICJvcHRpb25zIiwgImlkIiwgInNjcm9sbEludG9WaWV3IiwgIm5hbWUiLCAiY29tcGFyZSIsICJjdXIiLCAibm9uZSIsICJub0F0dHJzIiwgImJhc2VUaGVtZSIsICJwb3MiLCAibSIsICJzbmlwcGV0IiwgImRlZmF1bHRzIiwgImlucHV0SGFuZGxlciIsICJpbnNlcnQiLCAiY29kZVBvaW50U2l6ZSIsICJjb2RlUG9pbnRBdCIsICJicmFja2V0IiwgImRvYyIsICJjb25maWciLCAiY29udGVudCIsICJiYXNlVGhlbWUiLCAiaGFzaCIsICJUeXBlIiwgImNvbnRlbnQiLCAiTGluZSIsICJlbHQiLCAiY291bnQiLCAibWFya3MiLCAiYmFzZSIsICJlbXB0eSIsICJwYXJzZXIiLCAiRnJhZ21lbnRDdXJzb3IiLCAibm9uZSIsICJ0b3AiLCAicmFuZ2VFbmQiLCAidCIsICJjb25maWciLCAibm9kZVR5cGVzIiwgIm5hbWUiLCAiaWQiLCAicm0iLCAic3BlYyIsICJjb25jIiwgImNvbW1lbnQiLCAiY3VyIiwgIm5vZGUiLCAibSIsICJuZXh0IiwgInNjb3JlIiwgIl9hIiwgInBhcnNlciIsICJiYXNlIiwgImNvdW50IiwgImN1ciIsICJ0b3AiLCAiaSIsICJUeXBlIiwgImRhdGEiLCAiaWQiLCAiY3Vyc29yIiwgIkZyYWdtZW50Q3Vyc29yIiwgImluc2VydCIsICJuYW1lIiwgImNvbmZpZyIsICJ0IiwgInByZWMiLCAidmFsdWVzIiwgIkVsZW1lbnQiLCAibmFtZSIsICJwYXJzZXIiLCAiZ2V0QXR0cnMiLCAidGFncyIsICJpZCIsICJhdHRycyIsICJzcGFjZSIsICJkYXNoIiwgImlkIiwgImNhbGxlZSIsICJwYXJzZXIiLCAibmFtZSIsICJ0YWdzIiwgImlkZW50aWZpZXIiLCAiZG9jIiwgIl9hIiwgImNhbGxlZSIsICJjdXIiLCAiY3Vyc29yIiwgIm5vZGUiLCAicGFyc2VyIiwgIm5ld2xpbmUiLCAic3BhY2UiLCAic2xhc2giLCAicXVlc3Rpb24iLCAiYnJhY2tldEwiLCAic3BlY19pZGVudGlmaWVyIiwgInBhcnNlciIsICJpZCIsICJkb2MiLCAidG9wIiwgIm5vZGUiLCAibmFtZSIsICJwYXJzZXIiLCAibmFtZSIsICJjb25maWciLCAiZG9jIiwgImFuZHJvaWQiLCAiYmFzZSIsICJfYSIsICJlbXB0eSIsICJpbnNlcnQiLCAiZWxlbWVudE5hbWUiLCAiZG9jIiwgIm5hbWUiLCAiaWRlbnRpZmllciIsICJlbHQiLCAiX2EiLCAiYmFzZSIsICJjb25maWciLCAicGFyc2VyIiwgImN1ciIsICJhdXRvQ2xvc2VUYWdzIiwgInNlbGZDbG9zZXJzIiwgInRvIiwgImluc2VydCIsICJoZWFkaW5nIiwgInBhcnNlciIsICJkb2MiLCAiYWRkIiwgIm51bWJlciIsICJjdXIiLCAibm9kZSIsICJjb250ZW50IiwgInNwYWNlIiwgImNvbmZpZyIsICJpbnNlcnQiLCAiY2hhbmdlcyIsICJlbXB0eSIsICJfYSIsICJjb25maWciLCAiZGF0YSIsICJjb21tZW50IiwgImVtcHR5IiwgImlzQWRqYWNlbnQiLCAiY29uZmlnIiwgImNvbW1hbmQiLCAic2VsZWN0aW9uIiwgIl9hIiwgInNlbGVjdGlvbiIsICJub25lIiwgImlzQWRqYWNlbnQiLCAidCIsICJjb25maWciLCAiYnJhY2tldCIsICJzZWxlY3Rpb24iLCAic3BhY2UiLCAic2VsZWN0aW9uIiwgInNlbGVjdGlvbiIsICJjdXIiLCAiZmluZENsdXN0ZXJCcmVhayIsICJmaW5kQ2x1c3RlckJyZWFrIiwgIm5leHRDaGFyIiwgImxpbmVFbmQiLCAiZmluZENsdXN0ZXJCcmVhayIsICJzZWxlY3Rpb24iLCAiZGlzdCIsICJpbnNlcnQiLCAiY2hhbmdlcyIsICJjdXIiLCAic3BhY2UiLCAiY29kZVBvaW50QXQiLCAiY29kZVBvaW50U2l6ZSIsICJkb2MiLCAiX2EiLCAicGVyY2VudCIsICJsaW5lIiwgInNlbGVjdGlvbiIsICJjdXJzb3IiLCAid29yZCIsICJjb25maWciLCAiUXVlcnlUeXBlIiwgImFkZCIsICJmaW5kQ2x1c3RlckJyZWFrIiwgImZyb20iLCAidG8iLCAic2VsZWN0aW9uIiwgImNvbmZpZyIsICJjdXIiLCAiX2EiLCAibmFtZSIsICJjb250ZW50IiwgInBocmFzZSIsICJsaW5lRW5kIiwgImJhc2VUaGVtZSJdCn0K
